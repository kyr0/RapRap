var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a, prop, b2[prop]);
    }
  return a;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const p$4 = function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
};
p$4();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$1 = Symbol.for("react.element"), n$1 = Symbol.for("react.portal"), p$3 = Symbol.for("react.fragment"), q$1 = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t$1 = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$1 = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$2(a) {
  if (a === null || typeof a !== "object")
    return null;
  a = z$2 && a[z$2] || a["@@iterator"];
  return typeof a === "function" ? a : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a, b2, e) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a, b2) {
  if (typeof a !== "object" && typeof a !== "function" && a != null)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b2, "setState");
};
E$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a, b2, e) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a, b2, e) {
  var d, c = {}, k2 = null, h2 = null;
  if (b2 != null)
    for (d in b2.ref !== void 0 && (h2 = b2.ref), b2.key !== void 0 && (k2 = "" + b2.key), b2)
      J.call(b2, d) && !L$1.hasOwnProperty(d) && (c[d] = b2[d]);
  var g2 = arguments.length - 2;
  if (g2 === 1)
    c.children = e;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c.children = f2;
  }
  if (a && a.defaultProps)
    for (d in g2 = a.defaultProps, g2)
      c[d] === void 0 && (c[d] = g2[d]);
  return { $$typeof: l$1, type: a, key: k2, ref: h2, props: c, _owner: K$1.current };
}
function N$2(a, b2) {
  return { $$typeof: l$1, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$1(a) {
  return typeof a === "object" && a !== null && a.$$typeof === l$1;
}
function escape(a) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b2[a2];
  });
}
var P$1 = /\/+/g;
function Q$1(a, b2) {
  return typeof a === "object" && a !== null && a.key != null ? escape("" + a.key) : b2.toString(36);
}
function R$1(a, b2, e, d, c) {
  var k2 = typeof a;
  if (k2 === "undefined" || k2 === "boolean")
    a = null;
  var h2 = false;
  if (a === null)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l$1:
          case n$1:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a, c = c(h2), a = d === "" ? "." + Q$1(h2, 0) : d, I$1(c) ? (e = "", a != null && (e = a.replace(P$1, "$&/") + "/"), R$1(c, b2, e, "", function(a2) {
      return a2;
    })) : c != null && (O$1(c) && (c = N$2(c, e + (!c.key || h2 && h2.key === c.key ? "" : ("" + c.key).replace(P$1, "$&/") + "/") + a)), b2.push(c)), 1;
  h2 = 0;
  d = d === "" ? "." : d + ":";
  if (I$1(a))
    for (var g2 = 0; g2 < a.length; g2++) {
      k2 = a[g2];
      var f2 = d + Q$1(k2, g2);
      h2 += R$1(k2, b2, e, f2, c);
    }
  else if (f2 = A$2(a), typeof f2 === "function")
    for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; )
      k2 = k2.value, f2 = d + Q$1(k2, g2++), h2 += R$1(k2, b2, e, f2, c);
  else if (k2 === "object")
    throw b2 = String(a), Error("Objects are not valid as a React child (found: " + (b2 === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a, b2, e) {
  if (a == null)
    return a;
  var d = [], c = 0;
  R$1(a, d, "", "", function(a2) {
    return b2.call(e, a2, c++);
  });
  return d;
}
function T$1(a) {
  if (a._status === -1) {
    var b2 = a._result;
    b2 = b2();
    b2.then(function(b3) {
      if (a._status === 0 || a._status === -1)
        a._status = 1, a._result = b3;
    }, function(b3) {
      if (a._status === 0 || a._status === -1)
        a._status = 2, a._result = b3;
    });
    a._status === -1 && (a._status = 0, a._result = b2);
  }
  if (a._status === 1)
    return a._result.default;
  throw a._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
react_production_min.Children = { map: S$1, forEach: function(a, b2, e) {
  S$1(a, function() {
    b2.apply(this, arguments);
  }, e);
}, count: function(a) {
  var b2 = 0;
  S$1(a, function() {
    b2++;
  });
  return b2;
}, toArray: function(a) {
  return S$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$1(a))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$3;
react_production_min.Profiler = r;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$1;
react_production_min.Suspense = w;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(a, b2, e) {
  if (a === null || a === void 0)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d = C$1({}, a.props), c = a.key, k2 = a.ref, h2 = a._owner;
  if (b2 != null) {
    b2.ref !== void 0 && (k2 = b2.ref, h2 = K$1.current);
    b2.key !== void 0 && (c = "" + b2.key);
    if (a.type && a.type.defaultProps)
      var g2 = a.type.defaultProps;
    for (f2 in b2)
      J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d[f2] = b2[f2] === void 0 && g2 !== void 0 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (f2 === 1)
    d.children = e;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d.children = g2;
  }
  return { $$typeof: l$1, type: a.type, key: c, ref: k2, props: d, _owner: h2 };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t$1, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a) {
  var b2 = M$1.bind(null, a);
  b2.type = a;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$1, render: a };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a) {
  return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T$1 };
};
react_production_min.memo = function(a, b2) {
  return { $$typeof: x, type: a, compare: b2 === void 0 ? null : b2 };
};
react_production_min.startTransition = function(a) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a, b2) {
  return U$1.current.useCallback(a, b2);
};
react_production_min.useContext = function(a) {
  return U$1.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$1.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b2) {
  return U$1.current.useEffect(a, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a, b2, e) {
  return U$1.current.useImperativeHandle(a, b2, e);
};
react_production_min.useInsertionEffect = function(a, b2) {
  return U$1.current.useInsertionEffect(a, b2);
};
react_production_min.useLayoutEffect = function(a, b2) {
  return U$1.current.useLayoutEffect(a, b2);
};
react_production_min.useMemo = function(a, b2) {
  return U$1.current.useMemo(a, b2);
};
react_production_min.useReducer = function(a, b2, e) {
  return U$1.current.useReducer(a, b2, e);
};
react_production_min.useRef = function(a) {
  return U$1.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$1.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b2, e) {
  return U$1.current.useSyncExternalStore(a, b2, e);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.1.0";
{
  react.exports = react_production_min;
}
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a, b2) {
    var c = a.length;
    a.push(b2);
    a:
      for (; 0 < c; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (0 < g2(e, b2))
          a[d] = b2, a[c] = e, c = d;
        else
          break a;
      }
  }
  function h2(a) {
    return a.length === 0 ? null : a[0];
  }
  function k2(a) {
    if (a.length === 0)
      return null;
    var b2 = a[0], c = a.pop();
    if (c !== b2) {
      a[0] = c;
      a:
        for (var d = 0, e = a.length, w2 = e >>> 1; d < w2; ) {
          var m2 = 2 * (d + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
          if (0 > g2(C2, c))
            n2 < e && 0 > g2(x2, C2) ? (a[d] = x2, a[n2] = c, d = n2) : (a[d] = C2, a[m2] = c, d = m2);
          else if (n2 < e && 0 > g2(x2, c))
            a[d] = x2, a[n2] = c, d = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a, b2) {
    var c = a.sortIndex - b2.sortIndex;
    return c !== 0 ? c : a.id - b2.id;
  }
  if (typeof performance === "object" && typeof performance.now === "function") {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = typeof setTimeout === "function" ? setTimeout : null, E2 = typeof clearTimeout === "function" ? clearTimeout : null, F2 = typeof setImmediate !== "undefined" ? setImmediate : null;
  typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b2 = h2(t2); b2 !== null; ) {
      if (b2.callback === null)
        k2(t2);
      else if (b2.startTime <= a)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2)
      if (h2(r2) !== null)
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        b2 !== null && K2(H2, b2.startTime - a);
      }
  }
  function J2(a, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); v2 !== null && (!(v2.expirationTime > b2) || a && !M2()); ) {
        var d = v2.callback;
        if (typeof d === "function") {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e = d(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          typeof e === "function" ? v2.callback = e : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (v2 !== null)
        var w2 = true;
      else {
        var m2 = h2(t2);
        m2 !== null && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (O2 !== null) {
      var a = exports.unstable_now();
      Q2 = a;
      var b2 = true;
      try {
        b2 = O2(true, a);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if (typeof F2 === "function")
    S2 = function() {
      F2(R2);
    };
  else if (typeof MessageChannel !== "undefined") {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b2) {
    L2 = D2(function() {
      a(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c = y2;
    y2 = b2;
    try {
      return a();
    } finally {
      y2 = c;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c = y2;
    y2 = a;
    try {
      return b2();
    } finally {
      y2 = c;
    }
  };
  exports.unstable_scheduleCallback = function(a, b2, c) {
    var d = exports.unstable_now();
    typeof c === "object" && c !== null ? (c = c.delay, c = typeof c === "number" && 0 < c ? d + c : d) : c = d;
    switch (a) {
      case 1:
        var e = -1;
        break;
      case 2:
        e = 250;
        break;
      case 5:
        e = 1073741823;
        break;
      case 4:
        e = 1e4;
        break;
      default:
        e = 5e3;
    }
    e = c + e;
    a = { id: u2++, callback: b2, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
    c > d ? (a.sortIndex = c, f2(t2, a), h2(r2) === null && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c - d))) : (a.sortIndex = e, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a) {
    var b2 = y2;
    return function() {
      var c = y2;
      y2 = b2;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react.exports, ba = scheduler.exports;
function p$2(a) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b2) {
  ha(a, b2);
  ha(a + "Capture", b2);
}
function ha(a, b2) {
  ea[a] = b2;
  for (a = 0; a < b2.length; a++)
    da.add(b2[a]);
}
var ia = !(typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined"), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function na(a) {
  if (ja.call(ma, a))
    return true;
  if (ja.call(la, a))
    return false;
  if (ka.test(a))
    return ma[a] = true;
  la[a] = true;
  return false;
}
function oa(a, b2, c, d) {
  if (c !== null && c.type === 0)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d)
        return false;
      if (c !== null)
        return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return a !== "data-" && a !== "aria-";
    default:
      return false;
  }
}
function pa(a, b2, c, d) {
  if (b2 === null || typeof b2 === "undefined" || oa(a, b2, c, d))
    return true;
  if (d)
    return false;
  if (c !== null)
    switch (c.type) {
      case 3:
        return !b2;
      case 4:
        return b2 === false;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function t(a, b2, c, d, e, f2, g2) {
  this.acceptsBooleans = b2 === 2 || b2 === 3 || b2 === 4;
  this.attributeName = d;
  this.attributeNamespace = e;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z$1[a] = new t(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b2 = a[0];
  z$1[b2] = new t(b2, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z$1[a] = new t(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z$1[a] = new t(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z$1[a] = new t(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z$1[a] = new t(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z$1[a] = new t(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z$1[a] = new t(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z$1[a] = new t(a, 5, false, a.toLowerCase(), null, false, false);
});
var qa = /[\-:]([a-z])/g;
function ra(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b2 = a.replace(qa, ra);
  z$1[b2] = new t(b2, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b2 = a.replace(qa, ra);
  z$1[b2] = new t(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b2 = a.replace(qa, ra);
  z$1[b2] = new t(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z$1[a] = new t(a, 1, false, a.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new t("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z$1[a] = new t(a, 1, false, a.toLowerCase(), null, true, true);
});
function sa(a, b2, c, d) {
  var e = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
  if (e !== null ? e.type !== 0 : d || !(2 < b2.length) || b2[0] !== "o" && b2[0] !== "O" || b2[1] !== "n" && b2[1] !== "N")
    pa(b2, c, e, d) && (c = null), d || e === null ? na(b2) && (c === null ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c)) : e.mustUseProperty ? a[e.propertyName] = c === null ? e.type === 3 ? false : "" : c : (b2 = e.attributeName, d = e.attributeNamespace, c === null ? a.removeAttribute(b2) : (e = e.type, c = e === 3 || e === 4 && c === true ? "" : "" + c, d ? a.setAttributeNS(d, b2, c) : a.setAttribute(b2, c)));
}
var ta = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ua = Symbol.for("react.element"), va = Symbol.for("react.portal"), wa = Symbol.for("react.fragment"), xa = Symbol.for("react.strict_mode"), za = Symbol.for("react.profiler"), Aa = Symbol.for("react.provider"), Ba = Symbol.for("react.context"), Ca = Symbol.for("react.forward_ref"), Da = Symbol.for("react.suspense"), Ea = Symbol.for("react.suspense_list"), Fa = Symbol.for("react.memo"), Ga = Symbol.for("react.lazy");
var Ha = Symbol.for("react.offscreen");
var Ia = Symbol.iterator;
function Ja(a) {
  if (a === null || typeof a !== "object")
    return null;
  a = Ia && a[Ia] || a["@@iterator"];
  return typeof a === "function" ? a : null;
}
var A$1 = Object.assign, Ka;
function La(a) {
  if (Ka === void 0)
    try {
      throw Error();
    } catch (c) {
      var b2 = c.stack.trim().match(/\n( *(at )?)/);
      Ka = b2 && b2[1] || "";
    }
  return "\n" + Ka + a;
}
var Ma = false;
function Na(a, b2) {
  if (!a || Ma)
    return "";
  Ma = true;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect === "object" && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d = l2;
        }
        Reflect.construct(a, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d = l2;
        }
        a.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d && typeof l2.stack === "string") {
      for (var e = l2.stack.split("\n"), f2 = d.stack.split("\n"), g2 = e.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e[g2] !== f2[h2]) {
          if (g2 !== 1 || h2 !== 1) {
            do
              if (g2--, h2--, 0 > h2 || e[g2] !== f2[h2]) {
                var k2 = "\n" + e[g2].replace(" at new ", " at ");
                a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Ma = false, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? La(a) : "";
}
function Oa(a) {
  switch (a.tag) {
    case 5:
      return La(a.type);
    case 16:
      return La("Lazy");
    case 13:
      return La("Suspense");
    case 19:
      return La("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Na(a.type, false), a;
    case 11:
      return a = Na(a.type.render, false), a;
    case 1:
      return a = Na(a.type, true), a;
    default:
      return "";
  }
}
function Pa(a) {
  if (a == null)
    return null;
  if (typeof a === "function")
    return a.displayName || a.name || null;
  if (typeof a === "string")
    return a;
  switch (a) {
    case wa:
      return "Fragment";
    case va:
      return "Portal";
    case za:
      return "Profiler";
    case xa:
      return "StrictMode";
    case Da:
      return "Suspense";
    case Ea:
      return "SuspenseList";
  }
  if (typeof a === "object")
    switch (a.$$typeof) {
      case Ba:
        return (a.displayName || "Context") + ".Consumer";
      case Aa:
        return (a._context.displayName || "Context") + ".Provider";
      case Ca:
        var b2 = a.render;
        a = a.displayName;
        a || (a = b2.displayName || b2.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Fa:
        return b2 = a.displayName || null, b2 !== null ? b2 : Pa(a.type) || "Memo";
      case Ga:
        b2 = a._payload;
        a = a._init;
        try {
          return Pa(a(b2));
        } catch (c) {
        }
    }
  return null;
}
function Qa(a) {
  var b2 = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b2.render, a = a.displayName || a.name || "", b2.displayName || (a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Pa(b2);
    case 8:
      return b2 === xa ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof b2 === "function")
        return b2.displayName || b2.name || null;
      if (typeof b2 === "string")
        return b2;
  }
  return null;
}
function Ra(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Sa(a) {
  var b2 = a.type;
  return (a = a.nodeName) && a.toLowerCase() === "input" && (b2 === "checkbox" || b2 === "radio");
}
function Ta(a) {
  var b2 = Sa(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d = "" + a[b2];
  if (!a.hasOwnProperty(b2) && typeof c !== "undefined" && typeof c.get === "function" && typeof c.set === "function") {
    var e = c.get, f2 = c.set;
    Object.defineProperty(a, b2, { configurable: true, get: function() {
      return e.call(this);
    }, set: function(a2) {
      d = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b2, { enumerable: c.enumerable });
    return { getValue: function() {
      return d;
    }, setValue: function(a2) {
      d = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b2];
    } };
  }
}
function Ua(a) {
  a._valueTracker || (a._valueTracker = Ta(a));
}
function Va(a) {
  if (!a)
    return false;
  var b2 = a._valueTracker;
  if (!b2)
    return true;
  var c = b2.getValue();
  var d = "";
  a && (d = Sa(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b2.setValue(a), true) : false;
}
function Wa(a) {
  a = a || (typeof document !== "undefined" ? document : void 0);
  if (typeof a === "undefined")
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b2) {
    return a.body;
  }
}
function Xa(a, b2) {
  var c = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c != null ? c : a._wrapperState.initialChecked });
}
function Ya(a, b2) {
  var c = b2.defaultValue == null ? "" : b2.defaultValue, d = b2.checked != null ? b2.checked : b2.defaultChecked;
  c = Ra(b2.value != null ? b2.value : c);
  a._wrapperState = { initialChecked: d, initialValue: c, controlled: b2.type === "checkbox" || b2.type === "radio" ? b2.checked != null : b2.value != null };
}
function Za(a, b2) {
  b2 = b2.checked;
  b2 != null && sa(a, "checked", b2, false);
}
function $a(a, b2) {
  Za(a, b2);
  var c = Ra(b2.value), d = b2.type;
  if (c != null)
    if (d === "number") {
      if (c === 0 && a.value === "" || a.value != c)
        a.value = "" + c;
    } else
      a.value !== "" + c && (a.value = "" + c);
  else if (d === "submit" || d === "reset") {
    a.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? bb(a, b2.type, c) : b2.hasOwnProperty("defaultValue") && bb(a, b2.type, Ra(b2.defaultValue));
  b2.checked == null && b2.defaultChecked != null && (a.defaultChecked = !!b2.defaultChecked);
}
function cb(a, b2, c) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d = b2.type;
    if (!(d !== "submit" && d !== "reset" || b2.value !== void 0 && b2.value !== null))
      return;
    b2 = "" + a._wrapperState.initialValue;
    c || b2 === a.value || (a.value = b2);
    a.defaultValue = b2;
  }
  c = a.name;
  c !== "" && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  c !== "" && (a.name = c);
}
function bb(a, b2, c) {
  if (b2 !== "number" || Wa(a.ownerDocument) !== a)
    c == null ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
var db = Array.isArray;
function eb(a, b2, c, d) {
  a = a.options;
  if (b2) {
    b2 = {};
    for (var e = 0; e < c.length; e++)
      b2["$" + c[e]] = true;
    for (c = 0; c < a.length; c++)
      e = b2.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
  } else {
    c = "" + Ra(c);
    b2 = null;
    for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = true;
        d && (a[e].defaultSelected = true);
        return;
      }
      b2 !== null || a[e].disabled || (b2 = a[e]);
    }
    b2 !== null && (b2.selected = true);
  }
}
function fb(a, b2) {
  if (b2.dangerouslySetInnerHTML != null)
    throw Error(p$2(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function gb(a, b2) {
  var c = b2.value;
  if (c == null) {
    c = b2.children;
    b2 = b2.defaultValue;
    if (c != null) {
      if (b2 != null)
        throw Error(p$2(92));
      if (db(c)) {
        if (1 < c.length)
          throw Error(p$2(93));
        c = c[0];
      }
      b2 = c;
    }
    b2 == null && (b2 = "");
    c = b2;
  }
  a._wrapperState = { initialValue: Ra(c) };
}
function hb(a, b2) {
  var c = Ra(b2.value), d = Ra(b2.defaultValue);
  c != null && (c = "" + c, c !== a.value && (a.value = c), b2.defaultValue == null && a.defaultValue !== c && (a.defaultValue = c));
  d != null && (a.defaultValue = "" + d);
}
function ib(a) {
  var b2 = a.textContent;
  b2 === a._wrapperState.initialValue && b2 !== "" && b2 !== null && (a.value = b2);
}
function jb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function kb(a, b2) {
  return a == null || a === "http://www.w3.org/1999/xhtml" ? jb(b2) : a === "http://www.w3.org/2000/svg" && b2 === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a;
}
var lb, mb = function(a) {
  return typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction ? function(b2, c, d, e) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b2, c, d, e);
    });
  } : a;
}(function(a, b2) {
  if (a.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in a)
    a.innerHTML = b2;
  else {
    lb = lb || document.createElement("div");
    lb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = lb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b2.firstChild; )
      a.appendChild(b2.firstChild);
  }
});
function nb(a, b2) {
  if (b2) {
    var c = a.firstChild;
    if (c && c === a.lastChild && c.nodeType === 3) {
      c.nodeValue = b2;
      return;
    }
  }
  a.textContent = b2;
}
var ob = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, pb = ["Webkit", "ms", "Moz", "O"];
Object.keys(ob).forEach(function(a) {
  pb.forEach(function(b2) {
    b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
    ob[b2] = ob[a];
  });
});
function qb(a, b2, c) {
  return b2 == null || typeof b2 === "boolean" || b2 === "" ? "" : c || typeof b2 !== "number" || b2 === 0 || ob.hasOwnProperty(a) && ob[a] ? ("" + b2).trim() : b2 + "px";
}
function rb(a, b2) {
  a = a.style;
  for (var c in b2)
    if (b2.hasOwnProperty(c)) {
      var d = c.indexOf("--") === 0, e = qb(c, b2[c], d);
      c === "float" && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
}
var sb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function tb(a, b2) {
  if (b2) {
    if (sb[a] && (b2.children != null || b2.dangerouslySetInnerHTML != null))
      throw Error(p$2(137, a));
    if (b2.dangerouslySetInnerHTML != null) {
      if (b2.children != null)
        throw Error(p$2(60));
      if (typeof b2.dangerouslySetInnerHTML !== "object" || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$2(61));
    }
    if (b2.style != null && typeof b2.style !== "object")
      throw Error(p$2(62));
  }
}
function ub(a, b2) {
  if (a.indexOf("-") === -1)
    return typeof b2.is === "string";
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var vb = null;
function wb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return a.nodeType === 3 ? a.parentNode : a;
}
var xb = null, yb = null, zb = null;
function Ab(a) {
  if (a = Bb(a)) {
    if (typeof xb !== "function")
      throw Error(p$2(280));
    var b2 = a.stateNode;
    b2 && (b2 = Cb(b2), xb(a.stateNode, a.type, b2));
  }
}
function Db(a) {
  yb ? zb ? zb.push(a) : zb = [a] : yb = a;
}
function Eb() {
  if (yb) {
    var a = yb, b2 = zb;
    zb = yb = null;
    Ab(a);
    if (b2)
      for (a = 0; a < b2.length; a++)
        Ab(b2[a]);
  }
}
function Fb(a, b2) {
  return a(b2);
}
function Gb() {
}
var Hb = false;
function Ib(a, b2, c) {
  if (Hb)
    return a(b2, c);
  Hb = true;
  try {
    return Fb(a, b2, c);
  } finally {
    if (Hb = false, yb !== null || zb !== null)
      Gb(), Eb();
  }
}
function Jb(a, b2) {
  var c = a.stateNode;
  if (c === null)
    return null;
  var d = Cb(c);
  if (d === null)
    return null;
  c = d[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !(a === "button" || a === "input" || a === "select" || a === "textarea"));
        a = !d;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c && typeof c !== "function")
    throw Error(p$2(231, b2, typeof c));
  return c;
}
var Kb = false;
if (ia)
  try {
    var Lb = {};
    Object.defineProperty(Lb, "passive", { get: function() {
      Kb = true;
    } });
    window.addEventListener("test", Lb, Lb);
    window.removeEventListener("test", Lb, Lb);
  } catch (a) {
    Kb = false;
  }
function Mb(a, b2, c, d, e, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c, l2);
  } catch (n2) {
    this.onError(n2);
  }
}
var Nb = false, Ob = null, Pb = false, Qb = null, Rb = { onError: function(a) {
  Nb = true;
  Ob = a;
} };
function Sb(a, b2, c, d, e, f2, g2, h2, k2) {
  Nb = false;
  Ob = null;
  Mb.apply(Rb, arguments);
}
function Tb(a, b2, c, d, e, f2, g2, h2, k2) {
  Sb.apply(this, arguments);
  if (Nb) {
    if (Nb) {
      var l2 = Ob;
      Nb = false;
      Ob = null;
    } else
      throw Error(p$2(198));
    Pb || (Pb = true, Qb = l2);
  }
}
function Ub(a) {
  var b2 = a, c = a;
  if (a.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a = b2;
    do
      b2 = a, (b2.flags & 4098) !== 0 && (c = b2.return), a = b2.return;
    while (a);
  }
  return b2.tag === 3 ? c : null;
}
function Vb(a) {
  if (a.tag === 13) {
    var b2 = a.memoizedState;
    b2 === null && (a = a.alternate, a !== null && (b2 = a.memoizedState));
    if (b2 !== null)
      return b2.dehydrated;
  }
  return null;
}
function Wb(a) {
  if (Ub(a) !== a)
    throw Error(p$2(188));
}
function Xb(a) {
  var b2 = a.alternate;
  if (!b2) {
    b2 = Ub(a);
    if (b2 === null)
      throw Error(p$2(188));
    return b2 !== a ? null : a;
  }
  for (var c = a, d = b2; ; ) {
    var e = c.return;
    if (e === null)
      break;
    var f2 = e.alternate;
    if (f2 === null) {
      d = e.return;
      if (d !== null) {
        c = d;
        continue;
      }
      break;
    }
    if (e.child === f2.child) {
      for (f2 = e.child; f2; ) {
        if (f2 === c)
          return Wb(e), a;
        if (f2 === d)
          return Wb(e), b2;
        f2 = f2.sibling;
      }
      throw Error(p$2(188));
    }
    if (c.return !== d.return)
      c = e, d = f2;
    else {
      for (var g2 = false, h2 = e.child; h2; ) {
        if (h2 === c) {
          g2 = true;
          c = e;
          d = f2;
          break;
        }
        if (h2 === d) {
          g2 = true;
          d = e;
          c = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c) {
            g2 = true;
            c = f2;
            d = e;
            break;
          }
          if (h2 === d) {
            g2 = true;
            d = f2;
            c = e;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$2(189));
      }
    }
    if (c.alternate !== d)
      throw Error(p$2(190));
  }
  if (c.tag !== 3)
    throw Error(p$2(188));
  return c.stateNode.current === c ? a : b2;
}
function Yb(a) {
  a = Xb(a);
  return a !== null ? Zb(a) : null;
}
function Zb(a) {
  if (a.tag === 5 || a.tag === 6)
    return a;
  for (a = a.child; a !== null; ) {
    var b2 = Zb(a);
    if (b2 !== null)
      return b2;
    a = a.sibling;
  }
  return null;
}
var $b = ba.unstable_scheduleCallback, ac = ba.unstable_cancelCallback, bc = ba.unstable_shouldYield, cc = ba.unstable_requestPaint, B = ba.unstable_now, dc = ba.unstable_getCurrentPriorityLevel, ec = ba.unstable_ImmediatePriority, fc = ba.unstable_UserBlockingPriority, gc = ba.unstable_NormalPriority, hc = ba.unstable_LowPriority, ic = ba.unstable_IdlePriority, jc = null, kc = null;
function lc(a) {
  if (kc && typeof kc.onCommitFiberRoot === "function")
    try {
      kc.onCommitFiberRoot(jc, a, void 0, (a.current.flags & 128) === 128);
    } catch (b2) {
    }
}
var nc = Math.clz32 ? Math.clz32 : mc, oc = Math.log, pc = Math.LN2;
function mc(a) {
  a >>>= 0;
  return a === 0 ? 32 : 31 - (oc(a) / pc | 0) | 0;
}
var qc = 64, rc = 4194304;
function sc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function tc(a, b2) {
  var c = a.pendingLanes;
  if (c === 0)
    return 0;
  var d = 0, e = a.suspendedLanes, f2 = a.pingedLanes, g2 = c & 268435455;
  if (g2 !== 0) {
    var h2 = g2 & ~e;
    h2 !== 0 ? d = sc(h2) : (f2 &= g2, f2 !== 0 && (d = sc(f2)));
  } else
    g2 = c & ~e, g2 !== 0 ? d = sc(g2) : f2 !== 0 && (d = sc(f2));
  if (d === 0)
    return 0;
  if (b2 !== 0 && b2 !== d && (b2 & e) === 0 && (e = d & -d, f2 = b2 & -b2, e >= f2 || e === 16 && (f2 & 4194240) !== 0))
    return b2;
  (d & 4) !== 0 && (d |= c & 16);
  b2 = a.entangledLanes;
  if (b2 !== 0)
    for (a = a.entanglements, b2 &= d; 0 < b2; )
      c = 31 - nc(b2), e = 1 << c, d |= a[c], b2 &= ~e;
  return d;
}
function uc(a, b2) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function vc(a, b2) {
  for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g2 = 31 - nc(f2), h2 = 1 << g2, k2 = e[g2];
    if (k2 === -1) {
      if ((h2 & c) === 0 || (h2 & d) !== 0)
        e[g2] = uc(h2, b2);
    } else
      k2 <= b2 && (a.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function wc(a) {
  a = a.pendingLanes & -1073741825;
  return a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
}
function xc() {
  var a = qc;
  qc <<= 1;
  (qc & 4194240) === 0 && (qc = 64);
  return a;
}
function yc(a) {
  for (var b2 = [], c = 0; 31 > c; c++)
    b2.push(a);
  return b2;
}
function zc(a, b2, c) {
  a.pendingLanes |= b2;
  b2 !== 536870912 && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b2 = 31 - nc(b2);
  a[b2] = c;
}
function Ac(a, b2) {
  var c = a.pendingLanes & ~b2;
  a.pendingLanes = b2;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b2;
  a.mutableReadLanes &= b2;
  a.entangledLanes &= b2;
  b2 = a.entanglements;
  var d = a.eventTimes;
  for (a = a.expirationTimes; 0 < c; ) {
    var e = 31 - nc(c), f2 = 1 << e;
    b2[e] = 0;
    d[e] = -1;
    a[e] = -1;
    c &= ~f2;
  }
}
function Bc(a, b2) {
  var c = a.entangledLanes |= b2;
  for (a = a.entanglements; c; ) {
    var d = 31 - nc(c), e = 1 << d;
    e & b2 | a[d] & b2 && (a[d] |= b2);
    c &= ~e;
  }
}
var C = 0;
function Cc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? (a & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
}
var Dc, Ec, Fc, Gc, Hc, Ic = false, Jc = [], Kc = null, Lc = null, Mc = null, Nc = /* @__PURE__ */ new Map(), Oc = /* @__PURE__ */ new Map(), Pc = [], Qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Rc(a, b2) {
  switch (a) {
    case "focusin":
    case "focusout":
      Kc = null;
      break;
    case "dragenter":
    case "dragleave":
      Lc = null;
      break;
    case "mouseover":
    case "mouseout":
      Mc = null;
      break;
    case "pointerover":
    case "pointerout":
      Nc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Oc.delete(b2.pointerId);
  }
}
function Sc(a, b2, c, d, e, f2) {
  if (a === null || a.nativeEvent !== f2)
    return a = { blockedOn: b2, domEventName: c, eventSystemFlags: d, nativeEvent: f2, targetContainers: [e] }, b2 !== null && (b2 = Bb(b2), b2 !== null && Ec(b2)), a;
  a.eventSystemFlags |= d;
  b2 = a.targetContainers;
  e !== null && b2.indexOf(e) === -1 && b2.push(e);
  return a;
}
function Tc(a, b2, c, d, e) {
  switch (b2) {
    case "focusin":
      return Kc = Sc(Kc, a, b2, c, d, e), true;
    case "dragenter":
      return Lc = Sc(Lc, a, b2, c, d, e), true;
    case "mouseover":
      return Mc = Sc(Mc, a, b2, c, d, e), true;
    case "pointerover":
      var f2 = e.pointerId;
      Nc.set(f2, Sc(Nc.get(f2) || null, a, b2, c, d, e));
      return true;
    case "gotpointercapture":
      return f2 = e.pointerId, Oc.set(f2, Sc(Oc.get(f2) || null, a, b2, c, d, e)), true;
  }
  return false;
}
function Uc(a) {
  var b2 = Vc(a.target);
  if (b2 !== null) {
    var c = Ub(b2);
    if (c !== null) {
      if (b2 = c.tag, b2 === 13) {
        if (b2 = Vb(c), b2 !== null) {
          a.blockedOn = b2;
          Hc(a.priority, function() {
            Fc(c);
          });
          return;
        }
      } else if (b2 === 3 && c.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Wc(a) {
  if (a.blockedOn !== null)
    return false;
  for (var b2 = a.targetContainers; 0 < b2.length; ) {
    var c = Xc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
    if (c === null) {
      c = a.nativeEvent;
      var d = new c.constructor(c.type, c);
      vb = d;
      c.target.dispatchEvent(d);
      vb = null;
    } else
      return b2 = Bb(c), b2 !== null && Ec(b2), a.blockedOn = c, false;
    b2.shift();
  }
  return true;
}
function Yc(a, b2, c) {
  Wc(a) && c.delete(b2);
}
function Zc() {
  Ic = false;
  Kc !== null && Wc(Kc) && (Kc = null);
  Lc !== null && Wc(Lc) && (Lc = null);
  Mc !== null && Wc(Mc) && (Mc = null);
  Nc.forEach(Yc);
  Oc.forEach(Yc);
}
function $c(a, b2) {
  a.blockedOn === b2 && (a.blockedOn = null, Ic || (Ic = true, ba.unstable_scheduleCallback(ba.unstable_NormalPriority, Zc)));
}
function ad(a) {
  function b2(b3) {
    return $c(b3, a);
  }
  if (0 < Jc.length) {
    $c(Jc[0], a);
    for (var c = 1; c < Jc.length; c++) {
      var d = Jc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  Kc !== null && $c(Kc, a);
  Lc !== null && $c(Lc, a);
  Mc !== null && $c(Mc, a);
  Nc.forEach(b2);
  Oc.forEach(b2);
  for (c = 0; c < Pc.length; c++)
    d = Pc[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < Pc.length && (c = Pc[0], c.blockedOn === null); )
    Uc(c), c.blockedOn === null && Pc.shift();
}
var bd = ta.ReactCurrentBatchConfig, cd = true;
function dd(a, b2, c, d) {
  var e = C, f2 = bd.transition;
  bd.transition = null;
  try {
    C = 1, ed(a, b2, c, d);
  } finally {
    C = e, bd.transition = f2;
  }
}
function fd(a, b2, c, d) {
  var e = C, f2 = bd.transition;
  bd.transition = null;
  try {
    C = 4, ed(a, b2, c, d);
  } finally {
    C = e, bd.transition = f2;
  }
}
function ed(a, b2, c, d) {
  if (cd) {
    var e = Xc(a, b2, c, d);
    if (e === null)
      gd(a, b2, d, hd, c), Rc(a, d);
    else if (Tc(e, a, b2, c, d))
      d.stopPropagation();
    else if (Rc(a, d), b2 & 4 && -1 < Qc.indexOf(a)) {
      for (; e !== null; ) {
        var f2 = Bb(e);
        f2 !== null && Dc(f2);
        f2 = Xc(a, b2, c, d);
        f2 === null && gd(a, b2, d, hd, c);
        if (f2 === e)
          break;
        e = f2;
      }
      e !== null && d.stopPropagation();
    } else
      gd(a, b2, d, null, c);
  }
}
var hd = null;
function Xc(a, b2, c, d) {
  hd = null;
  a = wb(d);
  a = Vc(a);
  if (a !== null)
    if (b2 = Ub(a), b2 === null)
      a = null;
    else if (c = b2.tag, c === 13) {
      a = Vb(b2);
      if (a !== null)
        return a;
      a = null;
    } else if (c === 3) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return b2.tag === 3 ? b2.stateNode.containerInfo : null;
      a = null;
    } else
      b2 !== a && (a = null);
  hd = a;
  return null;
}
function id(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (dc()) {
        case ec:
          return 1;
        case fc:
          return 4;
        case gc:
        case hc:
          return 16;
        case ic:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var jd = null, kd = null, ld = null;
function md() {
  if (ld)
    return ld;
  var a, b2 = kd, c = b2.length, d, e = "value" in jd ? jd.value : jd.textContent, f2 = e.length;
  for (a = 0; a < c && b2[a] === e[a]; a++)
    ;
  var g2 = c - a;
  for (d = 1; d <= g2 && b2[c - d] === e[f2 - d]; d++)
    ;
  return ld = e.slice(a, 1 < d ? 1 - d : void 0);
}
function nd(a) {
  var b2 = a.keyCode;
  "charCode" in a ? (a = a.charCode, a === 0 && b2 === 13 && (a = 13)) : a = b2;
  a === 10 && (a = 13);
  return 32 <= a || a === 13 ? a : 0;
}
function od() {
  return true;
}
function pd() {
  return false;
}
function qd(a) {
  function b2(b3, d, e, f2, g2) {
    this._reactName = b3;
    this._targetInst = e;
    this.type = d;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c in a)
      a.hasOwnProperty(c) && (b3 = a[c], this[c] = b3 ? b3(f2) : f2[c]);
    this.isDefaultPrevented = (f2.defaultPrevented != null ? f2.defaultPrevented : f2.returnValue === false) ? od : pd;
    this.isPropagationStopped = pd;
    return this;
  }
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : typeof a2.returnValue !== "unknown" && (a2.returnValue = false), this.isDefaultPrevented = od);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : typeof a2.cancelBubble !== "unknown" && (a2.cancelBubble = true), this.isPropagationStopped = od);
  }, persist: function() {
  }, isPersistent: od });
  return b2;
}
var rd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, sd = qd(rd), td = A$1({}, rd, { view: 0, detail: 0 }), ud = qd(td), vd, wd, xd, zd = A$1({}, td, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: yd, button: 0, buttons: 0, relatedTarget: function(a) {
  return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== xd && (xd && a.type === "mousemove" ? (vd = a.screenX - xd.screenX, wd = a.screenY - xd.screenY) : wd = vd = 0, xd = a);
  return vd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : wd;
} }), Ad = qd(zd), Bd = A$1({}, zd, { dataTransfer: 0 }), Cd = qd(Bd), Dd = A$1({}, td, { relatedTarget: 0 }), Ed = qd(Dd), Fd = A$1({}, rd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Gd = qd(Fd), Hd = A$1({}, rd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Id = qd(Hd), Jd = A$1({}, rd, { data: 0 }), Kd = qd(Jd), Ld = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Md = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Nd = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Od(a) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a) : (a = Nd[a]) ? !!b2[a] : false;
}
function yd() {
  return Od;
}
var Pd = A$1({}, td, { key: function(a) {
  if (a.key) {
    var b2 = Ld[a.key] || a.key;
    if (b2 !== "Unidentified")
      return b2;
  }
  return a.type === "keypress" ? (a = nd(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? Md[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: yd, charCode: function(a) {
  return a.type === "keypress" ? nd(a) : 0;
}, keyCode: function(a) {
  return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
}, which: function(a) {
  return a.type === "keypress" ? nd(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
} }), Qd = qd(Pd), Rd = A$1({}, zd, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Sd = qd(Rd), Td = A$1({}, td, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: yd }), Ud = qd(Td), Vd = A$1({}, rd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Wd = qd(Vd), Xd = A$1({}, zd, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Yd = qd(Xd), Zd = [9, 13, 27, 32], $d = ia && "CompositionEvent" in window, ae = null;
ia && "documentMode" in document && (ae = document.documentMode);
var be = ia && "TextEvent" in window && !ae, ce = ia && (!$d || ae && 8 < ae && 11 >= ae), de = String.fromCharCode(32), ee = false;
function fe(a, b2) {
  switch (a) {
    case "keyup":
      return Zd.indexOf(b2.keyCode) !== -1;
    case "keydown":
      return b2.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function ge(a) {
  a = a.detail;
  return typeof a === "object" && "data" in a ? a.data : null;
}
var he = false;
function ie(a, b2) {
  switch (a) {
    case "compositionend":
      return ge(b2);
    case "keypress":
      if (b2.which !== 32)
        return null;
      ee = true;
      return de;
    case "textInput":
      return a = b2.data, a === de && ee ? null : a;
    default:
      return null;
  }
}
function je(a, b2) {
  if (he)
    return a === "compositionend" || !$d && fe(a, b2) ? (a = md(), ld = kd = jd = null, he = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return ce && b2.locale !== "ko" ? null : b2.data;
    default:
      return null;
  }
}
var ke$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function le(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 === "input" ? !!ke$1[a.type] : b2 === "textarea" ? true : false;
}
function me(a, b2, c, d) {
  Db(d);
  b2 = ne(b2, "onChange");
  0 < b2.length && (c = new sd("onChange", "change", null, c, d), a.push({ event: c, listeners: b2 }));
}
var oe = null, pe = null;
function qe(a) {
  re(a, 0);
}
function se(a) {
  var b2 = te(a);
  if (Va(b2))
    return a;
}
function ue(a, b2) {
  if (a === "change")
    return b2;
}
var ve = false;
if (ia) {
  var we;
  if (ia) {
    var xe = "oninput" in document;
    if (!xe) {
      var ye = document.createElement("div");
      ye.setAttribute("oninput", "return;");
      xe = typeof ye.oninput === "function";
    }
    we = xe;
  } else
    we = false;
  ve = we && (!document.documentMode || 9 < document.documentMode);
}
function ze() {
  oe && (oe.detachEvent("onpropertychange", Ae), pe = oe = null);
}
function Ae(a) {
  if (a.propertyName === "value" && se(pe)) {
    var b2 = [];
    me(b2, pe, a, wb(a));
    Ib(qe, b2);
  }
}
function Be(a, b2, c) {
  a === "focusin" ? (ze(), oe = b2, pe = c, oe.attachEvent("onpropertychange", Ae)) : a === "focusout" && ze();
}
function Ce(a) {
  if (a === "selectionchange" || a === "keyup" || a === "keydown")
    return se(pe);
}
function De(a, b2) {
  if (a === "click")
    return se(b2);
}
function Ee(a, b2) {
  if (a === "input" || a === "change")
    return se(b2);
}
function Fe(a, b2) {
  return a === b2 && (a !== 0 || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var Ge = typeof Object.is === "function" ? Object.is : Fe;
function He(a, b2) {
  if (Ge(a, b2))
    return true;
  if (typeof a !== "object" || a === null || typeof b2 !== "object" || b2 === null)
    return false;
  var c = Object.keys(a), d = Object.keys(b2);
  if (c.length !== d.length)
    return false;
  for (d = 0; d < c.length; d++) {
    var e = c[d];
    if (!ja.call(b2, e) || !Ge(a[e], b2[e]))
      return false;
  }
  return true;
}
function Ie(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Je(a, b2) {
  var c = Ie(a);
  a = 0;
  for (var d; c; ) {
    if (c.nodeType === 3) {
      d = a + c.textContent.length;
      if (a <= b2 && d >= b2)
        return { node: c, offset: b2 - a };
      a = d;
    }
    a: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Ie(c);
  }
}
function Ke(a, b2) {
  return a && b2 ? a === b2 ? true : a && a.nodeType === 3 ? false : b2 && b2.nodeType === 3 ? Ke(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
}
function Le() {
  for (var a = window, b2 = Wa(); b2 instanceof a.HTMLIFrameElement; ) {
    try {
      var c = typeof b2.contentWindow.location.href === "string";
    } catch (d) {
      c = false;
    }
    if (c)
      a = b2.contentWindow;
    else
      break;
    b2 = Wa(a.document);
  }
  return b2;
}
function Me(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 && (b2 === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || b2 === "textarea" || a.contentEditable === "true");
}
function Ne(a) {
  var b2 = Le(), c = a.focusedElem, d = a.selectionRange;
  if (b2 !== c && c && c.ownerDocument && Ke(c.ownerDocument.documentElement, c)) {
    if (d !== null && Me(c)) {
      if (b2 = d.start, a = d.end, a === void 0 && (a = b2), "selectionStart" in c)
        c.selectionStart = b2, c.selectionEnd = Math.min(a, c.value.length);
      else if (a = (b2 = c.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e = c.textContent.length, f2 = Math.min(d.start, e);
        d = d.end === void 0 ? f2 : Math.min(d.end, e);
        !a.extend && f2 > d && (e = d, d = f2, f2 = e);
        e = Je(c, f2);
        var g2 = Je(c, d);
        e && g2 && (a.rangeCount !== 1 || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e.node, e.offset), a.removeAllRanges(), f2 > d ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
      }
    }
    b2 = [];
    for (a = c; a = a.parentNode; )
      a.nodeType === 1 && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    typeof c.focus === "function" && c.focus();
    for (c = 0; c < b2.length; c++)
      a = b2[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Oe = ia && "documentMode" in document && 11 >= document.documentMode, Pe = null, Qe = null, Re = null, Se = false;
function Te(a, b2, c) {
  var d = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
  Se || Pe == null || Pe !== Wa(d) || (d = Pe, "selectionStart" in d && Me(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Re && He(Re, d) || (Re = d, d = ne(Qe, "onSelect"), 0 < d.length && (b2 = new sd("onSelect", "select", null, b2, c), a.push({ event: b2, listeners: d }), b2.target = Pe)));
}
function Ue(a, b2) {
  var c = {};
  c[a.toLowerCase()] = b2.toLowerCase();
  c["Webkit" + a] = "webkit" + b2;
  c["Moz" + a] = "moz" + b2;
  return c;
}
var Ve = { animationend: Ue("Animation", "AnimationEnd"), animationiteration: Ue("Animation", "AnimationIteration"), animationstart: Ue("Animation", "AnimationStart"), transitionend: Ue("Transition", "TransitionEnd") }, We = {}, Xe = {};
ia && (Xe = document.createElement("div").style, "AnimationEvent" in window || (delete Ve.animationend.animation, delete Ve.animationiteration.animation, delete Ve.animationstart.animation), "TransitionEvent" in window || delete Ve.transitionend.transition);
function Ye(a) {
  if (We[a])
    return We[a];
  if (!Ve[a])
    return a;
  var b2 = Ve[a], c;
  for (c in b2)
    if (b2.hasOwnProperty(c) && c in Xe)
      return We[a] = b2[c];
  return a;
}
var Ze = Ye("animationend"), $e = Ye("animationiteration"), af = Ye("animationstart"), bf = Ye("transitionend"), cf = /* @__PURE__ */ new Map(), df = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ef(a, b2) {
  cf.set(a, b2);
  fa(b2, [a]);
}
for (var ff = 0; ff < df.length; ff++) {
  var gf = df[ff], hf = gf.toLowerCase(), jf = gf[0].toUpperCase() + gf.slice(1);
  ef(hf, "on" + jf);
}
ef(Ze, "onAnimationEnd");
ef($e, "onAnimationIteration");
ef(af, "onAnimationStart");
ef("dblclick", "onDoubleClick");
ef("focusin", "onFocus");
ef("focusout", "onBlur");
ef(bf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var kf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), lf = new Set("cancel close invalid load scroll toggle".split(" ").concat(kf));
function mf(a, b2, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Tb(d, b2, void 0, a);
  a.currentTarget = null;
}
function re(a, b2) {
  b2 = (b2 & 4) !== 0;
  for (var c = 0; c < a.length; c++) {
    var d = a[c], e = d.event;
    d = d.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d.length - 1; 0 <= g2; g2--) {
          var h2 = d[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e.isPropagationStopped())
            break a;
          mf(e, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d.length; g2++) {
          h2 = d[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e.isPropagationStopped())
            break a;
          mf(e, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Pb)
    throw a = Qb, Pb = false, Qb = null, a;
}
function D(a, b2) {
  var c = b2[nf];
  c === void 0 && (c = b2[nf] = /* @__PURE__ */ new Set());
  var d = a + "__bubble";
  c.has(d) || (of(b2, a, 2, false), c.add(d));
}
function pf(a, b2, c) {
  var d = 0;
  b2 && (d |= 4);
  of(c, a, d, b2);
}
var qf = "_reactListening" + Math.random().toString(36).slice(2);
function rf(a) {
  if (!a[qf]) {
    a[qf] = true;
    da.forEach(function(b3) {
      b3 !== "selectionchange" && (lf.has(b3) || pf(b3, false, a), pf(b3, true, a));
    });
    var b2 = a.nodeType === 9 ? a : a.ownerDocument;
    b2 === null || b2[qf] || (b2[qf] = true, pf("selectionchange", false, b2));
  }
}
function of(a, b2, c, d) {
  switch (id(b2)) {
    case 1:
      var e = dd;
      break;
    case 4:
      e = fd;
      break;
    default:
      e = ed;
  }
  c = e.bind(null, b2, c, a);
  e = void 0;
  !Kb || b2 !== "touchstart" && b2 !== "touchmove" && b2 !== "wheel" || (e = true);
  d ? e !== void 0 ? a.addEventListener(b2, c, { capture: true, passive: e }) : a.addEventListener(b2, c, true) : e !== void 0 ? a.addEventListener(b2, c, { passive: e }) : a.addEventListener(b2, c, false);
}
function gd(a, b2, c, d, e) {
  var f2 = d;
  if ((b2 & 1) === 0 && (b2 & 2) === 0 && d !== null)
    a:
      for (; ; ) {
        if (d === null)
          return;
        var g2 = d.tag;
        if (g2 === 3 || g2 === 4) {
          var h2 = d.stateNode.containerInfo;
          if (h2 === e || h2.nodeType === 8 && h2.parentNode === e)
            break;
          if (g2 === 4)
            for (g2 = d.return; g2 !== null; ) {
              var k2 = g2.tag;
              if (k2 === 3 || k2 === 4) {
                if (k2 = g2.stateNode.containerInfo, k2 === e || k2.nodeType === 8 && k2.parentNode === e)
                  return;
              }
              g2 = g2.return;
            }
          for (; h2 !== null; ) {
            g2 = Vc(h2);
            if (g2 === null)
              return;
            k2 = g2.tag;
            if (k2 === 5 || k2 === 6) {
              d = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d = d.return;
      }
  Ib(function() {
    var d2 = f2, e2 = wb(c), g3 = [];
    a: {
      var h3 = cf.get(a);
      if (h3 !== void 0) {
        var k3 = sd, m2 = a;
        switch (a) {
          case "keypress":
            if (nd(c) === 0)
              break a;
          case "keydown":
          case "keyup":
            k3 = Qd;
            break;
          case "focusin":
            m2 = "focus";
            k3 = Ed;
            break;
          case "focusout":
            m2 = "blur";
            k3 = Ed;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Ed;
            break;
          case "click":
            if (c.button === 2)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Ad;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Cd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Ud;
            break;
          case Ze:
          case $e:
          case af:
            k3 = Gd;
            break;
          case bf:
            k3 = Wd;
            break;
          case "scroll":
            k3 = ud;
            break;
          case "wheel":
            k3 = Yd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Id;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Sd;
        }
        var w2 = (b2 & 4) !== 0, J2 = !w2 && a === "scroll", v2 = w2 ? h3 !== null ? h3 + "Capture" : null : h3;
        w2 = [];
        for (var x2 = d2, r2; x2 !== null; ) {
          r2 = x2;
          var F2 = r2.stateNode;
          r2.tag === 5 && F2 !== null && (r2 = F2, v2 !== null && (F2 = Jb(x2, v2), F2 != null && w2.push(sf(x2, F2, r2))));
          if (J2)
            break;
          x2 = x2.return;
        }
        0 < w2.length && (h3 = new k3(h3, m2, null, c, e2), g3.push({ event: h3, listeners: w2 }));
      }
    }
    if ((b2 & 7) === 0) {
      a: {
        h3 = a === "mouseover" || a === "pointerover";
        k3 = a === "mouseout" || a === "pointerout";
        if (h3 && c !== vb && (m2 = c.relatedTarget || c.fromElement) && (Vc(m2) || m2[tf]))
          break a;
        if (k3 || h3) {
          h3 = e2.window === e2 ? e2 : (h3 = e2.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (m2 = c.relatedTarget || c.toElement, k3 = d2, m2 = m2 ? Vc(m2) : null, m2 !== null && (J2 = Ub(m2), m2 !== J2 || m2.tag !== 5 && m2.tag !== 6))
              m2 = null;
          } else
            k3 = null, m2 = d2;
          if (k3 !== m2) {
            w2 = Ad;
            F2 = "onMouseLeave";
            v2 = "onMouseEnter";
            x2 = "mouse";
            if (a === "pointerout" || a === "pointerover")
              w2 = Sd, F2 = "onPointerLeave", v2 = "onPointerEnter", x2 = "pointer";
            J2 = k3 == null ? h3 : te(k3);
            r2 = m2 == null ? h3 : te(m2);
            h3 = new w2(F2, x2 + "leave", k3, c, e2);
            h3.target = J2;
            h3.relatedTarget = r2;
            F2 = null;
            Vc(e2) === d2 && (w2 = new w2(v2, x2 + "enter", m2, c, e2), w2.target = r2, w2.relatedTarget = J2, F2 = w2);
            J2 = F2;
            if (k3 && m2)
              b: {
                w2 = k3;
                v2 = m2;
                x2 = 0;
                for (r2 = w2; r2; r2 = uf(r2))
                  x2++;
                r2 = 0;
                for (F2 = v2; F2; F2 = uf(F2))
                  r2++;
                for (; 0 < x2 - r2; )
                  w2 = uf(w2), x2--;
                for (; 0 < r2 - x2; )
                  v2 = uf(v2), r2--;
                for (; x2--; ) {
                  if (w2 === v2 || v2 !== null && w2 === v2.alternate)
                    break b;
                  w2 = uf(w2);
                  v2 = uf(v2);
                }
                w2 = null;
              }
            else
              w2 = null;
            k3 !== null && vf(g3, h3, k3, w2, false);
            m2 !== null && J2 !== null && vf(g3, J2, m2, w2, true);
          }
        }
      }
      a: {
        h3 = d2 ? te(d2) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if (k3 === "select" || k3 === "input" && h3.type === "file")
          var Z = ue;
        else if (le(h3))
          if (ve)
            Z = Ee;
          else {
            Z = Ce;
            var ya = Be;
          }
        else
          (k3 = h3.nodeName) && k3.toLowerCase() === "input" && (h3.type === "checkbox" || h3.type === "radio") && (Z = De);
        if (Z && (Z = Z(a, d2))) {
          me(g3, Z, c, e2);
          break a;
        }
        ya && ya(a, h3, d2);
        a === "focusout" && (ya = h3._wrapperState) && ya.controlled && h3.type === "number" && bb(h3, "number", h3.value);
      }
      ya = d2 ? te(d2) : window;
      switch (a) {
        case "focusin":
          if (le(ya) || ya.contentEditable === "true")
            Pe = ya, Qe = d2, Re = null;
          break;
        case "focusout":
          Re = Qe = Pe = null;
          break;
        case "mousedown":
          Se = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Se = false;
          Te(g3, c, e2);
          break;
        case "selectionchange":
          if (Oe)
            break;
        case "keydown":
        case "keyup":
          Te(g3, c, e2);
      }
      var ab;
      if ($d)
        b: {
          switch (a) {
            case "compositionstart":
              var ca = "onCompositionStart";
              break b;
            case "compositionend":
              ca = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ca = "onCompositionUpdate";
              break b;
          }
          ca = void 0;
        }
      else
        he ? fe(a, c) && (ca = "onCompositionEnd") : a === "keydown" && c.keyCode === 229 && (ca = "onCompositionStart");
      ca && (ce && c.locale !== "ko" && (he || ca !== "onCompositionStart" ? ca === "onCompositionEnd" && he && (ab = md()) : (jd = e2, kd = "value" in jd ? jd.value : jd.textContent, he = true)), ya = ne(d2, ca), 0 < ya.length && (ca = new Kd(ca, a, null, c, e2), g3.push({ event: ca, listeners: ya }), ab ? ca.data = ab : (ab = ge(c), ab !== null && (ca.data = ab))));
      if (ab = be ? ie(a, c) : je(a, c))
        d2 = ne(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Kd("onBeforeInput", "beforeinput", null, c, e2), g3.push({ event: e2, listeners: d2 }), e2.data = ab);
    }
    re(g3, b2);
  });
}
function sf(a, b2, c) {
  return { instance: a, listener: b2, currentTarget: c };
}
function ne(a, b2) {
  for (var c = b2 + "Capture", d = []; a !== null; ) {
    var e = a, f2 = e.stateNode;
    e.tag === 5 && f2 !== null && (e = f2, f2 = Jb(a, c), f2 != null && d.unshift(sf(a, f2, e)), f2 = Jb(a, b2), f2 != null && d.push(sf(a, f2, e)));
    a = a.return;
  }
  return d;
}
function uf(a) {
  if (a === null)
    return null;
  do
    a = a.return;
  while (a && a.tag !== 5);
  return a ? a : null;
}
function vf(a, b2, c, d, e) {
  for (var f2 = b2._reactName, g2 = []; c !== null && c !== d; ) {
    var h2 = c, k2 = h2.alternate, l2 = h2.stateNode;
    if (k2 !== null && k2 === d)
      break;
    h2.tag === 5 && l2 !== null && (h2 = l2, e ? (k2 = Jb(c, f2), k2 != null && g2.unshift(sf(c, k2, h2))) : e || (k2 = Jb(c, f2), k2 != null && g2.push(sf(c, k2, h2))));
    c = c.return;
  }
  g2.length !== 0 && a.push({ event: b2, listeners: g2 });
}
var wf = /\r\n?/g, xf = /\u0000|\uFFFD/g;
function yf(a) {
  return (typeof a === "string" ? a : "" + a).replace(wf, "\n").replace(xf, "");
}
function zf(a, b2, c) {
  b2 = yf(b2);
  if (yf(a) !== b2 && c)
    throw Error(p$2(425));
}
function Af() {
}
var Bf = null, Cf = null;
function Df(a, b2) {
  return a === "textarea" || a === "noscript" || typeof b2.children === "string" || typeof b2.children === "number" || typeof b2.dangerouslySetInnerHTML === "object" && b2.dangerouslySetInnerHTML !== null && b2.dangerouslySetInnerHTML.__html != null;
}
var Ef = typeof setTimeout === "function" ? setTimeout : void 0, Ff = typeof clearTimeout === "function" ? clearTimeout : void 0, Gf = typeof Promise === "function" ? Promise : void 0, If = typeof queueMicrotask === "function" ? queueMicrotask : typeof Gf !== "undefined" ? function(a) {
  return Gf.resolve(null).then(a).catch(Hf);
} : Ef;
function Hf(a) {
  setTimeout(function() {
    throw a;
  });
}
function Jf(a, b2) {
  var c = b2, d = 0;
  do {
    var e = c.nextSibling;
    a.removeChild(c);
    if (e && e.nodeType === 8)
      if (c = e.data, c === "/$") {
        if (d === 0) {
          a.removeChild(e);
          ad(b2);
          return;
        }
        d--;
      } else
        c !== "$" && c !== "$?" && c !== "$!" || d++;
    c = e;
  } while (c);
  ad(b2);
}
function Kf(a) {
  for (; a != null; a = a.nextSibling) {
    var b2 = a.nodeType;
    if (b2 === 1 || b2 === 3)
      break;
    if (b2 === 8) {
      b2 = a.data;
      if (b2 === "$" || b2 === "$!" || b2 === "$?")
        break;
      if (b2 === "/$")
        return null;
    }
  }
  return a;
}
function Lf(a) {
  a = a.previousSibling;
  for (var b2 = 0; a; ) {
    if (a.nodeType === 8) {
      var c = a.data;
      if (c === "$" || c === "$!" || c === "$?") {
        if (b2 === 0)
          return a;
        b2--;
      } else
        c === "/$" && b2++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Mf = Math.random().toString(36).slice(2), Nf = "__reactFiber$" + Mf, Of = "__reactProps$" + Mf, tf = "__reactContainer$" + Mf, nf = "__reactEvents$" + Mf, Pf = "__reactListeners$" + Mf, Qf = "__reactHandles$" + Mf;
function Vc(a) {
  var b2 = a[Nf];
  if (b2)
    return b2;
  for (var c = a.parentNode; c; ) {
    if (b2 = c[tf] || c[Nf]) {
      c = b2.alternate;
      if (b2.child !== null || c !== null && c.child !== null)
        for (a = Lf(a); a !== null; ) {
          if (c = a[Nf])
            return c;
          a = Lf(a);
        }
      return b2;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Bb(a) {
  a = a[Nf] || a[tf];
  return !a || a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3 ? null : a;
}
function te(a) {
  if (a.tag === 5 || a.tag === 6)
    return a.stateNode;
  throw Error(p$2(33));
}
function Cb(a) {
  return a[Of] || null;
}
var Rf = [], Sf = -1;
function Tf(a) {
  return { current: a };
}
function E(a) {
  0 > Sf || (a.current = Rf[Sf], Rf[Sf] = null, Sf--);
}
function G(a, b2) {
  Sf++;
  Rf[Sf] = a.current;
  a.current = b2;
}
var Uf = {}, H = Tf(Uf), Vf = Tf(false), Wf = Uf;
function Xf(a, b2) {
  var c = a.type.contextTypes;
  if (!c)
    return Uf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d.__reactInternalMemoizedMaskedChildContext;
  var e = {}, f2;
  for (f2 in c)
    e[f2] = b2[f2];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}
function Yf(a) {
  a = a.childContextTypes;
  return a !== null && a !== void 0;
}
function Zf() {
  E(Vf);
  E(H);
}
function $f(a, b2, c) {
  if (H.current !== Uf)
    throw Error(p$2(168));
  G(H, b2);
  G(Vf, c);
}
function ag(a, b2, c) {
  var d = a.stateNode;
  b2 = b2.childContextTypes;
  if (typeof d.getChildContext !== "function")
    return c;
  d = d.getChildContext();
  for (var e in d)
    if (!(e in b2))
      throw Error(p$2(108, Qa(a) || "Unknown", e));
  return A$1({}, c, d);
}
function bg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Uf;
  Wf = H.current;
  G(H, a);
  G(Vf, Vf.current);
  return true;
}
function cg(a, b2, c) {
  var d = a.stateNode;
  if (!d)
    throw Error(p$2(169));
  c ? (a = ag(a, b2, Wf), d.__reactInternalMemoizedMergedChildContext = a, E(Vf), E(H), G(H, a)) : E(Vf);
  G(Vf, c);
}
var dg = null, eg = false, fg = false;
function gg(a) {
  dg === null ? dg = [a] : dg.push(a);
}
function hg(a) {
  eg = true;
  gg(a);
}
function ig() {
  if (!fg && dg !== null) {
    fg = true;
    var a = 0, b2 = C;
    try {
      var c = dg;
      for (C = 1; a < c.length; a++) {
        var d = c[a];
        do
          d = d(true);
        while (d !== null);
      }
      dg = null;
      eg = false;
    } catch (e) {
      throw dg !== null && (dg = dg.slice(a + 1)), $b(ec, ig), e;
    } finally {
      C = b2, fg = false;
    }
  }
  return null;
}
var jg = ta.ReactCurrentBatchConfig;
function kg(a, b2) {
  if (a && a.defaultProps) {
    b2 = A$1({}, b2);
    a = a.defaultProps;
    for (var c in a)
      b2[c] === void 0 && (b2[c] = a[c]);
    return b2;
  }
  return b2;
}
var lg = Tf(null), mg = null, ng = null, og = null;
function pg() {
  og = ng = mg = null;
}
function qg(a) {
  var b2 = lg.current;
  E(lg);
  a._currentValue = b2;
}
function rg(a, b2, c) {
  for (; a !== null; ) {
    var d = a.alternate;
    (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, d !== null && (d.childLanes |= b2)) : d !== null && (d.childLanes & b2) !== b2 && (d.childLanes |= b2);
    if (a === c)
      break;
    a = a.return;
  }
}
function sg(a, b2) {
  mg = a;
  og = ng = null;
  a = a.dependencies;
  a !== null && a.firstContext !== null && ((a.lanes & b2) !== 0 && (tg = true), a.firstContext = null);
}
function ug(a) {
  var b2 = a._currentValue;
  if (og !== a)
    if (a = { context: a, memoizedValue: b2, next: null }, ng === null) {
      if (mg === null)
        throw Error(p$2(308));
      ng = a;
      mg.dependencies = { lanes: 0, firstContext: a };
    } else
      ng = ng.next = a;
  return b2;
}
var vg = null, wg = false;
function xg(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function yg(a, b2) {
  a = a.updateQueue;
  b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function zg(a, b2) {
  return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function Ag(a, b2) {
  var c = a.updateQueue;
  c !== null && (c = c.shared, Bg(a) ? (a = c.interleaved, a === null ? (b2.next = b2, vg === null ? vg = [c] : vg.push(c)) : (b2.next = a.next, a.next = b2), c.interleaved = b2) : (a = c.pending, a === null ? b2.next = b2 : (b2.next = a.next, a.next = b2), c.pending = b2));
}
function Cg(a, b2, c) {
  b2 = b2.updateQueue;
  if (b2 !== null && (b2 = b2.shared, (c & 4194240) !== 0)) {
    var d = b2.lanes;
    d &= a.pendingLanes;
    c |= d;
    b2.lanes = c;
    Bc(a, c);
  }
}
function Dg(a, b2) {
  var c = a.updateQueue, d = a.alternate;
  if (d !== null && (d = d.updateQueue, c === d)) {
    var e = null, f2 = null;
    c = c.firstBaseUpdate;
    if (c !== null) {
      do {
        var g2 = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        f2 === null ? e = f2 = g2 : f2 = f2.next = g2;
        c = c.next;
      } while (c !== null);
      f2 === null ? e = f2 = b2 : f2 = f2.next = b2;
    } else
      e = f2 = b2;
    c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f2, shared: d.shared, effects: d.effects };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  a === null ? c.firstBaseUpdate = b2 : a.next = b2;
  c.lastBaseUpdate = b2;
}
function Eg(a, b2, c, d) {
  var e = a.updateQueue;
  wg = false;
  var f2 = e.firstBaseUpdate, g2 = e.lastBaseUpdate, h2 = e.shared.pending;
  if (h2 !== null) {
    e.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    g2 === null ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var n2 = a.alternate;
    n2 !== null && (n2 = n2.updateQueue, h2 = n2.lastBaseUpdate, h2 !== g2 && (h2 === null ? n2.firstBaseUpdate = l2 : h2.next = l2, n2.lastBaseUpdate = k2));
  }
  if (f2 !== null) {
    var u2 = e.baseState;
    g2 = 0;
    n2 = l2 = k2 = null;
    h2 = f2;
    do {
      var q2 = h2.lane, y2 = h2.eventTime;
      if ((d & q2) === q2) {
        n2 !== null && (n2 = n2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var m2 = a, w2 = h2;
          q2 = b2;
          y2 = c;
          switch (w2.tag) {
            case 1:
              m2 = w2.payload;
              if (typeof m2 === "function") {
                u2 = m2.call(y2, u2, q2);
                break a;
              }
              u2 = m2;
              break a;
            case 3:
              m2.flags = m2.flags & -65537 | 128;
            case 0:
              m2 = w2.payload;
              q2 = typeof m2 === "function" ? m2.call(y2, u2, q2) : m2;
              if (q2 === null || q2 === void 0)
                break a;
              u2 = A$1({}, u2, q2);
              break a;
            case 2:
              wg = true;
          }
        }
        h2.callback !== null && h2.lane !== 0 && (a.flags |= 64, q2 = e.effects, q2 === null ? e.effects = [h2] : q2.push(h2));
      } else
        y2 = { eventTime: y2, lane: q2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, n2 === null ? (l2 = n2 = y2, k2 = u2) : n2 = n2.next = y2, g2 |= q2;
      h2 = h2.next;
      if (h2 === null)
        if (h2 = e.shared.pending, h2 === null)
          break;
        else
          q2 = h2, h2 = q2.next, q2.next = null, e.lastBaseUpdate = q2, e.shared.pending = null;
    } while (1);
    n2 === null && (k2 = u2);
    e.baseState = k2;
    e.firstBaseUpdate = l2;
    e.lastBaseUpdate = n2;
    b2 = e.shared.interleaved;
    if (b2 !== null) {
      e = b2;
      do
        g2 |= e.lane, e = e.next;
      while (e !== b2);
    } else
      f2 === null && (e.shared.lanes = 0);
    Fg |= g2;
    a.lanes = g2;
    a.memoizedState = u2;
  }
}
function Gg(a, b2, c) {
  a = b2.effects;
  b2.effects = null;
  if (a !== null)
    for (b2 = 0; b2 < a.length; b2++) {
      var d = a[b2], e = d.callback;
      if (e !== null) {
        d.callback = null;
        d = c;
        if (typeof e !== "function")
          throw Error(p$2(191, e));
        e.call(d);
      }
    }
}
var Hg = new aa.Component().refs;
function Ig(a, b2, c, d) {
  b2 = a.memoizedState;
  c = c(d, b2);
  c = c === null || c === void 0 ? b2 : A$1({}, b2, c);
  a.memoizedState = c;
  a.lanes === 0 && (a.updateQueue.baseState = c);
}
var Mg = { isMounted: function(a) {
  return (a = a._reactInternals) ? Ub(a) === a : false;
}, enqueueSetState: function(a, b2, c) {
  a = a._reactInternals;
  var d = Jg(), e = Kg(a), f2 = zg(d, e);
  f2.payload = b2;
  c !== void 0 && c !== null && (f2.callback = c);
  Ag(a, f2);
  b2 = Lg(a, e, d);
  b2 !== null && Cg(b2, a, e);
}, enqueueReplaceState: function(a, b2, c) {
  a = a._reactInternals;
  var d = Jg(), e = Kg(a), f2 = zg(d, e);
  f2.tag = 1;
  f2.payload = b2;
  c !== void 0 && c !== null && (f2.callback = c);
  Ag(a, f2);
  b2 = Lg(a, e, d);
  b2 !== null && Cg(b2, a, e);
}, enqueueForceUpdate: function(a, b2) {
  a = a._reactInternals;
  var c = Jg(), d = Kg(a), e = zg(c, d);
  e.tag = 2;
  b2 !== void 0 && b2 !== null && (e.callback = b2);
  Ag(a, e);
  b2 = Lg(a, d, c);
  b2 !== null && Cg(b2, a, d);
} };
function Ng(a, b2, c, d, e, f2, g2) {
  a = a.stateNode;
  return typeof a.shouldComponentUpdate === "function" ? a.shouldComponentUpdate(d, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !He(c, d) || !He(e, f2) : true;
}
function Og(a, b2, c) {
  var d = false, e = Uf;
  var f2 = b2.contextType;
  typeof f2 === "object" && f2 !== null ? f2 = ug(f2) : (e = Yf(b2) ? Wf : H.current, d = b2.contextTypes, f2 = (d = d !== null && d !== void 0) ? Xf(a, e) : Uf);
  b2 = new b2(c, f2);
  a.memoizedState = b2.state !== null && b2.state !== void 0 ? b2.state : null;
  b2.updater = Mg;
  a.stateNode = b2;
  b2._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Pg(a, b2, c, d) {
  a = b2.state;
  typeof b2.componentWillReceiveProps === "function" && b2.componentWillReceiveProps(c, d);
  typeof b2.UNSAFE_componentWillReceiveProps === "function" && b2.UNSAFE_componentWillReceiveProps(c, d);
  b2.state !== a && Mg.enqueueReplaceState(b2, b2.state, null);
}
function Qg(a, b2, c, d) {
  var e = a.stateNode;
  e.props = c;
  e.state = a.memoizedState;
  e.refs = Hg;
  xg(a);
  var f2 = b2.contextType;
  typeof f2 === "object" && f2 !== null ? e.context = ug(f2) : (f2 = Yf(b2) ? Wf : H.current, e.context = Xf(a, f2));
  e.state = a.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  typeof f2 === "function" && (Ig(a, b2, f2, c), e.state = a.memoizedState);
  typeof b2.getDerivedStateFromProps === "function" || typeof e.getSnapshotBeforeUpdate === "function" || typeof e.UNSAFE_componentWillMount !== "function" && typeof e.componentWillMount !== "function" || (b2 = e.state, typeof e.componentWillMount === "function" && e.componentWillMount(), typeof e.UNSAFE_componentWillMount === "function" && e.UNSAFE_componentWillMount(), b2 !== e.state && Mg.enqueueReplaceState(e, e.state, null), Eg(a, c, e, d), e.state = a.memoizedState);
  typeof e.componentDidMount === "function" && (a.flags |= 4194308);
}
var Rg = [], Sg = 0, Tg = null, Ug = 0, Vg = [], Wg = 0, Xg = null, Yg = 1, Zg = "";
function $g(a, b2) {
  Rg[Sg++] = Ug;
  Rg[Sg++] = Tg;
  Tg = a;
  Ug = b2;
}
function ah(a, b2, c) {
  Vg[Wg++] = Yg;
  Vg[Wg++] = Zg;
  Vg[Wg++] = Xg;
  Xg = a;
  var d = Yg;
  a = Zg;
  var e = 32 - nc(d) - 1;
  d &= ~(1 << e);
  c += 1;
  var f2 = 32 - nc(b2) + e;
  if (30 < f2) {
    var g2 = e - e % 5;
    f2 = (d & (1 << g2) - 1).toString(32);
    d >>= g2;
    e -= g2;
    Yg = 1 << 32 - nc(b2) + e | c << e | d;
    Zg = f2 + a;
  } else
    Yg = 1 << f2 | c << e | d, Zg = a;
}
function bh(a) {
  a.return !== null && ($g(a, 1), ah(a, 1, 0));
}
function ch(a) {
  for (; a === Tg; )
    Tg = Rg[--Sg], Rg[Sg] = null, Ug = Rg[--Sg], Rg[Sg] = null;
  for (; a === Xg; )
    Xg = Vg[--Wg], Vg[Wg] = null, Zg = Vg[--Wg], Vg[Wg] = null, Yg = Vg[--Wg], Vg[Wg] = null;
}
var dh = null, eh = null, I = false, fh = null;
function gh(a, b2) {
  var c = hh(5, null, null, 0);
  c.elementType = "DELETED";
  c.stateNode = b2;
  c.return = a;
  b2 = a.deletions;
  b2 === null ? (a.deletions = [c], a.flags |= 16) : b2.push(c);
}
function ih(a, b2) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b2 = b2.nodeType !== 1 || c.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return b2 !== null ? (a.stateNode = b2, dh = a, eh = Kf(b2.firstChild), true) : false;
    case 6:
      return b2 = a.pendingProps === "" || b2.nodeType !== 3 ? null : b2, b2 !== null ? (a.stateNode = b2, dh = a, eh = null, true) : false;
    case 13:
      return b2 = b2.nodeType !== 8 ? null : b2, b2 !== null ? (c = Xg !== null ? { id: Yg, overflow: Zg } : null, a.memoizedState = { dehydrated: b2, treeContext: c, retryLane: 1073741824 }, c = hh(18, null, null, 0), c.stateNode = b2, c.return = a, a.child = c, dh = a, eh = null, true) : false;
    default:
      return false;
  }
}
function jh(a) {
  return (a.mode & 1) !== 0 && (a.flags & 128) === 0;
}
function kh(a) {
  if (I) {
    var b2 = eh;
    if (b2) {
      var c = b2;
      if (!ih(a, b2)) {
        if (jh(a))
          throw Error(p$2(418));
        b2 = Kf(c.nextSibling);
        var d = dh;
        b2 && ih(a, b2) ? gh(d, c) : (a.flags = a.flags & -4097 | 2, I = false, dh = a);
      }
    } else {
      if (jh(a))
        throw Error(p$2(418));
      a.flags = a.flags & -4097 | 2;
      I = false;
      dh = a;
    }
  }
}
function lh(a) {
  for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )
    a = a.return;
  dh = a;
}
function mh(a) {
  if (a !== dh)
    return false;
  if (!I)
    return lh(a), I = true, false;
  var b2;
  (b2 = a.tag !== 3) && !(b2 = a.tag !== 5) && (b2 = a.type, b2 = b2 !== "head" && b2 !== "body" && !Df(a.type, a.memoizedProps));
  if (b2 && (b2 = eh)) {
    if (jh(a)) {
      for (a = eh; a; )
        a = Kf(a.nextSibling);
      throw Error(p$2(418));
    }
    for (; b2; )
      gh(a, b2), b2 = Kf(b2.nextSibling);
  }
  lh(a);
  if (a.tag === 13) {
    a = a.memoizedState;
    a = a !== null ? a.dehydrated : null;
    if (!a)
      throw Error(p$2(317));
    a: {
      a = a.nextSibling;
      for (b2 = 0; a; ) {
        if (a.nodeType === 8) {
          var c = a.data;
          if (c === "/$") {
            if (b2 === 0) {
              eh = Kf(a.nextSibling);
              break a;
            }
            b2--;
          } else
            c !== "$" && c !== "$!" && c !== "$?" || b2++;
        }
        a = a.nextSibling;
      }
      eh = null;
    }
  } else
    eh = dh ? Kf(a.stateNode.nextSibling) : null;
  return true;
}
function nh() {
  eh = dh = null;
  I = false;
}
function oh(a) {
  fh === null ? fh = [a] : fh.push(a);
}
function ph(a, b2, c) {
  a = c.ref;
  if (a !== null && typeof a !== "function" && typeof a !== "object") {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (c.tag !== 1)
          throw Error(p$2(309));
        var d = c.stateNode;
      }
      if (!d)
        throw Error(p$2(147, a));
      var e = d, f2 = "" + a;
      if (b2 !== null && b2.ref !== null && typeof b2.ref === "function" && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a2) {
        var b3 = e.refs;
        b3 === Hg && (b3 = e.refs = {});
        a2 === null ? delete b3[f2] : b3[f2] = a2;
      };
      b2._stringRef = f2;
      return b2;
    }
    if (typeof a !== "string")
      throw Error(p$2(284));
    if (!c._owner)
      throw Error(p$2(290, a));
  }
  return a;
}
function qh(a, b2) {
  a = Object.prototype.toString.call(b2);
  throw Error(p$2(31, a === "[object Object]" ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
}
function rh(a) {
  var b2 = a._init;
  return b2(a._payload);
}
function sh(a) {
  function b2(b3, c2) {
    if (a) {
      var d2 = b3.deletions;
      d2 === null ? (b3.deletions = [c2], b3.flags |= 16) : d2.push(c2);
    }
  }
  function c(c2, d2) {
    if (!a)
      return null;
    for (; d2 !== null; )
      b2(c2, d2), d2 = d2.sibling;
    return null;
  }
  function d(a2, b3) {
    for (a2 = /* @__PURE__ */ new Map(); b3 !== null; )
      b3.key !== null ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
    return a2;
  }
  function e(a2, b3) {
    a2 = th(a2, b3);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b3, c2, d2) {
    b3.index = d2;
    if (!a)
      return b3.flags |= 1048576, c2;
    d2 = b3.alternate;
    if (d2 !== null)
      return d2 = d2.index, d2 < c2 ? (b3.flags |= 2, c2) : d2;
    b3.flags |= 2;
    return c2;
  }
  function g2(b3) {
    a && b3.alternate === null && (b3.flags |= 2);
    return b3;
  }
  function h2(a2, b3, c2, d2) {
    if (b3 === null || b3.tag !== 6)
      return b3 = uh(c2, a2.mode, d2), b3.return = a2, b3;
    b3 = e(b3, c2);
    b3.return = a2;
    return b3;
  }
  function k2(a2, b3, c2, d2) {
    var f3 = c2.type;
    if (f3 === wa)
      return n2(a2, b3, c2.props.children, d2, c2.key);
    if (b3 !== null && (b3.elementType === f3 || typeof f3 === "object" && f3 !== null && f3.$$typeof === Ga && rh(f3) === b3.type))
      return d2 = e(b3, c2.props), d2.ref = ph(a2, b3, c2), d2.return = a2, d2;
    d2 = vh(c2.type, c2.key, c2.props, null, a2.mode, d2);
    d2.ref = ph(a2, b3, c2);
    d2.return = a2;
    return d2;
  }
  function l2(a2, b3, c2, d2) {
    if (b3 === null || b3.tag !== 4 || b3.stateNode.containerInfo !== c2.containerInfo || b3.stateNode.implementation !== c2.implementation)
      return b3 = wh(c2, a2.mode, d2), b3.return = a2, b3;
    b3 = e(b3, c2.children || []);
    b3.return = a2;
    return b3;
  }
  function n2(a2, b3, c2, d2, f3) {
    if (b3 === null || b3.tag !== 7)
      return b3 = xh(c2, a2.mode, d2, f3), b3.return = a2, b3;
    b3 = e(b3, c2);
    b3.return = a2;
    return b3;
  }
  function u2(a2, b3, c2) {
    if (typeof b3 === "string" && b3 !== "" || typeof b3 === "number")
      return b3 = uh("" + b3, a2.mode, c2), b3.return = a2, b3;
    if (typeof b3 === "object" && b3 !== null) {
      switch (b3.$$typeof) {
        case ua:
          return c2 = vh(b3.type, b3.key, b3.props, null, a2.mode, c2), c2.ref = ph(a2, null, b3), c2.return = a2, c2;
        case va:
          return b3 = wh(b3, a2.mode, c2), b3.return = a2, b3;
        case Ga:
          var d2 = b3._init;
          return u2(a2, d2(b3._payload), c2);
      }
      if (db(b3) || Ja(b3))
        return b3 = xh(b3, a2.mode, c2, null), b3.return = a2, b3;
      qh(a2, b3);
    }
    return null;
  }
  function q2(a2, b3, c2, d2) {
    var e2 = b3 !== null ? b3.key : null;
    if (typeof c2 === "string" && c2 !== "" || typeof c2 === "number")
      return e2 !== null ? null : h2(a2, b3, "" + c2, d2);
    if (typeof c2 === "object" && c2 !== null) {
      switch (c2.$$typeof) {
        case ua:
          return c2.key === e2 ? k2(a2, b3, c2, d2) : null;
        case va:
          return c2.key === e2 ? l2(a2, b3, c2, d2) : null;
        case Ga:
          return e2 = c2._init, q2(a2, b3, e2(c2._payload), d2);
      }
      if (db(c2) || Ja(c2))
        return e2 !== null ? null : n2(a2, b3, c2, d2, null);
      qh(a2, c2);
    }
    return null;
  }
  function y2(a2, b3, c2, d2, e2) {
    if (typeof d2 === "string" && d2 !== "" || typeof d2 === "number")
      return a2 = a2.get(c2) || null, h2(b3, a2, "" + d2, e2);
    if (typeof d2 === "object" && d2 !== null) {
      switch (d2.$$typeof) {
        case ua:
          return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, k2(b3, a2, d2, e2);
        case va:
          return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, l2(b3, a2, d2, e2);
        case Ga:
          var f3 = d2._init;
          return y2(a2, b3, c2, f3(d2._payload), e2);
      }
      if (db(d2) || Ja(d2))
        return a2 = a2.get(c2) || null, n2(b3, a2, d2, e2, null);
      qh(b3, d2);
    }
    return null;
  }
  function m2(e2, g3, h3, k3) {
    for (var l3 = null, n3 = null, r2 = g3, m3 = g3 = 0, x2 = null; r2 !== null && m3 < h3.length; m3++) {
      r2.index > m3 ? (x2 = r2, r2 = null) : x2 = r2.sibling;
      var v2 = q2(e2, r2, h3[m3], k3);
      if (v2 === null) {
        r2 === null && (r2 = x2);
        break;
      }
      a && r2 && v2.alternate === null && b2(e2, r2);
      g3 = f2(v2, g3, m3);
      n3 === null ? l3 = v2 : n3.sibling = v2;
      n3 = v2;
      r2 = x2;
    }
    if (m3 === h3.length)
      return c(e2, r2), I && $g(e2, m3), l3;
    if (r2 === null) {
      for (; m3 < h3.length; m3++)
        r2 = u2(e2, h3[m3], k3), r2 !== null && (g3 = f2(r2, g3, m3), n3 === null ? l3 = r2 : n3.sibling = r2, n3 = r2);
      I && $g(e2, m3);
      return l3;
    }
    for (r2 = d(e2, r2); m3 < h3.length; m3++)
      x2 = y2(r2, e2, m3, h3[m3], k3), x2 !== null && (a && x2.alternate !== null && r2.delete(x2.key === null ? m3 : x2.key), g3 = f2(x2, g3, m3), n3 === null ? l3 = x2 : n3.sibling = x2, n3 = x2);
    a && r2.forEach(function(a2) {
      return b2(e2, a2);
    });
    I && $g(e2, m3);
    return l3;
  }
  function w2(e2, g3, h3, k3) {
    var l3 = Ja(h3);
    if (typeof l3 !== "function")
      throw Error(p$2(150));
    h3 = l3.call(h3);
    if (h3 == null)
      throw Error(p$2(151));
    for (var n3 = l3 = null, m3 = g3, r2 = g3 = 0, x2 = null, v2 = h3.next(); m3 !== null && !v2.done; r2++, v2 = h3.next()) {
      m3.index > r2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var w3 = q2(e2, m3, v2.value, k3);
      if (w3 === null) {
        m3 === null && (m3 = x2);
        break;
      }
      a && m3 && w3.alternate === null && b2(e2, m3);
      g3 = f2(w3, g3, r2);
      n3 === null ? l3 = w3 : n3.sibling = w3;
      n3 = w3;
      m3 = x2;
    }
    if (v2.done)
      return c(e2, m3), I && $g(e2, r2), l3;
    if (m3 === null) {
      for (; !v2.done; r2++, v2 = h3.next())
        v2 = u2(e2, v2.value, k3), v2 !== null && (g3 = f2(v2, g3, r2), n3 === null ? l3 = v2 : n3.sibling = v2, n3 = v2);
      I && $g(e2, r2);
      return l3;
    }
    for (m3 = d(e2, m3); !v2.done; r2++, v2 = h3.next())
      v2 = y2(m3, e2, r2, v2.value, k3), v2 !== null && (a && v2.alternate !== null && m3.delete(v2.key === null ? r2 : v2.key), g3 = f2(v2, g3, r2), n3 === null ? l3 = v2 : n3.sibling = v2, n3 = v2);
    a && m3.forEach(function(a2) {
      return b2(e2, a2);
    });
    I && $g(e2, r2);
    return l3;
  }
  function J2(a2, d2, f3, h3) {
    typeof f3 === "object" && f3 !== null && f3.type === wa && f3.key === null && (f3 = f3.props.children);
    if (typeof f3 === "object" && f3 !== null) {
      switch (f3.$$typeof) {
        case ua:
          a: {
            for (var k3 = f3.key, l3 = d2; l3 !== null; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === wa) {
                  if (l3.tag === 7) {
                    c(a2, l3.sibling);
                    d2 = e(l3, f3.props.children);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  }
                } else if (l3.elementType === k3 || typeof k3 === "object" && k3 !== null && k3.$$typeof === Ga && rh(k3) === l3.type) {
                  c(a2, l3.sibling);
                  d2 = e(l3, f3.props);
                  d2.ref = ph(a2, l3, f3);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                }
                c(a2, l3);
                break;
              } else
                b2(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === wa ? (d2 = xh(f3.props.children, a2.mode, h3, f3.key), d2.return = a2, a2 = d2) : (h3 = vh(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = ph(a2, d2, f3), h3.return = a2, a2 = h3);
          }
          return g2(a2);
        case va:
          a: {
            for (l3 = f3.key; d2 !== null; ) {
              if (d2.key === l3)
                if (d2.tag === 4 && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                  c(a2, d2.sibling);
                  d2 = e(d2, f3.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
              else
                b2(a2, d2);
              d2 = d2.sibling;
            }
            d2 = wh(f3, a2.mode, h3);
            d2.return = a2;
            a2 = d2;
          }
          return g2(a2);
        case Ga:
          return l3 = f3._init, J2(a2, d2, l3(f3._payload), h3);
      }
      if (db(f3))
        return m2(a2, d2, f3, h3);
      if (Ja(f3))
        return w2(a2, d2, f3, h3);
      qh(a2, f3);
    }
    return typeof f3 === "string" && f3 !== "" || typeof f3 === "number" ? (f3 = "" + f3, d2 !== null && d2.tag === 6 ? (c(a2, d2.sibling), d2 = e(d2, f3), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = uh(f3, a2.mode, h3), d2.return = a2, a2 = d2), g2(a2)) : c(a2, d2);
  }
  return J2;
}
var yh = sh(true), zh = sh(false), Ah = {}, Bh = Tf(Ah), Ch = Tf(Ah), Dh = Tf(Ah);
function Eh(a) {
  if (a === Ah)
    throw Error(p$2(174));
  return a;
}
function Fh(a, b2) {
  G(Dh, b2);
  G(Ch, a);
  G(Bh, Ah);
  a = b2.nodeType;
  switch (a) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : kb(null, "");
      break;
    default:
      a = a === 8 ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = kb(b2, a);
  }
  E(Bh);
  G(Bh, b2);
}
function Gh() {
  E(Bh);
  E(Ch);
  E(Dh);
}
function Hh(a) {
  Eh(Dh.current);
  var b2 = Eh(Bh.current);
  var c = kb(b2, a.type);
  b2 !== c && (G(Ch, a), G(Bh, c));
}
function Ih(a) {
  Ch.current === a && (E(Bh), E(Ch));
}
var K = Tf(0);
function Jh(a) {
  for (var b2 = a; b2 !== null; ) {
    if (b2.tag === 13) {
      var c = b2.memoizedState;
      if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || c.data === "$!"))
        return b2;
    } else if (b2.tag === 19 && b2.memoizedProps.revealOrder !== void 0) {
      if ((b2.flags & 128) !== 0)
        return b2;
    } else if (b2.child !== null) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a)
      break;
    for (; b2.sibling === null; ) {
      if (b2.return === null || b2.return === a)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Kh = [];
function Lh() {
  for (var a = 0; a < Kh.length; a++)
    Kh[a]._workInProgressVersionPrimary = null;
  Kh.length = 0;
}
var Mh = ta.ReactCurrentDispatcher, Nh = ta.ReactCurrentBatchConfig, Oh = 0, L = null, M = null, N$1 = null, Ph = false, Qh = false, Rh = 0, Sh = 0;
function O() {
  throw Error(p$2(321));
}
function Th(a, b2) {
  if (b2 === null)
    return false;
  for (var c = 0; c < b2.length && c < a.length; c++)
    if (!Ge(a[c], b2[c]))
      return false;
  return true;
}
function Uh(a, b2, c, d, e, f2) {
  Oh = f2;
  L = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Mh.current = a === null || a.memoizedState === null ? Vh : Wh;
  a = c(d, e);
  if (Qh) {
    f2 = 0;
    do {
      Qh = false;
      Rh = 0;
      if (25 <= f2)
        throw Error(p$2(301));
      f2 += 1;
      N$1 = M = null;
      b2.updateQueue = null;
      Mh.current = Xh;
      a = c(d, e);
    } while (Qh);
  }
  Mh.current = Yh;
  b2 = M !== null && M.next !== null;
  Oh = 0;
  N$1 = M = L = null;
  Ph = false;
  if (b2)
    throw Error(p$2(300));
  return a;
}
function Zh() {
  var a = Rh !== 0;
  Rh = 0;
  return a;
}
function $h() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  N$1 === null ? L.memoizedState = N$1 = a : N$1 = N$1.next = a;
  return N$1;
}
function ai() {
  if (M === null) {
    var a = L.alternate;
    a = a !== null ? a.memoizedState : null;
  } else
    a = M.next;
  var b2 = N$1 === null ? L.memoizedState : N$1.next;
  if (b2 !== null)
    N$1 = b2, M = a;
  else {
    if (a === null)
      throw Error(p$2(310));
    M = a;
    a = { memoizedState: M.memoizedState, baseState: M.baseState, baseQueue: M.baseQueue, queue: M.queue, next: null };
    N$1 === null ? L.memoizedState = N$1 = a : N$1 = N$1.next = a;
  }
  return N$1;
}
function bi(a, b2) {
  return typeof b2 === "function" ? b2(a) : b2;
}
function ci(a) {
  var b2 = ai(), c = b2.queue;
  if (c === null)
    throw Error(p$2(311));
  c.lastRenderedReducer = a;
  var d = M, e = d.baseQueue, f2 = c.pending;
  if (f2 !== null) {
    if (e !== null) {
      var g2 = e.next;
      e.next = f2.next;
      f2.next = g2;
    }
    d.baseQueue = e = f2;
    c.pending = null;
  }
  if (e !== null) {
    f2 = e.next;
    d = d.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var n2 = l2.lane;
      if ((Oh & n2) === n2)
        k2 !== null && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d = l2.hasEagerState ? l2.eagerState : a(d, l2.action);
      else {
        var u2 = {
          lane: n2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        k2 === null ? (h2 = k2 = u2, g2 = d) : k2 = k2.next = u2;
        L.lanes |= n2;
        Fg |= n2;
      }
      l2 = l2.next;
    } while (l2 !== null && l2 !== f2);
    k2 === null ? g2 = d : k2.next = h2;
    Ge(d, b2.memoizedState) || (tg = true);
    b2.memoizedState = d;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c.lastRenderedState = d;
  }
  a = c.interleaved;
  if (a !== null) {
    e = a;
    do
      f2 = e.lane, L.lanes |= f2, Fg |= f2, e = e.next;
    while (e !== a);
  } else
    e === null && (c.lanes = 0);
  return [b2.memoizedState, c.dispatch];
}
function di(a) {
  var b2 = ai(), c = b2.queue;
  if (c === null)
    throw Error(p$2(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch, e = c.pending, f2 = b2.memoizedState;
  if (e !== null) {
    c.pending = null;
    var g2 = e = e.next;
    do
      f2 = a(f2, g2.action), g2 = g2.next;
    while (g2 !== e);
    Ge(f2, b2.memoizedState) || (tg = true);
    b2.memoizedState = f2;
    b2.baseQueue === null && (b2.baseState = f2);
    c.lastRenderedState = f2;
  }
  return [f2, d];
}
function ei() {
}
function fi(a, b2) {
  var c = L, d = ai(), e = b2(), f2 = !Ge(d.memoizedState, e);
  f2 && (d.memoizedState = e, tg = true);
  d = d.queue;
  gi(hi.bind(null, c, d, a), [a]);
  if (d.getSnapshot !== b2 || f2 || N$1 !== null && N$1.memoizedState.tag & 1) {
    c.flags |= 2048;
    ii(9, ji.bind(null, c, d, e, b2), void 0, null);
    if (P === null)
      throw Error(p$2(349));
    (Oh & 30) !== 0 || ki(c, b2, e);
  }
  return e;
}
function ki(a, b2, c) {
  a.flags |= 16384;
  a = { getSnapshot: b2, value: c };
  b2 = L.updateQueue;
  b2 === null ? (b2 = { lastEffect: null, stores: null }, L.updateQueue = b2, b2.stores = [a]) : (c = b2.stores, c === null ? b2.stores = [a] : c.push(a));
}
function ji(a, b2, c, d) {
  b2.value = c;
  b2.getSnapshot = d;
  li(b2) && Lg(a, 1, -1);
}
function hi(a, b2, c) {
  return c(function() {
    li(b2) && Lg(a, 1, -1);
  });
}
function li(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var c = b2();
    return !Ge(a, c);
  } catch (d) {
    return true;
  }
}
function mi(a) {
  var b2 = $h();
  typeof a === "function" && (a = a());
  b2.memoizedState = b2.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: bi, lastRenderedState: a };
  b2.queue = a;
  a = a.dispatch = ni.bind(null, L, a);
  return [b2.memoizedState, a];
}
function ii(a, b2, c, d) {
  a = { tag: a, create: b2, destroy: c, deps: d, next: null };
  b2 = L.updateQueue;
  b2 === null ? (b2 = { lastEffect: null, stores: null }, L.updateQueue = b2, b2.lastEffect = a.next = a) : (c = b2.lastEffect, c === null ? b2.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b2.lastEffect = a));
  return a;
}
function oi() {
  return ai().memoizedState;
}
function pi(a, b2, c, d) {
  var e = $h();
  L.flags |= a;
  e.memoizedState = ii(1 | b2, c, void 0, d === void 0 ? null : d);
}
function qi(a, b2, c, d) {
  var e = ai();
  d = d === void 0 ? null : d;
  var f2 = void 0;
  if (M !== null) {
    var g2 = M.memoizedState;
    f2 = g2.destroy;
    if (d !== null && Th(d, g2.deps)) {
      e.memoizedState = ii(b2, c, f2, d);
      return;
    }
  }
  L.flags |= a;
  e.memoizedState = ii(1 | b2, c, f2, d);
}
function ri(a, b2) {
  return pi(8390656, 8, a, b2);
}
function gi(a, b2) {
  return qi(2048, 8, a, b2);
}
function si(a, b2) {
  return qi(4, 2, a, b2);
}
function ti(a, b2) {
  return qi(4, 4, a, b2);
}
function ui(a, b2) {
  if (typeof b2 === "function")
    return a = a(), b2(a), function() {
      b2(null);
    };
  if (b2 !== null && b2 !== void 0)
    return a = a(), b2.current = a, function() {
      b2.current = null;
    };
}
function vi(a, b2, c) {
  c = c !== null && c !== void 0 ? c.concat([a]) : null;
  return qi(4, 4, ui.bind(null, b2, a), c);
}
function wi() {
}
function xi(a, b2) {
  var c = ai();
  b2 = b2 === void 0 ? null : b2;
  var d = c.memoizedState;
  if (d !== null && b2 !== null && Th(b2, d[1]))
    return d[0];
  c.memoizedState = [a, b2];
  return a;
}
function yi(a, b2) {
  var c = ai();
  b2 = b2 === void 0 ? null : b2;
  var d = c.memoizedState;
  if (d !== null && b2 !== null && Th(b2, d[1]))
    return d[0];
  a = a();
  c.memoizedState = [a, b2];
  return a;
}
function zi(a, b2, c) {
  if ((Oh & 21) === 0)
    return a.baseState && (a.baseState = false, tg = true), a.memoizedState = c;
  Ge(c, b2) || (c = xc(), L.lanes |= c, Fg |= c, a.baseState = true);
  return b2;
}
function Ai(a, b2) {
  var c = C;
  C = c !== 0 && 4 > c ? c : 4;
  a(true);
  var d = Nh.transition;
  Nh.transition = {};
  try {
    a(false), b2();
  } finally {
    C = c, Nh.transition = d;
  }
}
function Bi() {
  return ai().memoizedState;
}
function Ci(a, b2, c) {
  var d = Kg(a);
  c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
  Di(a) ? Ei(b2, c) : (Fi(a, b2, c), c = Jg(), a = Lg(a, d, c), a !== null && Gi(a, b2, d));
}
function ni(a, b2, c) {
  var d = Kg(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
  if (Di(a))
    Ei(b2, e);
  else {
    Fi(a, b2, e);
    var f2 = a.alternate;
    if (a.lanes === 0 && (f2 === null || f2.lanes === 0) && (f2 = b2.lastRenderedReducer, f2 !== null))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c);
        e.hasEagerState = true;
        e.eagerState = h2;
        if (Ge(h2, g2))
          return;
      } catch (k2) {
      } finally {
      }
    c = Jg();
    a = Lg(a, d, c);
    a !== null && Gi(a, b2, d);
  }
}
function Di(a) {
  var b2 = a.alternate;
  return a === L || b2 !== null && b2 === L;
}
function Ei(a, b2) {
  Qh = Ph = true;
  var c = a.pending;
  c === null ? b2.next = b2 : (b2.next = c.next, c.next = b2);
  a.pending = b2;
}
function Fi(a, b2, c) {
  Bg(a) ? (a = b2.interleaved, a === null ? (c.next = c, vg === null ? vg = [b2] : vg.push(b2)) : (c.next = a.next, a.next = c), b2.interleaved = c) : (a = b2.pending, a === null ? c.next = c : (c.next = a.next, a.next = c), b2.pending = c);
}
function Gi(a, b2, c) {
  if ((c & 4194240) !== 0) {
    var d = b2.lanes;
    d &= a.pendingLanes;
    c |= d;
    b2.lanes = c;
    Bc(a, c);
  }
}
var Yh = { readContext: ug, useCallback: O, useContext: O, useEffect: O, useImperativeHandle: O, useInsertionEffect: O, useLayoutEffect: O, useMemo: O, useReducer: O, useRef: O, useState: O, useDebugValue: O, useDeferredValue: O, useTransition: O, useMutableSource: O, useSyncExternalStore: O, useId: O, unstable_isNewReconciler: false }, Vh = { readContext: ug, useCallback: function(a, b2) {
  $h().memoizedState = [a, b2 === void 0 ? null : b2];
  return a;
}, useContext: ug, useEffect: ri, useImperativeHandle: function(a, b2, c) {
  c = c !== null && c !== void 0 ? c.concat([a]) : null;
  return pi(4194308, 4, ui.bind(null, b2, a), c);
}, useLayoutEffect: function(a, b2) {
  return pi(4194308, 4, a, b2);
}, useInsertionEffect: function(a, b2) {
  return pi(4, 2, a, b2);
}, useMemo: function(a, b2) {
  var c = $h();
  b2 = b2 === void 0 ? null : b2;
  a = a();
  c.memoizedState = [a, b2];
  return a;
}, useReducer: function(a, b2, c) {
  var d = $h();
  b2 = c !== void 0 ? c(b2) : b2;
  d.memoizedState = d.baseState = b2;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
  d.queue = a;
  a = a.dispatch = Ci.bind(null, L, a);
  return [d.memoizedState, a];
}, useRef: function(a) {
  var b2 = $h();
  a = { current: a };
  return b2.memoizedState = a;
}, useState: mi, useDebugValue: wi, useDeferredValue: function(a) {
  return $h().memoizedState = a;
}, useTransition: function() {
  var a = mi(false), b2 = a[0];
  a = Ai.bind(null, a[1]);
  $h().memoizedState = a;
  return [b2, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b2, c) {
  var d = L, e = $h();
  if (I) {
    if (c === void 0)
      throw Error(p$2(407));
    c = c();
  } else {
    c = b2();
    if (P === null)
      throw Error(p$2(349));
    (Oh & 30) !== 0 || ki(d, b2, c);
  }
  e.memoizedState = c;
  var f2 = { value: c, getSnapshot: b2 };
  e.queue = f2;
  ri(hi.bind(null, d, f2, a), [a]);
  d.flags |= 2048;
  ii(9, ji.bind(null, d, f2, c, b2), void 0, null);
  return c;
}, useId: function() {
  var a = $h(), b2 = P.identifierPrefix;
  if (I) {
    var c = Zg;
    var d = Yg;
    c = (d & ~(1 << 32 - nc(d) - 1)).toString(32) + c;
    b2 = ":" + b2 + "R" + c;
    c = Rh++;
    0 < c && (b2 += "H" + c.toString(32));
    b2 += ":";
  } else
    c = Sh++, b2 = ":" + b2 + "r" + c.toString(32) + ":";
  return a.memoizedState = b2;
}, unstable_isNewReconciler: false }, Wh = {
  readContext: ug,
  useCallback: xi,
  useContext: ug,
  useEffect: gi,
  useImperativeHandle: vi,
  useInsertionEffect: si,
  useLayoutEffect: ti,
  useMemo: yi,
  useReducer: ci,
  useRef: oi,
  useState: function() {
    return ci(bi);
  },
  useDebugValue: wi,
  useDeferredValue: function(a) {
    var b2 = ai();
    return zi(b2, M.memoizedState, a);
  },
  useTransition: function() {
    var a = ci(bi)[0], b2 = ai().memoizedState;
    return [a, b2];
  },
  useMutableSource: ei,
  useSyncExternalStore: fi,
  useId: Bi,
  unstable_isNewReconciler: false
}, Xh = { readContext: ug, useCallback: xi, useContext: ug, useEffect: gi, useImperativeHandle: vi, useInsertionEffect: si, useLayoutEffect: ti, useMemo: yi, useReducer: di, useRef: oi, useState: function() {
  return di(bi);
}, useDebugValue: wi, useDeferredValue: function(a) {
  var b2 = ai();
  return M === null ? b2.memoizedState = a : zi(b2, M.memoizedState, a);
}, useTransition: function() {
  var a = di(bi)[0], b2 = ai().memoizedState;
  return [a, b2];
}, useMutableSource: ei, useSyncExternalStore: fi, useId: Bi, unstable_isNewReconciler: false };
function Hi(a, b2) {
  try {
    var c = "", d = b2;
    do
      c += Oa(d), d = d.return;
    while (d);
    var e = c;
  } catch (f2) {
    e = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b2, stack: e };
}
function Ii(a, b2) {
  try {
    console.error(b2.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var Ji = typeof WeakMap === "function" ? WeakMap : Map;
function Ki(a, b2, c) {
  c = zg(-1, c);
  c.tag = 3;
  c.payload = { element: null };
  var d = b2.value;
  c.callback = function() {
    Li || (Li = true, Mi = d);
    Ii(a, b2);
  };
  return c;
}
function Ni(a, b2, c) {
  c = zg(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if (typeof d === "function") {
    var e = b2.value;
    c.payload = function() {
      return d(e);
    };
    c.callback = function() {
      Ii(a, b2);
    };
  }
  var f2 = a.stateNode;
  f2 !== null && typeof f2.componentDidCatch === "function" && (c.callback = function() {
    Ii(a, b2);
    typeof d !== "function" && (Oi === null ? Oi = /* @__PURE__ */ new Set([this]) : Oi.add(this));
    var c2 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: c2 !== null ? c2 : "" });
  });
  return c;
}
function Pi(a, b2, c) {
  var d = a.pingCache;
  if (d === null) {
    d = a.pingCache = new Ji();
    var e = /* @__PURE__ */ new Set();
    d.set(b2, e);
  } else
    e = d.get(b2), e === void 0 && (e = /* @__PURE__ */ new Set(), d.set(b2, e));
  e.has(c) || (e.add(c), a = Qi.bind(null, a, b2, c), b2.then(a, a));
}
function Ri(a) {
  do {
    var b2;
    if (b2 = a.tag === 13)
      b2 = a.memoizedState, b2 = b2 !== null ? b2.dehydrated !== null ? true : false : true;
    if (b2)
      return a;
    a = a.return;
  } while (a !== null);
  return null;
}
function Si(a, b2, c, d, e) {
  if ((a.mode & 1) === 0)
    return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, c.tag === 1 && (c.alternate === null ? c.tag = 17 : (b2 = zg(-1, 1), b2.tag = 2, Ag(c, b2))), c.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e;
  return a;
}
var Ti, Ui, Vi, Wi;
Ti = function(a, b2) {
  for (var c = b2.child; c !== null; ) {
    if (c.tag === 5 || c.tag === 6)
      a.appendChild(c.stateNode);
    else if (c.tag !== 4 && c.child !== null) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b2)
      break;
    for (; c.sibling === null; ) {
      if (c.return === null || c.return === b2)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Ui = function() {
};
Vi = function(a, b2, c, d) {
  var e = a.memoizedProps;
  if (e !== d) {
    a = b2.stateNode;
    Eh(Bh.current);
    var f2 = null;
    switch (c) {
      case "input":
        e = Xa(a, e);
        d = Xa(a, d);
        f2 = [];
        break;
      case "select":
        e = A$1({}, e, { value: void 0 });
        d = A$1({}, d, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e = fb(a, e);
        d = fb(a, d);
        f2 = [];
        break;
      default:
        typeof e.onClick !== "function" && typeof d.onClick === "function" && (a.onclick = Af);
    }
    tb(c, d);
    var g2;
    c = null;
    for (l2 in e)
      if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && e[l2] != null)
        if (l2 === "style") {
          var h2 = e[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c || (c = {}), c[g2] = "");
        } else
          l2 !== "dangerouslySetInnerHTML" && l2 !== "children" && l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && l2 !== "autoFocus" && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d) {
      var k2 = d[l2];
      h2 = e != null ? e[l2] : void 0;
      if (d.hasOwnProperty(l2) && k2 !== h2 && (k2 != null || h2 != null))
        if (l2 === "style")
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c || (c = {}), c[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c || (c = {}), c[g2] = k2[g2]);
          } else
            c || (f2 || (f2 = []), f2.push(l2, c)), c = k2;
        else
          l2 === "dangerouslySetInnerHTML" ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, k2 != null && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : l2 === "children" ? typeof k2 !== "string" && typeof k2 !== "number" || (f2 = f2 || []).push(l2, "" + k2) : l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && (ea.hasOwnProperty(l2) ? (k2 != null && l2 === "onScroll" && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c && (f2 = f2 || []).push("style", c);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Wi = function(a, b2, c, d) {
  c !== d && (b2.flags |= 4);
};
function Xi(a, b2) {
  if (!I)
    switch (a.tailMode) {
      case "hidden":
        b2 = a.tail;
        for (var c = null; b2 !== null; )
          b2.alternate !== null && (c = b2), b2 = b2.sibling;
        c === null ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; c !== null; )
          c.alternate !== null && (d = c), c = c.sibling;
        d === null ? b2 || a.tail === null ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
}
function Q(a) {
  var b2 = a.alternate !== null && a.alternate.child === a.child, c = 0, d = 0;
  if (b2)
    for (var e = a.child; e !== null; )
      c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
  else
    for (e = a.child; e !== null; )
      c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
  a.subtreeFlags |= d;
  a.childLanes = c;
  return b2;
}
function Yi(a, b2, c) {
  var d = b2.pendingProps;
  ch(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Q(b2), null;
    case 1:
      return Yf(b2.type) && Zf(), Q(b2), null;
    case 3:
      d = b2.stateNode;
      Gh();
      E(Vf);
      E(H);
      Lh();
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (a === null || a.child === null)
        mh(b2) ? b2.flags |= 4 : a === null || a.memoizedState.isDehydrated && (b2.flags & 256) === 0 || (b2.flags |= 1024, fh !== null && (Zi(fh), fh = null));
      Ui(a, b2);
      Q(b2);
      return null;
    case 5:
      Ih(b2);
      var e = Eh(Dh.current);
      c = b2.type;
      if (a !== null && b2.stateNode != null)
        Vi(a, b2, c, d, e), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d) {
          if (b2.stateNode === null)
            throw Error(p$2(166));
          Q(b2);
          return null;
        }
        a = Eh(Bh.current);
        if (mh(b2)) {
          d = b2.stateNode;
          c = b2.type;
          var f2 = b2.memoizedProps;
          d[Nf] = b2;
          d[Of] = f2;
          a = (b2.mode & 1) !== 0;
          switch (c) {
            case "dialog":
              D("cancel", d);
              D("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d);
              break;
            case "video":
            case "audio":
              for (e = 0; e < kf.length; e++)
                D(kf[e], d);
              break;
            case "source":
              D("error", d);
              break;
            case "img":
            case "image":
            case "link":
              D("error", d);
              D("load", d);
              break;
            case "details":
              D("toggle", d);
              break;
            case "input":
              Ya(d, f2);
              D("invalid", d);
              break;
            case "select":
              d._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d);
              break;
            case "textarea":
              gb(d, f2), D("invalid", d);
          }
          tb(c, f2);
          e = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              g2 === "children" ? typeof h2 === "string" ? d.textContent !== h2 && (f2.suppressHydrationWarning !== true && zf(d.textContent, h2, a), e = ["children", h2]) : typeof h2 === "number" && d.textContent !== "" + h2 && (f2.suppressHydrationWarning !== true && zf(d.textContent, h2, a), e = ["children", "" + h2]) : ea.hasOwnProperty(g2) && h2 != null && g2 === "onScroll" && D("scroll", d);
            }
          switch (c) {
            case "input":
              Ua(d);
              cb(d, f2, true);
              break;
            case "textarea":
              Ua(d);
              ib(d);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof f2.onClick === "function" && (d.onclick = Af);
          }
          d = e;
          b2.updateQueue = d;
          d !== null && (b2.flags |= 4);
        } else {
          g2 = e.nodeType === 9 ? e : e.ownerDocument;
          a === "http://www.w3.org/1999/xhtml" && (a = jb(c));
          a === "http://www.w3.org/1999/xhtml" ? c === "script" ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : typeof d.is === "string" ? a = g2.createElement(c, { is: d.is }) : (a = g2.createElement(c), c === "select" && (g2 = a, d.multiple ? g2.multiple = true : d.size && (g2.size = d.size))) : a = g2.createElementNS(a, c);
          a[Nf] = b2;
          a[Of] = d;
          Ti(a, b2, false, false);
          b2.stateNode = a;
          a: {
            g2 = ub(c, d);
            switch (c) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e = d;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e = d;
                break;
              case "video":
              case "audio":
                for (e = 0; e < kf.length; e++)
                  D(kf[e], a);
                e = d;
                break;
              case "source":
                D("error", a);
                e = d;
                break;
              case "img":
              case "image":
              case "link":
                D("error", a);
                D("load", a);
                e = d;
                break;
              case "details":
                D("toggle", a);
                e = d;
                break;
              case "input":
                Ya(a, d);
                e = Xa(a, d);
                D("invalid", a);
                break;
              case "option":
                e = d;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d.multiple };
                e = A$1({}, d, { value: void 0 });
                D("invalid", a);
                break;
              case "textarea":
                gb(a, d);
                e = fb(a, d);
                D("invalid", a);
                break;
              default:
                e = d;
            }
            tb(c, e);
            h2 = e;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                f2 === "style" ? rb(a, k2) : f2 === "dangerouslySetInnerHTML" ? (k2 = k2 ? k2.__html : void 0, k2 != null && mb(a, k2)) : f2 === "children" ? typeof k2 === "string" ? (c !== "textarea" || k2 !== "") && nb(a, k2) : typeof k2 === "number" && nb(a, "" + k2) : f2 !== "suppressContentEditableWarning" && f2 !== "suppressHydrationWarning" && f2 !== "autoFocus" && (ea.hasOwnProperty(f2) ? k2 != null && f2 === "onScroll" && D("scroll", a) : k2 != null && sa(a, f2, k2, g2));
              }
            switch (c) {
              case "input":
                Ua(a);
                cb(a, d, false);
                break;
              case "textarea":
                Ua(a);
                ib(a);
                break;
              case "option":
                d.value != null && a.setAttribute("value", "" + Ra(d.value));
                break;
              case "select":
                a.multiple = !!d.multiple;
                f2 = d.value;
                f2 != null ? eb(a, !!d.multiple, f2, false) : d.defaultValue != null && eb(a, !!d.multiple, d.defaultValue, true);
                break;
              default:
                typeof e.onClick === "function" && (a.onclick = Af);
            }
            switch (c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d = !!d.autoFocus;
                break a;
              case "img":
                d = true;
                break a;
              default:
                d = false;
            }
          }
          d && (b2.flags |= 4);
        }
        b2.ref !== null && (b2.flags |= 512, b2.flags |= 2097152);
      }
      Q(b2);
      return null;
    case 6:
      if (a && b2.stateNode != null)
        Wi(a, b2, a.memoizedProps, d);
      else {
        if (typeof d !== "string" && b2.stateNode === null)
          throw Error(p$2(166));
        c = Eh(Dh.current);
        Eh(Bh.current);
        if (mh(b2)) {
          d = b2.stateNode;
          c = b2.memoizedProps;
          d[Nf] = b2;
          if (f2 = d.nodeValue !== c) {
            if (a = dh, a !== null)
              switch (a.tag) {
                case 3:
                  zf(d.nodeValue, c, (a.mode & 1) !== 0);
                  break;
                case 5:
                  a.memoizedProps.suppressHydrationWarning !== true && zf(d.nodeValue, c, (a.mode & 1) !== 0);
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d = (c.nodeType === 9 ? c : c.ownerDocument).createTextNode(d), d[Nf] = b2, b2.stateNode = d;
      }
      Q(b2);
      return null;
    case 13:
      E(K);
      d = b2.memoizedState;
      if (I && eh !== null && (b2.mode & 1) !== 0 && (b2.flags & 128) === 0) {
        for (d = eh; d; )
          d = Kf(d.nextSibling);
        nh();
        b2.flags |= 98560;
        return b2;
      }
      if (d !== null && d.dehydrated !== null) {
        d = mh(b2);
        if (a === null) {
          if (!d)
            throw Error(p$2(318));
          d = b2.memoizedState;
          d = d !== null ? d.dehydrated : null;
          if (!d)
            throw Error(p$2(317));
          d[Nf] = b2;
        } else
          nh(), (b2.flags & 128) === 0 && (b2.memoizedState = null), b2.flags |= 4;
        Q(b2);
        return null;
      }
      fh !== null && (Zi(fh), fh = null);
      if ((b2.flags & 128) !== 0)
        return b2.lanes = c, b2;
      d = d !== null;
      c = false;
      a === null ? mh(b2) : c = a.memoizedState !== null;
      d !== c && d && (b2.child.flags |= 8192, (b2.mode & 1) !== 0 && (a === null || (K.current & 1) !== 0 ? R === 0 && (R = 3) : $i()));
      b2.updateQueue !== null && (b2.flags |= 4);
      Q(b2);
      return null;
    case 4:
      return Gh(), Ui(a, b2), a === null && rf(b2.stateNode.containerInfo), Q(b2), null;
    case 10:
      return qg(b2.type._context), Q(b2), null;
    case 17:
      return Yf(b2.type) && Zf(), Q(b2), null;
    case 19:
      E(K);
      f2 = b2.memoizedState;
      if (f2 === null)
        return Q(b2), null;
      d = (b2.flags & 128) !== 0;
      g2 = f2.rendering;
      if (g2 === null)
        if (d)
          Xi(f2, false);
        else {
          if (R !== 0 || a !== null && (a.flags & 128) !== 0)
            for (a = b2.child; a !== null; ) {
              g2 = Jh(a);
              if (g2 !== null) {
                b2.flags |= 128;
                Xi(f2, false);
                d = g2.updateQueue;
                d !== null && (b2.updateQueue = d, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d = c;
                for (c = b2.child; c !== null; )
                  f2 = c, a = d, f2.flags &= 14680066, g2 = f2.alternate, g2 === null ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                G(K, K.current & 1 | 2);
                return b2.child;
              }
              a = a.sibling;
            }
          f2.tail !== null && B() > aj && (b2.flags |= 128, d = true, Xi(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d)
          if (a = Jh(g2), a !== null) {
            if (b2.flags |= 128, d = true, c = a.updateQueue, c !== null && (b2.updateQueue = c, b2.flags |= 4), Xi(f2, true), f2.tail === null && f2.tailMode === "hidden" && !g2.alternate && !I)
              return Q(b2), null;
          } else
            2 * B() - f2.renderingStartTime > aj && c !== 1073741824 && (b2.flags |= 128, d = true, Xi(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c = f2.last, c !== null ? c.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (f2.tail !== null)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c = K.current, G(K, d ? c & 1 | 2 : c & 1), b2;
      Q(b2);
      return null;
    case 22:
    case 23:
      return bj(), d = b2.memoizedState !== null, a !== null && a.memoizedState !== null !== d && (b2.flags |= 8192), d && (b2.mode & 1) !== 0 ? (cj & 1073741824) !== 0 && (Q(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : Q(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$2(156, b2.tag));
}
var dj = ta.ReactCurrentOwner, tg = false;
function ej(a, b2, c, d) {
  b2.child = a === null ? zh(b2, null, c, d) : yh(b2, a.child, c, d);
}
function fj(a, b2, c, d, e) {
  c = c.render;
  var f2 = b2.ref;
  sg(b2, e);
  d = Uh(a, b2, c, d, f2, e);
  c = Zh();
  if (a !== null && !tg)
    return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e, gj(a, b2, e);
  I && c && bh(b2);
  b2.flags |= 1;
  ej(a, b2, d, e);
  return b2.child;
}
function hj(a, b2, c, d, e) {
  if (a === null) {
    var f2 = c.type;
    if (typeof f2 === "function" && !ij(f2) && f2.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0)
      return b2.tag = 15, b2.type = f2, jj(a, b2, f2, d, e);
    a = vh(c.type, null, d, b2, b2.mode, e);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  f2 = a.child;
  if ((a.lanes & e) === 0) {
    var g2 = f2.memoizedProps;
    c = c.compare;
    c = c !== null ? c : He;
    if (c(g2, d) && a.ref === b2.ref)
      return gj(a, b2, e);
  }
  b2.flags |= 1;
  a = th(f2, d);
  a.ref = b2.ref;
  a.return = b2;
  return b2.child = a;
}
function jj(a, b2, c, d, e) {
  if (a !== null) {
    var f2 = a.memoizedProps;
    if (He(f2, d) && a.ref === b2.ref)
      if (tg = false, b2.pendingProps = d = f2, (a.lanes & e) !== 0)
        (a.flags & 131072) !== 0 && (tg = true);
      else
        return b2.lanes = a.lanes, gj(a, b2, e);
  }
  return kj(a, b2, c, d, e);
}
function lj(a, b2, c) {
  var d = b2.pendingProps, e = d.children, f2 = a !== null ? a.memoizedState : null;
  if (d.mode === "hidden")
    if ((b2.mode & 1) === 0)
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(mj, cj), cj |= c;
    else if ((c & 1073741824) !== 0)
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, d = f2 !== null ? f2.baseLanes : c, G(mj, cj), cj |= d;
    else
      return a = f2 !== null ? f2.baseLanes | c : c, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(mj, cj), cj |= a, null;
  else
    f2 !== null ? (d = f2.baseLanes | c, b2.memoizedState = null) : d = c, G(mj, cj), cj |= d;
  ej(a, b2, e, c);
  return b2.child;
}
function nj(a, b2) {
  var c = b2.ref;
  if (a === null && c !== null || a !== null && a.ref !== c)
    b2.flags |= 512, b2.flags |= 2097152;
}
function kj(a, b2, c, d, e) {
  var f2 = Yf(c) ? Wf : H.current;
  f2 = Xf(b2, f2);
  sg(b2, e);
  c = Uh(a, b2, c, d, f2, e);
  d = Zh();
  if (a !== null && !tg)
    return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e, gj(a, b2, e);
  I && d && bh(b2);
  b2.flags |= 1;
  ej(a, b2, c, e);
  return b2.child;
}
function oj(a, b2, c, d, e) {
  if (Yf(c)) {
    var f2 = true;
    bg(b2);
  } else
    f2 = false;
  sg(b2, e);
  if (b2.stateNode === null)
    a !== null && (a.alternate = null, b2.alternate = null, b2.flags |= 2), Og(b2, c, d), Qg(b2, c, d, e), d = true;
  else if (a === null) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c.contextType;
    typeof l2 === "object" && l2 !== null ? l2 = ug(l2) : (l2 = Yf(c) ? Wf : H.current, l2 = Xf(b2, l2));
    var n2 = c.getDerivedStateFromProps, u2 = typeof n2 === "function" || typeof g2.getSnapshotBeforeUpdate === "function";
    u2 || typeof g2.UNSAFE_componentWillReceiveProps !== "function" && typeof g2.componentWillReceiveProps !== "function" || (h2 !== d || k2 !== l2) && Pg(b2, g2, d, l2);
    wg = false;
    var q2 = b2.memoizedState;
    g2.state = q2;
    Eg(b2, d, g2, e);
    k2 = b2.memoizedState;
    h2 !== d || q2 !== k2 || Vf.current || wg ? (typeof n2 === "function" && (Ig(b2, c, n2, d), k2 = b2.memoizedState), (h2 = wg || Ng(b2, c, h2, d, q2, k2, l2)) ? (u2 || typeof g2.UNSAFE_componentWillMount !== "function" && typeof g2.componentWillMount !== "function" || (typeof g2.componentWillMount === "function" && g2.componentWillMount(), typeof g2.UNSAFE_componentWillMount === "function" && g2.UNSAFE_componentWillMount()), typeof g2.componentDidMount === "function" && (b2.flags |= 4194308)) : (typeof g2.componentDidMount === "function" && (b2.flags |= 4194308), b2.memoizedProps = d, b2.memoizedState = k2), g2.props = d, g2.state = k2, g2.context = l2, d = h2) : (typeof g2.componentDidMount === "function" && (b2.flags |= 4194308), d = false);
  } else {
    g2 = b2.stateNode;
    yg(a, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : kg(b2.type, h2);
    g2.props = l2;
    u2 = b2.pendingProps;
    q2 = g2.context;
    k2 = c.contextType;
    typeof k2 === "object" && k2 !== null ? k2 = ug(k2) : (k2 = Yf(c) ? Wf : H.current, k2 = Xf(b2, k2));
    var y2 = c.getDerivedStateFromProps;
    (n2 = typeof y2 === "function" || typeof g2.getSnapshotBeforeUpdate === "function") || typeof g2.UNSAFE_componentWillReceiveProps !== "function" && typeof g2.componentWillReceiveProps !== "function" || (h2 !== u2 || q2 !== k2) && Pg(b2, g2, d, k2);
    wg = false;
    q2 = b2.memoizedState;
    g2.state = q2;
    Eg(b2, d, g2, e);
    var m2 = b2.memoizedState;
    h2 !== u2 || q2 !== m2 || Vf.current || wg ? (typeof y2 === "function" && (Ig(b2, c, y2, d), m2 = b2.memoizedState), (l2 = wg || Ng(b2, c, l2, d, q2, m2, k2) || false) ? (n2 || typeof g2.UNSAFE_componentWillUpdate !== "function" && typeof g2.componentWillUpdate !== "function" || (typeof g2.componentWillUpdate === "function" && g2.componentWillUpdate(d, m2, k2), typeof g2.UNSAFE_componentWillUpdate === "function" && g2.UNSAFE_componentWillUpdate(d, m2, k2)), typeof g2.componentDidUpdate === "function" && (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate === "function" && (b2.flags |= 1024)) : (typeof g2.componentDidUpdate !== "function" || h2 === a.memoizedProps && q2 === a.memoizedState || (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate !== "function" || h2 === a.memoizedProps && q2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d, b2.memoizedState = m2), g2.props = d, g2.state = m2, g2.context = k2, d = l2) : (typeof g2.componentDidUpdate !== "function" || h2 === a.memoizedProps && q2 === a.memoizedState || (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate !== "function" || h2 === a.memoizedProps && q2 === a.memoizedState || (b2.flags |= 1024), d = false);
  }
  return pj(a, b2, c, d, f2, e);
}
function pj(a, b2, c, d, e, f2) {
  nj(a, b2);
  var g2 = (b2.flags & 128) !== 0;
  if (!d && !g2)
    return e && cg(b2, c, false), gj(a, b2, f2);
  d = b2.stateNode;
  dj.current = b2;
  var h2 = g2 && typeof c.getDerivedStateFromError !== "function" ? null : d.render();
  b2.flags |= 1;
  a !== null && g2 ? (b2.child = yh(b2, a.child, null, f2), b2.child = yh(b2, null, h2, f2)) : ej(a, b2, h2, f2);
  b2.memoizedState = d.state;
  e && cg(b2, c, true);
  return b2.child;
}
function qj(a) {
  var b2 = a.stateNode;
  b2.pendingContext ? $f(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && $f(a, b2.context, false);
  Fh(a, b2.containerInfo);
}
function rj(a, b2, c, d, e) {
  nh();
  oh(e);
  b2.flags |= 256;
  ej(a, b2, c, d);
  return b2.child;
}
var sj = { dehydrated: null, treeContext: null, retryLane: 0 };
function tj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function uj(a, b2) {
  return { baseLanes: a.baseLanes | b2, cachePool: null, transitions: a.transitions };
}
function vj(a, b2, c) {
  var d = b2.pendingProps, e = K.current, f2 = false, g2 = (b2.flags & 128) !== 0, h2;
  (h2 = g2) || (h2 = a !== null && a.memoizedState === null ? false : (e & 2) !== 0);
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (a === null || a.memoizedState !== null)
    e |= 1;
  G(K, e & 1);
  if (a === null) {
    kh(b2);
    a = b2.memoizedState;
    if (a !== null && (a = a.dehydrated, a !== null))
      return (b2.mode & 1) === 0 ? b2.lanes = 1 : a.data === "$!" ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    e = d.children;
    a = d.fallback;
    return f2 ? (d = b2.mode, f2 = b2.child, e = { mode: "hidden", children: e }, (d & 1) === 0 && f2 !== null ? (f2.childLanes = 0, f2.pendingProps = e) : f2 = wj(e, d, 0, null), a = xh(a, d, c, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = tj(c), b2.memoizedState = sj, a) : xj(b2, e);
  }
  e = a.memoizedState;
  if (e !== null) {
    h2 = e.dehydrated;
    if (h2 !== null) {
      if (g2) {
        if (b2.flags & 256)
          return b2.flags &= -257, yj(a, b2, c, Error(p$2(422)));
        if (b2.memoizedState !== null)
          return b2.child = a.child, b2.flags |= 128, null;
        f2 = d.fallback;
        e = b2.mode;
        d = wj({ mode: "visible", children: d.children }, e, 0, null);
        f2 = xh(f2, e, c, null);
        f2.flags |= 2;
        d.return = b2;
        f2.return = b2;
        d.sibling = f2;
        b2.child = d;
        (b2.mode & 1) !== 0 && yh(b2, a.child, null, c);
        b2.child.memoizedState = tj(c);
        b2.memoizedState = sj;
        return f2;
      }
      if ((b2.mode & 1) === 0)
        b2 = yj(a, b2, c, null);
      else if (h2.data === "$!")
        b2 = yj(a, b2, c, Error(p$2(419)));
      else if (d = (c & a.childLanes) !== 0, tg || d) {
        d = P;
        if (d !== null) {
          switch (c & -c) {
            case 4:
              f2 = 2;
              break;
            case 16:
              f2 = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              f2 = 32;
              break;
            case 536870912:
              f2 = 268435456;
              break;
            default:
              f2 = 0;
          }
          d = (f2 & (d.suspendedLanes | c)) !== 0 ? 0 : f2;
          d !== 0 && d !== e.retryLane && (e.retryLane = d, Lg(a, d, -1));
        }
        $i();
        b2 = yj(a, b2, c, Error(p$2(421)));
      } else
        h2.data === "$?" ? (b2.flags |= 128, b2.child = a.child, b2 = zj.bind(null, a), h2._reactRetry = b2, b2 = null) : (c = e.treeContext, eh = Kf(h2.nextSibling), dh = b2, I = true, fh = null, c !== null && (Vg[Wg++] = Yg, Vg[Wg++] = Zg, Vg[Wg++] = Xg, Yg = c.id, Zg = c.overflow, Xg = b2), b2 = xj(b2, b2.pendingProps.children), b2.flags |= 4096);
      return b2;
    }
    if (f2)
      return d = Aj(a, b2, d.children, d.fallback, c), f2 = b2.child, e = a.child.memoizedState, f2.memoizedState = e === null ? tj(c) : uj(e, c), f2.childLanes = a.childLanes & ~c, b2.memoizedState = sj, d;
    c = Bj(a, b2, d.children, c);
    b2.memoizedState = null;
    return c;
  }
  if (f2)
    return d = Aj(a, b2, d.children, d.fallback, c), f2 = b2.child, e = a.child.memoizedState, f2.memoizedState = e === null ? tj(c) : uj(e, c), f2.childLanes = a.childLanes & ~c, b2.memoizedState = sj, d;
  c = Bj(a, b2, d.children, c);
  b2.memoizedState = null;
  return c;
}
function xj(a, b2) {
  b2 = wj({ mode: "visible", children: b2 }, a.mode, 0, null);
  b2.return = a;
  return a.child = b2;
}
function Bj(a, b2, c, d) {
  var e = a.child;
  a = e.sibling;
  c = th(e, { mode: "visible", children: c });
  (b2.mode & 1) === 0 && (c.lanes = d);
  c.return = b2;
  c.sibling = null;
  a !== null && (d = b2.deletions, d === null ? (b2.deletions = [a], b2.flags |= 16) : d.push(a));
  return b2.child = c;
}
function Aj(a, b2, c, d, e) {
  var f2 = b2.mode;
  a = a.child;
  var g2 = a.sibling, h2 = { mode: "hidden", children: c };
  (f2 & 1) === 0 && b2.child !== a ? (c = b2.child, c.childLanes = 0, c.pendingProps = h2, b2.deletions = null) : (c = th(a, h2), c.subtreeFlags = a.subtreeFlags & 14680064);
  g2 !== null ? d = th(g2, d) : (d = xh(d, f2, e, null), d.flags |= 2);
  d.return = b2;
  c.return = b2;
  c.sibling = d;
  b2.child = c;
  return d;
}
function yj(a, b2, c, d) {
  d !== null && oh(d);
  yh(b2, a.child, null, c);
  a = xj(b2, b2.pendingProps.children);
  a.flags |= 2;
  b2.memoizedState = null;
  return a;
}
function Cj(a, b2, c) {
  a.lanes |= b2;
  var d = a.alternate;
  d !== null && (d.lanes |= b2);
  rg(a.return, b2, c);
}
function Dj(a, b2, c, d, e) {
  var f2 = a.memoizedState;
  f2 === null ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d, f2.tail = c, f2.tailMode = e);
}
function Ej(a, b2, c) {
  var d = b2.pendingProps, e = d.revealOrder, f2 = d.tail;
  ej(a, b2, d.children, c);
  d = K.current;
  if ((d & 2) !== 0)
    d = d & 1 | 2, b2.flags |= 128;
  else {
    if (a !== null && (a.flags & 128) !== 0)
      a:
        for (a = b2.child; a !== null; ) {
          if (a.tag === 13)
            a.memoizedState !== null && Cj(a, c, b2);
          else if (a.tag === 19)
            Cj(a, c, b2);
          else if (a.child !== null) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b2)
            break a;
          for (; a.sibling === null; ) {
            if (a.return === null || a.return === b2)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d &= 1;
  }
  G(K, d);
  if ((b2.mode & 1) === 0)
    b2.memoizedState = null;
  else
    switch (e) {
      case "forwards":
        c = b2.child;
        for (e = null; c !== null; )
          a = c.alternate, a !== null && Jh(a) === null && (e = c), c = c.sibling;
        c = e;
        c === null ? (e = b2.child, b2.child = null) : (e = c.sibling, c.sibling = null);
        Dj(b2, false, e, c, f2);
        break;
      case "backwards":
        c = null;
        e = b2.child;
        for (b2.child = null; e !== null; ) {
          a = e.alternate;
          if (a !== null && Jh(a) === null) {
            b2.child = e;
            break;
          }
          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }
        Dj(b2, true, c, null, f2);
        break;
      case "together":
        Dj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function gj(a, b2, c) {
  a !== null && (b2.dependencies = a.dependencies);
  Fg |= b2.lanes;
  if ((c & b2.childLanes) === 0)
    return null;
  if (a !== null && b2.child !== a.child)
    throw Error(p$2(153));
  if (b2.child !== null) {
    a = b2.child;
    c = th(a, a.pendingProps);
    b2.child = c;
    for (c.return = b2; a.sibling !== null; )
      a = a.sibling, c = c.sibling = th(a, a.pendingProps), c.return = b2;
    c.sibling = null;
  }
  return b2.child;
}
function Fj(a, b2, c) {
  switch (b2.tag) {
    case 3:
      qj(b2);
      nh();
      break;
    case 5:
      Hh(b2);
      break;
    case 1:
      Yf(b2.type) && bg(b2);
      break;
    case 4:
      Fh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d = b2.type._context, e = b2.memoizedProps.value;
      G(lg, d._currentValue);
      d._currentValue = e;
      break;
    case 13:
      d = b2.memoizedState;
      if (d !== null) {
        if (d.dehydrated !== null)
          return G(K, K.current & 1), b2.flags |= 128, null;
        if ((c & b2.child.childLanes) !== 0)
          return vj(a, b2, c);
        G(K, K.current & 1);
        a = gj(a, b2, c);
        return a !== null ? a.sibling : null;
      }
      G(K, K.current & 1);
      break;
    case 19:
      d = (c & b2.childLanes) !== 0;
      if ((a.flags & 128) !== 0) {
        if (d)
          return Ej(a, b2, c);
        b2.flags |= 128;
      }
      e = b2.memoizedState;
      e !== null && (e.rendering = null, e.tail = null, e.lastEffect = null);
      G(K, K.current);
      if (d)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, lj(a, b2, c);
  }
  return gj(a, b2, c);
}
function Gj(a, b2) {
  ch(b2);
  switch (b2.tag) {
    case 1:
      return Yf(b2.type) && Zf(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 3:
      return Gh(), E(Vf), E(H), Lh(), a = b2.flags, (a & 65536) !== 0 && (a & 128) === 0 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 5:
      return Ih(b2), null;
    case 13:
      E(K);
      a = b2.memoizedState;
      if (a !== null && a.dehydrated !== null) {
        if (b2.alternate === null)
          throw Error(p$2(340));
        nh();
      }
      a = b2.flags;
      return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 19:
      return E(K), null;
    case 4:
      return Gh(), null;
    case 10:
      return qg(b2.type._context), null;
    case 22:
    case 23:
      return bj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Hj = false, S = false, Ij = typeof WeakSet === "function" ? WeakSet : Set, T = null;
function Jj(a, b2) {
  var c = a.ref;
  if (c !== null)
    if (typeof c === "function")
      try {
        c(null);
      } catch (d) {
        U(a, b2, d);
      }
    else
      c.current = null;
}
function Kj(a, b2, c) {
  try {
    c();
  } catch (d) {
    U(a, b2, d);
  }
}
var Lj = false;
function Mj(a, b2) {
  Bf = cd;
  a = Le();
  if (Me(a)) {
    if ("selectionStart" in a)
      var c = { start: a.selectionStart, end: a.selectionEnd };
    else
      a: {
        c = (c = a.ownerDocument) && c.defaultView || window;
        var d = c.getSelection && c.getSelection();
        if (d && d.rangeCount !== 0) {
          c = d.anchorNode;
          var e = d.anchorOffset, f2 = d.focusNode;
          d = d.focusOffset;
          try {
            c.nodeType, f2.nodeType;
          } catch (Z) {
            c = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, n2 = 0, u2 = a, q2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                u2 !== c || e !== 0 && u2.nodeType !== 3 || (h2 = g2 + e);
                u2 !== f2 || d !== 0 && u2.nodeType !== 3 || (k2 = g2 + d);
                u2.nodeType === 3 && (g2 += u2.nodeValue.length);
                if ((y2 = u2.firstChild) === null)
                  break;
                q2 = u2;
                u2 = y2;
              }
              for (; ; ) {
                if (u2 === a)
                  break b;
                q2 === c && ++l2 === e && (h2 = g2);
                q2 === f2 && ++n2 === d && (k2 = g2);
                if ((y2 = u2.nextSibling) !== null)
                  break;
                u2 = q2;
                q2 = u2.parentNode;
              }
              u2 = y2;
            }
          c = h2 === -1 || k2 === -1 ? null : { start: h2, end: k2 };
        } else
          c = null;
      }
    c = c || { start: 0, end: 0 };
  } else
    c = null;
  Cf = { focusedElem: a, selectionRange: c };
  cd = false;
  for (T = b2; T !== null; )
    if (b2 = T, a = b2.child, (b2.subtreeFlags & 1028) !== 0 && a !== null)
      a.return = b2, T = a;
    else
      for (; T !== null; ) {
        b2 = T;
        try {
          var m2 = b2.alternate;
          if ((b2.flags & 1024) !== 0)
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (m2 !== null) {
                  var w2 = m2.memoizedProps, J2 = m2.memoizedState, v2 = b2.stateNode, x2 = v2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? w2 : kg(b2.type, w2), J2);
                  v2.__reactInternalSnapshotBeforeUpdate = x2;
                }
                break;
              case 3:
                var r2 = b2.stateNode.containerInfo;
                if (r2.nodeType === 1)
                  r2.textContent = "";
                else if (r2.nodeType === 9) {
                  var F2 = r2.body;
                  F2 != null && (F2.textContent = "");
                }
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$2(163));
            }
        } catch (Z) {
          U(b2, b2.return, Z);
        }
        a = b2.sibling;
        if (a !== null) {
          a.return = b2.return;
          T = a;
          break;
        }
        T = b2.return;
      }
  m2 = Lj;
  Lj = false;
  return m2;
}
function Nj(a, b2, c) {
  var d = b2.updateQueue;
  d = d !== null ? d.lastEffect : null;
  if (d !== null) {
    var e = d = d.next;
    do {
      if ((e.tag & a) === a) {
        var f2 = e.destroy;
        e.destroy = void 0;
        f2 !== void 0 && Kj(b2, c, f2);
      }
      e = e.next;
    } while (e !== d);
  }
}
function Oj(a, b2) {
  b2 = b2.updateQueue;
  b2 = b2 !== null ? b2.lastEffect : null;
  if (b2 !== null) {
    var c = b2 = b2.next;
    do {
      if ((c.tag & a) === a) {
        var d = c.create;
        c.destroy = d();
      }
      c = c.next;
    } while (c !== b2);
  }
}
function Pj(a) {
  var b2 = a.ref;
  if (b2 !== null) {
    var c = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c;
        break;
      default:
        a = c;
    }
    typeof b2 === "function" ? b2(a) : b2.current = a;
  }
}
function Qj(a) {
  var b2 = a.alternate;
  b2 !== null && (a.alternate = null, Qj(b2));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  a.tag === 5 && (b2 = a.stateNode, b2 !== null && (delete b2[Nf], delete b2[Of], delete b2[nf], delete b2[Pf], delete b2[Qf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Rj(a) {
  return a.tag === 5 || a.tag === 3 || a.tag === 4;
}
function Sj(a) {
  a:
    for (; ; ) {
      for (; a.sibling === null; ) {
        if (a.return === null || Rj(a.return))
          return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
        if (a.flags & 2)
          continue a;
        if (a.child === null || a.tag === 4)
          continue a;
        else
          a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2))
        return a.stateNode;
    }
}
function Tj(a, b2, c) {
  var d = a.tag;
  if (d === 5 || d === 6)
    a = a.stateNode, b2 ? c.nodeType === 8 ? c.parentNode.insertBefore(a, b2) : c.insertBefore(a, b2) : (c.nodeType === 8 ? (b2 = c.parentNode, b2.insertBefore(a, c)) : (b2 = c, b2.appendChild(a)), c = c._reactRootContainer, c !== null && c !== void 0 || b2.onclick !== null || (b2.onclick = Af));
  else if (d !== 4 && (a = a.child, a !== null))
    for (Tj(a, b2, c), a = a.sibling; a !== null; )
      Tj(a, b2, c), a = a.sibling;
}
function Uj(a, b2, c) {
  var d = a.tag;
  if (d === 5 || d === 6)
    a = a.stateNode, b2 ? c.insertBefore(a, b2) : c.appendChild(a);
  else if (d !== 4 && (a = a.child, a !== null))
    for (Uj(a, b2, c), a = a.sibling; a !== null; )
      Uj(a, b2, c), a = a.sibling;
}
var V = null, Vj = false;
function Wj(a, b2, c) {
  for (c = c.child; c !== null; )
    Xj(a, b2, c), c = c.sibling;
}
function Xj(a, b2, c) {
  if (kc && typeof kc.onCommitFiberUnmount === "function")
    try {
      kc.onCommitFiberUnmount(jc, c);
    } catch (h2) {
    }
  switch (c.tag) {
    case 5:
      S || Jj(c, b2);
    case 6:
      var d = V, e = Vj;
      V = null;
      Wj(a, b2, c);
      V = d;
      Vj = e;
      V !== null && (Vj ? (a = V, c = c.stateNode, a.nodeType === 8 ? a.parentNode.removeChild(c) : a.removeChild(c)) : V.removeChild(c.stateNode));
      break;
    case 18:
      V !== null && (Vj ? (a = V, c = c.stateNode, a.nodeType === 8 ? Jf(a.parentNode, c) : a.nodeType === 1 && Jf(a, c), ad(a)) : Jf(V, c.stateNode));
      break;
    case 4:
      d = V;
      e = Vj;
      V = c.stateNode.containerInfo;
      Vj = true;
      Wj(a, b2, c);
      V = d;
      Vj = e;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!S && (d = c.updateQueue, d !== null && (d = d.lastEffect, d !== null))) {
        e = d = d.next;
        do {
          var f2 = e, g2 = f2.destroy;
          f2 = f2.tag;
          g2 !== void 0 && ((f2 & 2) !== 0 ? Kj(c, b2, g2) : (f2 & 4) !== 0 && Kj(c, b2, g2));
          e = e.next;
        } while (e !== d);
      }
      Wj(a, b2, c);
      break;
    case 1:
      if (!S && (Jj(c, b2), d = c.stateNode, typeof d.componentWillUnmount === "function"))
        try {
          d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
        } catch (h2) {
          U(c, b2, h2);
        }
      Wj(a, b2, c);
      break;
    case 21:
      Wj(a, b2, c);
      break;
    case 22:
      c.mode & 1 ? (S = (d = S) || c.memoizedState !== null, Wj(a, b2, c), S = d) : Wj(a, b2, c);
      break;
    default:
      Wj(a, b2, c);
  }
}
function Yj(a) {
  var b2 = a.updateQueue;
  if (b2 !== null) {
    a.updateQueue = null;
    var c = a.stateNode;
    c === null && (c = a.stateNode = new Ij());
    b2.forEach(function(b3) {
      var d = Zj.bind(null, a, b3);
      c.has(b3) || (c.add(b3), b3.then(d, d));
    });
  }
}
function ak(a, b2) {
  var c = b2.deletions;
  if (c !== null)
    for (var d = 0; d < c.length; d++) {
      var e = c[d];
      try {
        var f2 = a, g2 = b2, h2 = g2;
        a:
          for (; h2 !== null; ) {
            switch (h2.tag) {
              case 5:
                V = h2.stateNode;
                Vj = false;
                break a;
              case 3:
                V = h2.stateNode.containerInfo;
                Vj = true;
                break a;
              case 4:
                V = h2.stateNode.containerInfo;
                Vj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (V === null)
          throw Error(p$2(160));
        Xj(f2, g2, e);
        V = null;
        Vj = false;
        var k2 = e.alternate;
        k2 !== null && (k2.return = null);
        e.return = null;
      } catch (l2) {
        U(e, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; b2 !== null; )
      bk(b2, a), b2 = b2.sibling;
}
function bk(a, b2) {
  var c = a.alternate, d = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ak(b2, a);
      ck(a);
      if (d & 4) {
        try {
          Nj(3, a, a.return), Oj(3, a);
        } catch (m2) {
          U(a, a.return, m2);
        }
        try {
          Nj(5, a, a.return);
        } catch (m2) {
          U(a, a.return, m2);
        }
      }
      break;
    case 1:
      ak(b2, a);
      ck(a);
      d & 512 && c !== null && Jj(c, c.return);
      break;
    case 5:
      ak(b2, a);
      ck(a);
      d & 512 && c !== null && Jj(c, c.return);
      if (a.flags & 32) {
        var e = a.stateNode;
        try {
          nb(e, "");
        } catch (m2) {
          U(a, a.return, m2);
        }
      }
      if (d & 4 && (e = a.stateNode, e != null)) {
        var f2 = a.memoizedProps, g2 = c !== null ? c.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (k2 !== null)
          try {
            h2 === "input" && f2.type === "radio" && f2.name != null && Za(e, f2);
            ub(h2, g2);
            var l2 = ub(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var n2 = k2[g2], u2 = k2[g2 + 1];
              n2 === "style" ? rb(e, u2) : n2 === "dangerouslySetInnerHTML" ? mb(e, u2) : n2 === "children" ? nb(e, u2) : sa(e, n2, u2, l2);
            }
            switch (h2) {
              case "input":
                $a(e, f2);
                break;
              case "textarea":
                hb(e, f2);
                break;
              case "select":
                var q2 = e._wrapperState.wasMultiple;
                e._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                y2 != null ? eb(e, !!f2.multiple, y2, false) : q2 !== !!f2.multiple && (f2.defaultValue != null ? eb(e, !!f2.multiple, f2.defaultValue, true) : eb(e, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e[Of] = f2;
          } catch (m2) {
            U(a, a.return, m2);
          }
      }
      break;
    case 6:
      ak(b2, a);
      ck(a);
      if (d & 4) {
        if (a.stateNode === null)
          throw Error(p$2(162));
        l2 = a.stateNode;
        n2 = a.memoizedProps;
        try {
          l2.nodeValue = n2;
        } catch (m2) {
          U(a, a.return, m2);
        }
      }
      break;
    case 3:
      ak(b2, a);
      ck(a);
      if (d & 4 && c !== null && c.memoizedState.isDehydrated)
        try {
          ad(b2.containerInfo);
        } catch (m2) {
          U(a, a.return, m2);
        }
      break;
    case 4:
      ak(b2, a);
      ck(a);
      break;
    case 13:
      ak(b2, a);
      ck(a);
      l2 = a.child;
      l2.flags & 8192 && l2.memoizedState !== null && (l2.alternate === null || l2.alternate.memoizedState === null) && (dk = B());
      d & 4 && Yj(a);
      break;
    case 22:
      l2 = c !== null && c.memoizedState !== null;
      a.mode & 1 ? (S = (n2 = S) || l2, ak(b2, a), S = n2) : ak(b2, a);
      ck(a);
      if (d & 8192) {
        n2 = a.memoizedState !== null;
        a:
          for (u2 = null, q2 = a; ; ) {
            if (q2.tag === 5) {
              if (u2 === null) {
                u2 = q2;
                try {
                  e = q2.stateNode, n2 ? (f2 = e.style, typeof f2.setProperty === "function" ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = k2 !== void 0 && k2 !== null && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = qb("display", g2));
                } catch (m2) {
                  U(a, a.return, m2);
                }
              }
            } else if (q2.tag === 6) {
              if (u2 === null)
                try {
                  q2.stateNode.nodeValue = n2 ? "" : q2.memoizedProps;
                } catch (m2) {
                  U(a, a.return, m2);
                }
            } else if ((q2.tag !== 22 && q2.tag !== 23 || q2.memoizedState === null || q2 === a) && q2.child !== null) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a)
              break a;
            for (; q2.sibling === null; ) {
              if (q2.return === null || q2.return === a)
                break a;
              u2 === q2 && (u2 = null);
              q2 = q2.return;
            }
            u2 === q2 && (u2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
        if (n2 && !l2 && (a.mode & 1) !== 0)
          for (T = a, a = a.child; a !== null; ) {
            for (l2 = T = a; T !== null; ) {
              n2 = T;
              u2 = n2.child;
              switch (n2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Nj(4, n2, n2.return);
                  break;
                case 1:
                  Jj(n2, n2.return);
                  f2 = n2.stateNode;
                  if (typeof f2.componentWillUnmount === "function") {
                    q2 = n2;
                    y2 = n2.return;
                    try {
                      e = q2, f2.props = e.memoizedProps, f2.state = e.memoizedState, f2.componentWillUnmount();
                    } catch (m2) {
                      U(q2, y2, m2);
                    }
                  }
                  break;
                case 5:
                  Jj(n2, n2.return);
                  break;
                case 22:
                  if (n2.memoizedState !== null) {
                    ek(l2);
                    continue;
                  }
              }
              u2 !== null ? (u2.return = n2, T = u2) : ek(l2);
            }
            a = a.sibling;
          }
      }
      break;
    case 19:
      ak(b2, a);
      ck(a);
      d & 4 && Yj(a);
      break;
    case 21:
      break;
    default:
      ak(b2, a), ck(a);
  }
}
function ck(a) {
  var b2 = a.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c = a.return; c !== null; ) {
          if (Rj(c)) {
            var d = c;
            break a;
          }
          c = c.return;
        }
        throw Error(p$2(160));
      }
      switch (d.tag) {
        case 5:
          var e = d.stateNode;
          d.flags & 32 && (nb(e, ""), d.flags &= -33);
          var f2 = Sj(a);
          Uj(a, f2, e);
          break;
        case 3:
        case 4:
          var g2 = d.stateNode.containerInfo, h2 = Sj(a);
          Tj(a, h2, g2);
          break;
        default:
          throw Error(p$2(161));
      }
    } catch (k2) {
      U(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b2 & 4096 && (a.flags &= -4097);
}
function fk(a, b2, c) {
  T = a;
  gk(a);
}
function gk(a, b2, c) {
  for (var d = (a.mode & 1) !== 0; T !== null; ) {
    var e = T, f2 = e.child;
    if (e.tag === 22 && d) {
      var g2 = e.memoizedState !== null || Hj;
      if (!g2) {
        var h2 = e.alternate, k2 = h2 !== null && h2.memoizedState !== null || S;
        h2 = Hj;
        var l2 = S;
        Hj = g2;
        if ((S = k2) && !l2)
          for (T = e; T !== null; )
            g2 = T, k2 = g2.child, g2.tag === 22 && g2.memoizedState !== null ? hk(e) : k2 !== null ? (k2.return = g2, T = k2) : hk(e);
        for (; f2 !== null; )
          T = f2, gk(f2), f2 = f2.sibling;
        T = e;
        Hj = h2;
        S = l2;
      }
      ik(a);
    } else
      (e.subtreeFlags & 8772) !== 0 && f2 !== null ? (f2.return = e, T = f2) : ik(a);
  }
}
function ik(a) {
  for (; T !== null; ) {
    var b2 = T;
    if ((b2.flags & 8772) !== 0) {
      var c = b2.alternate;
      try {
        if ((b2.flags & 8772) !== 0)
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              S || Oj(5, b2);
              break;
            case 1:
              var d = b2.stateNode;
              if (b2.flags & 4 && !S)
                if (c === null)
                  d.componentDidMount();
                else {
                  var e = b2.elementType === b2.type ? c.memoizedProps : kg(b2.type, c.memoizedProps);
                  d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              f2 !== null && Gg(b2, f2, d);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (g2 !== null) {
                c = null;
                if (b2.child !== null)
                  switch (b2.child.tag) {
                    case 5:
                      c = b2.child.stateNode;
                      break;
                    case 1:
                      c = b2.child.stateNode;
                  }
                Gg(b2, g2, c);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (c === null && b2.flags & 4) {
                c = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c.focus();
                    break;
                  case "img":
                    k2.src && (c.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (b2.memoizedState === null) {
                var l2 = b2.alternate;
                if (l2 !== null) {
                  var n2 = l2.memoizedState;
                  if (n2 !== null) {
                    var u2 = n2.dehydrated;
                    u2 !== null && ad(u2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
              break;
            default:
              throw Error(p$2(163));
          }
        S || b2.flags & 512 && Pj(b2);
      } catch (q2) {
        U(b2, b2.return, q2);
      }
    }
    if (b2 === a) {
      T = null;
      break;
    }
    c = b2.sibling;
    if (c !== null) {
      c.return = b2.return;
      T = c;
      break;
    }
    T = b2.return;
  }
}
function ek(a) {
  for (; T !== null; ) {
    var b2 = T;
    if (b2 === a) {
      T = null;
      break;
    }
    var c = b2.sibling;
    if (c !== null) {
      c.return = b2.return;
      T = c;
      break;
    }
    T = b2.return;
  }
}
function hk(a) {
  for (; T !== null; ) {
    var b2 = T;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c = b2.return;
          try {
            Oj(4, b2);
          } catch (k2) {
            U(b2, c, k2);
          }
          break;
        case 1:
          var d = b2.stateNode;
          if (typeof d.componentDidMount === "function") {
            var e = b2.return;
            try {
              d.componentDidMount();
            } catch (k2) {
              U(b2, e, k2);
            }
          }
          var f2 = b2.return;
          try {
            Pj(b2);
          } catch (k2) {
            U(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Pj(b2);
          } catch (k2) {
            U(b2, g2, k2);
          }
      }
    } catch (k2) {
      U(b2, b2.return, k2);
    }
    if (b2 === a) {
      T = null;
      break;
    }
    var h2 = b2.sibling;
    if (h2 !== null) {
      h2.return = b2.return;
      T = h2;
      break;
    }
    T = b2.return;
  }
}
var jk = Math.ceil, kk = ta.ReactCurrentDispatcher, lk = ta.ReactCurrentOwner, mk = ta.ReactCurrentBatchConfig, W$1 = 0, P = null, X = null, Y = 0, cj = 0, mj = Tf(0), R = 0, nk = null, Fg = 0, ok = 0, pk = 0, qk = null, rk = null, dk = 0, aj = Infinity, sk = null, Li = false, Mi = null, Oi = null, tk = false, uk = null, vk = 0, wk = 0, xk = null, yk = -1, zk = 0;
function Jg() {
  return (W$1 & 6) !== 0 ? B() : yk !== -1 ? yk : yk = B();
}
function Kg(a) {
  if ((a.mode & 1) === 0)
    return 1;
  if ((W$1 & 2) !== 0 && Y !== 0)
    return Y & -Y;
  if (jg.transition !== null)
    return zk === 0 && (zk = xc()), zk;
  a = C;
  if (a !== 0)
    return a;
  a = window.event;
  a = a === void 0 ? 16 : id(a.type);
  return a;
}
function Lg(a, b2, c) {
  if (50 < wk)
    throw wk = 0, xk = null, Error(p$2(185));
  var d = Ak(a, b2);
  if (d === null)
    return null;
  zc(d, b2, c);
  if ((W$1 & 2) === 0 || d !== P)
    d === P && ((W$1 & 2) === 0 && (ok |= b2), R === 4 && Bk(d, Y)), Ck(d, c), b2 === 1 && W$1 === 0 && (a.mode & 1) === 0 && (aj = B() + 500, eg && ig());
  return d;
}
function Ak(a, b2) {
  a.lanes |= b2;
  var c = a.alternate;
  c !== null && (c.lanes |= b2);
  c = a;
  for (a = a.return; a !== null; )
    a.childLanes |= b2, c = a.alternate, c !== null && (c.childLanes |= b2), c = a, a = a.return;
  return c.tag === 3 ? c.stateNode : null;
}
function Bg(a) {
  return (P !== null || vg !== null) && (a.mode & 1) !== 0 && (W$1 & 2) === 0;
}
function Ck(a, b2) {
  var c = a.callbackNode;
  vc(a, b2);
  var d = tc(a, a === P ? Y : 0);
  if (d === 0)
    c !== null && ac(c), a.callbackNode = null, a.callbackPriority = 0;
  else if (b2 = d & -d, a.callbackPriority !== b2) {
    c != null && ac(c);
    if (b2 === 1)
      a.tag === 0 ? hg(Dk.bind(null, a)) : gg(Dk.bind(null, a)), If(function() {
        W$1 === 0 && ig();
      }), c = null;
    else {
      switch (Cc(d)) {
        case 1:
          c = ec;
          break;
        case 4:
          c = fc;
          break;
        case 16:
          c = gc;
          break;
        case 536870912:
          c = ic;
          break;
        default:
          c = gc;
      }
      c = Ek(c, Fk.bind(null, a));
    }
    a.callbackPriority = b2;
    a.callbackNode = c;
  }
}
function Fk(a, b2) {
  yk = -1;
  zk = 0;
  if ((W$1 & 6) !== 0)
    throw Error(p$2(327));
  var c = a.callbackNode;
  if (Gk() && a.callbackNode !== c)
    return null;
  var d = tc(a, a === P ? Y : 0);
  if (d === 0)
    return null;
  if ((d & 30) !== 0 || (d & a.expiredLanes) !== 0 || b2)
    b2 = Hk(a, d);
  else {
    b2 = d;
    var e = W$1;
    W$1 |= 2;
    var f2 = Ik();
    if (P !== a || Y !== b2)
      sk = null, aj = B() + 500, Jk(a, b2);
    do
      try {
        Kk();
        break;
      } catch (h2) {
        Lk(a, h2);
      }
    while (1);
    pg();
    kk.current = f2;
    W$1 = e;
    X !== null ? b2 = 0 : (P = null, Y = 0, b2 = R);
  }
  if (b2 !== 0) {
    b2 === 2 && (e = wc(a), e !== 0 && (d = e, b2 = Mk(a, e)));
    if (b2 === 1)
      throw c = nk, Jk(a, 0), Bk(a, d), Ck(a, B()), c;
    if (b2 === 6)
      Bk(a, d);
    else {
      e = a.current.alternate;
      if ((d & 30) === 0 && !Nk(e) && (b2 = Hk(a, d), b2 === 2 && (f2 = wc(a), f2 !== 0 && (d = f2, b2 = Mk(a, f2))), b2 === 1))
        throw c = nk, Jk(a, 0), Bk(a, d), Ck(a, B()), c;
      a.finishedWork = e;
      a.finishedLanes = d;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$2(345));
        case 2:
          Ok(a, rk, sk);
          break;
        case 3:
          Bk(a, d);
          if ((d & 130023424) === d && (b2 = dk + 500 - B(), 10 < b2)) {
            if (tc(a, 0) !== 0)
              break;
            e = a.suspendedLanes;
            if ((e & d) !== d) {
              Jg();
              a.pingedLanes |= a.suspendedLanes & e;
              break;
            }
            a.timeoutHandle = Ef(Ok.bind(null, a, rk, sk), b2);
            break;
          }
          Ok(a, rk, sk);
          break;
        case 4:
          Bk(a, d);
          if ((d & 4194240) === d)
            break;
          b2 = a.eventTimes;
          for (e = -1; 0 < d; ) {
            var g2 = 31 - nc(d);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e && (e = g2);
            d &= ~f2;
          }
          d = e;
          d = B() - d;
          d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * jk(d / 1960)) - d;
          if (10 < d) {
            a.timeoutHandle = Ef(Ok.bind(null, a, rk, sk), d);
            break;
          }
          Ok(a, rk, sk);
          break;
        case 5:
          Ok(a, rk, sk);
          break;
        default:
          throw Error(p$2(329));
      }
    }
  }
  Ck(a, B());
  return a.callbackNode === c ? Fk.bind(null, a) : null;
}
function Mk(a, b2) {
  var c = qk;
  a.current.memoizedState.isDehydrated && (Jk(a, b2).flags |= 256);
  a = Hk(a, b2);
  a !== 2 && (b2 = rk, rk = c, b2 !== null && Zi(b2));
  return a;
}
function Zi(a) {
  rk === null ? rk = a : rk.push.apply(rk, a);
}
function Nk(a) {
  for (var b2 = a; ; ) {
    if (b2.flags & 16384) {
      var c = b2.updateQueue;
      if (c !== null && (c = c.stores, c !== null))
        for (var d = 0; d < c.length; d++) {
          var e = c[d], f2 = e.getSnapshot;
          e = e.value;
          try {
            if (!Ge(f2(), e))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c = b2.child;
    if (b2.subtreeFlags & 16384 && c !== null)
      c.return = b2, b2 = c;
    else {
      if (b2 === a)
        break;
      for (; b2.sibling === null; ) {
        if (b2.return === null || b2.return === a)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Bk(a, b2) {
  b2 &= ~pk;
  b2 &= ~ok;
  a.suspendedLanes |= b2;
  a.pingedLanes &= ~b2;
  for (a = a.expirationTimes; 0 < b2; ) {
    var c = 31 - nc(b2), d = 1 << c;
    a[c] = -1;
    b2 &= ~d;
  }
}
function Dk(a) {
  if ((W$1 & 6) !== 0)
    throw Error(p$2(327));
  Gk();
  var b2 = tc(a, 0);
  if ((b2 & 1) === 0)
    return Ck(a, B()), null;
  var c = Hk(a, b2);
  if (a.tag !== 0 && c === 2) {
    var d = wc(a);
    d !== 0 && (b2 = d, c = Mk(a, d));
  }
  if (c === 1)
    throw c = nk, Jk(a, 0), Bk(a, b2), Ck(a, B()), c;
  if (c === 6)
    throw Error(p$2(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b2;
  Ok(a, rk, sk);
  Ck(a, B());
  return null;
}
function Pk(a, b2) {
  var c = W$1;
  W$1 |= 1;
  try {
    return a(b2);
  } finally {
    W$1 = c, W$1 === 0 && (aj = B() + 500, eg && ig());
  }
}
function Qk(a) {
  uk !== null && uk.tag === 0 && (W$1 & 6) === 0 && Gk();
  var b2 = W$1;
  W$1 |= 1;
  var c = mk.transition, d = C;
  try {
    if (mk.transition = null, C = 1, a)
      return a();
  } finally {
    C = d, mk.transition = c, W$1 = b2, (W$1 & 6) === 0 && ig();
  }
}
function bj() {
  cj = mj.current;
  E(mj);
}
function Jk(a, b2) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  c !== -1 && (a.timeoutHandle = -1, Ff(c));
  if (X !== null)
    for (c = X.return; c !== null; ) {
      var d = c;
      ch(d);
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          d !== null && d !== void 0 && Zf();
          break;
        case 3:
          Gh();
          E(Vf);
          E(H);
          Lh();
          break;
        case 5:
          Ih(d);
          break;
        case 4:
          Gh();
          break;
        case 13:
          E(K);
          break;
        case 19:
          E(K);
          break;
        case 10:
          qg(d.type._context);
          break;
        case 22:
        case 23:
          bj();
      }
      c = c.return;
    }
  P = a;
  X = a = th(a.current, null);
  Y = cj = b2;
  R = 0;
  nk = null;
  pk = ok = Fg = 0;
  rk = qk = null;
  if (vg !== null) {
    for (b2 = 0; b2 < vg.length; b2++)
      if (c = vg[b2], d = c.interleaved, d !== null) {
        c.interleaved = null;
        var e = d.next, f2 = c.pending;
        if (f2 !== null) {
          var g2 = f2.next;
          f2.next = e;
          d.next = g2;
        }
        c.pending = d;
      }
    vg = null;
  }
  return a;
}
function Lk(a, b2) {
  do {
    var c = X;
    try {
      pg();
      Mh.current = Yh;
      if (Ph) {
        for (var d = L.memoizedState; d !== null; ) {
          var e = d.queue;
          e !== null && (e.pending = null);
          d = d.next;
        }
        Ph = false;
      }
      Oh = 0;
      N$1 = M = L = null;
      Qh = false;
      Rh = 0;
      lk.current = null;
      if (c === null || c.return === null) {
        R = 1;
        nk = b2;
        X = null;
        break;
      }
      a: {
        var f2 = a, g2 = c.return, h2 = c, k2 = b2;
        b2 = Y;
        h2.flags |= 32768;
        if (k2 !== null && typeof k2 === "object" && typeof k2.then === "function") {
          var l2 = k2, n2 = h2, u2 = n2.tag;
          if ((n2.mode & 1) === 0 && (u2 === 0 || u2 === 11 || u2 === 15)) {
            var q2 = n2.alternate;
            q2 ? (n2.updateQueue = q2.updateQueue, n2.memoizedState = q2.memoizedState, n2.lanes = q2.lanes) : (n2.updateQueue = null, n2.memoizedState = null);
          }
          var y2 = Ri(g2);
          if (y2 !== null) {
            y2.flags &= -257;
            Si(y2, g2, h2, f2, b2);
            y2.mode & 1 && Pi(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var m2 = b2.updateQueue;
            if (m2 === null) {
              var w2 = /* @__PURE__ */ new Set();
              w2.add(k2);
              b2.updateQueue = w2;
            } else
              m2.add(k2);
            break a;
          } else {
            if ((b2 & 1) === 0) {
              Pi(f2, l2, b2);
              $i();
              break a;
            }
            k2 = Error(p$2(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Ri(g2);
          if (J2 !== null) {
            (J2.flags & 65536) === 0 && (J2.flags |= 256);
            Si(J2, g2, h2, f2, b2);
            oh(k2);
            break a;
          }
        }
        f2 = k2;
        R !== 4 && (R = 2);
        qk === null ? qk = [f2] : qk.push(f2);
        k2 = Hi(k2, h2);
        h2 = g2;
        do {
          switch (h2.tag) {
            case 3:
              h2.flags |= 65536;
              b2 &= -b2;
              h2.lanes |= b2;
              var v2 = Ki(h2, k2, b2);
              Dg(h2, v2);
              break a;
            case 1:
              f2 = k2;
              var x2 = h2.type, r2 = h2.stateNode;
              if ((h2.flags & 128) === 0 && (typeof x2.getDerivedStateFromError === "function" || r2 !== null && typeof r2.componentDidCatch === "function" && (Oi === null || !Oi.has(r2)))) {
                h2.flags |= 65536;
                b2 &= -b2;
                h2.lanes |= b2;
                var F2 = Ni(h2, f2, b2);
                Dg(h2, F2);
                break a;
              }
          }
          h2 = h2.return;
        } while (h2 !== null);
      }
      Rk(c);
    } catch (Z) {
      b2 = Z;
      X === c && c !== null && (X = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Ik() {
  var a = kk.current;
  kk.current = Yh;
  return a === null ? Yh : a;
}
function $i() {
  if (R === 0 || R === 3 || R === 2)
    R = 4;
  P === null || (Fg & 268435455) === 0 && (ok & 268435455) === 0 || Bk(P, Y);
}
function Hk(a, b2) {
  var c = W$1;
  W$1 |= 2;
  var d = Ik();
  if (P !== a || Y !== b2)
    sk = null, Jk(a, b2);
  do
    try {
      Sk();
      break;
    } catch (e) {
      Lk(a, e);
    }
  while (1);
  pg();
  W$1 = c;
  kk.current = d;
  if (X !== null)
    throw Error(p$2(261));
  P = null;
  Y = 0;
  return R;
}
function Sk() {
  for (; X !== null; )
    Tk(X);
}
function Kk() {
  for (; X !== null && !bc(); )
    Tk(X);
}
function Tk(a) {
  var b2 = Uk(a.alternate, a, cj);
  a.memoizedProps = a.pendingProps;
  b2 === null ? Rk(a) : X = b2;
  lk.current = null;
}
function Rk(a) {
  var b2 = a;
  do {
    var c = b2.alternate;
    a = b2.return;
    if ((b2.flags & 32768) === 0) {
      if (c = Yi(c, b2, cj), c !== null) {
        X = c;
        return;
      }
    } else {
      c = Gj(c, b2);
      if (c !== null) {
        c.flags &= 32767;
        X = c;
        return;
      }
      if (a !== null)
        a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        R = 6;
        X = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (b2 !== null) {
      X = b2;
      return;
    }
    X = b2 = a;
  } while (b2 !== null);
  R === 0 && (R = 5);
}
function Ok(a, b2, c) {
  var d = C, e = mk.transition;
  try {
    mk.transition = null, C = 1, Vk(a, b2, c, d);
  } finally {
    mk.transition = e, C = d;
  }
  return null;
}
function Vk(a, b2, c, d) {
  do
    Gk();
  while (uk !== null);
  if ((W$1 & 6) !== 0)
    throw Error(p$2(327));
  c = a.finishedWork;
  var e = a.finishedLanes;
  if (c === null)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current)
    throw Error(p$2(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c.lanes | c.childLanes;
  Ac(a, f2);
  a === P && (X = P = null, Y = 0);
  (c.subtreeFlags & 2064) === 0 && (c.flags & 2064) === 0 || tk || (tk = true, Ek(gc, function() {
    Gk();
    return null;
  }));
  f2 = (c.flags & 15990) !== 0;
  if ((c.subtreeFlags & 15990) !== 0 || f2) {
    f2 = mk.transition;
    mk.transition = null;
    var g2 = C;
    C = 1;
    var h2 = W$1;
    W$1 |= 4;
    lk.current = null;
    Mj(a, c);
    bk(c, a);
    Ne(Cf);
    cd = !!Bf;
    Cf = Bf = null;
    a.current = c;
    fk(c);
    cc();
    W$1 = h2;
    C = g2;
    mk.transition = f2;
  } else
    a.current = c;
  tk && (tk = false, uk = a, vk = e);
  f2 = a.pendingLanes;
  f2 === 0 && (Oi = null);
  lc(c.stateNode);
  Ck(a, B());
  if (b2 !== null)
    for (d = a.onRecoverableError, c = 0; c < b2.length; c++)
      d(b2[c]);
  if (Li)
    throw Li = false, a = Mi, Mi = null, a;
  (vk & 1) !== 0 && a.tag !== 0 && Gk();
  f2 = a.pendingLanes;
  (f2 & 1) !== 0 ? a === xk ? wk++ : (wk = 0, xk = a) : wk = 0;
  ig();
  return null;
}
function Gk() {
  if (uk !== null) {
    var a = Cc(vk), b2 = mk.transition, c = C;
    try {
      mk.transition = null;
      C = 16 > a ? 16 : a;
      if (uk === null)
        var d = false;
      else {
        a = uk;
        uk = null;
        vk = 0;
        if ((W$1 & 6) !== 0)
          throw Error(p$2(331));
        var e = W$1;
        W$1 |= 4;
        for (T = a.current; T !== null; ) {
          var f2 = T, g2 = f2.child;
          if ((T.flags & 16) !== 0) {
            var h2 = f2.deletions;
            if (h2 !== null) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (T = l2; T !== null; ) {
                  var n2 = T;
                  switch (n2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Nj(8, n2, f2);
                  }
                  var u2 = n2.child;
                  if (u2 !== null)
                    u2.return = n2, T = u2;
                  else
                    for (; T !== null; ) {
                      n2 = T;
                      var q2 = n2.sibling, y2 = n2.return;
                      Qj(n2);
                      if (n2 === l2) {
                        T = null;
                        break;
                      }
                      if (q2 !== null) {
                        q2.return = y2;
                        T = q2;
                        break;
                      }
                      T = y2;
                    }
                }
              }
              var m2 = f2.alternate;
              if (m2 !== null) {
                var w2 = m2.child;
                if (w2 !== null) {
                  m2.child = null;
                  do {
                    var J2 = w2.sibling;
                    w2.sibling = null;
                    w2 = J2;
                  } while (w2 !== null);
                }
              }
              T = f2;
            }
          }
          if ((f2.subtreeFlags & 2064) !== 0 && g2 !== null)
            g2.return = f2, T = g2;
          else
            b:
              for (; T !== null; ) {
                f2 = T;
                if ((f2.flags & 2048) !== 0)
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Nj(9, f2, f2.return);
                  }
                var v2 = f2.sibling;
                if (v2 !== null) {
                  v2.return = f2.return;
                  T = v2;
                  break b;
                }
                T = f2.return;
              }
        }
        var x2 = a.current;
        for (T = x2; T !== null; ) {
          g2 = T;
          var r2 = g2.child;
          if ((g2.subtreeFlags & 2064) !== 0 && r2 !== null)
            r2.return = g2, T = r2;
          else
            b:
              for (g2 = x2; T !== null; ) {
                h2 = T;
                if ((h2.flags & 2048) !== 0)
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Oj(9, h2);
                    }
                  } catch (Z) {
                    U(h2, h2.return, Z);
                  }
                if (h2 === g2) {
                  T = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (F2 !== null) {
                  F2.return = h2.return;
                  T = F2;
                  break b;
                }
                T = h2.return;
              }
        }
        W$1 = e;
        ig();
        if (kc && typeof kc.onPostCommitFiberRoot === "function")
          try {
            kc.onPostCommitFiberRoot(jc, a);
          } catch (Z) {
          }
        d = true;
      }
      return d;
    } finally {
      C = c, mk.transition = b2;
    }
  }
  return false;
}
function Wk(a, b2, c) {
  b2 = Hi(c, b2);
  b2 = Ki(a, b2, 1);
  Ag(a, b2);
  b2 = Jg();
  a = Ak(a, 1);
  a !== null && (zc(a, 1, b2), Ck(a, b2));
}
function U(a, b2, c) {
  if (a.tag === 3)
    Wk(a, a, c);
  else
    for (; b2 !== null; ) {
      if (b2.tag === 3) {
        Wk(b2, a, c);
        break;
      } else if (b2.tag === 1) {
        var d = b2.stateNode;
        if (typeof b2.type.getDerivedStateFromError === "function" || typeof d.componentDidCatch === "function" && (Oi === null || !Oi.has(d))) {
          a = Hi(c, a);
          a = Ni(b2, a, 1);
          Ag(b2, a);
          a = Jg();
          b2 = Ak(b2, 1);
          b2 !== null && (zc(b2, 1, a), Ck(b2, a));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Qi(a, b2, c) {
  var d = a.pingCache;
  d !== null && d.delete(b2);
  b2 = Jg();
  a.pingedLanes |= a.suspendedLanes & c;
  P === a && (Y & c) === c && (R === 4 || R === 3 && (Y & 130023424) === Y && 500 > B() - dk ? Jk(a, 0) : pk |= c);
  Ck(a, b2);
}
function Xk(a, b2) {
  b2 === 0 && ((a.mode & 1) === 0 ? b2 = 1 : (b2 = rc, rc <<= 1, (rc & 130023424) === 0 && (rc = 4194304)));
  var c = Jg();
  a = Ak(a, b2);
  a !== null && (zc(a, b2, c), Ck(a, c));
}
function zj(a) {
  var b2 = a.memoizedState, c = 0;
  b2 !== null && (c = b2.retryLane);
  Xk(a, c);
}
function Zj(a, b2) {
  var c = 0;
  switch (a.tag) {
    case 13:
      var d = a.stateNode;
      var e = a.memoizedState;
      e !== null && (c = e.retryLane);
      break;
    case 19:
      d = a.stateNode;
      break;
    default:
      throw Error(p$2(314));
  }
  d !== null && d.delete(b2);
  Xk(a, c);
}
var Uk;
Uk = function(a, b2, c) {
  if (a !== null)
    if (a.memoizedProps !== b2.pendingProps || Vf.current)
      tg = true;
    else {
      if ((a.lanes & c) === 0 && (b2.flags & 128) === 0)
        return tg = false, Fj(a, b2, c);
      tg = (a.flags & 131072) !== 0 ? true : false;
    }
  else
    tg = false, I && (b2.flags & 1048576) !== 0 && ah(b2, Ug, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d = b2.type;
      a !== null && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
      a = b2.pendingProps;
      var e = Xf(b2, H.current);
      sg(b2, c);
      e = Uh(null, b2, d, a, e, c);
      var f2 = Zh();
      b2.flags |= 1;
      typeof e === "object" && e !== null && typeof e.render === "function" && e.$$typeof === void 0 ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Yf(d) ? (f2 = true, bg(b2)) : f2 = false, b2.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, xg(b2), e.updater = Mg, b2.stateNode = e, e._reactInternals = b2, Qg(b2, d, a, c), b2 = pj(null, b2, d, true, f2, c)) : (b2.tag = 0, I && f2 && bh(b2), ej(null, b2, e, c), b2 = b2.child);
      return b2;
    case 16:
      d = b2.elementType;
      a: {
        a !== null && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
        a = b2.pendingProps;
        e = d._init;
        d = e(d._payload);
        b2.type = d;
        e = b2.tag = Yk(d);
        a = kg(d, a);
        switch (e) {
          case 0:
            b2 = kj(null, b2, d, a, c);
            break a;
          case 1:
            b2 = oj(null, b2, d, a, c);
            break a;
          case 11:
            b2 = fj(null, b2, d, a, c);
            break a;
          case 14:
            b2 = hj(null, b2, d, kg(d.type, a), c);
            break a;
        }
        throw Error(p$2(306, d, ""));
      }
      return b2;
    case 0:
      return d = b2.type, e = b2.pendingProps, e = b2.elementType === d ? e : kg(d, e), kj(a, b2, d, e, c);
    case 1:
      return d = b2.type, e = b2.pendingProps, e = b2.elementType === d ? e : kg(d, e), oj(a, b2, d, e, c);
    case 3:
      a: {
        qj(b2);
        if (a === null)
          throw Error(p$2(387));
        d = b2.pendingProps;
        f2 = b2.memoizedState;
        e = f2.element;
        yg(a, b2);
        Eg(b2, d, null, c);
        var g2 = b2.memoizedState;
        d = g2.element;
        if (f2.isDehydrated)
          if (f2 = {
            element: d,
            isDehydrated: false,
            cache: g2.cache,
            pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries,
            transitions: g2.transitions
          }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e = Error(p$2(423));
            b2 = rj(a, b2, d, c, e);
            break a;
          } else if (d !== e) {
            e = Error(p$2(424));
            b2 = rj(a, b2, d, c, e);
            break a;
          } else
            for (eh = Kf(b2.stateNode.containerInfo.firstChild), dh = b2, I = true, fh = null, c = zh(b2, null, d, c), b2.child = c; c; )
              c.flags = c.flags & -3 | 4096, c = c.sibling;
        else {
          nh();
          if (d === e) {
            b2 = gj(a, b2, c);
            break a;
          }
          ej(a, b2, d, c);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Hh(b2), a === null && kh(b2), d = b2.type, e = b2.pendingProps, f2 = a !== null ? a.memoizedProps : null, g2 = e.children, Df(d, e) ? g2 = null : f2 !== null && Df(d, f2) && (b2.flags |= 32), nj(a, b2), ej(a, b2, g2, c), b2.child;
    case 6:
      return a === null && kh(b2), null;
    case 13:
      return vj(a, b2, c);
    case 4:
      return Fh(b2, b2.stateNode.containerInfo), d = b2.pendingProps, a === null ? b2.child = yh(b2, null, d, c) : ej(a, b2, d, c), b2.child;
    case 11:
      return d = b2.type, e = b2.pendingProps, e = b2.elementType === d ? e : kg(d, e), fj(a, b2, d, e, c);
    case 7:
      return ej(a, b2, b2.pendingProps, c), b2.child;
    case 8:
      return ej(a, b2, b2.pendingProps.children, c), b2.child;
    case 12:
      return ej(a, b2, b2.pendingProps.children, c), b2.child;
    case 10:
      a: {
        d = b2.type._context;
        e = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e.value;
        G(lg, d._currentValue);
        d._currentValue = g2;
        if (f2 !== null)
          if (Ge(f2.value, g2)) {
            if (f2.children === e.children && !Vf.current) {
              b2 = gj(a, b2, c);
              break a;
            }
          } else
            for (f2 = b2.child, f2 !== null && (f2.return = b2); f2 !== null; ) {
              var h2 = f2.dependencies;
              if (h2 !== null) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; k2 !== null; ) {
                  if (k2.context === d) {
                    if (f2.tag === 1) {
                      k2 = zg(-1, c & -c);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (l2 !== null) {
                        l2 = l2.shared;
                        var n2 = l2.pending;
                        n2 === null ? k2.next = k2 : (k2.next = n2.next, n2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c;
                    k2 = f2.alternate;
                    k2 !== null && (k2.lanes |= c);
                    rg(f2.return, c, b2);
                    h2.lanes |= c;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (f2.tag === 10)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (f2.tag === 18) {
                g2 = f2.return;
                if (g2 === null)
                  throw Error(p$2(341));
                g2.lanes |= c;
                h2 = g2.alternate;
                h2 !== null && (h2.lanes |= c);
                rg(g2, c, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (g2 !== null)
                g2.return = f2;
              else
                for (g2 = f2; g2 !== null; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (f2 !== null) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        ej(a, b2, e.children, c);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e = b2.type, d = b2.pendingProps.children, sg(b2, c), e = ug(e), d = d(e), b2.flags |= 1, ej(a, b2, d, c), b2.child;
    case 14:
      return d = b2.type, e = kg(d, b2.pendingProps), e = kg(d.type, e), hj(a, b2, d, e, c);
    case 15:
      return jj(a, b2, b2.type, b2.pendingProps, c);
    case 17:
      return d = b2.type, e = b2.pendingProps, e = b2.elementType === d ? e : kg(d, e), a !== null && (a.alternate = null, b2.alternate = null, b2.flags |= 2), b2.tag = 1, Yf(d) ? (a = true, bg(b2)) : a = false, sg(b2, c), Og(b2, d, e), Qg(b2, d, e, c), pj(null, b2, d, true, a, c);
    case 19:
      return Ej(a, b2, c);
    case 22:
      return lj(a, b2, c);
  }
  throw Error(p$2(156, b2.tag));
};
function Ek(a, b2) {
  return $b(a, b2);
}
function Zk(a, b2, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function hh(a, b2, c, d) {
  return new Zk(a, b2, c, d);
}
function ij(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function Yk(a) {
  if (typeof a === "function")
    return ij(a) ? 1 : 0;
  if (a !== void 0 && a !== null) {
    a = a.$$typeof;
    if (a === Ca)
      return 11;
    if (a === Fa)
      return 14;
  }
  return 2;
}
function th(a, b2) {
  var c = a.alternate;
  c === null ? (c = hh(a.tag, b2, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b2, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
  c.flags = a.flags & 14680064;
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b2 = a.dependencies;
  c.dependencies = b2 === null ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function vh(a, b2, c, d, e, f2) {
  var g2 = 2;
  d = a;
  if (typeof a === "function")
    ij(a) && (g2 = 1);
  else if (typeof a === "string")
    g2 = 5;
  else
    a:
      switch (a) {
        case wa:
          return xh(c.children, e, f2, b2);
        case xa:
          g2 = 8;
          e |= 8;
          break;
        case za:
          return a = hh(12, c, b2, e | 2), a.elementType = za, a.lanes = f2, a;
        case Da:
          return a = hh(13, c, b2, e), a.elementType = Da, a.lanes = f2, a;
        case Ea:
          return a = hh(19, c, b2, e), a.elementType = Ea, a.lanes = f2, a;
        case Ha:
          return wj(c, e, f2, b2);
        default:
          if (typeof a === "object" && a !== null)
            switch (a.$$typeof) {
              case Aa:
                g2 = 10;
                break a;
              case Ba:
                g2 = 9;
                break a;
              case Ca:
                g2 = 11;
                break a;
              case Fa:
                g2 = 14;
                break a;
              case Ga:
                g2 = 16;
                d = null;
                break a;
            }
          throw Error(p$2(130, a == null ? a : typeof a, ""));
      }
  b2 = hh(g2, c, b2, e);
  b2.elementType = a;
  b2.type = d;
  b2.lanes = f2;
  return b2;
}
function xh(a, b2, c, d) {
  a = hh(7, a, d, b2);
  a.lanes = c;
  return a;
}
function wj(a, b2, c, d) {
  a = hh(22, a, d, b2);
  a.elementType = Ha;
  a.lanes = c;
  a.stateNode = {};
  return a;
}
function uh(a, b2, c) {
  a = hh(6, a, null, b2);
  a.lanes = c;
  return a;
}
function wh(a, b2, c) {
  b2 = hh(4, a.children !== null ? a.children : [], a.key, b2);
  b2.lanes = c;
  b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b2;
}
function $k(a, b2, c, d, e) {
  this.tag = b2;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = yc(0);
  this.expirationTimes = yc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = yc(0);
  this.identifierPrefix = d;
  this.onRecoverableError = e;
  this.mutableSourceEagerHydrationData = null;
}
function al(a, b2, c, d, e, f2, g2, h2, k2) {
  a = new $k(a, b2, c, h2, k2);
  b2 === 1 ? (b2 = 1, f2 === true && (b2 |= 8)) : b2 = 0;
  f2 = hh(3, null, null, b2);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  xg(f2);
  return a;
}
function bl(a, b2, c) {
  var d = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: va, key: d == null ? null : "" + d, children: a, containerInfo: b2, implementation: c };
}
function cl(a) {
  if (!a)
    return Uf;
  a = a._reactInternals;
  a: {
    if (Ub(a) !== a || a.tag !== 1)
      throw Error(p$2(170));
    var b2 = a;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Yf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (b2 !== null);
    throw Error(p$2(171));
  }
  if (a.tag === 1) {
    var c = a.type;
    if (Yf(c))
      return ag(a, c, b2);
  }
  return b2;
}
function dl(a, b2, c, d, e, f2, g2, h2, k2) {
  a = al(c, d, true, a, e, f2, g2, h2, k2);
  a.context = cl(null);
  c = a.current;
  d = Jg();
  e = Kg(c);
  f2 = zg(d, e);
  f2.callback = b2 !== void 0 && b2 !== null ? b2 : null;
  Ag(c, f2);
  a.current.lanes = e;
  zc(a, e, d);
  Ck(a, d);
  return a;
}
function el(a, b2, c, d) {
  var e = b2.current, f2 = Jg(), g2 = Kg(e);
  c = cl(c);
  b2.context === null ? b2.context = c : b2.pendingContext = c;
  b2 = zg(f2, g2);
  b2.payload = { element: a };
  d = d === void 0 ? null : d;
  d !== null && (b2.callback = d);
  Ag(e, b2);
  a = Lg(e, g2, f2);
  a !== null && Cg(a, e, g2);
  return g2;
}
function fl(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function gl(a, b2) {
  a = a.memoizedState;
  if (a !== null && a.dehydrated !== null) {
    var c = a.retryLane;
    a.retryLane = c !== 0 && c < b2 ? c : b2;
  }
}
function hl(a, b2) {
  gl(a, b2);
  (a = a.alternate) && gl(a, b2);
}
function il() {
  return null;
}
var jl = typeof reportError === "function" ? reportError : function(a) {
  console.error(a);
};
function kl(a) {
  this._internalRoot = a;
}
ll.prototype.render = kl.prototype.render = function(a) {
  var b2 = this._internalRoot;
  if (b2 === null)
    throw Error(p$2(409));
  el(a, b2, null, null);
};
ll.prototype.unmount = kl.prototype.unmount = function() {
  var a = this._internalRoot;
  if (a !== null) {
    this._internalRoot = null;
    var b2 = a.containerInfo;
    Qk(function() {
      el(null, a, null, null);
    });
    b2[tf] = null;
  }
};
function ll(a) {
  this._internalRoot = a;
}
ll.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b2 = Gc();
    a = { blockedOn: null, target: a, priority: b2 };
    for (var c = 0; c < Pc.length && b2 !== 0 && b2 < Pc[c].priority; c++)
      ;
    Pc.splice(c, 0, a);
    c === 0 && Uc(a);
  }
};
function ml(a) {
  return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11);
}
function nl(a) {
  return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11 && (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "));
}
function ol() {
}
function pl(a, b2, c, d, e) {
  if (e) {
    if (typeof d === "function") {
      var f2 = d;
      d = function() {
        var a2 = fl(g2);
        f2.call(a2);
      };
    }
    var g2 = dl(b2, d, a, 0, null, false, false, "", ol);
    a._reactRootContainer = g2;
    a[tf] = g2.current;
    rf(a.nodeType === 8 ? a.parentNode : a);
    Qk();
    return g2;
  }
  for (; e = a.lastChild; )
    a.removeChild(e);
  if (typeof d === "function") {
    var h2 = d;
    d = function() {
      var a2 = fl(k2);
      h2.call(a2);
    };
  }
  var k2 = al(a, 0, false, null, null, false, false, "", ol);
  a._reactRootContainer = k2;
  a[tf] = k2.current;
  rf(a.nodeType === 8 ? a.parentNode : a);
  Qk(function() {
    el(b2, k2, c, d);
  });
  return k2;
}
function ql(a, b2, c, d, e) {
  var f2 = c._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if (typeof e === "function") {
      var h2 = e;
      e = function() {
        var a2 = fl(g2);
        h2.call(a2);
      };
    }
    el(b2, g2, a, e);
  } else
    g2 = pl(c, b2, a, e, d);
  return fl(g2);
}
Dc = function(a) {
  switch (a.tag) {
    case 3:
      var b2 = a.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c = sc(b2.pendingLanes);
        c !== 0 && (Bc(b2, c | 1), Ck(b2, B()), (W$1 & 6) === 0 && (aj = B() + 500, ig()));
      }
      break;
    case 13:
      var d = Jg();
      Qk(function() {
        return Lg(a, 1, d);
      });
      hl(a, 1);
  }
};
Ec = function(a) {
  if (a.tag === 13) {
    var b2 = Jg();
    Lg(a, 134217728, b2);
    hl(a, 134217728);
  }
};
Fc = function(a) {
  if (a.tag === 13) {
    var b2 = Jg(), c = Kg(a);
    Lg(a, c, b2);
    hl(a, c);
  }
};
Gc = function() {
  return C;
};
Hc = function(a, b2) {
  var c = C;
  try {
    return C = a, b2();
  } finally {
    C = c;
  }
};
xb = function(a, b2, c) {
  switch (b2) {
    case "input":
      $a(a, c);
      b2 = c.name;
      if (c.type === "radio" && b2 != null) {
        for (c = a; c.parentNode; )
          c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c.length; b2++) {
          var d = c[b2];
          if (d !== a && d.form === a.form) {
            var e = Cb(d);
            if (!e)
              throw Error(p$2(90));
            Va(d);
            $a(d, e);
          }
        }
      }
      break;
    case "textarea":
      hb(a, c);
      break;
    case "select":
      b2 = c.value, b2 != null && eb(a, !!c.multiple, b2, false);
  }
};
Fb = Pk;
Gb = Qk;
var rl = { usingClientEntryPoint: false, Events: [Bb, te, Cb, Db, Eb, Pk] }, sl = { findFiberByHostInstance: Vc, bundleType: 0, version: "18.1.0", rendererPackageName: "react-dom" };
var tl = { bundleType: sl.bundleType, version: sl.version, rendererPackageName: sl.rendererPackageName, rendererConfig: sl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ta.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Yb(a);
  return a === null ? null : a.stateNode;
}, findFiberByHostInstance: sl.findFiberByHostInstance || il, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.1.0-next-22edb9f77-20220426" };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined") {
  var ul = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!ul.isDisabled && ul.supportsFiber)
    try {
      jc = ul.inject(tl), kc = ul;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = rl;
reactDom_production_min.createPortal = function(a, b2) {
  var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!ml(b2))
    throw Error(p$2(200));
  return bl(a, b2, null, c);
};
reactDom_production_min.createRoot = function(a, b2) {
  if (!ml(a))
    throw Error(p$2(299));
  var c = false, d = "", e = jl;
  b2 !== null && b2 !== void 0 && (b2.unstable_strictMode === true && (c = true), b2.identifierPrefix !== void 0 && (d = b2.identifierPrefix), b2.onRecoverableError !== void 0 && (e = b2.onRecoverableError));
  b2 = al(a, 1, false, null, null, c, false, d, e);
  a[tf] = b2.current;
  rf(a.nodeType === 8 ? a.parentNode : a);
  return new kl(b2);
};
reactDom_production_min.findDOMNode = function(a) {
  if (a == null)
    return null;
  if (a.nodeType === 1)
    return a;
  var b2 = a._reactInternals;
  if (b2 === void 0) {
    if (typeof a.render === "function")
      throw Error(p$2(188));
    a = Object.keys(a).join(",");
    throw Error(p$2(268, a));
  }
  a = Yb(b2);
  a = a === null ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Qk(a);
};
reactDom_production_min.hydrate = function(a, b2, c) {
  if (!nl(b2))
    throw Error(p$2(200));
  return ql(null, a, b2, true, c);
};
reactDom_production_min.hydrateRoot = function(a, b2, c) {
  if (!ml(a))
    throw Error(p$2(405));
  var d = c != null && c.hydratedSources || null, e = false, f2 = "", g2 = jl;
  c !== null && c !== void 0 && (c.unstable_strictMode === true && (e = true), c.identifierPrefix !== void 0 && (f2 = c.identifierPrefix), c.onRecoverableError !== void 0 && (g2 = c.onRecoverableError));
  b2 = dl(b2, null, a, 1, c != null ? c : null, e, false, f2, g2);
  a[tf] = b2.current;
  rf(a);
  if (d)
    for (a = 0; a < d.length; a++)
      c = d[a], e = c._getVersion, e = e(c._source), b2.mutableSourceEagerHydrationData == null ? b2.mutableSourceEagerHydrationData = [c, e] : b2.mutableSourceEagerHydrationData.push(c, e);
  return new ll(b2);
};
reactDom_production_min.render = function(a, b2, c) {
  if (!nl(b2))
    throw Error(p$2(200));
  return ql(null, a, b2, false, c);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!nl(a))
    throw Error(p$2(40));
  return a._reactRootContainer ? (Qk(function() {
    ql(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[tf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Pk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c, d) {
  if (!nl(c))
    throw Error(p$2(200));
  if (a == null || a._reactInternals === void 0)
    throw Error(p$2(38));
  return ql(a, b2, c, false, d);
};
reactDom_production_min.version = "18.1.0-next-22edb9f77-20220426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var m$1 = reactDom.exports;
{
  client.createRoot = m$1.createRoot;
  client.hydrateRoot = m$1.hydrateRoot;
}
var A = Object.defineProperty;
var f$1 = Object.getOwnPropertySymbols;
var g = Object.prototype.hasOwnProperty, v = Object.prototype.propertyIsEnumerable;
var h = (e, o, t2) => o in e ? A(e, o, { enumerable: true, configurable: true, writable: true, value: t2 }) : e[o] = t2, i = (e, o) => {
  for (var t2 in o || (o = {}))
    g.call(o, t2) && h(e, t2, o[t2]);
  if (f$1)
    for (var t2 of f$1(o))
      v.call(o, t2) && h(e, t2, o[t2]);
  return e;
};
var p$1 = "nes-ui-dark-mode", N = (e) => {
  document.documentElement.classList.toggle(p$1, e);
  try {
    localStorage.setItem(p$1, e ? "true" : "false");
  } catch (o) {
  }
}, $ = () => {
  let e = !!window.matchMedia("(prefers-color-scheme: dark)"), o = false;
  try {
    o = localStorage.getItem(p$1) !== null;
  } catch (s) {
  }
  let t2 = false;
  return o ? t2 = localStorage.getItem(p$1) === "true" : t2 = e, t2;
};
var b = ((r2) => (r2.primary = "#209cee", r2.success = "#92cc41", r2.warning = "#f7d51d", r2.error = "#e76e55", r2.disabled = "#888", r2.black = "#000", r2.dark = "#212529", r2.white = "#fff", r2.color00 = "#59595f", r2.color01 = "#00008f", r2.color02 = "#18008f", r2.color03 = "#3f0077", r2.color04 = "#550055", r2.color05 = "#550011", r2.color06 = "#550000", r2.color07 = "#442200", r2.color08 = "#333300", r2.color09 = "#113300", r2.color0A = "#003311", r2.color0B = "#004444", r2.color0C = "#004466", r2.color0D = "#000000", r2.color0E = "#080808", r2.color0F = "#080808", r2.color10 = "#aaaaaa", r2.color11 = "#0044dd", r2.color12 = "#5511ee", r2.color13 = "#7700ee", r2.color14 = "#9900bb", r2.color15 = "#aa0055", r2.color16 = "#993300", r2.color17 = "#884400", r2.color18 = "#666600", r2.color19 = "#336600", r2.color1A = "#006600", r2.color1B = "#006655", r2.color1C = "#005588", r2.color1D = "#080808", r2.color1E = "#080808", r2.color1F = "#080808", r2.color20 = "#eeeeee", r2.color21 = "#4488ff", r2.color22 = "#7777ff", r2.color23 = "#9944ff", r2.color24 = "#bb44ee", r2.color25 = "#cc5599", r2.color26 = "#dd6644", r2.color27 = "#cc8800", r2.color28 = "#bbaa00", r2.color29 = "#77bb00", r2.color2A = "#22bb22", r2.color2B = "#22bb77", r2.color2C = "#22bbcc", r2.color2D = "#444444", r2.color2E = "#080808", r2.color2F = "#080808", r2.color30 = "#eeeeee", r2.color31 = "#99ccff", r2.color32 = "#aaaaff", r2.color33 = "#bb99ff", r2.color34 = "#dd99ff", r2.color35 = "#ee99dd", r2.color36 = "#eeaaaa", r2.color37 = "#eebb99", r2.color38 = "#eedd88", r2.color39 = "#bbdd88", r2.color3A = "#99dd99", r2.color3B = "#99ddbb", r2.color3C = "#99ddee", r2.color3D = "#aaaaaa", r2.color3E = "#080808", r2.color3F = "#080808", r2))(b || {});
Object.keys(b).sort();
var z = { marginLeft: "auto", marginRight: "auto" }, W = { marginLeft: "auto", marginRight: 0 }, ke = ({ id: e, title: o, children: t2, style: s, roundedCorners: n2, align: l2, alignTitle: c }) => react.exports.createElement("section", { id: e, className: `nes-ui-container ${o ? "nes-ui-with-title" : ""} ${n2 ? "nes-ui-is-rounded" : ""}  ${l2 ? "nes-ui-is-" + l2 : ""}`, style: s }, o && react.exports.createElement("h3", { className: "nes-ui-title", style: i(i({}, s), c === "center" ? z : c === "right" ? W : {}) }, o), t2);
var bo = ({ id: e, children: o, style: t2, className: s }) => react.exports.createElement("div", { id: e, className: `nes-ui-row ${s || ""}`, style: t2 }, o);
typeof document != "undefined" && (document.documentElement.classList.toggle("nes-ui", true), N($()));
var App$1 = "";
var phaser = { exports: {} };
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    return function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, { enumerable: true, get: getter });
        }
      };
      __webpack_require__.r = function(exports2) {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
        }
        Object.defineProperty(exports2, "__esModule", { value: true });
      };
      __webpack_require__.t = function(value, mode) {
        if (mode & 1)
          value = __webpack_require__(value);
        if (mode & 8)
          return value;
        if (mode & 4 && typeof value === "object" && value && value.__esModule)
          return value;
        var ns = /* @__PURE__ */ Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", { enumerable: true, value });
        if (mode & 2 && typeof value != "string")
          for (var key in value)
            __webpack_require__.d(ns, key, function(key2) {
              return value[key2];
            }.bind(null, key));
        return ns;
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? function getDefault() {
          return module2["default"];
        } : function getModuleExports() {
          return module2;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = 1528);
    }([
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        function hasGetterOrSetter(def) {
          return !!def.get && typeof def.get === "function" || !!def.set && typeof def.set === "function";
        }
        function getProperty(definition, k2, isClassDescriptor) {
          var def = isClassDescriptor ? definition[k2] : Object.getOwnPropertyDescriptor(definition, k2);
          if (!isClassDescriptor && def.value && typeof def.value === "object") {
            def = def.value;
          }
          if (def && hasGetterOrSetter(def)) {
            if (typeof def.enumerable === "undefined") {
              def.enumerable = true;
            }
            if (typeof def.configurable === "undefined") {
              def.configurable = true;
            }
            return def;
          } else {
            return false;
          }
        }
        function hasNonConfigurable(obj, k2) {
          var prop = Object.getOwnPropertyDescriptor(obj, k2);
          if (!prop) {
            return false;
          }
          if (prop.value && typeof prop.value === "object") {
            prop = prop.value;
          }
          if (prop.configurable === false) {
            return true;
          }
          return false;
        }
        function extend(ctor, definition, isClassDescriptor, extend2) {
          for (var k2 in definition) {
            if (!definition.hasOwnProperty(k2)) {
              continue;
            }
            var def = getProperty(definition, k2, isClassDescriptor);
            if (def !== false) {
              var parent = extend2 || ctor;
              if (hasNonConfigurable(parent.prototype, k2)) {
                if (Class.ignoreFinals) {
                  continue;
                }
                throw new Error("cannot override final property '" + k2 + "', set Class.ignoreFinals = true to skip");
              }
              Object.defineProperty(ctor.prototype, k2, def);
            } else {
              ctor.prototype[k2] = definition[k2];
            }
          }
        }
        function mixin(myClass, mixins) {
          if (!mixins) {
            return;
          }
          if (!Array.isArray(mixins)) {
            mixins = [mixins];
          }
          for (var i2 = 0; i2 < mixins.length; i2++) {
            extend(myClass, mixins[i2].prototype || mixins[i2]);
          }
        }
        function Class(definition) {
          if (!definition) {
            definition = {};
          }
          var initialize;
          var Extends;
          if (definition.initialize) {
            if (typeof definition.initialize !== "function") {
              throw new Error("initialize must be a function");
            }
            initialize = definition.initialize;
            delete definition.initialize;
          } else if (definition.Extends) {
            var base = definition.Extends;
            initialize = function() {
              base.apply(this, arguments);
            };
          } else {
            initialize = function() {
            };
          }
          if (definition.Extends) {
            initialize.prototype = Object.create(definition.Extends.prototype);
            initialize.prototype.constructor = initialize;
            Extends = definition.Extends;
            delete definition.Extends;
          } else {
            initialize.prototype.constructor = initialize;
          }
          var mixins = null;
          if (definition.Mixins) {
            mixins = definition.Mixins;
            delete definition.Mixins;
          }
          mixin(initialize, mixins);
          extend(initialize, definition, true, Extends);
          return initialize;
        }
        Class.extend = extend;
        Class.mixin = mixin;
        Class.ignoreFinals = false;
        module2.exports = Class;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var NOOP = function() {
        };
        module2.exports = NOOP;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetFastValue = function(source, key, defaultValue) {
          var t2 = typeof source;
          if (!source || t2 === "number" || t2 === "string") {
            return defaultValue;
          } else if (source.hasOwnProperty(key) && source[key] !== void 0) {
            return source[key];
          } else {
            return defaultValue;
          }
        };
        module2.exports = GetFastValue;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FuzzyEqual = __webpack_require__(124);
        var Vector2 = new Class({
          initialize: function Vector22(x2, y2) {
            this.x = 0;
            this.y = 0;
            if (typeof x2 === "object") {
              this.x = x2.x || 0;
              this.y = x2.y || 0;
            } else {
              if (y2 === void 0) {
                y2 = x2;
              }
              this.x = x2 || 0;
              this.y = y2 || 0;
            }
          },
          clone: function() {
            return new Vector2(this.x, this.y);
          },
          copy: function(src) {
            this.x = src.x || 0;
            this.y = src.y || 0;
            return this;
          },
          setFromObject: function(obj) {
            this.x = obj.x || 0;
            this.y = obj.y || 0;
            return this;
          },
          set: function(x2, y2) {
            if (y2 === void 0) {
              y2 = x2;
            }
            this.x = x2;
            this.y = y2;
            return this;
          },
          setTo: function(x2, y2) {
            return this.set(x2, y2);
          },
          setToPolar: function(azimuth, radius) {
            if (radius == null) {
              radius = 1;
            }
            this.x = Math.cos(azimuth) * radius;
            this.y = Math.sin(azimuth) * radius;
            return this;
          },
          equals: function(v2) {
            return this.x === v2.x && this.y === v2.y;
          },
          fuzzyEquals: function(v2, epsilon) {
            return FuzzyEqual(this.x, v2.x, epsilon) && FuzzyEqual(this.y, v2.y, epsilon);
          },
          angle: function() {
            var angle = Math.atan2(this.y, this.x);
            if (angle < 0) {
              angle += 2 * Math.PI;
            }
            return angle;
          },
          setAngle: function(angle) {
            return this.setToPolar(angle, this.length());
          },
          add: function(src) {
            this.x += src.x;
            this.y += src.y;
            return this;
          },
          subtract: function(src) {
            this.x -= src.x;
            this.y -= src.y;
            return this;
          },
          multiply: function(src) {
            this.x *= src.x;
            this.y *= src.y;
            return this;
          },
          scale: function(value) {
            if (isFinite(value)) {
              this.x *= value;
              this.y *= value;
            } else {
              this.x = 0;
              this.y = 0;
            }
            return this;
          },
          divide: function(src) {
            this.x /= src.x;
            this.y /= src.y;
            return this;
          },
          negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            return this;
          },
          distance: function(src) {
            var dx = src.x - this.x;
            var dy = src.y - this.y;
            return Math.sqrt(dx * dx + dy * dy);
          },
          distanceSq: function(src) {
            var dx = src.x - this.x;
            var dy = src.y - this.y;
            return dx * dx + dy * dy;
          },
          length: function() {
            var x2 = this.x;
            var y2 = this.y;
            return Math.sqrt(x2 * x2 + y2 * y2);
          },
          setLength: function(length) {
            return this.normalize().scale(length);
          },
          lengthSq: function() {
            var x2 = this.x;
            var y2 = this.y;
            return x2 * x2 + y2 * y2;
          },
          normalize: function() {
            var x2 = this.x;
            var y2 = this.y;
            var len = x2 * x2 + y2 * y2;
            if (len > 0) {
              len = 1 / Math.sqrt(len);
              this.x = x2 * len;
              this.y = y2 * len;
            }
            return this;
          },
          normalizeRightHand: function() {
            var x2 = this.x;
            this.x = this.y * -1;
            this.y = x2;
            return this;
          },
          normalizeLeftHand: function() {
            var x2 = this.x;
            this.x = this.y;
            this.y = x2 * -1;
            return this;
          },
          dot: function(src) {
            return this.x * src.x + this.y * src.y;
          },
          cross: function(src) {
            return this.x * src.y - this.y * src.x;
          },
          lerp: function(src, t2) {
            if (t2 === void 0) {
              t2 = 0;
            }
            var ax = this.x;
            var ay = this.y;
            this.x = ax + t2 * (src.x - ax);
            this.y = ay + t2 * (src.y - ay);
            return this;
          },
          transformMat3: function(mat) {
            var x2 = this.x;
            var y2 = this.y;
            var m2 = mat.val;
            this.x = m2[0] * x2 + m2[3] * y2 + m2[6];
            this.y = m2[1] * x2 + m2[4] * y2 + m2[7];
            return this;
          },
          transformMat4: function(mat) {
            var x2 = this.x;
            var y2 = this.y;
            var m2 = mat.val;
            this.x = m2[0] * x2 + m2[4] * y2 + m2[12];
            this.y = m2[1] * x2 + m2[5] * y2 + m2[13];
            return this;
          },
          reset: function() {
            this.x = 0;
            this.y = 0;
            return this;
          },
          limit: function(max) {
            var len = this.length();
            if (len && len > max) {
              this.scale(max / len);
            }
            return this;
          },
          reflect: function(normal) {
            normal = normal.clone().normalize();
            return this.subtract(normal.scale(2 * this.dot(normal)));
          },
          mirror: function(axis) {
            return this.reflect(axis).negate();
          },
          rotate: function(delta) {
            var cos = Math.cos(delta);
            var sin = Math.sin(delta);
            return this.set(cos * this.x - sin * this.y, sin * this.x + cos * this.y);
          }
        });
        Vector2.ZERO = new Vector2();
        Vector2.RIGHT = new Vector2(1, 0);
        Vector2.LEFT = new Vector2(-1, 0);
        Vector2.UP = new Vector2(0, -1);
        Vector2.DOWN = new Vector2(0, 1);
        Vector2.ONE = new Vector2(1, 1);
        module2.exports = Vector2;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GEOM_CONST = __webpack_require__(56);
        var Point = new Class({
          initialize: function Point2(x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = x2;
            }
            this.type = GEOM_CONST.POINT;
            this.x = x2;
            this.y = y2;
          },
          setTo: function(x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = x2;
            }
            this.x = x2;
            this.y = y2;
            return this;
          }
        });
        module2.exports = Point;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var PluginCache = __webpack_require__(24);
        var SceneEvents = __webpack_require__(20);
        var GameObjectFactory = new Class({
          initialize: function GameObjectFactory2(scene) {
            this.scene = scene;
            this.systems = scene.sys;
            this.events = scene.sys.events;
            this.displayList;
            this.updateList;
            this.events.once(SceneEvents.BOOT, this.boot, this);
            this.events.on(SceneEvents.START, this.start, this);
          },
          boot: function() {
            this.displayList = this.systems.displayList;
            this.updateList = this.systems.updateList;
            this.events.once(SceneEvents.DESTROY, this.destroy, this);
          },
          start: function() {
            this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          existing: function(child) {
            if (child.renderCanvas || child.renderWebGL) {
              this.displayList.add(child);
            }
            if (child.preUpdate) {
              this.updateList.add(child);
            }
            return child;
          },
          shutdown: function() {
            this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          destroy: function() {
            this.shutdown();
            this.events.off(SceneEvents.START, this.start, this);
            this.scene = null;
            this.systems = null;
            this.events = null;
            this.displayList = null;
            this.updateList = null;
          }
        });
        GameObjectFactory.register = function(factoryType, factoryFunction) {
          if (!GameObjectFactory.prototype.hasOwnProperty(factoryType)) {
            GameObjectFactory.prototype[factoryType] = factoryFunction;
          }
        };
        GameObjectFactory.remove = function(factoryType) {
          if (GameObjectFactory.prototype.hasOwnProperty(factoryType)) {
            delete GameObjectFactory.prototype[factoryType];
          }
        };
        PluginCache.register("GameObjectFactory", GameObjectFactory, "add");
        module2.exports = GameObjectFactory;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetValue = function(source, key, defaultValue) {
          if (!source || typeof source === "number") {
            return defaultValue;
          } else if (source.hasOwnProperty(key)) {
            return source[key];
          } else if (key.indexOf(".") !== -1) {
            var keys = key.split(".");
            var parent = source;
            var value = defaultValue;
            for (var i2 = 0; i2 < keys.length; i2++) {
              if (parent.hasOwnProperty(keys[i2])) {
                value = parent[keys[i2]];
                parent = parent[keys[i2]];
              } else {
                value = defaultValue;
                break;
              }
            }
            return value;
          } else {
            return defaultValue;
          }
        };
        module2.exports = GetValue;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var IsPlainObject2 = function(obj) {
          if (typeof obj !== "object" || obj.nodeType || obj === obj.window) {
            return false;
          }
          try {
            if (obj.constructor && !{}.hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf")) {
              return false;
            }
          } catch (e) {
            return false;
          }
          return true;
        };
        module2.exports = IsPlainObject2;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var types = {};
        var FileTypesManager = {
          install: function(loader) {
            for (var key in types) {
              loader[key] = types[key];
            }
          },
          register: function(key, factoryFunction) {
            types[key] = factoryFunction;
          },
          destroy: function() {
            types = {};
          }
        };
        module2.exports = FileTypesManager;
      },
      function(module2, exports2, __webpack_require__) {
        var has = Object.prototype.hasOwnProperty, prefix = "~";
        function Events() {
        }
        if (Object.create) {
          Events.prototype = /* @__PURE__ */ Object.create(null);
          if (!new Events().__proto__)
            prefix = false;
        }
        function EE(fn, context, once) {
          this.fn = fn;
          this.context = context;
          this.once = once || false;
        }
        function addListener(emitter, event, fn, context, once) {
          if (typeof fn !== "function") {
            throw new TypeError("The listener must be a function");
          }
          var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
          if (!emitter._events[evt])
            emitter._events[evt] = listener, emitter._eventsCount++;
          else if (!emitter._events[evt].fn)
            emitter._events[evt].push(listener);
          else
            emitter._events[evt] = [emitter._events[evt], listener];
          return emitter;
        }
        function clearEvent(emitter, evt) {
          if (--emitter._eventsCount === 0)
            emitter._events = new Events();
          else
            delete emitter._events[evt];
        }
        function EventEmitter() {
          this._events = new Events();
          this._eventsCount = 0;
        }
        EventEmitter.prototype.eventNames = function eventNames() {
          var names = [], events, name;
          if (this._eventsCount === 0)
            return names;
          for (name in events = this._events) {
            if (has.call(events, name))
              names.push(prefix ? name.slice(1) : name);
          }
          if (Object.getOwnPropertySymbols) {
            return names.concat(Object.getOwnPropertySymbols(events));
          }
          return names;
        };
        EventEmitter.prototype.listeners = function listeners(event) {
          var evt = prefix ? prefix + event : event, handlers = this._events[evt];
          if (!handlers)
            return [];
          if (handlers.fn)
            return [handlers.fn];
          for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
            ee2[i2] = handlers[i2].fn;
          }
          return ee2;
        };
        EventEmitter.prototype.listenerCount = function listenerCount(event) {
          var evt = prefix ? prefix + event : event, listeners = this._events[evt];
          if (!listeners)
            return 0;
          if (listeners.fn)
            return 1;
          return listeners.length;
        };
        EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt])
            return false;
          var listeners = this._events[evt], len = arguments.length, args, i2;
          if (listeners.fn) {
            if (listeners.once)
              this.removeListener(event, listeners.fn, void 0, true);
            switch (len) {
              case 1:
                return listeners.fn.call(listeners.context), true;
              case 2:
                return listeners.fn.call(listeners.context, a1), true;
              case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;
              case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;
              case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
              case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
            }
            for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
              args[i2 - 1] = arguments[i2];
            }
            listeners.fn.apply(listeners.context, args);
          } else {
            var length = listeners.length, j;
            for (i2 = 0; i2 < length; i2++) {
              if (listeners[i2].once)
                this.removeListener(event, listeners[i2].fn, void 0, true);
              switch (len) {
                case 1:
                  listeners[i2].fn.call(listeners[i2].context);
                  break;
                case 2:
                  listeners[i2].fn.call(listeners[i2].context, a1);
                  break;
                case 3:
                  listeners[i2].fn.call(listeners[i2].context, a1, a2);
                  break;
                case 4:
                  listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                  break;
                default:
                  if (!args)
                    for (j = 1, args = new Array(len - 1); j < len; j++) {
                      args[j - 1] = arguments[j];
                    }
                  listeners[i2].fn.apply(listeners[i2].context, args);
              }
            }
          }
          return true;
        };
        EventEmitter.prototype.on = function on(event, fn, context) {
          return addListener(this, event, fn, context, false);
        };
        EventEmitter.prototype.once = function once(event, fn, context) {
          return addListener(this, event, fn, context, true);
        };
        EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt])
            return this;
          if (!fn) {
            clearEvent(this, evt);
            return this;
          }
          var listeners = this._events[evt];
          if (listeners.fn) {
            if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
              clearEvent(this, evt);
            }
          } else {
            for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
              if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
                events.push(listeners[i2]);
              }
            }
            if (events.length)
              this._events[evt] = events.length === 1 ? events[0] : events;
            else
              clearEvent(this, evt);
          }
          return this;
        };
        EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
          var evt;
          if (event) {
            evt = prefix ? prefix + event : event;
            if (this._events[evt])
              clearEvent(this, evt);
          } else {
            this._events = new Events();
            this._eventsCount = 0;
          }
          return this;
        };
        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
        EventEmitter.prototype.addListener = EventEmitter.prototype.on;
        EventEmitter.prefixed = prefix;
        EventEmitter.EventEmitter = EventEmitter;
        {
          module2.exports = EventEmitter;
        }
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Contains = __webpack_require__(57);
        var GetPoint = __webpack_require__(171);
        var GetPoints = __webpack_require__(306);
        var GEOM_CONST = __webpack_require__(56);
        var Line = __webpack_require__(47);
        var Random = __webpack_require__(174);
        var Rectangle = new Class({
          initialize: function Rectangle2(x2, y2, width, height) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = 0;
            }
            if (height === void 0) {
              height = 0;
            }
            this.type = GEOM_CONST.RECTANGLE;
            this.x = x2;
            this.y = y2;
            this.width = width;
            this.height = height;
          },
          contains: function(x2, y2) {
            return Contains(this, x2, y2);
          },
          getPoint: function(position, output) {
            return GetPoint(this, position, output);
          },
          getPoints: function(quantity, stepRate, output) {
            return GetPoints(this, quantity, stepRate, output);
          },
          getRandomPoint: function(point) {
            return Random(this, point);
          },
          setTo: function(x2, y2, width, height) {
            this.x = x2;
            this.y = y2;
            this.width = width;
            this.height = height;
            return this;
          },
          setEmpty: function() {
            return this.setTo(0, 0, 0, 0);
          },
          setPosition: function(x2, y2) {
            if (y2 === void 0) {
              y2 = x2;
            }
            this.x = x2;
            this.y = y2;
            return this;
          },
          setSize: function(width, height) {
            if (height === void 0) {
              height = width;
            }
            this.width = width;
            this.height = height;
            return this;
          },
          isEmpty: function() {
            return this.width <= 0 || this.height <= 0;
          },
          getLineA: function(line) {
            if (line === void 0) {
              line = new Line();
            }
            line.setTo(this.x, this.y, this.right, this.y);
            return line;
          },
          getLineB: function(line) {
            if (line === void 0) {
              line = new Line();
            }
            line.setTo(this.right, this.y, this.right, this.bottom);
            return line;
          },
          getLineC: function(line) {
            if (line === void 0) {
              line = new Line();
            }
            line.setTo(this.right, this.bottom, this.x, this.bottom);
            return line;
          },
          getLineD: function(line) {
            if (line === void 0) {
              line = new Line();
            }
            line.setTo(this.x, this.bottom, this.x, this.y);
            return line;
          },
          left: {
            get: function() {
              return this.x;
            },
            set: function(value) {
              if (value >= this.right) {
                this.width = 0;
              } else {
                this.width = this.right - value;
              }
              this.x = value;
            }
          },
          right: {
            get: function() {
              return this.x + this.width;
            },
            set: function(value) {
              if (value <= this.x) {
                this.width = 0;
              } else {
                this.width = value - this.x;
              }
            }
          },
          top: {
            get: function() {
              return this.y;
            },
            set: function(value) {
              if (value >= this.bottom) {
                this.height = 0;
              } else {
                this.height = this.bottom - value;
              }
              this.y = value;
            }
          },
          bottom: {
            get: function() {
              return this.y + this.height;
            },
            set: function(value) {
              if (value <= this.y) {
                this.height = 0;
              } else {
                this.height = value - this.y;
              }
            }
          },
          centerX: {
            get: function() {
              return this.x + this.width / 2;
            },
            set: function(value) {
              this.x = value - this.width / 2;
            }
          },
          centerY: {
            get: function() {
              return this.y + this.height / 2;
            },
            set: function(value) {
              this.y = value - this.height / 2;
            }
          }
        });
        module2.exports = Rectangle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Alpha: __webpack_require__(607),
          AlphaSingle: __webpack_require__(303),
          BlendMode: __webpack_require__(304),
          ComputedSize: __webpack_require__(608),
          Crop: __webpack_require__(609),
          Depth: __webpack_require__(305),
          Flip: __webpack_require__(610),
          GetBounds: __webpack_require__(611),
          Mask: __webpack_require__(309),
          Origin: __webpack_require__(632),
          PathFollower: __webpack_require__(633),
          Pipeline: __webpack_require__(167),
          ScrollFactor: __webpack_require__(312),
          Size: __webpack_require__(634),
          Texture: __webpack_require__(635),
          TextureCrop: __webpack_require__(636),
          Tint: __webpack_require__(637),
          ToJSON: __webpack_require__(176),
          Transform: __webpack_require__(313),
          TransformMatrix: __webpack_require__(25),
          Visible: __webpack_require__(314)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Felipe Alfonso <@bitnenfer>
         * @author       Matthew Groves <@doormat>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        function GenerateSrc(maxIfs) {
          var src = "";
          for (var i2 = 0; i2 < maxIfs; ++i2) {
            if (i2 > 0) {
              src += "\nelse ";
            }
            if (i2 < maxIfs - 1) {
              src += "if(test == " + i2 + ".0){}";
            }
          }
          return src;
        }
        module2.exports = {
          getTintFromFloats: function(r2, g2, b2, a) {
            var ur = (r2 * 255 | 0) & 255;
            var ug2 = (g2 * 255 | 0) & 255;
            var ub2 = (b2 * 255 | 0) & 255;
            var ua2 = (a * 255 | 0) & 255;
            return (ua2 << 24 | ur << 16 | ug2 << 8 | ub2) >>> 0;
          },
          getTintAppendFloatAlpha: function(rgb, a) {
            var ua2 = (a * 255 | 0) & 255;
            return (ua2 << 24 | rgb) >>> 0;
          },
          getTintAppendFloatAlphaAndSwap: function(rgb, a) {
            var ur = (rgb >> 16 | 0) & 255;
            var ug2 = (rgb >> 8 | 0) & 255;
            var ub2 = (rgb | 0) & 255;
            var ua2 = (a * 255 | 0) & 255;
            return (ua2 << 24 | ub2 << 16 | ug2 << 8 | ur) >>> 0;
          },
          getFloatsFromUintRGB: function(rgb) {
            var ur = (rgb >> 16 | 0) & 255;
            var ug2 = (rgb >> 8 | 0) & 255;
            var ub2 = (rgb | 0) & 255;
            return [ur / 255, ug2 / 255, ub2 / 255];
          },
          checkShaderMax: function(gl2, maxTextures) {
            if (!maxTextures || maxTextures === -1) {
              maxTextures = gl2.getParameter(gl2.MAX_TEXTURE_IMAGE_UNITS);
            }
            var shader = gl2.createShader(gl2.FRAGMENT_SHADER);
            var fragTemplate = [
              "precision mediump float;",
              "void main(void){",
              "float test = 0.1;",
              "%forloop%",
              "gl_FragColor = vec4(0.0);",
              "}"
            ].join("\n");
            while (true) {
              var fragmentSrc = fragTemplate.replace(/%forloop%/gi, GenerateSrc(maxTextures));
              gl2.shaderSource(shader, fragmentSrc);
              gl2.compileShader(shader);
              if (!gl2.getShaderParameter(shader, gl2.COMPILE_STATUS)) {
                maxTextures = maxTextures / 2 | 0;
              } else {
                break;
              }
            }
            return maxTextures;
          },
          parseFragmentShaderMaxTextures: function(fragmentShaderSource, maxTextures) {
            if (!fragmentShaderSource) {
              return "";
            }
            var src = "";
            for (var i2 = 0; i2 < maxTextures; i2++) {
              if (i2 > 0) {
                src += "\n	else ";
              }
              if (i2 < maxTextures - 1) {
                src += "if (outTexId < " + i2 + ".5)";
              }
              src += "\n	{";
              src += "\n		texture = texture2D(uMainSampler[" + i2 + "], outTexCoord);";
              src += "\n	}";
            }
            fragmentShaderSource = fragmentShaderSource.replace(/%count%/gi, maxTextures.toString());
            return fragmentShaderSource.replace(/%forloop%/gi, src);
          }
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MATH = __webpack_require__(193);
        var GetValue = __webpack_require__(6);
        var GetAdvancedValue = function(source, key, defaultValue) {
          var value = GetValue(source, key, null);
          if (value === null) {
            return defaultValue;
          } else if (Array.isArray(value)) {
            return MATH.RND.pick(value);
          } else if (typeof value === "object") {
            if (value.hasOwnProperty("randInt")) {
              return MATH.RND.integerInRange(value.randInt[0], value.randInt[1]);
            } else if (value.hasOwnProperty("randFloat")) {
              return MATH.RND.realInRange(value.randFloat[0], value.randFloat[1]);
            }
          } else if (typeof value === "function") {
            return value(key);
          }
          return value;
        };
        module2.exports = GetAdvancedValue;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MATH_CONST = {
          PI2: Math.PI * 2,
          TAU: Math.PI * 0.5,
          EPSILON: 1e-6,
          DEG_TO_RAD: Math.PI / 180,
          RAD_TO_DEG: 180 / Math.PI,
          RND: null,
          MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,
          MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991
        };
        module2.exports = MATH_CONST;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var ComponentsToJSON = __webpack_require__(176);
        var DataManager = __webpack_require__(101);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(75);
        var SceneEvents = __webpack_require__(20);
        var GameObject = new Class({
          Extends: EventEmitter,
          initialize: function GameObject2(scene, type) {
            EventEmitter.call(this);
            this.scene = scene;
            this.displayList = null;
            this.type = type;
            this.state = 0;
            this.parentContainer = null;
            this.name = "";
            this.active = true;
            this.tabIndex = -1;
            this.data = null;
            this.renderFlags = 15;
            this.cameraFilter = 0;
            this.input = null;
            this.body = null;
            this.ignoreDestroy = false;
            this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);
            this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);
            scene.sys.queueDepthSort();
          },
          setActive: function(value) {
            this.active = value;
            return this;
          },
          setName: function(value) {
            this.name = value;
            return this;
          },
          setState: function(value) {
            this.state = value;
            return this;
          },
          setDataEnabled: function() {
            if (!this.data) {
              this.data = new DataManager(this);
            }
            return this;
          },
          setData: function(key, value) {
            if (!this.data) {
              this.data = new DataManager(this);
            }
            this.data.set(key, value);
            return this;
          },
          incData: function(key, value) {
            if (!this.data) {
              this.data = new DataManager(this);
            }
            this.data.inc(key, value);
            return this;
          },
          toggleData: function(key) {
            if (!this.data) {
              this.data = new DataManager(this);
            }
            this.data.toggle(key);
            return this;
          },
          getData: function(key) {
            if (!this.data) {
              this.data = new DataManager(this);
            }
            return this.data.get(key);
          },
          setInteractive: function(hitArea, hitAreaCallback, dropZone) {
            this.scene.sys.input.enable(this, hitArea, hitAreaCallback, dropZone);
            return this;
          },
          disableInteractive: function() {
            if (this.input) {
              this.input.enabled = false;
            }
            return this;
          },
          removeInteractive: function() {
            this.scene.sys.input.clear(this);
            this.input = void 0;
            return this;
          },
          addedToScene: function() {
          },
          removedFromScene: function() {
          },
          update: function() {
          },
          toJSON: function() {
            return ComponentsToJSON(this);
          },
          willRender: function(camera) {
            return !(GameObject.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
          },
          getIndexList: function() {
            var child = this;
            var parent = this.parentContainer;
            var indexes = [];
            while (parent) {
              indexes.unshift(parent.getIndex(child));
              child = parent;
              if (!parent.parentContainer) {
                break;
              } else {
                parent = parent.parentContainer;
              }
            }
            if (this.displayList) {
              indexes.unshift(this.displayList.getIndex(child));
            } else {
              indexes.unshift(this.scene.sys.displayList.getIndex(child));
            }
            return indexes;
          },
          addToDisplayList: function(displayList) {
            if (displayList === void 0) {
              displayList = this.scene.sys.displayList;
            }
            if (this.displayList && this.displayList !== displayList) {
              this.removeFromDisplayList();
            }
            if (!displayList.exists(this)) {
              this.displayList = displayList;
              displayList.add(this, true);
              displayList.queueDepthSort();
              this.emit(Events.ADDED_TO_SCENE, this, this.scene);
              displayList.events.emit(SceneEvents.ADDED_TO_SCENE, this, this.scene);
            }
            return this;
          },
          addToUpdateList: function() {
            if (this.scene && this.preUpdate) {
              this.scene.sys.updateList.add(this);
            }
            return this;
          },
          removeFromDisplayList: function() {
            var displayList = this.displayList || this.scene.sys.displayList;
            if (displayList.exists(this)) {
              displayList.remove(this, true);
              displayList.queueDepthSort();
              this.displayList = null;
              this.emit(Events.REMOVED_FROM_SCENE, this, this.scene);
              displayList.events.emit(SceneEvents.REMOVED_FROM_SCENE, this, this.scene);
            }
            return this;
          },
          removeFromUpdateList: function() {
            if (this.scene && this.preUpdate) {
              this.scene.sys.updateList.remove(this);
            }
            return this;
          },
          destroy: function(fromScene) {
            if (!this.scene || this.ignoreDestroy) {
              return;
            }
            if (fromScene === void 0) {
              fromScene = false;
            }
            if (this.preDestroy) {
              this.preDestroy.call(this);
            }
            this.emit(Events.DESTROY, this, fromScene);
            this.removeAllListeners();
            if (this.postPipelines) {
              this.resetPostPipeline(true);
            }
            this.removeFromDisplayList();
            this.removeFromUpdateList();
            if (this.input) {
              this.scene.sys.input.clear(this);
              this.input = void 0;
            }
            if (this.data) {
              this.data.destroy();
              this.data = void 0;
            }
            if (this.body) {
              this.body.destroy();
              this.body = void 0;
            }
            this.active = false;
            this.visible = false;
            this.scene = void 0;
            this.parentContainer = void 0;
          }
        });
        GameObject.RENDER_MASK = 15;
        module2.exports = GameObject;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var PluginCache = __webpack_require__(24);
        var SceneEvents = __webpack_require__(20);
        var GameObjectCreator = new Class({
          initialize: function GameObjectCreator2(scene) {
            this.scene = scene;
            this.systems = scene.sys;
            this.events = scene.sys.events;
            this.displayList;
            this.updateList;
            this.events.once(SceneEvents.BOOT, this.boot, this);
            this.events.on(SceneEvents.START, this.start, this);
          },
          boot: function() {
            this.displayList = this.systems.displayList;
            this.updateList = this.systems.updateList;
            this.events.once(SceneEvents.DESTROY, this.destroy, this);
          },
          start: function() {
            this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          shutdown: function() {
            this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          destroy: function() {
            this.shutdown();
            this.events.off(SceneEvents.START, this.start, this);
            this.scene = null;
            this.systems = null;
            this.events = null;
            this.displayList = null;
            this.updateList = null;
          }
        });
        GameObjectCreator.register = function(factoryType, factoryFunction) {
          if (!GameObjectCreator.prototype.hasOwnProperty(factoryType)) {
            GameObjectCreator.prototype[factoryType] = factoryFunction;
          }
        };
        GameObjectCreator.remove = function(factoryType) {
          if (GameObjectCreator.prototype.hasOwnProperty(factoryType)) {
            delete GameObjectCreator.prototype[factoryType];
          }
        };
        PluginCache.register("GameObjectCreator", GameObjectCreator, "make");
        module2.exports = GameObjectCreator;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var IsPlainObject2 = __webpack_require__(7);
        var Extend = function() {
          var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i2 = 1, length = arguments.length, deep = false;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[1] || {};
            i2 = 2;
          }
          if (length === i2) {
            target = this;
            --i2;
          }
          for (; i2 < length; i2++) {
            if ((options = arguments[i2]) != null) {
              for (name in options) {
                src = target[name];
                copy = options[name];
                if (target === copy) {
                  continue;
                }
                if (deep && copy && (IsPlainObject2(copy) || (copyIsArray = Array.isArray(copy)))) {
                  if (copyIsArray) {
                    copyIsArray = false;
                    clone = src && Array.isArray(src) ? src : [];
                  } else {
                    clone = src && IsPlainObject2(src) ? src : {};
                  }
                  target[name] = Extend(deep, clone, copy);
                } else if (copy !== void 0) {
                  target[name] = copy;
                }
              }
            }
          }
          return target;
        };
        module2.exports = Extend;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clamp = function(value, min, max) {
          return Math.max(min, Math.min(max, value));
        };
        module2.exports = Clamp;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TransformMatrix = __webpack_require__(25);
        var tempMatrix1 = new TransformMatrix();
        var tempMatrix2 = new TransformMatrix();
        var tempMatrix3 = new TransformMatrix();
        var result = { camera: tempMatrix1, sprite: tempMatrix2, calc: tempMatrix3 };
        var GetCalcMatrix = function(src, camera, parentMatrix) {
          var camMatrix = tempMatrix1;
          var spriteMatrix = tempMatrix2;
          var calcMatrix = tempMatrix3;
          spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);
          camMatrix.copyFrom(camera.matrix);
          if (parentMatrix) {
            camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
            spriteMatrix.e = src.x;
            spriteMatrix.f = src.y;
          } else {
            spriteMatrix.e -= camera.scrollX * src.scrollFactorX;
            spriteMatrix.f -= camera.scrollY * src.scrollFactorY;
          }
          camMatrix.multiply(spriteMatrix, calcMatrix);
          return result;
        };
        module2.exports = GetCalcMatrix;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          ADDED_TO_SCENE: __webpack_require__(656),
          BOOT: __webpack_require__(657),
          CREATE: __webpack_require__(658),
          DESTROY: __webpack_require__(659),
          PAUSE: __webpack_require__(660),
          POST_UPDATE: __webpack_require__(661),
          PRE_RENDER: __webpack_require__(662),
          PRE_UPDATE: __webpack_require__(663),
          READY: __webpack_require__(664),
          REMOVED_FROM_SCENE: __webpack_require__(665),
          RENDER: __webpack_require__(666),
          RESUME: __webpack_require__(667),
          SHUTDOWN: __webpack_require__(668),
          SLEEP: __webpack_require__(669),
          START: __webpack_require__(670),
          TRANSITION_COMPLETE: __webpack_require__(671),
          TRANSITION_INIT: __webpack_require__(672),
          TRANSITION_OUT: __webpack_require__(673),
          TRANSITION_START: __webpack_require__(674),
          TRANSITION_WAKE: __webpack_require__(675),
          UPDATE: __webpack_require__(676),
          WAKE: __webpack_require__(677)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FILE_CONST = {
          LOADER_IDLE: 0,
          LOADER_LOADING: 1,
          LOADER_PROCESSING: 2,
          LOADER_COMPLETE: 3,
          LOADER_SHUTDOWN: 4,
          LOADER_DESTROYED: 5,
          FILE_PENDING: 10,
          FILE_LOADING: 11,
          FILE_LOADED: 12,
          FILE_FAILED: 13,
          FILE_PROCESSING: 14,
          FILE_ERRORED: 16,
          FILE_COMPLETE: 17,
          FILE_DESTROYED: 18,
          FILE_POPULATED: 19
        };
        module2.exports = FILE_CONST;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          BLUR: __webpack_require__(612),
          BOOT: __webpack_require__(613),
          CONTEXT_LOST: __webpack_require__(614),
          CONTEXT_RESTORED: __webpack_require__(615),
          DESTROY: __webpack_require__(616),
          FOCUS: __webpack_require__(617),
          HIDDEN: __webpack_require__(618),
          PAUSE: __webpack_require__(619),
          POST_RENDER: __webpack_require__(620),
          POST_STEP: __webpack_require__(621),
          PRE_RENDER: __webpack_require__(622),
          PRE_STEP: __webpack_require__(623),
          READY: __webpack_require__(624),
          RESUME: __webpack_require__(625),
          STEP: __webpack_require__(626),
          VISIBLE: __webpack_require__(627)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var Events = __webpack_require__(95);
        var GetFastValue = __webpack_require__(2);
        var GetURL = __webpack_require__(155);
        var MergeXHRSettings = __webpack_require__(240);
        var XHRLoader = __webpack_require__(517);
        var XHRSettings = __webpack_require__(156);
        var File = new Class({
          initialize: function File2(loader, fileConfig) {
            this.loader = loader;
            this.cache = GetFastValue(fileConfig, "cache", false);
            this.type = GetFastValue(fileConfig, "type", false);
            this.key = GetFastValue(fileConfig, "key", false);
            var loadKey = this.key;
            if (loader.prefix && loader.prefix !== "") {
              this.key = loader.prefix + loadKey;
            }
            if (!this.type || !this.key) {
              throw new Error("Invalid Loader." + this.type + " key");
            }
            var url = GetFastValue(fileConfig, "url");
            if (url === void 0) {
              url = loader.path + loadKey + "." + GetFastValue(fileConfig, "extension", "");
            } else if (typeof url === "string" && !url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/)) {
              url = loader.path + url;
            }
            this.url = url;
            this.src = "";
            this.xhrSettings = XHRSettings(GetFastValue(fileConfig, "responseType", void 0));
            if (GetFastValue(fileConfig, "xhrSettings", false)) {
              this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, "xhrSettings", {}));
            }
            this.xhrLoader = null;
            this.state = typeof this.url === "function" ? CONST.FILE_POPULATED : CONST.FILE_PENDING;
            this.bytesTotal = 0;
            this.bytesLoaded = -1;
            this.percentComplete = -1;
            this.crossOrigin = void 0;
            this.data = void 0;
            this.config = GetFastValue(fileConfig, "config", {});
            this.multiFile;
            this.linkFile;
          },
          setLink: function(fileB) {
            this.linkFile = fileB;
            fileB.linkFile = this;
          },
          resetXHR: function() {
            if (this.xhrLoader) {
              this.xhrLoader.onload = void 0;
              this.xhrLoader.onerror = void 0;
              this.xhrLoader.onprogress = void 0;
            }
          },
          load: function() {
            if (this.state === CONST.FILE_POPULATED) {
              this.loader.nextFile(this, true);
            } else {
              this.state = CONST.FILE_LOADING;
              this.src = GetURL(this, this.loader.baseURL);
              if (this.src.indexOf("data:") === 0) {
                console.warn("Local data URIs are not supported: " + this.key);
              } else {
                this.xhrLoader = XHRLoader(this, this.loader.xhr);
              }
            }
          },
          onLoad: function(xhr, event) {
            var isLocalFile = xhr.responseURL && (xhr.responseURL.indexOf("file://") === 0 || xhr.responseURL.indexOf("capacitor://") === 0);
            var localFileOk = isLocalFile && event.target.status === 0;
            var success = !(event.target && event.target.status !== 200) || localFileOk;
            if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599) {
              success = false;
            }
            this.state = CONST.FILE_LOADED;
            this.resetXHR();
            this.loader.nextFile(this, success);
          },
          onError: function() {
            this.resetXHR();
            this.loader.nextFile(this, false);
          },
          onProgress: function(event) {
            if (event.lengthComputable) {
              this.bytesLoaded = event.loaded;
              this.bytesTotal = event.total;
              this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1);
              this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);
            }
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            this.onProcessComplete();
          },
          onProcessComplete: function() {
            this.state = CONST.FILE_COMPLETE;
            if (this.multiFile) {
              this.multiFile.onFileComplete(this);
            }
            this.loader.fileProcessComplete(this);
          },
          onProcessError: function() {
            this.state = CONST.FILE_ERRORED;
            if (this.multiFile) {
              this.multiFile.onFileFailed(this);
            }
            this.loader.fileProcessComplete(this);
          },
          hasCacheConflict: function() {
            return this.cache && this.cache.exists(this.key);
          },
          addToCache: function() {
            if (this.cache) {
              this.cache.add(this.key, this.data);
            }
            this.pendingDestroy();
          },
          pendingDestroy: function(data) {
            if (data === void 0) {
              data = this.data;
            }
            var key = this.key;
            var type = this.type;
            this.loader.emit(Events.FILE_COMPLETE, key, type, data);
            this.loader.emit(Events.FILE_KEY_COMPLETE + type + "-" + key, key, type, data);
            this.loader.flagForRemoval(this);
          },
          destroy: function() {
            this.loader = null;
            this.cache = null;
            this.xhrSettings = null;
            this.multiFile = null;
            this.linkFile = null;
            this.data = null;
          }
        });
        File.createObjectURL = function(image, blob, defaultType) {
          if (typeof URL === "function") {
            image.src = URL.createObjectURL(blob);
          } else {
            var reader = new FileReader();
            reader.onload = function() {
              image.removeAttribute("crossOrigin");
              image.src = "data:" + (blob.type || defaultType) + ";base64," + reader.result.split(",")[1];
            };
            reader.onerror = image.onerror;
            reader.readAsDataURL(blob);
          }
        };
        File.revokeObjectURL = function(image) {
          if (typeof URL === "function") {
            URL.revokeObjectURL(image.src);
          }
        };
        module2.exports = File;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var corePlugins = {};
        var customPlugins = {};
        var PluginCache = {};
        PluginCache.register = function(key, plugin, mapping, custom) {
          if (custom === void 0) {
            custom = false;
          }
          corePlugins[key] = { plugin, mapping, custom };
        };
        PluginCache.registerCustom = function(key, plugin, mapping, data) {
          customPlugins[key] = { plugin, mapping, data };
        };
        PluginCache.hasCore = function(key) {
          return corePlugins.hasOwnProperty(key);
        };
        PluginCache.hasCustom = function(key) {
          return customPlugins.hasOwnProperty(key);
        };
        PluginCache.getCore = function(key) {
          return corePlugins[key];
        };
        PluginCache.getCustom = function(key) {
          return customPlugins[key];
        };
        PluginCache.getCustomClass = function(key) {
          return customPlugins.hasOwnProperty(key) ? customPlugins[key].plugin : null;
        };
        PluginCache.remove = function(key) {
          if (corePlugins.hasOwnProperty(key)) {
            delete corePlugins[key];
          }
        };
        PluginCache.removeCustom = function(key) {
          if (customPlugins.hasOwnProperty(key)) {
            delete customPlugins[key];
          }
        };
        PluginCache.destroyCorePlugins = function() {
          for (var key in corePlugins) {
            if (corePlugins.hasOwnProperty(key)) {
              delete corePlugins[key];
            }
          }
        };
        PluginCache.destroyCustomPlugins = function() {
          for (var key in customPlugins) {
            if (customPlugins.hasOwnProperty(key)) {
              delete customPlugins[key];
            }
          }
        };
        module2.exports = PluginCache;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var MATH_CONST = __webpack_require__(14);
        var Vector2 = __webpack_require__(3);
        var TransformMatrix = new Class({
          initialize: function TransformMatrix2(a, b2, c, d, tx, ty) {
            if (a === void 0) {
              a = 1;
            }
            if (b2 === void 0) {
              b2 = 0;
            }
            if (c === void 0) {
              c = 0;
            }
            if (d === void 0) {
              d = 1;
            }
            if (tx === void 0) {
              tx = 0;
            }
            if (ty === void 0) {
              ty = 0;
            }
            this.matrix = new Float32Array([a, b2, c, d, tx, ty, 0, 0, 1]);
            this.decomposedMatrix = {
              translateX: 0,
              translateY: 0,
              scaleX: 1,
              scaleY: 1,
              rotation: 0
            };
          },
          a: {
            get: function() {
              return this.matrix[0];
            },
            set: function(value) {
              this.matrix[0] = value;
            }
          },
          b: {
            get: function() {
              return this.matrix[1];
            },
            set: function(value) {
              this.matrix[1] = value;
            }
          },
          c: {
            get: function() {
              return this.matrix[2];
            },
            set: function(value) {
              this.matrix[2] = value;
            }
          },
          d: {
            get: function() {
              return this.matrix[3];
            },
            set: function(value) {
              this.matrix[3] = value;
            }
          },
          e: {
            get: function() {
              return this.matrix[4];
            },
            set: function(value) {
              this.matrix[4] = value;
            }
          },
          f: {
            get: function() {
              return this.matrix[5];
            },
            set: function(value) {
              this.matrix[5] = value;
            }
          },
          tx: {
            get: function() {
              return this.matrix[4];
            },
            set: function(value) {
              this.matrix[4] = value;
            }
          },
          ty: {
            get: function() {
              return this.matrix[5];
            },
            set: function(value) {
              this.matrix[5] = value;
            }
          },
          rotation: {
            get: function() {
              return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1);
            }
          },
          rotationNormalized: {
            get: function() {
              var matrix = this.matrix;
              var a = matrix[0];
              var b2 = matrix[1];
              var c = matrix[2];
              var d = matrix[3];
              if (a || b2) {
                return b2 > 0 ? Math.acos(a / this.scaleX) : -Math.acos(a / this.scaleX);
              } else if (c || d) {
                return MATH_CONST.TAU - (d > 0 ? Math.acos(-c / this.scaleY) : -Math.acos(c / this.scaleY));
              } else {
                return 0;
              }
            }
          },
          scaleX: {
            get: function() {
              return Math.sqrt(this.a * this.a + this.b * this.b);
            }
          },
          scaleY: {
            get: function() {
              return Math.sqrt(this.c * this.c + this.d * this.d);
            }
          },
          loadIdentity: function() {
            var matrix = this.matrix;
            matrix[0] = 1;
            matrix[1] = 0;
            matrix[2] = 0;
            matrix[3] = 1;
            matrix[4] = 0;
            matrix[5] = 0;
            return this;
          },
          translate: function(x2, y2) {
            var matrix = this.matrix;
            matrix[4] = matrix[0] * x2 + matrix[2] * y2 + matrix[4];
            matrix[5] = matrix[1] * x2 + matrix[3] * y2 + matrix[5];
            return this;
          },
          scale: function(x2, y2) {
            var matrix = this.matrix;
            matrix[0] *= x2;
            matrix[1] *= x2;
            matrix[2] *= y2;
            matrix[3] *= y2;
            return this;
          },
          rotate: function(angle) {
            var sin = Math.sin(angle);
            var cos = Math.cos(angle);
            var matrix = this.matrix;
            var a = matrix[0];
            var b2 = matrix[1];
            var c = matrix[2];
            var d = matrix[3];
            matrix[0] = a * cos + c * sin;
            matrix[1] = b2 * cos + d * sin;
            matrix[2] = a * -sin + c * cos;
            matrix[3] = b2 * -sin + d * cos;
            return this;
          },
          multiply: function(rhs, out) {
            var matrix = this.matrix;
            var source = rhs.matrix;
            var localA = matrix[0];
            var localB = matrix[1];
            var localC = matrix[2];
            var localD = matrix[3];
            var localE = matrix[4];
            var localF = matrix[5];
            var sourceA = source[0];
            var sourceB = source[1];
            var sourceC = source[2];
            var sourceD = source[3];
            var sourceE = source[4];
            var sourceF = source[5];
            var destinationMatrix = out === void 0 ? this : out;
            destinationMatrix.a = sourceA * localA + sourceB * localC;
            destinationMatrix.b = sourceA * localB + sourceB * localD;
            destinationMatrix.c = sourceC * localA + sourceD * localC;
            destinationMatrix.d = sourceC * localB + sourceD * localD;
            destinationMatrix.e = sourceE * localA + sourceF * localC + localE;
            destinationMatrix.f = sourceE * localB + sourceF * localD + localF;
            return destinationMatrix;
          },
          multiplyWithOffset: function(src, offsetX, offsetY) {
            var matrix = this.matrix;
            var otherMatrix = src.matrix;
            var a0 = matrix[0];
            var b0 = matrix[1];
            var c0 = matrix[2];
            var d0 = matrix[3];
            var tx0 = matrix[4];
            var ty0 = matrix[5];
            var pse = offsetX * a0 + offsetY * c0 + tx0;
            var psf = offsetX * b0 + offsetY * d0 + ty0;
            var a1 = otherMatrix[0];
            var b1 = otherMatrix[1];
            var c1 = otherMatrix[2];
            var d1 = otherMatrix[3];
            var tx1 = otherMatrix[4];
            var ty1 = otherMatrix[5];
            matrix[0] = a1 * a0 + b1 * c0;
            matrix[1] = a1 * b0 + b1 * d0;
            matrix[2] = c1 * a0 + d1 * c0;
            matrix[3] = c1 * b0 + d1 * d0;
            matrix[4] = tx1 * a0 + ty1 * c0 + pse;
            matrix[5] = tx1 * b0 + ty1 * d0 + psf;
            return this;
          },
          transform: function(a, b2, c, d, tx, ty) {
            var matrix = this.matrix;
            var a0 = matrix[0];
            var b0 = matrix[1];
            var c0 = matrix[2];
            var d0 = matrix[3];
            var tx0 = matrix[4];
            var ty0 = matrix[5];
            matrix[0] = a * a0 + b2 * c0;
            matrix[1] = a * b0 + b2 * d0;
            matrix[2] = c * a0 + d * c0;
            matrix[3] = c * b0 + d * d0;
            matrix[4] = tx * a0 + ty * c0 + tx0;
            matrix[5] = tx * b0 + ty * d0 + ty0;
            return this;
          },
          transformPoint: function(x2, y2, point) {
            if (point === void 0) {
              point = { x: 0, y: 0 };
            }
            var matrix = this.matrix;
            var a = matrix[0];
            var b2 = matrix[1];
            var c = matrix[2];
            var d = matrix[3];
            var tx = matrix[4];
            var ty = matrix[5];
            point.x = x2 * a + y2 * c + tx;
            point.y = x2 * b2 + y2 * d + ty;
            return point;
          },
          invert: function() {
            var matrix = this.matrix;
            var a = matrix[0];
            var b2 = matrix[1];
            var c = matrix[2];
            var d = matrix[3];
            var tx = matrix[4];
            var ty = matrix[5];
            var n2 = a * d - b2 * c;
            matrix[0] = d / n2;
            matrix[1] = -b2 / n2;
            matrix[2] = -c / n2;
            matrix[3] = a / n2;
            matrix[4] = (c * ty - d * tx) / n2;
            matrix[5] = -(a * ty - b2 * tx) / n2;
            return this;
          },
          copyFrom: function(src) {
            var matrix = this.matrix;
            matrix[0] = src.a;
            matrix[1] = src.b;
            matrix[2] = src.c;
            matrix[3] = src.d;
            matrix[4] = src.e;
            matrix[5] = src.f;
            return this;
          },
          copyFromArray: function(src) {
            var matrix = this.matrix;
            matrix[0] = src[0];
            matrix[1] = src[1];
            matrix[2] = src[2];
            matrix[3] = src[3];
            matrix[4] = src[4];
            matrix[5] = src[5];
            return this;
          },
          copyToContext: function(ctx) {
            var matrix = this.matrix;
            ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
            return ctx;
          },
          setToContext: function(ctx) {
            var matrix = this.matrix;
            ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
            return ctx;
          },
          copyToArray: function(out) {
            var matrix = this.matrix;
            if (out === void 0) {
              out = [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]];
            } else {
              out[0] = matrix[0];
              out[1] = matrix[1];
              out[2] = matrix[2];
              out[3] = matrix[3];
              out[4] = matrix[4];
              out[5] = matrix[5];
            }
            return out;
          },
          setTransform: function(a, b2, c, d, tx, ty) {
            var matrix = this.matrix;
            matrix[0] = a;
            matrix[1] = b2;
            matrix[2] = c;
            matrix[3] = d;
            matrix[4] = tx;
            matrix[5] = ty;
            return this;
          },
          decomposeMatrix: function() {
            var decomposedMatrix = this.decomposedMatrix;
            var matrix = this.matrix;
            var a = matrix[0];
            var b2 = matrix[1];
            var c = matrix[2];
            var d = matrix[3];
            var determ = a * d - b2 * c;
            decomposedMatrix.translateX = matrix[4];
            decomposedMatrix.translateY = matrix[5];
            if (a || b2) {
              var r2 = Math.sqrt(a * a + b2 * b2);
              decomposedMatrix.rotation = b2 > 0 ? Math.acos(a / r2) : -Math.acos(a / r2);
              decomposedMatrix.scaleX = r2;
              decomposedMatrix.scaleY = determ / r2;
            } else if (c || d) {
              var s = Math.sqrt(c * c + d * d);
              decomposedMatrix.rotation = Math.PI * 0.5 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
              decomposedMatrix.scaleX = determ / s;
              decomposedMatrix.scaleY = s;
            } else {
              decomposedMatrix.rotation = 0;
              decomposedMatrix.scaleX = 0;
              decomposedMatrix.scaleY = 0;
            }
            return decomposedMatrix;
          },
          applyITRS: function(x2, y2, rotation, scaleX, scaleY) {
            var matrix = this.matrix;
            var radianSin = Math.sin(rotation);
            var radianCos = Math.cos(rotation);
            matrix[4] = x2;
            matrix[5] = y2;
            matrix[0] = radianCos * scaleX;
            matrix[1] = radianSin * scaleX;
            matrix[2] = -radianSin * scaleY;
            matrix[3] = radianCos * scaleY;
            return this;
          },
          applyInverse: function(x2, y2, output) {
            if (output === void 0) {
              output = new Vector2();
            }
            var matrix = this.matrix;
            var a = matrix[0];
            var b2 = matrix[1];
            var c = matrix[2];
            var d = matrix[3];
            var tx = matrix[4];
            var ty = matrix[5];
            var id2 = 1 / (a * d + c * -b2);
            output.x = d * id2 * x2 + -c * id2 * y2 + (ty * c - tx * d) * id2;
            output.y = a * id2 * y2 + -b2 * id2 * x2 + (-ty * a + tx * b2) * id2;
            return output;
          },
          getX: function(x2, y2) {
            return x2 * this.a + y2 * this.c + this.e;
          },
          getY: function(x2, y2) {
            return x2 * this.b + y2 * this.d + this.f;
          },
          getXRound: function(x2, y2, round) {
            var v2 = this.getX(x2, y2);
            if (round) {
              v2 = Math.round(v2);
            }
            return v2;
          },
          getYRound: function(x2, y2, round) {
            var v2 = this.getY(x2, y2);
            if (round) {
              v2 = Math.round(v2);
            }
            return v2;
          },
          getCSSMatrix: function() {
            var m2 = this.matrix;
            return "matrix(" + m2[0] + "," + m2[1] + "," + m2[2] + "," + m2[3] + "," + m2[4] + "," + m2[5] + ")";
          },
          destroy: function() {
            this.matrix = null;
            this.decomposedMatrix = null;
          }
        });
        module2.exports = TransformMatrix;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetFastValue = __webpack_require__(2);
        var GetTilesWithin = function(tileX, tileY, width, height, filteringOptions, layer) {
          if (tileX === void 0) {
            tileX = 0;
          }
          if (tileY === void 0) {
            tileY = 0;
          }
          if (width === void 0) {
            width = layer.width;
          }
          if (height === void 0) {
            height = layer.height;
          }
          if (!filteringOptions) {
            filteringOptions = {};
          }
          var isNotEmpty = GetFastValue(filteringOptions, "isNotEmpty", false);
          var isColliding = GetFastValue(filteringOptions, "isColliding", false);
          var hasInterestingFace = GetFastValue(filteringOptions, "hasInterestingFace", false);
          if (tileX < 0) {
            width += tileX;
            tileX = 0;
          }
          if (tileY < 0) {
            height += tileY;
            tileY = 0;
          }
          if (tileX + width > layer.width) {
            width = Math.max(layer.width - tileX, 0);
          }
          if (tileY + height > layer.height) {
            height = Math.max(layer.height - tileY, 0);
          }
          var results = [];
          for (var ty = tileY; ty < tileY + height; ty++) {
            for (var tx = tileX; tx < tileX + width; tx++) {
              var tile = layer.data[ty][tx];
              if (tile !== null) {
                if (isNotEmpty && tile.index === -1) {
                  continue;
                }
                if (isColliding && !tile.collides) {
                  continue;
                }
                if (hasInterestingFace && !tile.hasInterestingFace) {
                  continue;
                }
                results.push(tile);
              }
            }
          }
          return results;
        };
        module2.exports = GetTilesWithin;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = function(items, key, value, step, index2, direction) {
          if (step === void 0) {
            step = 0;
          }
          if (index2 === void 0) {
            index2 = 0;
          }
          if (direction === void 0) {
            direction = 1;
          }
          var i2;
          var t2 = 0;
          var end = items.length;
          if (direction === 1) {
            for (i2 = index2; i2 < end; i2++) {
              items[i2][key] = value + t2 * step;
              t2++;
            }
          } else {
            for (i2 = index2; i2 >= 0; i2--) {
              items[i2][key] = value + t2 * step;
              t2++;
            }
          }
          return items;
        };
        module2.exports = PropertyValueSet;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BlendModes = __webpack_require__(35);
        var GetAdvancedValue = __webpack_require__(13);
        var BuildGameObject = function(scene, gameObject, config) {
          gameObject.x = GetAdvancedValue(config, "x", 0);
          gameObject.y = GetAdvancedValue(config, "y", 0);
          gameObject.depth = GetAdvancedValue(config, "depth", 0);
          gameObject.flipX = GetAdvancedValue(config, "flipX", false);
          gameObject.flipY = GetAdvancedValue(config, "flipY", false);
          var scale = GetAdvancedValue(config, "scale", null);
          if (typeof scale === "number") {
            gameObject.setScale(scale);
          } else if (scale !== null) {
            gameObject.scaleX = GetAdvancedValue(scale, "x", 1);
            gameObject.scaleY = GetAdvancedValue(scale, "y", 1);
          }
          var scrollFactor = GetAdvancedValue(config, "scrollFactor", null);
          if (typeof scrollFactor === "number") {
            gameObject.setScrollFactor(scrollFactor);
          } else if (scrollFactor !== null) {
            gameObject.scrollFactorX = GetAdvancedValue(scrollFactor, "x", 1);
            gameObject.scrollFactorY = GetAdvancedValue(scrollFactor, "y", 1);
          }
          gameObject.rotation = GetAdvancedValue(config, "rotation", 0);
          var angle = GetAdvancedValue(config, "angle", null);
          if (angle !== null) {
            gameObject.angle = angle;
          }
          gameObject.alpha = GetAdvancedValue(config, "alpha", 1);
          var origin = GetAdvancedValue(config, "origin", null);
          if (typeof origin === "number") {
            gameObject.setOrigin(origin);
          } else if (origin !== null) {
            var ox = GetAdvancedValue(origin, "x", 0.5);
            var oy = GetAdvancedValue(origin, "y", 0.5);
            gameObject.setOrigin(ox, oy);
          }
          gameObject.blendMode = GetAdvancedValue(config, "blendMode", BlendModes.NORMAL);
          gameObject.visible = GetAdvancedValue(config, "visible", true);
          var add = GetAdvancedValue(config, "add", true);
          if (add) {
            scene.sys.displayList.add(gameObject);
          }
          if (gameObject.preUpdate) {
            scene.sys.updateList.add(gameObject);
          }
          return gameObject;
        };
        module2.exports = BuildGameObject;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          ORTHOGONAL: 0,
          ISOMETRIC: 1,
          STAGGERED: 2,
          HEXAGONAL: 3
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCalcMatrix = __webpack_require__(19);
        var SetTransform = function(renderer, ctx, src, camera, parentMatrix) {
          var alpha = camera.alpha * src.alpha;
          if (alpha <= 0) {
            return false;
          }
          var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
          ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
          ctx.globalAlpha = alpha;
          ctx.save();
          calcMatrix.setToContext(ctx);
          ctx.imageSmoothingEnabled = !(!renderer.antialias || src.frame && src.frame.source.scaleMode);
          return true;
        };
        module2.exports = SetTransform;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(33);
        var Smoothing = __webpack_require__(192);
        var pool = [];
        var _disableContextSmoothing = false;
        var CanvasPool = function() {
          var create = function(parent, width, height, canvasType, selfParent) {
            if (width === void 0) {
              width = 1;
            }
            if (height === void 0) {
              height = 1;
            }
            if (canvasType === void 0) {
              canvasType = CONST.CANVAS;
            }
            if (selfParent === void 0) {
              selfParent = false;
            }
            var canvas;
            var container = first(canvasType);
            if (container === null) {
              container = {
                parent,
                canvas: document.createElement("canvas"),
                type: canvasType
              };
              if (canvasType === CONST.CANVAS) {
                pool.push(container);
              }
              canvas = container.canvas;
            } else {
              container.parent = parent;
              canvas = container.canvas;
            }
            if (selfParent) {
              container.parent = canvas;
            }
            canvas.width = width;
            canvas.height = height;
            if (_disableContextSmoothing && canvasType === CONST.CANVAS) {
              Smoothing.disable(canvas.getContext("2d"));
            }
            return canvas;
          };
          var create2D = function(parent, width, height) {
            return create(parent, width, height, CONST.CANVAS);
          };
          var createWebGL = function(parent, width, height) {
            return create(parent, width, height, CONST.WEBGL);
          };
          var first = function(canvasType) {
            if (canvasType === void 0) {
              canvasType = CONST.CANVAS;
            }
            if (canvasType === CONST.WEBGL) {
              return null;
            }
            for (var i2 = 0; i2 < pool.length; i2++) {
              var container = pool[i2];
              if (!container.parent && container.type === canvasType) {
                return container;
              }
            }
            return null;
          };
          var remove = function(parent) {
            var isCanvas = parent instanceof HTMLCanvasElement;
            pool.forEach(function(container) {
              if (isCanvas && container.canvas === parent || !isCanvas && container.parent === parent) {
                container.parent = null;
                container.canvas.width = 1;
                container.canvas.height = 1;
              }
            });
          };
          var total = function() {
            var c = 0;
            pool.forEach(function(container) {
              if (container.parent) {
                c++;
              }
            });
            return c;
          };
          var free = function() {
            return pool.length - total();
          };
          var disableSmoothing = function() {
            _disableContextSmoothing = true;
          };
          var enableSmoothing = function() {
            _disableContextSmoothing = false;
          };
          return {
            create2D,
            create,
            createWebGL,
            disableSmoothing,
            enableSmoothing,
            first,
            free,
            pool,
            remove,
            total
          };
        };
        module2.exports = CanvasPool();
      },
      function(module2, exports2) {
        var Common = {};
        module2.exports = Common;
        (function() {
          Common._nextId = 0;
          Common._seed = 0;
          Common._nowStartTime = +new Date();
          Common.extend = function(obj, deep) {
            var argsStart, deepClone;
            if (typeof deep === "boolean") {
              argsStart = 2;
              deepClone = deep;
            } else {
              argsStart = 1;
              deepClone = true;
            }
            for (var i2 = argsStart; i2 < arguments.length; i2++) {
              var source = arguments[i2];
              if (source) {
                for (var prop in source) {
                  if (deepClone && source[prop] && source[prop].constructor === Object) {
                    if (!obj[prop] || obj[prop].constructor === Object) {
                      obj[prop] = obj[prop] || {};
                      Common.extend(obj[prop], deepClone, source[prop]);
                    } else {
                      obj[prop] = source[prop];
                    }
                  } else {
                    obj[prop] = source[prop];
                  }
                }
              }
            }
            return obj;
          };
          Common.clone = function(obj, deep) {
            return Common.extend({}, deep, obj);
          };
          Common.keys = function(obj) {
            if (Object.keys)
              return Object.keys(obj);
            var keys = [];
            for (var key in obj)
              keys.push(key);
            return keys;
          };
          Common.values = function(obj) {
            var values = [];
            if (Object.keys) {
              var keys = Object.keys(obj);
              for (var i2 = 0; i2 < keys.length; i2++) {
                values.push(obj[keys[i2]]);
              }
              return values;
            }
            for (var key in obj)
              values.push(obj[key]);
            return values;
          };
          Common.get = function(obj, path, begin, end) {
            path = path.split(".").slice(begin, end);
            for (var i2 = 0; i2 < path.length; i2 += 1) {
              obj = obj[path[i2]];
            }
            return obj;
          };
          Common.set = function(obj, path, val, begin, end) {
            var parts = path.split(".").slice(begin, end);
            Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;
            return val;
          };
          Common.shuffle = function(array) {
            for (var i2 = array.length - 1; i2 > 0; i2--) {
              var j = Math.floor(Common.random() * (i2 + 1));
              var temp = array[i2];
              array[i2] = array[j];
              array[j] = temp;
            }
            return array;
          };
          Common.choose = function(choices) {
            return choices[Math.floor(Common.random() * choices.length)];
          };
          Common.isElement = function(obj) {
            if (typeof HTMLElement !== "undefined") {
              return obj instanceof HTMLElement;
            }
            return !!(obj && obj.nodeType && obj.nodeName);
          };
          Common.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
          Common.isFunction = function(obj) {
            return typeof obj === "function";
          };
          Common.isPlainObject = function(obj) {
            return typeof obj === "object" && obj.constructor === Object;
          };
          Common.isString = function(obj) {
            return Object.prototype.toString.call(obj) === "[object String]";
          };
          Common.clamp = function(value, min, max) {
            if (value < min)
              return min;
            if (value > max)
              return max;
            return value;
          };
          Common.sign = function(value) {
            return value < 0 ? -1 : 1;
          };
          Common.now = function() {
            if (typeof window !== "undefined" && window.performance) {
              if (window.performance.now) {
                return window.performance.now();
              } else if (window.performance.webkitNow) {
                return window.performance.webkitNow();
              }
            }
            return new Date() - Common._nowStartTime;
          };
          Common.random = function(min, max) {
            min = typeof min !== "undefined" ? min : 0;
            max = typeof max !== "undefined" ? max : 1;
            return min + _seededRandom() * (max - min);
          };
          var _seededRandom = function() {
            Common._seed = (Common._seed * 9301 + 49297) % 233280;
            return Common._seed / 233280;
          };
          Common.colorToNumber = function(colorString) {
            colorString = colorString.replace("#", "");
            if (colorString.length == 3) {
              colorString = colorString.charAt(0) + colorString.charAt(0) + colorString.charAt(1) + colorString.charAt(1) + colorString.charAt(2) + colorString.charAt(2);
            }
            return parseInt(colorString, 16);
          };
          Common.logLevel = 1;
          Common.log = function() {
            if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
              console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
            }
          };
          Common.info = function() {
            if (console && Common.logLevel > 0 && Common.logLevel <= 2) {
              console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
            }
          };
          Common.warn = function() {
            if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
              console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
            }
          };
          Common.nextId = function() {
            return Common._nextId++;
          };
          Common.indexOf = function(haystack, needle) {
            if (haystack.indexOf)
              return haystack.indexOf(needle);
            for (var i2 = 0; i2 < haystack.length; i2++) {
              if (haystack[i2] === needle)
                return i2;
            }
            return -1;
          };
          Common.map = function(list, func) {
            if (list.map) {
              return list.map(func);
            }
            var mapped = [];
            for (var i2 = 0; i2 < list.length; i2 += 1) {
              mapped.push(func(list[i2]));
            }
            return mapped;
          };
          Common.topologicalSort = function(graph) {
            var result = [], visited = [], temp = [];
            for (var node in graph) {
              if (!visited[node] && !temp[node]) {
                Common._topologicalSort(node, visited, temp, graph, result);
              }
            }
            return result;
          };
          Common._topologicalSort = function(node, visited, temp, graph, result) {
            var neighbors = graph[node] || [];
            temp[node] = true;
            for (var i2 = 0; i2 < neighbors.length; i2 += 1) {
              var neighbor = neighbors[i2];
              if (temp[neighbor]) {
                continue;
              }
              if (!visited[neighbor]) {
                Common._topologicalSort(neighbor, visited, temp, graph, result);
              }
            }
            temp[node] = false;
            visited[node] = true;
            result.push(node);
          };
          Common.chain = function() {
            var funcs = [];
            for (var i2 = 0; i2 < arguments.length; i2 += 1) {
              var func = arguments[i2];
              if (func._chained) {
                funcs.push.apply(funcs, func._chained);
              } else {
                funcs.push(func);
              }
            }
            var chain = function() {
              var lastResult, args = new Array(arguments.length);
              for (var i3 = 0, l2 = arguments.length; i3 < l2; i3++) {
                args[i3] = arguments[i3];
              }
              for (i3 = 0; i3 < funcs.length; i3 += 1) {
                var result = funcs[i3].apply(lastResult, args);
                if (typeof result !== "undefined") {
                  lastResult = result;
                }
              }
              return lastResult;
            };
            chain._chained = funcs;
            return chain;
          };
          Common.chainPathBefore = function(base, path, func) {
            return Common.set(base, path, Common.chain(func, Common.get(base, path)));
          };
          Common.chainPathAfter = function(base, path, func) {
            return Common.set(base, path, Common.chain(Common.get(base, path), func));
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = {
          VERSION: "3.55.2",
          BlendModes: __webpack_require__(35),
          ScaleModes: __webpack_require__(168),
          AUTO: 0,
          CANVAS: 1,
          WEBGL: 2,
          HEADLESS: 3,
          FOREVER: -1,
          NONE: 4,
          UP: 5,
          DOWN: 6,
          LEFT: 7,
          RIGHT: 8
        };
        module2.exports = CONST;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var GameObject = __webpack_require__(15);
        var Line = __webpack_require__(47);
        var Shape = new Class({
          Extends: GameObject,
          Mixins: [
            Components.AlphaSingle,
            Components.BlendMode,
            Components.Depth,
            Components.GetBounds,
            Components.Mask,
            Components.Origin,
            Components.Pipeline,
            Components.ScrollFactor,
            Components.Transform,
            Components.Visible
          ],
          initialize: function Shape2(scene, type, data) {
            if (type === void 0) {
              type = "Shape";
            }
            GameObject.call(this, scene, type);
            this.geom = data;
            this.pathData = [];
            this.pathIndexes = [];
            this.fillColor = 16777215;
            this.fillAlpha = 1;
            this.strokeColor = 16777215;
            this.strokeAlpha = 1;
            this.lineWidth = 1;
            this.isFilled = false;
            this.isStroked = false;
            this.closePath = true;
            this._tempLine = new Line();
            this.width = 0;
            this.height = 0;
            this.initPipeline();
          },
          setFillStyle: function(color, alpha) {
            if (alpha === void 0) {
              alpha = 1;
            }
            if (color === void 0) {
              this.isFilled = false;
            } else {
              this.fillColor = color;
              this.fillAlpha = alpha;
              this.isFilled = true;
            }
            return this;
          },
          setStrokeStyle: function(lineWidth, color, alpha) {
            if (alpha === void 0) {
              alpha = 1;
            }
            if (lineWidth === void 0) {
              this.isStroked = false;
            } else {
              this.lineWidth = lineWidth;
              this.strokeColor = color;
              this.strokeAlpha = alpha;
              this.isStroked = true;
            }
            return this;
          },
          setClosePath: function(value) {
            this.closePath = value;
            return this;
          },
          setSize: function(width, height) {
            this.width = width;
            this.height = height;
            return this;
          },
          setDisplaySize: function(width, height) {
            this.displayWidth = width;
            this.displayHeight = height;
            return this;
          },
          preDestroy: function() {
            this.geom = null;
            this._tempLine = null;
            this.pathData = [];
            this.pathIndexes = [];
          },
          displayWidth: {
            get: function() {
              return this.scaleX * this.width;
            },
            set: function(value) {
              this.scaleX = value / this.width;
            }
          },
          displayHeight: {
            get: function() {
              return this.scaleY * this.height;
            },
            set: function(value) {
              this.scaleY = value / this.height;
            }
          }
        });
        module2.exports = Shape;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          SKIP_CHECK: -1,
          NORMAL: 0,
          ADD: 1,
          MULTIPLY: 2,
          SCREEN: 3,
          OVERLAY: 4,
          DARKEN: 5,
          LIGHTEN: 6,
          COLOR_DODGE: 7,
          COLOR_BURN: 8,
          HARD_LIGHT: 9,
          SOFT_LIGHT: 10,
          DIFFERENCE: 11,
          EXCLUSION: 12,
          HUE: 13,
          SATURATION: 14,
          COLOR: 15,
          LUMINOSITY: 16,
          ERASE: 17,
          SOURCE_IN: 18,
          SOURCE_OUT: 19,
          SOURCE_ATOP: 20,
          DESTINATION_OVER: 21,
          DESTINATION_IN: 22,
          DESTINATION_OUT: 23,
          DESTINATION_ATOP: 24,
          LIGHTER: 25,
          COPY: 26,
          XOR: 27
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(14);
        var DegToRad = function(degrees) {
          return degrees * CONST.DEG_TO_RAD;
        };
        module2.exports = DegToRad;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          DESTROY: __webpack_require__(743),
          FADE_IN_COMPLETE: __webpack_require__(744),
          FADE_IN_START: __webpack_require__(745),
          FADE_OUT_COMPLETE: __webpack_require__(746),
          FADE_OUT_START: __webpack_require__(747),
          FLASH_COMPLETE: __webpack_require__(748),
          FLASH_START: __webpack_require__(749),
          FOLLOW_UPDATE: __webpack_require__(750),
          PAN_COMPLETE: __webpack_require__(751),
          PAN_START: __webpack_require__(752),
          POST_RENDER: __webpack_require__(753),
          PRE_RENDER: __webpack_require__(754),
          ROTATE_COMPLETE: __webpack_require__(755),
          ROTATE_START: __webpack_require__(756),
          SHAKE_COMPLETE: __webpack_require__(757),
          SHAKE_START: __webpack_require__(758),
          ZOOM_COMPLETE: __webpack_require__(759),
          ZOOM_START: __webpack_require__(760)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetColor = __webpack_require__(103);
        var GetColor32 = __webpack_require__(328);
        var HSVToRGB = __webpack_require__(188);
        var RGBToHSV = __webpack_require__(329);
        var Color = new Class({
          initialize: function Color2(red, green, blue, alpha) {
            if (red === void 0) {
              red = 0;
            }
            if (green === void 0) {
              green = 0;
            }
            if (blue === void 0) {
              blue = 0;
            }
            if (alpha === void 0) {
              alpha = 255;
            }
            this.r = 0;
            this.g = 0;
            this.b = 0;
            this.a = 255;
            this._h = 0;
            this._s = 0;
            this._v = 0;
            this._locked = false;
            this.gl = [0, 0, 0, 1];
            this._color = 0;
            this._color32 = 0;
            this._rgba = "";
            this.setTo(red, green, blue, alpha);
          },
          transparent: function() {
            this._locked = true;
            this.red = 0;
            this.green = 0;
            this.blue = 0;
            this.alpha = 0;
            this._locked = false;
            return this.update(true);
          },
          setTo: function(red, green, blue, alpha, updateHSV) {
            if (alpha === void 0) {
              alpha = 255;
            }
            if (updateHSV === void 0) {
              updateHSV = true;
            }
            this._locked = true;
            this.red = red;
            this.green = green;
            this.blue = blue;
            this.alpha = alpha;
            this._locked = false;
            return this.update(updateHSV);
          },
          setGLTo: function(red, green, blue, alpha) {
            if (alpha === void 0) {
              alpha = 1;
            }
            this._locked = true;
            this.redGL = red;
            this.greenGL = green;
            this.blueGL = blue;
            this.alphaGL = alpha;
            this._locked = false;
            return this.update(true);
          },
          setFromRGB: function(color) {
            this._locked = true;
            this.red = color.r;
            this.green = color.g;
            this.blue = color.b;
            if (color.hasOwnProperty("a")) {
              this.alpha = color.a;
            }
            this._locked = false;
            return this.update(true);
          },
          setFromHSV: function(h2, s, v2) {
            return HSVToRGB(h2, s, v2, this);
          },
          update: function(updateHSV) {
            if (updateHSV === void 0) {
              updateHSV = false;
            }
            if (this._locked) {
              return this;
            }
            var r2 = this.r;
            var g2 = this.g;
            var b2 = this.b;
            var a = this.a;
            this._color = GetColor(r2, g2, b2);
            this._color32 = GetColor32(r2, g2, b2, a);
            this._rgba = "rgba(" + r2 + "," + g2 + "," + b2 + "," + a / 255 + ")";
            if (updateHSV) {
              RGBToHSV(r2, g2, b2, this);
            }
            return this;
          },
          updateHSV: function() {
            var r2 = this.r;
            var g2 = this.g;
            var b2 = this.b;
            RGBToHSV(r2, g2, b2, this);
            return this;
          },
          clone: function() {
            return new Color(this.r, this.g, this.b, this.a);
          },
          gray: function(shade) {
            return this.setTo(shade, shade, shade);
          },
          random: function(min, max) {
            if (min === void 0) {
              min = 0;
            }
            if (max === void 0) {
              max = 255;
            }
            var r2 = Math.floor(min + Math.random() * (max - min));
            var g2 = Math.floor(min + Math.random() * (max - min));
            var b2 = Math.floor(min + Math.random() * (max - min));
            return this.setTo(r2, g2, b2);
          },
          randomGray: function(min, max) {
            if (min === void 0) {
              min = 0;
            }
            if (max === void 0) {
              max = 255;
            }
            var s = Math.floor(min + Math.random() * (max - min));
            return this.setTo(s, s, s);
          },
          saturate: function(amount) {
            this.s += amount / 100;
            return this;
          },
          desaturate: function(amount) {
            this.s -= amount / 100;
            return this;
          },
          lighten: function(amount) {
            this.v += amount / 100;
            return this;
          },
          darken: function(amount) {
            this.v -= amount / 100;
            return this;
          },
          brighten: function(amount) {
            var r2 = this.r;
            var g2 = this.g;
            var b2 = this.b;
            r2 = Math.max(0, Math.min(255, r2 - Math.round(255 * -(amount / 100))));
            g2 = Math.max(0, Math.min(255, g2 - Math.round(255 * -(amount / 100))));
            b2 = Math.max(0, Math.min(255, b2 - Math.round(255 * -(amount / 100))));
            return this.setTo(r2, g2, b2);
          },
          color: {
            get: function() {
              return this._color;
            }
          },
          color32: {
            get: function() {
              return this._color32;
            }
          },
          rgba: {
            get: function() {
              return this._rgba;
            }
          },
          redGL: {
            get: function() {
              return this.gl[0];
            },
            set: function(value) {
              this.gl[0] = Math.min(Math.abs(value), 1);
              this.r = Math.floor(this.gl[0] * 255);
              this.update(true);
            }
          },
          greenGL: {
            get: function() {
              return this.gl[1];
            },
            set: function(value) {
              this.gl[1] = Math.min(Math.abs(value), 1);
              this.g = Math.floor(this.gl[1] * 255);
              this.update(true);
            }
          },
          blueGL: {
            get: function() {
              return this.gl[2];
            },
            set: function(value) {
              this.gl[2] = Math.min(Math.abs(value), 1);
              this.b = Math.floor(this.gl[2] * 255);
              this.update(true);
            }
          },
          alphaGL: {
            get: function() {
              return this.gl[3];
            },
            set: function(value) {
              this.gl[3] = Math.min(Math.abs(value), 1);
              this.a = Math.floor(this.gl[3] * 255);
              this.update();
            }
          },
          red: {
            get: function() {
              return this.r;
            },
            set: function(value) {
              value = Math.floor(Math.abs(value));
              this.r = Math.min(value, 255);
              this.gl[0] = value / 255;
              this.update(true);
            }
          },
          green: {
            get: function() {
              return this.g;
            },
            set: function(value) {
              value = Math.floor(Math.abs(value));
              this.g = Math.min(value, 255);
              this.gl[1] = value / 255;
              this.update(true);
            }
          },
          blue: {
            get: function() {
              return this.b;
            },
            set: function(value) {
              value = Math.floor(Math.abs(value));
              this.b = Math.min(value, 255);
              this.gl[2] = value / 255;
              this.update(true);
            }
          },
          alpha: {
            get: function() {
              return this.a;
            },
            set: function(value) {
              value = Math.floor(Math.abs(value));
              this.a = Math.min(value, 255);
              this.gl[3] = value / 255;
              this.update();
            }
          },
          h: {
            get: function() {
              return this._h;
            },
            set: function(value) {
              this._h = value;
              HSVToRGB(value, this._s, this._v, this);
            }
          },
          s: {
            get: function() {
              return this._s;
            },
            set: function(value) {
              this._s = value;
              HSVToRGB(this._h, value, this._v, this);
            }
          },
          v: {
            get: function() {
              return this._v;
            },
            set: function(value) {
              this._v = value;
              HSVToRGB(this._h, this._s, value, this);
            }
          }
        });
        module2.exports = Color;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Vector3 = new Class({
          initialize: function Vector32(x2, y2, z2) {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            if (typeof x2 === "object") {
              this.x = x2.x || 0;
              this.y = x2.y || 0;
              this.z = x2.z || 0;
            } else {
              this.x = x2 || 0;
              this.y = y2 || 0;
              this.z = z2 || 0;
            }
          },
          up: function() {
            this.x = 0;
            this.y = 1;
            this.z = 0;
            return this;
          },
          min: function(v2) {
            this.x = Math.min(this.x, v2.x);
            this.y = Math.min(this.y, v2.y);
            this.z = Math.min(this.z, v2.z);
            return this;
          },
          max: function(v2) {
            this.x = Math.max(this.x, v2.x);
            this.y = Math.max(this.y, v2.y);
            this.z = Math.max(this.z, v2.z);
            return this;
          },
          clone: function() {
            return new Vector3(this.x, this.y, this.z);
          },
          addVectors: function(a, b2) {
            this.x = a.x + b2.x;
            this.y = a.y + b2.y;
            this.z = a.z + b2.z;
            return this;
          },
          crossVectors: function(a, b2) {
            var ax = a.x;
            var ay = a.y;
            var az = a.z;
            var bx = b2.x;
            var by = b2.y;
            var bz = b2.z;
            this.x = ay * bz - az * by;
            this.y = az * bx - ax * bz;
            this.z = ax * by - ay * bx;
            return this;
          },
          equals: function(v2) {
            return this.x === v2.x && this.y === v2.y && this.z === v2.z;
          },
          copy: function(src) {
            this.x = src.x;
            this.y = src.y;
            this.z = src.z || 0;
            return this;
          },
          set: function(x2, y2, z2) {
            if (typeof x2 === "object") {
              this.x = x2.x || 0;
              this.y = x2.y || 0;
              this.z = x2.z || 0;
            } else {
              this.x = x2 || 0;
              this.y = y2 || 0;
              this.z = z2 || 0;
            }
            return this;
          },
          setFromMatrixPosition: function(m2) {
            return this.fromArray(m2.val, 12);
          },
          setFromMatrixColumn: function(mat4, index2) {
            return this.fromArray(mat4.val, index2 * 4);
          },
          fromArray: function(array, offset) {
            if (offset === void 0) {
              offset = 0;
            }
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            return this;
          },
          add: function(v2) {
            this.x += v2.x;
            this.y += v2.y;
            this.z += v2.z || 0;
            return this;
          },
          addScalar: function(s) {
            this.x += s;
            this.y += s;
            this.z += s;
            return this;
          },
          addScale: function(v2, scale) {
            this.x += v2.x * scale;
            this.y += v2.y * scale;
            this.z += v2.z * scale || 0;
            return this;
          },
          subtract: function(v2) {
            this.x -= v2.x;
            this.y -= v2.y;
            this.z -= v2.z || 0;
            return this;
          },
          multiply: function(v2) {
            this.x *= v2.x;
            this.y *= v2.y;
            this.z *= v2.z || 1;
            return this;
          },
          scale: function(scale) {
            if (isFinite(scale)) {
              this.x *= scale;
              this.y *= scale;
              this.z *= scale;
            } else {
              this.x = 0;
              this.y = 0;
              this.z = 0;
            }
            return this;
          },
          divide: function(v2) {
            this.x /= v2.x;
            this.y /= v2.y;
            this.z /= v2.z || 1;
            return this;
          },
          negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
          },
          distance: function(v2) {
            var dx = v2.x - this.x;
            var dy = v2.y - this.y;
            var dz = v2.z - this.z || 0;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
          },
          distanceSq: function(v2) {
            var dx = v2.x - this.x;
            var dy = v2.y - this.y;
            var dz = v2.z - this.z || 0;
            return dx * dx + dy * dy + dz * dz;
          },
          length: function() {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
          },
          lengthSq: function() {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            return x2 * x2 + y2 * y2 + z2 * z2;
          },
          normalize: function() {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var len = x2 * x2 + y2 * y2 + z2 * z2;
            if (len > 0) {
              len = 1 / Math.sqrt(len);
              this.x = x2 * len;
              this.y = y2 * len;
              this.z = z2 * len;
            }
            return this;
          },
          dot: function(v2) {
            return this.x * v2.x + this.y * v2.y + this.z * v2.z;
          },
          cross: function(v2) {
            var ax = this.x;
            var ay = this.y;
            var az = this.z;
            var bx = v2.x;
            var by = v2.y;
            var bz = v2.z;
            this.x = ay * bz - az * by;
            this.y = az * bx - ax * bz;
            this.z = ax * by - ay * bx;
            return this;
          },
          lerp: function(v2, t2) {
            if (t2 === void 0) {
              t2 = 0;
            }
            var ax = this.x;
            var ay = this.y;
            var az = this.z;
            this.x = ax + t2 * (v2.x - ax);
            this.y = ay + t2 * (v2.y - ay);
            this.z = az + t2 * (v2.z - az);
            return this;
          },
          applyMatrix3: function(mat3) {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var m2 = mat3.val;
            this.x = m2[0] * x2 + m2[3] * y2 + m2[6] * z2;
            this.y = m2[1] * x2 + m2[4] * y2 + m2[7] * z2;
            this.z = m2[2] * x2 + m2[5] * y2 + m2[8] * z2;
            return this;
          },
          applyMatrix4: function(mat4) {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var m2 = mat4.val;
            var w2 = 1 / (m2[3] * x2 + m2[7] * y2 + m2[11] * z2 + m2[15]);
            this.x = (m2[0] * x2 + m2[4] * y2 + m2[8] * z2 + m2[12]) * w2;
            this.y = (m2[1] * x2 + m2[5] * y2 + m2[9] * z2 + m2[13]) * w2;
            this.z = (m2[2] * x2 + m2[6] * y2 + m2[10] * z2 + m2[14]) * w2;
            return this;
          },
          transformMat3: function(mat) {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var m2 = mat.val;
            this.x = x2 * m2[0] + y2 * m2[3] + z2 * m2[6];
            this.y = x2 * m2[1] + y2 * m2[4] + z2 * m2[7];
            this.z = x2 * m2[2] + y2 * m2[5] + z2 * m2[8];
            return this;
          },
          transformMat4: function(mat) {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var m2 = mat.val;
            this.x = m2[0] * x2 + m2[4] * y2 + m2[8] * z2 + m2[12];
            this.y = m2[1] * x2 + m2[5] * y2 + m2[9] * z2 + m2[13];
            this.z = m2[2] * x2 + m2[6] * y2 + m2[10] * z2 + m2[14];
            return this;
          },
          transformCoordinates: function(mat) {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var m2 = mat.val;
            var tx = x2 * m2[0] + y2 * m2[4] + z2 * m2[8] + m2[12];
            var ty = x2 * m2[1] + y2 * m2[5] + z2 * m2[9] + m2[13];
            var tz = x2 * m2[2] + y2 * m2[6] + z2 * m2[10] + m2[14];
            var tw = x2 * m2[3] + y2 * m2[7] + z2 * m2[11] + m2[15];
            this.x = tx / tw;
            this.y = ty / tw;
            this.z = tz / tw;
            return this;
          },
          transformQuat: function(q2) {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var qx = q2.x;
            var qy = q2.y;
            var qz = q2.z;
            var qw = q2.w;
            var ix = qw * x2 + qy * z2 - qz * y2;
            var iy = qw * y2 + qz * x2 - qx * z2;
            var iz = qw * z2 + qx * y2 - qy * x2;
            var iw = -qx * x2 - qy * y2 - qz * z2;
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
          },
          project: function(mat) {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var m2 = mat.val;
            var a00 = m2[0];
            var a01 = m2[1];
            var a02 = m2[2];
            var a03 = m2[3];
            var a10 = m2[4];
            var a11 = m2[5];
            var a12 = m2[6];
            var a13 = m2[7];
            var a20 = m2[8];
            var a21 = m2[9];
            var a22 = m2[10];
            var a23 = m2[11];
            var a30 = m2[12];
            var a31 = m2[13];
            var a32 = m2[14];
            var a33 = m2[15];
            var lw = 1 / (x2 * a03 + y2 * a13 + z2 * a23 + a33);
            this.x = (x2 * a00 + y2 * a10 + z2 * a20 + a30) * lw;
            this.y = (x2 * a01 + y2 * a11 + z2 * a21 + a31) * lw;
            this.z = (x2 * a02 + y2 * a12 + z2 * a22 + a32) * lw;
            return this;
          },
          projectViewMatrix: function(viewMatrix, projectionMatrix) {
            return this.applyMatrix4(viewMatrix).applyMatrix4(projectionMatrix);
          },
          unprojectViewMatrix: function(projectionMatrix, worldMatrix) {
            return this.applyMatrix4(projectionMatrix).applyMatrix4(worldMatrix);
          },
          unproject: function(viewport, invProjectionView) {
            var viewX = viewport.x;
            var viewY = viewport.y;
            var viewWidth = viewport.z;
            var viewHeight = viewport.w;
            var x2 = this.x - viewX;
            var y2 = viewHeight - this.y - 1 - viewY;
            var z2 = this.z;
            this.x = 2 * x2 / viewWidth - 1;
            this.y = 2 * y2 / viewHeight - 1;
            this.z = 2 * z2 - 1;
            return this.project(invProjectionView);
          },
          reset: function() {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            return this;
          }
        });
        Vector3.ZERO = new Vector3();
        Vector3.RIGHT = new Vector3(1, 0, 0);
        Vector3.LEFT = new Vector3(-1, 0, 0);
        Vector3.UP = new Vector3(0, -1, 0);
        Vector3.DOWN = new Vector3(0, 1, 0);
        Vector3.FORWARD = new Vector3(0, 0, 1);
        Vector3.BACK = new Vector3(0, 0, -1);
        Vector3.ONE = new Vector3(1, 1, 1);
        module2.exports = Vector3;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          CSV: 0,
          TILED_JSON: 1,
          ARRAY_2D: 2,
          WELTMEISTER: 3
        };
      },
      function(module2, exports2, __webpack_require__) {
        var Body = {};
        module2.exports = Body;
        var Vertices = __webpack_require__(64);
        var Vector = __webpack_require__(83);
        var Sleeping = __webpack_require__(165);
        var Common = __webpack_require__(32);
        var Bounds = __webpack_require__(84);
        var Axes = __webpack_require__(271);
        (function() {
          Body._inertiaScale = 4;
          Body._nextCollidingGroupId = 1;
          Body._nextNonCollidingGroupId = -1;
          Body._nextCategory = 1;
          Body.create = function(options) {
            var defaults = {
              id: Common.nextId(),
              type: "body",
              label: "Body",
              parts: [],
              plugin: {},
              angle: 0,
              vertices: null,
              position: { x: 0, y: 0 },
              force: { x: 0, y: 0 },
              torque: 0,
              positionImpulse: { x: 0, y: 0 },
              previousPositionImpulse: { x: 0, y: 0 },
              constraintImpulse: { x: 0, y: 0, angle: 0 },
              totalContacts: 0,
              speed: 0,
              angularSpeed: 0,
              velocity: { x: 0, y: 0 },
              angularVelocity: 0,
              isSensor: false,
              isStatic: false,
              isSleeping: false,
              motion: 0,
              sleepThreshold: 60,
              density: 1e-3,
              restitution: 0,
              friction: 0.1,
              frictionStatic: 0.5,
              frictionAir: 0.01,
              collisionFilter: {
                category: 1,
                mask: 4294967295,
                group: 0
              },
              slop: 0.05,
              timeScale: 1,
              events: null,
              bounds: null,
              chamfer: null,
              circleRadius: 0,
              positionPrev: null,
              anglePrev: 0,
              parent: null,
              axes: null,
              area: 0,
              mass: 0,
              inverseMass: 0,
              inertia: 0,
              inverseInertia: 0,
              _original: null,
              render: {
                visible: true,
                opacity: 1,
                sprite: {
                  xOffset: 0,
                  yOffset: 0
                },
                fillColor: null,
                fillOpacity: null,
                lineColor: null,
                lineOpacity: null,
                lineThickness: null
              },
              gameObject: null,
              scale: { x: 1, y: 1 },
              centerOfMass: { x: 0, y: 0 },
              centerOffset: { x: 0, y: 0 },
              gravityScale: { x: 1, y: 1 },
              ignoreGravity: false,
              ignorePointer: false,
              onCollideCallback: null,
              onCollideEndCallback: null,
              onCollideActiveCallback: null,
              onCollideWith: {}
            };
            if (!options.hasOwnProperty("position") && options.hasOwnProperty("vertices")) {
              options.position = Vertices.centre(options.vertices);
            } else if (!options.hasOwnProperty("vertices")) {
              defaults.vertices = Vertices.fromPath("L 0 0 L 40 0 L 40 40 L 0 40");
            }
            var body = Common.extend(defaults, options);
            _initProperties(body, options);
            body.setOnCollideWith = function(body2, callback) {
              if (callback) {
                this.onCollideWith[body2.id] = callback;
              } else {
                delete this.onCollideWith[body2.id];
              }
              return this;
            };
            return body;
          };
          Body.nextGroup = function(isNonColliding) {
            if (isNonColliding)
              return Body._nextNonCollidingGroupId--;
            return Body._nextCollidingGroupId++;
          };
          Body.nextCategory = function() {
            Body._nextCategory = Body._nextCategory << 1;
            return Body._nextCategory;
          };
          var _initProperties = function(body, options) {
            options = options || {};
            Body.set(body, {
              bounds: body.bounds || Bounds.create(body.vertices),
              positionPrev: body.positionPrev || Vector.clone(body.position),
              anglePrev: body.anglePrev || body.angle,
              vertices: body.vertices,
              parts: body.parts || [body],
              isStatic: body.isStatic,
              isSleeping: body.isSleeping,
              parent: body.parent || body
            });
            var bounds = body.bounds;
            Vertices.rotate(body.vertices, body.angle, body.position);
            Axes.rotate(body.axes, body.angle);
            Bounds.update(bounds, body.vertices, body.velocity);
            Body.set(body, {
              axes: options.axes || body.axes,
              area: options.area || body.area,
              mass: options.mass || body.mass,
              inertia: options.inertia || body.inertia
            });
            if (body.parts.length === 1) {
              var centerOfMass = body.centerOfMass;
              var centerOffset = body.centerOffset;
              var bodyWidth = bounds.max.x - bounds.min.x;
              var bodyHeight = bounds.max.y - bounds.min.y;
              centerOfMass.x = -(bounds.min.x - body.position.x) / bodyWidth;
              centerOfMass.y = -(bounds.min.y - body.position.y) / bodyHeight;
              centerOffset.x = bodyWidth * centerOfMass.x;
              centerOffset.y = bodyHeight * centerOfMass.y;
            }
          };
          Body.set = function(body, settings, value) {
            var property;
            if (typeof settings === "string") {
              property = settings;
              settings = {};
              settings[property] = value;
            }
            for (property in settings) {
              if (!Object.prototype.hasOwnProperty.call(settings, property))
                continue;
              value = settings[property];
              switch (property) {
                case "isStatic":
                  Body.setStatic(body, value);
                  break;
                case "isSleeping":
                  Sleeping.set(body, value);
                  break;
                case "mass":
                  Body.setMass(body, value);
                  break;
                case "density":
                  Body.setDensity(body, value);
                  break;
                case "inertia":
                  Body.setInertia(body, value);
                  break;
                case "vertices":
                  Body.setVertices(body, value);
                  break;
                case "position":
                  Body.setPosition(body, value);
                  break;
                case "angle":
                  Body.setAngle(body, value);
                  break;
                case "velocity":
                  Body.setVelocity(body, value);
                  break;
                case "angularVelocity":
                  Body.setAngularVelocity(body, value);
                  break;
                case "parts":
                  Body.setParts(body, value);
                  break;
                case "centre":
                  Body.setCentre(body, value);
                  break;
                default:
                  body[property] = value;
              }
            }
          };
          Body.setStatic = function(body, isStatic) {
            for (var i2 = 0; i2 < body.parts.length; i2++) {
              var part = body.parts[i2];
              part.isStatic = isStatic;
              if (isStatic) {
                part._original = {
                  restitution: part.restitution,
                  friction: part.friction,
                  mass: part.mass,
                  inertia: part.inertia,
                  density: part.density,
                  inverseMass: part.inverseMass,
                  inverseInertia: part.inverseInertia
                };
                part.restitution = 0;
                part.friction = 1;
                part.mass = part.inertia = part.density = Infinity;
                part.inverseMass = part.inverseInertia = 0;
                part.positionPrev.x = part.position.x;
                part.positionPrev.y = part.position.y;
                part.anglePrev = part.angle;
                part.angularVelocity = 0;
                part.speed = 0;
                part.angularSpeed = 0;
                part.motion = 0;
              } else if (part._original) {
                part.restitution = part._original.restitution;
                part.friction = part._original.friction;
                part.mass = part._original.mass;
                part.inertia = part._original.inertia;
                part.density = part._original.density;
                part.inverseMass = part._original.inverseMass;
                part.inverseInertia = part._original.inverseInertia;
                part._original = null;
              }
            }
          };
          Body.setMass = function(body, mass) {
            var moment = body.inertia / (body.mass / 6);
            body.inertia = moment * (mass / 6);
            body.inverseInertia = 1 / body.inertia;
            body.mass = mass;
            body.inverseMass = 1 / body.mass;
            body.density = body.mass / body.area;
          };
          Body.setDensity = function(body, density) {
            Body.setMass(body, density * body.area);
            body.density = density;
          };
          Body.setInertia = function(body, inertia) {
            body.inertia = inertia;
            body.inverseInertia = 1 / body.inertia;
          };
          Body.setVertices = function(body, vertices) {
            if (vertices[0].body === body) {
              body.vertices = vertices;
            } else {
              body.vertices = Vertices.create(vertices, body);
            }
            body.axes = Axes.fromVertices(body.vertices);
            body.area = Vertices.area(body.vertices);
            Body.setMass(body, body.density * body.area);
            var centre = Vertices.centre(body.vertices);
            Vertices.translate(body.vertices, centre, -1);
            Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));
            Vertices.translate(body.vertices, body.position);
            Bounds.update(body.bounds, body.vertices, body.velocity);
          };
          Body.setParts = function(body, parts, autoHull) {
            var i2;
            parts = parts.slice(0);
            body.parts.length = 0;
            body.parts.push(body);
            body.parent = body;
            for (i2 = 0; i2 < parts.length; i2++) {
              var part = parts[i2];
              if (part !== body) {
                part.parent = body;
                body.parts.push(part);
              }
            }
            if (body.parts.length === 1)
              return;
            autoHull = typeof autoHull !== "undefined" ? autoHull : true;
            if (autoHull) {
              var vertices = [];
              for (i2 = 0; i2 < parts.length; i2++) {
                vertices = vertices.concat(parts[i2].vertices);
              }
              Vertices.clockwiseSort(vertices);
              var hull = Vertices.hull(vertices), hullCentre = Vertices.centre(hull);
              Body.setVertices(body, hull);
              Vertices.translate(body.vertices, hullCentre);
            }
            var total = Body._totalProperties(body);
            var cx = total.centre.x;
            var cy = total.centre.y;
            var bounds = body.bounds;
            var centerOfMass = body.centerOfMass;
            var centerOffset = body.centerOffset;
            Bounds.update(bounds, body.vertices, body.velocity);
            centerOfMass.x = -(bounds.min.x - cx) / (bounds.max.x - bounds.min.x);
            centerOfMass.y = -(bounds.min.y - cy) / (bounds.max.y - bounds.min.y);
            centerOffset.x = cx;
            centerOffset.y = cy;
            body.area = total.area;
            body.parent = body;
            body.position.x = cx;
            body.position.y = cy;
            body.positionPrev.x = cx;
            body.positionPrev.y = cy;
            Body.setMass(body, total.mass);
            Body.setInertia(body, total.inertia);
            Body.setPosition(body, total.centre);
          };
          Body.setCentre = function(body, centre, relative) {
            if (!relative) {
              body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);
              body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);
              body.position.x = centre.x;
              body.position.y = centre.y;
            } else {
              body.positionPrev.x += centre.x;
              body.positionPrev.y += centre.y;
              body.position.x += centre.x;
              body.position.y += centre.y;
            }
          };
          Body.setPosition = function(body, position) {
            var delta = Vector.sub(position, body.position);
            body.positionPrev.x += delta.x;
            body.positionPrev.y += delta.y;
            for (var i2 = 0; i2 < body.parts.length; i2++) {
              var part = body.parts[i2];
              part.position.x += delta.x;
              part.position.y += delta.y;
              Vertices.translate(part.vertices, delta);
              Bounds.update(part.bounds, part.vertices, body.velocity);
            }
          };
          Body.setAngle = function(body, angle) {
            var delta = angle - body.angle;
            body.anglePrev += delta;
            for (var i2 = 0; i2 < body.parts.length; i2++) {
              var part = body.parts[i2];
              part.angle += delta;
              Vertices.rotate(part.vertices, delta, body.position);
              Axes.rotate(part.axes, delta);
              Bounds.update(part.bounds, part.vertices, body.velocity);
              if (i2 > 0) {
                Vector.rotateAbout(part.position, delta, body.position, part.position);
              }
            }
          };
          Body.setVelocity = function(body, velocity) {
            body.positionPrev.x = body.position.x - velocity.x;
            body.positionPrev.y = body.position.y - velocity.y;
            body.velocity.x = velocity.x;
            body.velocity.y = velocity.y;
            body.speed = Vector.magnitude(body.velocity);
          };
          Body.setAngularVelocity = function(body, velocity) {
            body.anglePrev = body.angle - velocity;
            body.angularVelocity = velocity;
            body.angularSpeed = Math.abs(body.angularVelocity);
          };
          Body.translate = function(body, translation) {
            Body.setPosition(body, Vector.add(body.position, translation));
          };
          Body.rotate = function(body, rotation, point) {
            if (!point) {
              Body.setAngle(body, body.angle + rotation);
            } else {
              var cos = Math.cos(rotation), sin = Math.sin(rotation), dx = body.position.x - point.x, dy = body.position.y - point.y;
              Body.setPosition(body, {
                x: point.x + (dx * cos - dy * sin),
                y: point.y + (dx * sin + dy * cos)
              });
              Body.setAngle(body, body.angle + rotation);
            }
          };
          Body.scale = function(body, scaleX, scaleY, point) {
            var totalArea = 0, totalInertia = 0;
            point = point || body.position;
            for (var i2 = 0; i2 < body.parts.length; i2++) {
              var part = body.parts[i2];
              part.scale.x = scaleX;
              part.scale.y = scaleY;
              Vertices.scale(part.vertices, scaleX, scaleY, point);
              part.axes = Axes.fromVertices(part.vertices);
              part.area = Vertices.area(part.vertices);
              Body.setMass(part, body.density * part.area);
              Vertices.translate(part.vertices, { x: -part.position.x, y: -part.position.y });
              Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));
              Vertices.translate(part.vertices, { x: part.position.x, y: part.position.y });
              if (i2 > 0) {
                totalArea += part.area;
                totalInertia += part.inertia;
              }
              part.position.x = point.x + (part.position.x - point.x) * scaleX;
              part.position.y = point.y + (part.position.y - point.y) * scaleY;
              Bounds.update(part.bounds, part.vertices, body.velocity);
            }
            if (body.parts.length > 1) {
              body.area = totalArea;
              if (!body.isStatic) {
                Body.setMass(body, body.density * totalArea);
                Body.setInertia(body, totalInertia);
              }
            }
            if (body.circleRadius) {
              if (scaleX === scaleY) {
                body.circleRadius *= scaleX;
              } else {
                body.circleRadius = null;
              }
            }
          };
          Body.update = function(body, deltaTime, timeScale, correction) {
            var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);
            var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale, velocityPrevX = body.position.x - body.positionPrev.x, velocityPrevY = body.position.y - body.positionPrev.y;
            body.velocity.x = velocityPrevX * frictionAir * correction + body.force.x / body.mass * deltaTimeSquared;
            body.velocity.y = velocityPrevY * frictionAir * correction + body.force.y / body.mass * deltaTimeSquared;
            body.positionPrev.x = body.position.x;
            body.positionPrev.y = body.position.y;
            body.position.x += body.velocity.x;
            body.position.y += body.velocity.y;
            body.angularVelocity = (body.angle - body.anglePrev) * frictionAir * correction + body.torque / body.inertia * deltaTimeSquared;
            body.anglePrev = body.angle;
            body.angle += body.angularVelocity;
            body.speed = Vector.magnitude(body.velocity);
            body.angularSpeed = Math.abs(body.angularVelocity);
            for (var i2 = 0; i2 < body.parts.length; i2++) {
              var part = body.parts[i2];
              Vertices.translate(part.vertices, body.velocity);
              if (i2 > 0) {
                part.position.x += body.velocity.x;
                part.position.y += body.velocity.y;
              }
              if (body.angularVelocity !== 0) {
                Vertices.rotate(part.vertices, body.angularVelocity, body.position);
                Axes.rotate(part.axes, body.angularVelocity);
                if (i2 > 0) {
                  Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);
                }
              }
              Bounds.update(part.bounds, part.vertices, body.velocity);
            }
          };
          Body.applyForce = function(body, position, force) {
            body.force.x += force.x;
            body.force.y += force.y;
            var offset = { x: position.x - body.position.x, y: position.y - body.position.y };
            body.torque += offset.x * force.y - offset.y * force.x;
          };
          Body._totalProperties = function(body) {
            var properties = {
              mass: 0,
              area: 0,
              inertia: 0,
              centre: { x: 0, y: 0 }
            };
            for (var i2 = body.parts.length === 1 ? 0 : 1; i2 < body.parts.length; i2++) {
              var part = body.parts[i2], mass = part.mass !== Infinity ? part.mass : 1;
              properties.mass += mass;
              properties.area += part.area;
              properties.inertia += part.inertia;
              properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));
            }
            properties.centre = Vector.div(properties.centre, properties.mass);
            return properties;
          };
        })();
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetBottom = function(gameObject) {
          return gameObject.y + gameObject.height - gameObject.height * gameObject.originY;
        };
        module2.exports = GetBottom;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetLeft = function(gameObject) {
          return gameObject.x - gameObject.width * gameObject.originX;
        };
        module2.exports = GetLeft;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetRight = function(gameObject) {
          return gameObject.x + gameObject.width - gameObject.width * gameObject.originX;
        };
        module2.exports = GetRight;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTop = function(gameObject) {
          return gameObject.y - gameObject.height * gameObject.originY;
        };
        module2.exports = GetTop;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueInc = function(items, key, value, step, index2, direction) {
          if (step === void 0) {
            step = 0;
          }
          if (index2 === void 0) {
            index2 = 0;
          }
          if (direction === void 0) {
            direction = 1;
          }
          var i2;
          var t2 = 0;
          var end = items.length;
          if (direction === 1) {
            for (i2 = index2; i2 < end; i2++) {
              items[i2][key] += value + t2 * step;
              t2++;
            }
          } else {
            for (i2 = index2; i2 >= 0; i2--) {
              items[i2][key] += value + t2 * step;
              t2++;
            }
          }
          return items;
        };
        module2.exports = PropertyValueInc;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetPoint = __webpack_require__(307);
        var GetPoints = __webpack_require__(172);
        var GEOM_CONST = __webpack_require__(56);
        var Random = __webpack_require__(173);
        var Vector2 = __webpack_require__(3);
        var Line = new Class({
          initialize: function Line2(x1, y1, x2, y2) {
            if (x1 === void 0) {
              x1 = 0;
            }
            if (y1 === void 0) {
              y1 = 0;
            }
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            this.type = GEOM_CONST.LINE;
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
          },
          getPoint: function(position, output) {
            return GetPoint(this, position, output);
          },
          getPoints: function(quantity, stepRate, output) {
            return GetPoints(this, quantity, stepRate, output);
          },
          getRandomPoint: function(point) {
            return Random(this, point);
          },
          setTo: function(x1, y1, x2, y2) {
            if (x1 === void 0) {
              x1 = 0;
            }
            if (y1 === void 0) {
              y1 = 0;
            }
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
            return this;
          },
          getPointA: function(vec2) {
            if (vec2 === void 0) {
              vec2 = new Vector2();
            }
            vec2.set(this.x1, this.y1);
            return vec2;
          },
          getPointB: function(vec2) {
            if (vec2 === void 0) {
              vec2 = new Vector2();
            }
            vec2.set(this.x2, this.y2);
            return vec2;
          },
          left: {
            get: function() {
              return Math.min(this.x1, this.x2);
            },
            set: function(value) {
              if (this.x1 <= this.x2) {
                this.x1 = value;
              } else {
                this.x2 = value;
              }
            }
          },
          right: {
            get: function() {
              return Math.max(this.x1, this.x2);
            },
            set: function(value) {
              if (this.x1 > this.x2) {
                this.x1 = value;
              } else {
                this.x2 = value;
              }
            }
          },
          top: {
            get: function() {
              return Math.min(this.y1, this.y2);
            },
            set: function(value) {
              if (this.y1 <= this.y2) {
                this.y1 = value;
              } else {
                this.y2 = value;
              }
            }
          },
          bottom: {
            get: function() {
              return Math.max(this.y1, this.y2);
            },
            set: function(value) {
              if (this.y1 > this.y2) {
                this.y1 = value;
              } else {
                this.y2 = value;
              }
            }
          }
        });
        module2.exports = Line;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FillStyleCanvas = function(ctx, src, altColor, altAlpha) {
          var fillColor = altColor ? altColor : src.fillColor;
          var fillAlpha = altAlpha ? altAlpha : src.fillAlpha;
          var red = (fillColor & 16711680) >>> 16;
          var green = (fillColor & 65280) >>> 8;
          var blue = fillColor & 255;
          ctx.fillStyle = "rgba(" + red + "," + green + "," + blue + "," + fillAlpha + ")";
        };
        module2.exports = FillStyleCanvas;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var MultiFile = new Class({
          initialize: function MultiFile2(loader, type, key, files) {
            var finalFiles = [];
            files.forEach(function(file) {
              if (file) {
                finalFiles.push(file);
              }
            });
            this.loader = loader;
            this.type = type;
            this.key = key;
            this.multiKeyIndex = loader.multiKeyIndex++;
            this.files = finalFiles;
            this.complete = false;
            this.pending = finalFiles.length;
            this.failed = 0;
            this.config = {};
            this.baseURL = loader.baseURL;
            this.path = loader.path;
            this.prefix = loader.prefix;
            for (var i2 = 0; i2 < finalFiles.length; i2++) {
              finalFiles[i2].multiFile = this;
            }
          },
          isReadyToProcess: function() {
            return this.pending === 0 && this.failed === 0 && !this.complete;
          },
          addToMultiFile: function(file) {
            this.files.push(file);
            file.multiFile = this;
            this.pending++;
            this.complete = false;
            return this;
          },
          onFileComplete: function(file) {
            var index2 = this.files.indexOf(file);
            if (index2 !== -1) {
              this.pending--;
            }
          },
          onFileFailed: function(file) {
            var index2 = this.files.indexOf(file);
            if (index2 !== -1) {
              this.failed++;
            }
          }
        });
        module2.exports = MultiFile;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DistanceBetween = function(x1, y1, x2, y2) {
          var dx = x1 - x2;
          var dy = y1 - y2;
          return Math.sqrt(dx * dx + dy * dy);
        };
        module2.exports = DistanceBetween;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          BOOT: __webpack_require__(922),
          DESTROY: __webpack_require__(923),
          DRAG_END: __webpack_require__(924),
          DRAG_ENTER: __webpack_require__(925),
          DRAG: __webpack_require__(926),
          DRAG_LEAVE: __webpack_require__(927),
          DRAG_OVER: __webpack_require__(928),
          DRAG_START: __webpack_require__(929),
          DROP: __webpack_require__(930),
          GAME_OUT: __webpack_require__(931),
          GAME_OVER: __webpack_require__(932),
          GAMEOBJECT_DOWN: __webpack_require__(933),
          GAMEOBJECT_DRAG_END: __webpack_require__(934),
          GAMEOBJECT_DRAG_ENTER: __webpack_require__(935),
          GAMEOBJECT_DRAG: __webpack_require__(936),
          GAMEOBJECT_DRAG_LEAVE: __webpack_require__(937),
          GAMEOBJECT_DRAG_OVER: __webpack_require__(938),
          GAMEOBJECT_DRAG_START: __webpack_require__(939),
          GAMEOBJECT_DROP: __webpack_require__(940),
          GAMEOBJECT_MOVE: __webpack_require__(941),
          GAMEOBJECT_OUT: __webpack_require__(942),
          GAMEOBJECT_OVER: __webpack_require__(943),
          GAMEOBJECT_POINTER_DOWN: __webpack_require__(944),
          GAMEOBJECT_POINTER_MOVE: __webpack_require__(945),
          GAMEOBJECT_POINTER_OUT: __webpack_require__(946),
          GAMEOBJECT_POINTER_OVER: __webpack_require__(947),
          GAMEOBJECT_POINTER_UP: __webpack_require__(948),
          GAMEOBJECT_POINTER_WHEEL: __webpack_require__(949),
          GAMEOBJECT_UP: __webpack_require__(950),
          GAMEOBJECT_WHEEL: __webpack_require__(951),
          MANAGER_BOOT: __webpack_require__(952),
          MANAGER_PROCESS: __webpack_require__(953),
          MANAGER_UPDATE: __webpack_require__(954),
          POINTER_DOWN: __webpack_require__(955),
          POINTER_DOWN_OUTSIDE: __webpack_require__(956),
          POINTER_MOVE: __webpack_require__(957),
          POINTER_OUT: __webpack_require__(958),
          POINTER_OVER: __webpack_require__(959),
          POINTER_UP: __webpack_require__(960),
          POINTER_UP_OUTSIDE: __webpack_require__(961),
          POINTER_WHEEL: __webpack_require__(962),
          POINTERLOCK_CHANGE: __webpack_require__(963),
          PRE_UPDATE: __webpack_require__(964),
          SHUTDOWN: __webpack_require__(965),
          START: __webpack_require__(966),
          UPDATE: __webpack_require__(967)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetTop = function(gameObject, value) {
          gameObject.y = value + gameObject.height * gameObject.originY;
          return gameObject;
        };
        module2.exports = SetTop;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetLeft = function(gameObject, value) {
          gameObject.x = value + gameObject.width * gameObject.originX;
          return gameObject;
        };
        module2.exports = SetLeft;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetRight = function(gameObject, value) {
          gameObject.x = value - gameObject.width + gameObject.width * gameObject.originX;
          return gameObject;
        };
        module2.exports = SetRight;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetBottom = function(gameObject, value) {
          gameObject.y = value - gameObject.height + gameObject.height * gameObject.originY;
          return gameObject;
        };
        module2.exports = SetBottom;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GEOM_CONST = {
          CIRCLE: 0,
          ELLIPSE: 1,
          LINE: 2,
          POINT: 3,
          POLYGON: 4,
          RECTANGLE: 5,
          TRIANGLE: 6
        };
        module2.exports = GEOM_CONST;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Contains = function(rect, x2, y2) {
          if (rect.width <= 0 || rect.height <= 0) {
            return false;
          }
          return rect.x <= x2 && rect.x + rect.width >= x2 && rect.y <= y2 && rect.y + rect.height >= y2;
        };
        module2.exports = Contains;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var DeepCopy = __webpack_require__(175);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(374);
        var GetFastValue = __webpack_require__(2);
        var Matrix4 = __webpack_require__(69);
        var RendererEvents = __webpack_require__(91);
        var RenderTarget = __webpack_require__(141);
        var Utils = __webpack_require__(12);
        var WebGLShader = __webpack_require__(375);
        var WebGLPipeline = new Class({
          Extends: EventEmitter,
          initialize: function WebGLPipeline2(config) {
            EventEmitter.call(this);
            var game = config.game;
            var renderer = game.renderer;
            var gl2 = renderer.gl;
            this.name = GetFastValue(config, "name", "WebGLPipeline");
            this.game = game;
            this.renderer = renderer;
            this.manager;
            this.gl = gl2;
            this.view = game.canvas;
            this.width = 0;
            this.height = 0;
            this.vertexCount = 0;
            this.vertexCapacity = 0;
            this.vertexData;
            this.vertexBuffer;
            this.topology = GetFastValue(config, "topology", gl2.TRIANGLES);
            this.bytes;
            this.vertexViewF32;
            this.vertexViewU32;
            this.active = true;
            this.currentUnit = 0;
            this.forceZero = GetFastValue(config, "forceZero", false);
            this.hasBooted = false;
            this.isPostFX = false;
            this.renderTargets = [];
            this.currentRenderTarget;
            this.shaders = [];
            this.currentShader;
            this.projectionMatrix;
            this.projectionWidth = 0;
            this.projectionHeight = 0;
            this.config = config;
            this.glReset = false;
          },
          boot: function() {
            var i2;
            var gl2 = this.gl;
            var config = this.config;
            var renderer = this.renderer;
            if (!this.isPostFX) {
              this.projectionMatrix = new Matrix4().identity();
            }
            var renderTargets = this.renderTargets;
            var targets = GetFastValue(config, "renderTarget", false);
            if (typeof targets === "boolean" && targets) {
              targets = 1;
            }
            var width = renderer.width;
            var height = renderer.height;
            if (typeof targets === "number") {
              for (i2 = 0; i2 < targets; i2++) {
                renderTargets.push(new RenderTarget(renderer, width, height, 1, 0, true));
              }
            } else if (Array.isArray(targets)) {
              for (i2 = 0; i2 < targets.length; i2++) {
                var scale = GetFastValue(targets[i2], "scale", 1);
                var minFilter = GetFastValue(targets[i2], "minFilter", 0);
                var autoClear = GetFastValue(targets[i2], "autoClear", 1);
                renderTargets.push(new RenderTarget(renderer, width, height, scale, minFilter, autoClear));
              }
            }
            if (renderTargets.length) {
              this.currentRenderTarget = renderTargets[0];
            }
            this.setShadersFromConfig(config);
            var shaders = this.shaders;
            var vertexSize = 0;
            for (i2 = 0; i2 < shaders.length; i2++) {
              if (shaders[i2].vertexSize > vertexSize) {
                vertexSize = shaders[i2].vertexSize;
              }
            }
            var batchSize = GetFastValue(config, "batchSize", renderer.config.batchSize);
            this.vertexCapacity = batchSize * 6;
            var data = new ArrayBuffer(this.vertexCapacity * vertexSize);
            this.vertexData = data;
            this.bytes = new Uint8Array(data);
            this.vertexViewF32 = new Float32Array(data);
            this.vertexViewU32 = new Uint32Array(data);
            var configVerts = GetFastValue(config, "vertices", null);
            if (configVerts) {
              this.vertexViewF32.set(configVerts);
              this.vertexBuffer = renderer.createVertexBuffer(data, gl2.STATIC_DRAW);
            } else {
              this.vertexBuffer = renderer.createVertexBuffer(data.byteLength, gl2.DYNAMIC_DRAW);
            }
            this.setVertexBuffer();
            for (i2 = shaders.length - 1; i2 >= 0; i2--) {
              shaders[i2].rebind();
            }
            this.hasBooted = true;
            renderer.on(RendererEvents.RESIZE, this.resize, this);
            renderer.on(RendererEvents.PRE_RENDER, this.onPreRender, this);
            renderer.on(RendererEvents.RENDER, this.onRender, this);
            renderer.on(RendererEvents.POST_RENDER, this.onPostRender, this);
            this.emit(Events.BOOT, this);
            this.onBoot();
          },
          onBoot: function() {
          },
          onResize: function() {
          },
          setShader: function(shader, setAttributes) {
            var renderer = this.renderer;
            if (shader !== this.currentShader || renderer.currentProgram !== this.currentShader.program) {
              this.flush();
              renderer.resetTextures();
              var wasBound = this.setVertexBuffer();
              if (wasBound && !setAttributes) {
                setAttributes = true;
              }
              shader.bind(setAttributes, false);
              this.currentShader = shader;
            }
            return this;
          },
          getShaderByName: function(name) {
            var shaders = this.shaders;
            for (var i2 = 0; i2 < shaders.length; i2++) {
              if (shaders[i2].name === name) {
                return shaders[i2];
              }
            }
          },
          setShadersFromConfig: function(config) {
            var i2;
            var shaders = this.shaders;
            var renderer = this.renderer;
            for (i2 = 0; i2 < shaders.length; i2++) {
              shaders[i2].destroy();
            }
            var vName = "vertShader";
            var fName = "fragShader";
            var aName = "attributes";
            var defaultVertShader = GetFastValue(config, vName, null);
            var defaultFragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(config, fName, null), renderer.maxTextures);
            var defaultAttribs = GetFastValue(config, aName, null);
            var configShaders = GetFastValue(config, "shaders", []);
            var len = configShaders.length;
            if (len === 0) {
              if (defaultVertShader && defaultFragShader) {
                this.shaders = [new WebGLShader(this, "default", defaultVertShader, defaultFragShader, DeepCopy(defaultAttribs))];
              }
            } else {
              var newShaders = [];
              for (i2 = 0; i2 < len; i2++) {
                var shaderEntry = configShaders[i2];
                var name = GetFastValue(shaderEntry, "name", "default");
                var vertShader = GetFastValue(shaderEntry, vName, defaultVertShader);
                var fragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(shaderEntry, fName, defaultFragShader), renderer.maxTextures);
                var attributes = GetFastValue(shaderEntry, aName, defaultAttribs);
                if (vertShader && fragShader) {
                  newShaders.push(new WebGLShader(this, name, vertShader, fragShader, DeepCopy(attributes)));
                }
              }
              this.shaders = newShaders;
            }
            if (this.shaders.length === 0) {
              console.warn("Pipeline: " + this.name + " - Invalid shader config");
            } else {
              this.currentShader = this.shaders[0];
            }
            return this;
          },
          setGameObject: function(gameObject, frame) {
            if (frame === void 0) {
              frame = gameObject.frame;
            }
            this.currentUnit = this.renderer.setTextureSource(frame.source);
            return this.currentUnit;
          },
          shouldFlush: function(amount) {
            if (amount === void 0) {
              amount = 0;
            }
            return this.vertexCount + amount > this.vertexCapacity;
          },
          resize: function(width, height) {
            if (width !== this.width || height !== this.height) {
              this.flush();
            }
            this.width = width;
            this.height = height;
            var targets = this.renderTargets;
            for (var i2 = 0; i2 < targets.length; i2++) {
              targets[i2].resize(width, height);
            }
            this.setProjectionMatrix(width, height);
            this.emit(Events.RESIZE, width, height, this);
            this.onResize(width, height);
            return this;
          },
          setProjectionMatrix: function(width, height) {
            var projectionMatrix = this.projectionMatrix;
            if (!projectionMatrix) {
              return this;
            }
            this.projectionWidth = width;
            this.projectionHeight = height;
            projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);
            var shaders = this.shaders;
            var name = "uProjectionMatrix";
            for (var i2 = 0; i2 < shaders.length; i2++) {
              var shader = shaders[i2];
              if (shader.hasUniform(name)) {
                shader.resetUniform(name);
                shader.setMatrix4fv(name, false, projectionMatrix.val, shader);
              }
            }
            return this;
          },
          updateProjectionMatrix: function() {
            if (this.projectionMatrix) {
              var globalWidth = this.renderer.projectionWidth;
              var globalHeight = this.renderer.projectionHeight;
              if (this.projectionWidth !== globalWidth || this.projectionHeight !== globalHeight) {
                this.setProjectionMatrix(globalWidth, globalHeight);
              }
            }
          },
          bind: function(currentShader) {
            if (currentShader === void 0) {
              currentShader = this.currentShader;
            }
            if (this.glReset) {
              return this.rebind(currentShader);
            }
            var wasBound = this.setVertexBuffer();
            currentShader.bind(wasBound);
            this.currentShader = currentShader;
            this.emit(Events.BIND, this, currentShader);
            this.onActive(currentShader);
            return this;
          },
          rebind: function(currentShader) {
            this.setVertexBuffer();
            var shaders = this.shaders;
            for (var i2 = shaders.length - 1; i2 >= 0; i2--) {
              var shader = shaders[i2].rebind();
              if (!currentShader || shader === currentShader) {
                this.currentShader = shader;
              }
            }
            this.emit(Events.REBIND, this.currentShader);
            this.onActive(this.currentShader);
            this.onRebind();
            this.glReset = false;
            return this;
          },
          setVertexBuffer: function() {
            var gl2 = this.gl;
            var buffer = this.vertexBuffer;
            if (gl2.getParameter(gl2.ARRAY_BUFFER_BINDING) !== buffer) {
              gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer);
              return true;
            }
            return false;
          },
          preBatch: function(gameObject) {
            if (this.currentRenderTarget) {
              this.currentRenderTarget.bind();
            }
            this.onPreBatch(gameObject);
            return this;
          },
          postBatch: function(gameObject) {
            this.onDraw(this.currentRenderTarget);
            this.onPostBatch(gameObject);
            return this;
          },
          onDraw: function() {
          },
          unbind: function() {
            if (this.currentRenderTarget) {
              this.currentRenderTarget.unbind();
            }
          },
          flush: function(isPostFlush) {
            if (isPostFlush === void 0) {
              isPostFlush = false;
            }
            if (this.vertexCount > 0) {
              this.emit(Events.BEFORE_FLUSH, this, isPostFlush);
              this.onBeforeFlush(isPostFlush);
              var gl2 = this.gl;
              var vertexCount = this.vertexCount;
              var vertexSize = this.currentShader.vertexSize;
              if (this.active) {
                this.setVertexBuffer();
                if (vertexCount === this.vertexCapacity) {
                  gl2.bufferData(gl2.ARRAY_BUFFER, this.vertexData, gl2.DYNAMIC_DRAW);
                } else {
                  gl2.bufferSubData(gl2.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));
                }
                gl2.drawArrays(this.topology, 0, vertexCount);
              }
              this.vertexCount = 0;
              this.emit(Events.AFTER_FLUSH, this, isPostFlush);
              this.onAfterFlush(isPostFlush);
            }
            return this;
          },
          onActive: function() {
          },
          onBind: function() {
          },
          onRebind: function() {
          },
          onBatch: function() {
          },
          onPreBatch: function() {
          },
          onPostBatch: function() {
          },
          onPreRender: function() {
          },
          onRender: function() {
          },
          onPostRender: function() {
          },
          onBeforeFlush: function() {
          },
          onAfterFlush: function() {
          },
          batchVert: function(x2, y2, u2, v2, unit, tintEffect, tint) {
            var vertexViewF32 = this.vertexViewF32;
            var vertexViewU32 = this.vertexViewU32;
            var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
            vertexViewF32[++vertexOffset] = x2;
            vertexViewF32[++vertexOffset] = y2;
            vertexViewF32[++vertexOffset] = u2;
            vertexViewF32[++vertexOffset] = v2;
            vertexViewF32[++vertexOffset] = unit;
            vertexViewF32[++vertexOffset] = tintEffect;
            vertexViewU32[++vertexOffset] = tint;
            this.vertexCount++;
          },
          batchQuad: function(gameObject, x0, y0, x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, unit) {
            if (unit === void 0) {
              unit = this.currentUnit;
            }
            var hasFlushed = false;
            if (this.shouldFlush(6)) {
              this.flush();
              hasFlushed = true;
              unit = this.setTexture2D(texture);
            }
            this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);
            this.batchVert(x1, y1, u0, v1, unit, tintEffect, tintBL);
            this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBR);
            this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);
            this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBR);
            this.batchVert(x3, y3, u1, v0, unit, tintEffect, tintTR);
            this.onBatch(gameObject);
            return hasFlushed;
          },
          batchTri: function(gameObject, x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintEffect, texture, unit) {
            if (unit === void 0) {
              unit = this.currentUnit;
            }
            var hasFlushed = false;
            if (this.shouldFlush(3)) {
              this.flush();
              hasFlushed = true;
              unit = this.setTexture2D(texture);
            }
            this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);
            this.batchVert(x1, y1, u0, v1, unit, tintEffect, tintTR);
            this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBL);
            this.onBatch(gameObject);
            return hasFlushed;
          },
          drawFillRect: function(x2, y2, width, height, color, alpha, texture, flipUV) {
            if (texture === void 0) {
              texture = this.renderer.whiteTexture.glTexture;
            }
            if (flipUV === void 0) {
              flipUV = true;
            }
            x2 = Math.floor(x2);
            y2 = Math.floor(y2);
            var xw = Math.floor(x2 + width);
            var yh2 = Math.floor(y2 + height);
            var unit = this.setTexture2D(texture);
            var tint = Utils.getTintAppendFloatAlphaAndSwap(color, alpha);
            var u0 = 0;
            var v0 = 0;
            var u1 = 1;
            var v1 = 1;
            if (flipUV) {
              v0 = 1;
              v1 = 0;
            }
            this.batchQuad(null, x2, y2, x2, yh2, xw, yh2, xw, y2, u0, v0, u1, v1, tint, tint, tint, tint, 0, texture, unit);
          },
          setTexture2D: function(texture) {
            if (texture === void 0) {
              texture = this.renderer.whiteTexture.glTexture;
            }
            this.currentUnit = this.renderer.setTexture2D(texture);
            return this.currentUnit;
          },
          bindTexture: function(texture, unit) {
            if (unit === void 0) {
              unit = 0;
            }
            var gl2 = this.gl;
            gl2.activeTexture(gl2.TEXTURE0 + unit);
            gl2.bindTexture(gl2.TEXTURE_2D, texture);
            return this;
          },
          bindRenderTarget: function(target, unit) {
            return this.bindTexture(target.texture, unit);
          },
          setTime: function(uniform) {
            this.set1f(uniform, this.game.loop.getDuration());
            return this;
          },
          set1f: function(name, x2, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set1f(name, x2);
            return this;
          },
          set2f: function(name, x2, y2, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set2f(name, x2, y2);
            return this;
          },
          set3f: function(name, x2, y2, z2, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set3f(name, x2, y2, z2);
            return this;
          },
          set4f: function(name, x2, y2, z2, w2, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set4f(name, x2, y2, z2, w2);
            return this;
          },
          set1fv: function(name, arr, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set1fv(name, arr);
            return this;
          },
          set2fv: function(name, arr, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set2fv(name, arr);
            return this;
          },
          set3fv: function(name, arr, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set3fv(name, arr);
            return this;
          },
          set4fv: function(name, arr, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set4fv(name, arr);
            return this;
          },
          set1iv: function(name, arr, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set1iv(name, arr);
            return this;
          },
          set2iv: function(name, arr, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set2iv(name, arr);
            return this;
          },
          set3iv: function(name, arr, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set3iv(name, arr);
            return this;
          },
          set4iv: function(name, arr, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set4iv(name, arr);
            return this;
          },
          set1i: function(name, x2, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set1i(name, x2);
            return this;
          },
          set2i: function(name, x2, y2, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set2i(name, x2, y2);
            return this;
          },
          set3i: function(name, x2, y2, z2, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set3i(name, x2, y2, z2);
            return this;
          },
          set4i: function(name, x2, y2, z2, w2, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.set4i(name, x2, y2, z2, w2);
            return this;
          },
          setMatrix2fv: function(name, transpose, matrix, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.setMatrix2fv(name, transpose, matrix);
            return this;
          },
          setMatrix3fv: function(name, transpose, matrix, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.setMatrix3fv(name, transpose, matrix);
            return this;
          },
          setMatrix4fv: function(name, transpose, matrix, shader) {
            if (shader === void 0) {
              shader = this.currentShader;
            }
            shader.setMatrix4fv(name, transpose, matrix);
            return this;
          },
          destroy: function() {
            this.emit(Events.DESTROY, this);
            var i2;
            var shaders = this.shaders;
            for (i2 = 0; i2 < shaders.length; i2++) {
              shaders[i2].destroy();
            }
            var targets = this.renderTargets;
            for (i2 = 0; i2 < targets.length; i2++) {
              targets[i2].destroy();
            }
            this.gl.deleteBuffer(this.vertexBuffer);
            var renderer = this.renderer;
            renderer.off(RendererEvents.RESIZE, this.resize, this);
            renderer.off(RendererEvents.PRE_RENDER, this.onPreRender, this);
            renderer.off(RendererEvents.RENDER, this.onRender, this);
            renderer.off(RendererEvents.POST_RENDER, this.onPostRender, this);
            this.removeAllListeners();
            this.game = null;
            this.renderer = null;
            this.manager = null;
            this.gl = null;
            this.view = null;
            this.shaders = null;
            this.renderTargets = null;
            this.bytes = null;
            this.vertexViewF32 = null;
            this.vertexViewU32 = null;
            this.vertexData = null;
            this.vertexBuffer = null;
            this.currentShader = null;
            this.currentRenderTarget = null;
            return this;
          }
        });
        module2.exports = WebGLPipeline;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        function earcut(data, holeIndices, dim) {
          dim = dim || 2;
          var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
          if (!outerNode || outerNode.next === outerNode.prev)
            return triangles;
          var minX, minY, maxX, maxY, x2, y2, invSize;
          if (hasHoles)
            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
          if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (var i2 = dim; i2 < outerLen; i2 += dim) {
              x2 = data[i2];
              y2 = data[i2 + 1];
              if (x2 < minX)
                minX = x2;
              if (y2 < minY)
                minY = y2;
              if (x2 > maxX)
                maxX = x2;
              if (y2 > maxY)
                maxY = y2;
            }
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
          }
          earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
          return triangles;
        }
        function linkedList(data, start, end, dim, clockwise) {
          var i2, last;
          if (clockwise === signedArea(data, start, end, dim) > 0) {
            for (i2 = start; i2 < end; i2 += dim)
              last = insertNode(i2, data[i2], data[i2 + 1], last);
          } else {
            for (i2 = end - dim; i2 >= start; i2 -= dim)
              last = insertNode(i2, data[i2], data[i2 + 1], last);
          }
          if (last && equals(last, last.next)) {
            removeNode(last);
            last = last.next;
          }
          return last;
        }
        function filterPoints(start, end) {
          if (!start)
            return start;
          if (!end)
            end = start;
          var p2 = start, again;
          do {
            again = false;
            if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
              removeNode(p2);
              p2 = end = p2.prev;
              if (p2 === p2.next)
                break;
              again = true;
            } else {
              p2 = p2.next;
            }
          } while (again || p2 !== end);
          return end;
        }
        function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
          if (!ear)
            return;
          if (!pass && invSize)
            indexCurve(ear, minX, minY, invSize);
          var stop = ear, prev, next;
          while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;
            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
              triangles.push(prev.i / dim);
              triangles.push(ear.i / dim);
              triangles.push(next.i / dim);
              removeNode(ear);
              ear = next.next;
              stop = next.next;
              continue;
            }
            ear = next;
            if (ear === stop) {
              if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
              } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
              } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
              }
              break;
            }
          }
        }
        function isEar(ear) {
          var a = ear.prev, b2 = ear, c = ear.next;
          if (area(a, b2, c) >= 0)
            return false;
          var p2 = ear.next.next;
          while (p2 !== ear.prev) {
            if (pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
              return false;
            p2 = p2.next;
          }
          return true;
        }
        function isEarHashed(ear, minX, minY, invSize) {
          var a = ear.prev, b2 = ear, c = ear.next;
          if (area(a, b2, c) >= 0)
            return false;
          var minTX = a.x < b2.x ? a.x < c.x ? a.x : c.x : b2.x < c.x ? b2.x : c.x, minTY = a.y < b2.y ? a.y < c.y ? a.y : c.y : b2.y < c.y ? b2.y : c.y, maxTX = a.x > b2.x ? a.x > c.x ? a.x : c.x : b2.x > c.x ? b2.x : c.x, maxTY = a.y > b2.y ? a.y > c.y ? a.y : c.y : b2.y > c.y ? b2.y : c.y;
          var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
          var p2 = ear.prevZ, n2 = ear.nextZ;
          while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
            if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
              return false;
            p2 = p2.prevZ;
            if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
              return false;
            n2 = n2.nextZ;
          }
          while (p2 && p2.z >= minZ) {
            if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
              return false;
            p2 = p2.prevZ;
          }
          while (n2 && n2.z <= maxZ) {
            if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
              return false;
            n2 = n2.nextZ;
          }
          return true;
        }
        function cureLocalIntersections(start, triangles, dim) {
          var p2 = start;
          do {
            var a = p2.prev, b2 = p2.next.next;
            if (!equals(a, b2) && intersects(a, p2, p2.next, b2) && locallyInside(a, b2) && locallyInside(b2, a)) {
              triangles.push(a.i / dim);
              triangles.push(p2.i / dim);
              triangles.push(b2.i / dim);
              removeNode(p2);
              removeNode(p2.next);
              p2 = start = b2;
            }
            p2 = p2.next;
          } while (p2 !== start);
          return filterPoints(p2);
        }
        function splitEarcut(start, triangles, dim, minX, minY, invSize) {
          var a = start;
          do {
            var b2 = a.next.next;
            while (b2 !== a.prev) {
              if (a.i !== b2.i && isValidDiagonal(a, b2)) {
                var c = splitPolygon(a, b2);
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
              }
              b2 = b2.next;
            }
            a = a.next;
          } while (a !== start);
        }
        function eliminateHoles(data, holeIndices, outerNode, dim) {
          var queue = [], i2, len, start, end, list;
          for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
            start = holeIndices[i2] * dim;
            end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next)
              list.steiner = true;
            queue.push(getLeftmost(list));
          }
          queue.sort(compareX);
          for (i2 = 0; i2 < queue.length; i2++) {
            eliminateHole(queue[i2], outerNode);
            outerNode = filterPoints(outerNode, outerNode.next);
          }
          return outerNode;
        }
        function compareX(a, b2) {
          return a.x - b2.x;
        }
        function eliminateHole(hole, outerNode) {
          outerNode = findHoleBridge(hole, outerNode);
          if (outerNode) {
            var b2 = splitPolygon(outerNode, hole);
            filterPoints(outerNode, outerNode.next);
            filterPoints(b2, b2.next);
          }
        }
        function findHoleBridge(hole, outerNode) {
          var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
          do {
            if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
              var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
              if (x2 <= hx && x2 > qx) {
                qx = x2;
                if (x2 === hx) {
                  if (hy === p2.y)
                    return p2;
                  if (hy === p2.next.y)
                    return p2.next;
                }
                m2 = p2.x < p2.next.x ? p2 : p2.next;
              }
            }
            p2 = p2.next;
          } while (p2 !== outerNode);
          if (!m2)
            return null;
          if (hx === qx)
            return m2;
          var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
          p2 = m2;
          do {
            if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
              tan = Math.abs(hy - p2.y) / (hx - p2.x);
              if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
                m2 = p2;
                tanMin = tan;
              }
            }
            p2 = p2.next;
          } while (p2 !== stop);
          return m2;
        }
        function sectorContainsSector(m2, p2) {
          return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
        }
        function indexCurve(start, minX, minY, invSize) {
          var p2 = start;
          do {
            if (p2.z === null)
              p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
            p2.prevZ = p2.prev;
            p2.nextZ = p2.next;
            p2 = p2.next;
          } while (p2 !== start);
          p2.prevZ.nextZ = null;
          p2.prevZ = null;
          sortLinked(p2);
        }
        function sortLinked(list) {
          var i2, p2, q2, e, tail, numMerges, pSize, qSize, inSize = 1;
          do {
            p2 = list;
            list = null;
            tail = null;
            numMerges = 0;
            while (p2) {
              numMerges++;
              q2 = p2;
              pSize = 0;
              for (i2 = 0; i2 < inSize; i2++) {
                pSize++;
                q2 = q2.nextZ;
                if (!q2)
                  break;
              }
              qSize = inSize;
              while (pSize > 0 || qSize > 0 && q2) {
                if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
                  e = p2;
                  p2 = p2.nextZ;
                  pSize--;
                } else {
                  e = q2;
                  q2 = q2.nextZ;
                  qSize--;
                }
                if (tail)
                  tail.nextZ = e;
                else
                  list = e;
                e.prevZ = tail;
                tail = e;
              }
              p2 = q2;
            }
            tail.nextZ = null;
            inSize *= 2;
          } while (numMerges > 1);
          return list;
        }
        function zOrder(x2, y2, minX, minY, invSize) {
          x2 = 32767 * (x2 - minX) * invSize;
          y2 = 32767 * (y2 - minY) * invSize;
          x2 = (x2 | x2 << 8) & 16711935;
          x2 = (x2 | x2 << 4) & 252645135;
          x2 = (x2 | x2 << 2) & 858993459;
          x2 = (x2 | x2 << 1) & 1431655765;
          y2 = (y2 | y2 << 8) & 16711935;
          y2 = (y2 | y2 << 4) & 252645135;
          y2 = (y2 | y2 << 2) & 858993459;
          y2 = (y2 | y2 << 1) & 1431655765;
          return x2 | y2 << 1;
        }
        function getLeftmost(start) {
          var p2 = start, leftmost = start;
          do {
            if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
              leftmost = p2;
            p2 = p2.next;
          } while (p2 !== start);
          return leftmost;
        }
        function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
          return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
        }
        function isValidDiagonal(a, b2) {
          return a.next.i !== b2.i && a.prev.i !== b2.i && !intersectsPolygon(a, b2) && (locallyInside(a, b2) && locallyInside(b2, a) && middleInside(a, b2) && (area(a.prev, a, b2.prev) || area(a, b2.prev, b2)) || equals(a, b2) && area(a.prev, a, a.next) > 0 && area(b2.prev, b2, b2.next) > 0);
        }
        function area(p2, q2, r2) {
          return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
        }
        function equals(p1, p2) {
          return p1.x === p2.x && p1.y === p2.y;
        }
        function intersects(p1, q1, p2, q2) {
          var o1 = sign(area(p1, q1, p2));
          var o2 = sign(area(p1, q1, q2));
          var o3 = sign(area(p2, q2, p1));
          var o4 = sign(area(p2, q2, q1));
          if (o1 !== o2 && o3 !== o4)
            return true;
          if (o1 === 0 && onSegment(p1, p2, q1))
            return true;
          if (o2 === 0 && onSegment(p1, q2, q1))
            return true;
          if (o3 === 0 && onSegment(p2, p1, q2))
            return true;
          if (o4 === 0 && onSegment(p2, q1, q2))
            return true;
          return false;
        }
        function onSegment(p2, q2, r2) {
          return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
        }
        function sign(num) {
          return num > 0 ? 1 : num < 0 ? -1 : 0;
        }
        function intersectsPolygon(a, b2) {
          var p2 = a;
          do {
            if (p2.i !== a.i && p2.next.i !== a.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a, b2))
              return true;
            p2 = p2.next;
          } while (p2 !== a);
          return false;
        }
        function locallyInside(a, b2) {
          return area(a.prev, a, a.next) < 0 ? area(a, b2, a.next) >= 0 && area(a, a.prev, b2) >= 0 : area(a, b2, a.prev) < 0 || area(a, a.next, b2) < 0;
        }
        function middleInside(a, b2) {
          var p2 = a, inside = false, px = (a.x + b2.x) / 2, py = (a.y + b2.y) / 2;
          do {
            if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
              inside = !inside;
            p2 = p2.next;
          } while (p2 !== a);
          return inside;
        }
        function splitPolygon(a, b2) {
          var a2 = new Node(a.i, a.x, a.y), b22 = new Node(b2.i, b2.x, b2.y), an = a.next, bp = b2.prev;
          a.next = b2;
          b2.prev = a;
          a2.next = an;
          an.prev = a2;
          b22.next = a2;
          a2.prev = b22;
          bp.next = b22;
          b22.prev = bp;
          return b22;
        }
        function insertNode(i2, x2, y2, last) {
          var p2 = new Node(i2, x2, y2);
          if (!last) {
            p2.prev = p2;
            p2.next = p2;
          } else {
            p2.next = last.next;
            p2.prev = last;
            last.next.prev = p2;
            last.next = p2;
          }
          return p2;
        }
        function removeNode(p2) {
          p2.next.prev = p2.prev;
          p2.prev.next = p2.next;
          if (p2.prevZ)
            p2.prevZ.nextZ = p2.nextZ;
          if (p2.nextZ)
            p2.nextZ.prevZ = p2.prevZ;
        }
        function Node(i2, x2, y2) {
          this.i = i2;
          this.x = x2;
          this.y = y2;
          this.prev = null;
          this.next = null;
          this.z = null;
          this.prevZ = null;
          this.nextZ = null;
          this.steiner = false;
        }
        earcut.deviation = function(data, holeIndices, dim, triangles) {
          var hasHoles = holeIndices && holeIndices.length;
          var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
          var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
          if (hasHoles) {
            for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
              var start = holeIndices[i2] * dim;
              var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
              polygonArea -= Math.abs(signedArea(data, start, end, dim));
            }
          }
          var trianglesArea = 0;
          for (i2 = 0; i2 < triangles.length; i2 += 3) {
            var a = triangles[i2] * dim;
            var b2 = triangles[i2 + 1] * dim;
            var c = triangles[i2 + 2] * dim;
            trianglesArea += Math.abs((data[a] - data[c]) * (data[b2 + 1] - data[a + 1]) - (data[a] - data[b2]) * (data[c + 1] - data[a + 1]));
          }
          return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
        };
        function signedArea(data, start, end, dim) {
          var sum = 0;
          for (var i2 = start, j = end - dim; i2 < end; i2 += dim) {
            sum += (data[j] - data[i2]) * (data[i2 + 1] + data[j + 1]);
            j = i2;
          }
          return sum;
        }
        earcut.flatten = function(data) {
          var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
          for (var i2 = 0; i2 < data.length; i2++) {
            for (var j = 0; j < data[i2].length; j++) {
              for (var d = 0; d < dim; d++)
                result.vertices.push(data[i2][j][d]);
            }
            if (i2 > 0) {
              holeIndex += data[i2 - 1].length;
              result.holes.push(holeIndex);
            }
          }
          return result;
        };
        module2.exports = earcut;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var LineStyleCanvas = function(ctx, src, altColor, altAlpha) {
          var strokeColor = altColor ? altColor : src.strokeColor;
          var strokeAlpha = altAlpha ? altAlpha : src.strokeAlpha;
          var red = (strokeColor & 16711680) >>> 16;
          var green = (strokeColor & 65280) >>> 8;
          var blue = strokeColor & 255;
          ctx.strokeStyle = "rgba(" + red + "," + green + "," + blue + "," + strokeAlpha + ")";
          ctx.lineWidth = src.lineWidth;
        };
        module2.exports = LineStyleCanvas;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var GetValue = __webpack_require__(6);
        var IsPlainObject2 = __webpack_require__(7);
        var JSONFile = new Class({
          Extends: File,
          initialize: function JSONFile2(loader, key, url, xhrSettings, dataKey) {
            var extension = "json";
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
              dataKey = GetFastValue(config, "dataKey", dataKey);
            }
            var fileConfig = {
              type: "json",
              cache: loader.cacheManager.json,
              extension,
              responseType: "text",
              key,
              url,
              xhrSettings,
              config: dataKey
            };
            File.call(this, loader, fileConfig);
            if (IsPlainObject2(url)) {
              if (dataKey) {
                this.data = GetValue(url, dataKey);
              } else {
                this.data = url;
              }
              this.state = CONST.FILE_POPULATED;
            }
          },
          onProcess: function() {
            if (this.state !== CONST.FILE_POPULATED) {
              this.state = CONST.FILE_PROCESSING;
              try {
                var json = JSON.parse(this.xhrLoader.responseText);
              } catch (e) {
                console.warn("Invalid JSON: " + this.key);
                this.onProcessError();
                throw e;
              }
              var key = this.config;
              if (typeof key === "string") {
                this.data = GetValue(json, key, json);
              } else {
                this.data = json;
              }
            }
            this.onProcessComplete();
          }
        });
        FileTypesManager.register("json", function(key, url, dataKey, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new JSONFile(this, key[i2]));
            }
          } else {
            this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));
          }
          return this;
        });
        module2.exports = JSONFile;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = {
          DYNAMIC_BODY: 0,
          STATIC_BODY: 1,
          GROUP: 2,
          TILEMAPLAYER: 3,
          FACING_NONE: 10,
          FACING_UP: 11,
          FACING_DOWN: 12,
          FACING_LEFT: 13,
          FACING_RIGHT: 14
        };
        module2.exports = CONST;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTileAt = __webpack_require__(158);
        var GetTilesWithin = __webpack_require__(26);
        var CalculateFacesWithin = function(tileX, tileY, width, height, layer) {
          var above = null;
          var below = null;
          var left = null;
          var right = null;
          var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
          for (var i2 = 0; i2 < tiles.length; i2++) {
            var tile = tiles[i2];
            if (tile) {
              if (tile.collides) {
                above = GetTileAt(tile.x, tile.y - 1, true, layer);
                below = GetTileAt(tile.x, tile.y + 1, true, layer);
                left = GetTileAt(tile.x - 1, tile.y, true, layer);
                right = GetTileAt(tile.x + 1, tile.y, true, layer);
                tile.faceTop = above && above.collides ? false : true;
                tile.faceBottom = below && below.collides ? false : true;
                tile.faceLeft = left && left.collides ? false : true;
                tile.faceRight = right && right.collides ? false : true;
              } else {
                tile.resetFaces();
              }
            }
          }
        };
        module2.exports = CalculateFacesWithin;
      },
      function(module2, exports2, __webpack_require__) {
        var Vertices = {};
        module2.exports = Vertices;
        var Vector = __webpack_require__(83);
        var Common = __webpack_require__(32);
        (function() {
          Vertices.create = function(points, body) {
            var vertices = [];
            for (var i2 = 0; i2 < points.length; i2++) {
              var point = points[i2], vertex = {
                x: point.x,
                y: point.y,
                index: i2,
                body,
                isInternal: false,
                contact: null,
                offset: null
              };
              vertex.contact = {
                vertex,
                normalImpulse: 0,
                tangentImpulse: 0
              };
              vertices.push(vertex);
            }
            return vertices;
          };
          Vertices.fromPath = function(path, body) {
            var pathPattern = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, points = [];
            path.replace(pathPattern, function(match, x2, y2) {
              points.push({ x: parseFloat(x2), y: parseFloat(y2) });
            });
            return Vertices.create(points, body);
          };
          Vertices.centre = function(vertices) {
            var area = Vertices.area(vertices, true), centre = { x: 0, y: 0 }, cross, temp, j;
            for (var i2 = 0; i2 < vertices.length; i2++) {
              j = (i2 + 1) % vertices.length;
              cross = Vector.cross(vertices[i2], vertices[j]);
              temp = Vector.mult(Vector.add(vertices[i2], vertices[j]), cross);
              centre = Vector.add(centre, temp);
            }
            return Vector.div(centre, 6 * area);
          };
          Vertices.mean = function(vertices) {
            var average = { x: 0, y: 0 };
            for (var i2 = 0; i2 < vertices.length; i2++) {
              average.x += vertices[i2].x;
              average.y += vertices[i2].y;
            }
            return Vector.div(average, vertices.length);
          };
          Vertices.area = function(vertices, signed) {
            var area = 0, j = vertices.length - 1;
            for (var i2 = 0; i2 < vertices.length; i2++) {
              area += (vertices[j].x - vertices[i2].x) * (vertices[j].y + vertices[i2].y);
              j = i2;
            }
            if (signed)
              return area / 2;
            return Math.abs(area) / 2;
          };
          Vertices.inertia = function(vertices, mass) {
            var numerator = 0, denominator = 0, v2 = vertices, cross, j;
            for (var n2 = 0; n2 < v2.length; n2++) {
              j = (n2 + 1) % v2.length;
              cross = Math.abs(Vector.cross(v2[j], v2[n2]));
              numerator += cross * (Vector.dot(v2[j], v2[j]) + Vector.dot(v2[j], v2[n2]) + Vector.dot(v2[n2], v2[n2]));
              denominator += cross;
            }
            return mass / 6 * (numerator / denominator);
          };
          Vertices.translate = function(vertices, vector, scalar) {
            var i2;
            if (scalar) {
              for (i2 = 0; i2 < vertices.length; i2++) {
                vertices[i2].x += vector.x * scalar;
                vertices[i2].y += vector.y * scalar;
              }
            } else {
              for (i2 = 0; i2 < vertices.length; i2++) {
                vertices[i2].x += vector.x;
                vertices[i2].y += vector.y;
              }
            }
            return vertices;
          };
          Vertices.rotate = function(vertices, angle, point) {
            if (angle === 0)
              return;
            var cos = Math.cos(angle), sin = Math.sin(angle);
            for (var i2 = 0; i2 < vertices.length; i2++) {
              var vertice = vertices[i2], dx = vertice.x - point.x, dy = vertice.y - point.y;
              vertice.x = point.x + (dx * cos - dy * sin);
              vertice.y = point.y + (dx * sin + dy * cos);
            }
            return vertices;
          };
          Vertices.contains = function(vertices, point) {
            for (var i2 = 0; i2 < vertices.length; i2++) {
              var vertice = vertices[i2], nextVertice = vertices[(i2 + 1) % vertices.length];
              if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {
                return false;
              }
            }
            return true;
          };
          Vertices.scale = function(vertices, scaleX, scaleY, point) {
            if (scaleX === 1 && scaleY === 1)
              return vertices;
            point = point || Vertices.centre(vertices);
            var vertex, delta;
            for (var i2 = 0; i2 < vertices.length; i2++) {
              vertex = vertices[i2];
              delta = Vector.sub(vertex, point);
              vertices[i2].x = point.x + delta.x * scaleX;
              vertices[i2].y = point.y + delta.y * scaleY;
            }
            return vertices;
          };
          Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {
            if (typeof radius === "number") {
              radius = [radius];
            } else {
              radius = radius || [8];
            }
            quality = typeof quality !== "undefined" ? quality : -1;
            qualityMin = qualityMin || 2;
            qualityMax = qualityMax || 14;
            var newVertices = [];
            for (var i2 = 0; i2 < vertices.length; i2++) {
              var prevVertex = vertices[i2 - 1 >= 0 ? i2 - 1 : vertices.length - 1], vertex = vertices[i2], nextVertex = vertices[(i2 + 1) % vertices.length], currentRadius = radius[i2 < radius.length ? i2 : radius.length - 1];
              if (currentRadius === 0) {
                newVertices.push(vertex);
                continue;
              }
              var prevNormal = Vector.normalise({
                x: vertex.y - prevVertex.y,
                y: prevVertex.x - vertex.x
              });
              var nextNormal = Vector.normalise({
                x: nextVertex.y - vertex.y,
                y: vertex.x - nextVertex.x
              });
              var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)), radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius), midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)), scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));
              var precision = quality;
              if (quality === -1) {
                precision = Math.pow(currentRadius, 0.32) * 1.75;
              }
              precision = Common.clamp(precision, qualityMin, qualityMax);
              if (precision % 2 === 1)
                precision += 1;
              var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)), theta = alpha / precision;
              for (var j = 0; j < precision; j++) {
                newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));
              }
            }
            return newVertices;
          };
          Vertices.clockwiseSort = function(vertices) {
            var centre = Vertices.mean(vertices);
            vertices.sort(function(vertexA, vertexB) {
              return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);
            });
            return vertices;
          };
          Vertices.isConvex = function(vertices) {
            var flag = 0, n2 = vertices.length, i2, j, k2, z2;
            if (n2 < 3)
              return null;
            for (i2 = 0; i2 < n2; i2++) {
              j = (i2 + 1) % n2;
              k2 = (i2 + 2) % n2;
              z2 = (vertices[j].x - vertices[i2].x) * (vertices[k2].y - vertices[j].y);
              z2 -= (vertices[j].y - vertices[i2].y) * (vertices[k2].x - vertices[j].x);
              if (z2 < 0) {
                flag |= 1;
              } else if (z2 > 0) {
                flag |= 2;
              }
              if (flag === 3) {
                return false;
              }
            }
            if (flag !== 0) {
              return true;
            } else {
              return null;
            }
          };
          Vertices.hull = function(vertices) {
            var upper = [], lower = [], vertex, i2;
            vertices = vertices.slice(0);
            vertices.sort(function(vertexA, vertexB) {
              var dx = vertexA.x - vertexB.x;
              return dx !== 0 ? dx : vertexA.y - vertexB.y;
            });
            for (i2 = 0; i2 < vertices.length; i2 += 1) {
              vertex = vertices[i2];
              while (lower.length >= 2 && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {
                lower.pop();
              }
              lower.push(vertex);
            }
            for (i2 = vertices.length - 1; i2 >= 0; i2 -= 1) {
              vertex = vertices[i2];
              while (upper.length >= 2 && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {
                upper.pop();
              }
              upper.push(vertex);
            }
            upper.pop();
            lower.pop();
            return upper.concat(lower);
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Contains = __webpack_require__(66);
        var GetPoint = __webpack_require__(300);
        var GetPoints = __webpack_require__(301);
        var GEOM_CONST = __webpack_require__(56);
        var Random = __webpack_require__(170);
        var Circle = new Class({
          initialize: function Circle2(x2, y2, radius) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (radius === void 0) {
              radius = 0;
            }
            this.type = GEOM_CONST.CIRCLE;
            this.x = x2;
            this.y = y2;
            this._radius = radius;
            this._diameter = radius * 2;
          },
          contains: function(x2, y2) {
            return Contains(this, x2, y2);
          },
          getPoint: function(position, point) {
            return GetPoint(this, position, point);
          },
          getPoints: function(quantity, stepRate, output) {
            return GetPoints(this, quantity, stepRate, output);
          },
          getRandomPoint: function(point) {
            return Random(this, point);
          },
          setTo: function(x2, y2, radius) {
            this.x = x2;
            this.y = y2;
            this._radius = radius;
            this._diameter = radius * 2;
            return this;
          },
          setEmpty: function() {
            this._radius = 0;
            this._diameter = 0;
            return this;
          },
          setPosition: function(x2, y2) {
            if (y2 === void 0) {
              y2 = x2;
            }
            this.x = x2;
            this.y = y2;
            return this;
          },
          isEmpty: function() {
            return this._radius <= 0;
          },
          radius: {
            get: function() {
              return this._radius;
            },
            set: function(value) {
              this._radius = value;
              this._diameter = value * 2;
            }
          },
          diameter: {
            get: function() {
              return this._diameter;
            },
            set: function(value) {
              this._diameter = value;
              this._radius = value * 0.5;
            }
          },
          left: {
            get: function() {
              return this.x - this._radius;
            },
            set: function(value) {
              this.x = value + this._radius;
            }
          },
          right: {
            get: function() {
              return this.x + this._radius;
            },
            set: function(value) {
              this.x = value - this._radius;
            }
          },
          top: {
            get: function() {
              return this.y - this._radius;
            },
            set: function(value) {
              this.y = value + this._radius;
            }
          },
          bottom: {
            get: function() {
              return this.y + this._radius;
            },
            set: function(value) {
              this.y = value - this._radius;
            }
          }
        });
        module2.exports = Circle;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Contains = function(circle, x2, y2) {
          if (circle.radius > 0 && x2 >= circle.left && x2 <= circle.right && y2 >= circle.top && y2 <= circle.bottom) {
            var dx = (circle.x - x2) * (circle.x - x2);
            var dy = (circle.y - y2) * (circle.y - y2);
            return dx + dy <= circle.radius * circle.radius;
          } else {
            return false;
          }
        };
        module2.exports = Contains;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Length = function(line) {
          return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
        };
        module2.exports = Length;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Wrap = function(value, min, max) {
          var range = max - min;
          return min + ((value - min) % range + range) % range;
        };
        module2.exports = Wrap;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Vector3 = __webpack_require__(39);
        var EPSILON = 1e-6;
        var Matrix4 = new Class({
          initialize: function Matrix42(m2) {
            this.val = new Float32Array(16);
            if (m2) {
              this.copy(m2);
            } else {
              this.identity();
            }
          },
          clone: function() {
            return new Matrix4(this);
          },
          set: function(src) {
            return this.copy(src);
          },
          setValues: function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
            var out = this.val;
            out[0] = m00;
            out[1] = m01;
            out[2] = m02;
            out[3] = m03;
            out[4] = m10;
            out[5] = m11;
            out[6] = m12;
            out[7] = m13;
            out[8] = m20;
            out[9] = m21;
            out[10] = m22;
            out[11] = m23;
            out[12] = m30;
            out[13] = m31;
            out[14] = m32;
            out[15] = m33;
            return this;
          },
          copy: function(src) {
            var a = src.val;
            return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
          },
          fromArray: function(a) {
            return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
          },
          zero: function() {
            return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          },
          transform: function(position, scale, rotation) {
            var rotMatrix = _tempMat1.fromQuat(rotation);
            var rm = rotMatrix.val;
            var sx = scale.x;
            var sy = scale.y;
            var sz = scale.z;
            return this.setValues(rm[0] * sx, rm[1] * sx, rm[2] * sx, 0, rm[4] * sy, rm[5] * sy, rm[6] * sy, 0, rm[8] * sz, rm[9] * sz, rm[10] * sz, 0, position.x, position.y, position.z, 1);
          },
          xyz: function(x2, y2, z2) {
            this.identity();
            var out = this.val;
            out[12] = x2;
            out[13] = y2;
            out[14] = z2;
            return this;
          },
          scaling: function(x2, y2, z2) {
            this.zero();
            var out = this.val;
            out[0] = x2;
            out[5] = y2;
            out[10] = z2;
            out[15] = 1;
            return this;
          },
          identity: function() {
            return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          },
          transpose: function() {
            var a = this.val;
            var a01 = a[1];
            var a02 = a[2];
            var a03 = a[3];
            var a12 = a[6];
            var a13 = a[7];
            var a23 = a[11];
            a[1] = a[4];
            a[2] = a[8];
            a[3] = a[12];
            a[4] = a01;
            a[6] = a[9];
            a[7] = a[13];
            a[8] = a02;
            a[9] = a12;
            a[11] = a[14];
            a[12] = a03;
            a[13] = a13;
            a[14] = a23;
            return this;
          },
          getInverse: function(m2) {
            this.copy(m2);
            return this.invert();
          },
          invert: function() {
            var a = this.val;
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a03 = a[3];
            var a10 = a[4];
            var a11 = a[5];
            var a12 = a[6];
            var a13 = a[7];
            var a20 = a[8];
            var a21 = a[9];
            var a22 = a[10];
            var a23 = a[11];
            var a30 = a[12];
            var a31 = a[13];
            var a32 = a[14];
            var a33 = a[15];
            var b00 = a00 * a11 - a01 * a10;
            var b01 = a00 * a12 - a02 * a10;
            var b02 = a00 * a13 - a03 * a10;
            var b03 = a01 * a12 - a02 * a11;
            var b04 = a01 * a13 - a03 * a11;
            var b05 = a02 * a13 - a03 * a12;
            var b06 = a20 * a31 - a21 * a30;
            var b07 = a20 * a32 - a22 * a30;
            var b08 = a20 * a33 - a23 * a30;
            var b09 = a21 * a32 - a22 * a31;
            var b10 = a21 * a33 - a23 * a31;
            var b11 = a22 * a33 - a23 * a32;
            var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            if (!det) {
              return this;
            }
            det = 1 / det;
            return this.setValues((a11 * b11 - a12 * b10 + a13 * b09) * det, (a02 * b10 - a01 * b11 - a03 * b09) * det, (a31 * b05 - a32 * b04 + a33 * b03) * det, (a22 * b04 - a21 * b05 - a23 * b03) * det, (a12 * b08 - a10 * b11 - a13 * b07) * det, (a00 * b11 - a02 * b08 + a03 * b07) * det, (a32 * b02 - a30 * b05 - a33 * b01) * det, (a20 * b05 - a22 * b02 + a23 * b01) * det, (a10 * b10 - a11 * b08 + a13 * b06) * det, (a01 * b08 - a00 * b10 - a03 * b06) * det, (a30 * b04 - a31 * b02 + a33 * b00) * det, (a21 * b02 - a20 * b04 - a23 * b00) * det, (a11 * b07 - a10 * b09 - a12 * b06) * det, (a00 * b09 - a01 * b07 + a02 * b06) * det, (a31 * b01 - a30 * b03 - a32 * b00) * det, (a20 * b03 - a21 * b01 + a22 * b00) * det);
          },
          adjoint: function() {
            var a = this.val;
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a03 = a[3];
            var a10 = a[4];
            var a11 = a[5];
            var a12 = a[6];
            var a13 = a[7];
            var a20 = a[8];
            var a21 = a[9];
            var a22 = a[10];
            var a23 = a[11];
            var a30 = a[12];
            var a31 = a[13];
            var a32 = a[14];
            var a33 = a[15];
            return this.setValues(a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22), -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22)), a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12), -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12)), -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22)), a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22), -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12)), a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12), a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21), -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21)), a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11), -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11)), -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21)), a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21), -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11)), a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
          },
          determinant: function() {
            var a = this.val;
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a03 = a[3];
            var a10 = a[4];
            var a11 = a[5];
            var a12 = a[6];
            var a13 = a[7];
            var a20 = a[8];
            var a21 = a[9];
            var a22 = a[10];
            var a23 = a[11];
            var a30 = a[12];
            var a31 = a[13];
            var a32 = a[14];
            var a33 = a[15];
            var b00 = a00 * a11 - a01 * a10;
            var b01 = a00 * a12 - a02 * a10;
            var b02 = a00 * a13 - a03 * a10;
            var b03 = a01 * a12 - a02 * a11;
            var b04 = a01 * a13 - a03 * a11;
            var b05 = a02 * a13 - a03 * a12;
            var b06 = a20 * a31 - a21 * a30;
            var b07 = a20 * a32 - a22 * a30;
            var b08 = a20 * a33 - a23 * a30;
            var b09 = a21 * a32 - a22 * a31;
            var b10 = a21 * a33 - a23 * a31;
            var b11 = a22 * a33 - a23 * a32;
            return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          },
          multiply: function(src) {
            var a = this.val;
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a03 = a[3];
            var a10 = a[4];
            var a11 = a[5];
            var a12 = a[6];
            var a13 = a[7];
            var a20 = a[8];
            var a21 = a[9];
            var a22 = a[10];
            var a23 = a[11];
            var a30 = a[12];
            var a31 = a[13];
            var a32 = a[14];
            var a33 = a[15];
            var b2 = src.val;
            var b0 = b2[0];
            var b1 = b2[1];
            var b22 = b2[2];
            var b3 = b2[3];
            a[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
            a[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
            a[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
            a[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
            b0 = b2[4];
            b1 = b2[5];
            b22 = b2[6];
            b3 = b2[7];
            a[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
            a[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
            a[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
            a[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
            b0 = b2[8];
            b1 = b2[9];
            b22 = b2[10];
            b3 = b2[11];
            a[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
            a[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
            a[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
            a[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
            b0 = b2[12];
            b1 = b2[13];
            b22 = b2[14];
            b3 = b2[15];
            a[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
            a[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
            a[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
            a[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
            return this;
          },
          multiplyLocal: function(src) {
            var a = this.val;
            var b2 = src.val;
            return this.setValues(a[0] * b2[0] + a[1] * b2[4] + a[2] * b2[8] + a[3] * b2[12], a[0] * b2[1] + a[1] * b2[5] + a[2] * b2[9] + a[3] * b2[13], a[0] * b2[2] + a[1] * b2[6] + a[2] * b2[10] + a[3] * b2[14], a[0] * b2[3] + a[1] * b2[7] + a[2] * b2[11] + a[3] * b2[15], a[4] * b2[0] + a[5] * b2[4] + a[6] * b2[8] + a[7] * b2[12], a[4] * b2[1] + a[5] * b2[5] + a[6] * b2[9] + a[7] * b2[13], a[4] * b2[2] + a[5] * b2[6] + a[6] * b2[10] + a[7] * b2[14], a[4] * b2[3] + a[5] * b2[7] + a[6] * b2[11] + a[7] * b2[15], a[8] * b2[0] + a[9] * b2[4] + a[10] * b2[8] + a[11] * b2[12], a[8] * b2[1] + a[9] * b2[5] + a[10] * b2[9] + a[11] * b2[13], a[8] * b2[2] + a[9] * b2[6] + a[10] * b2[10] + a[11] * b2[14], a[8] * b2[3] + a[9] * b2[7] + a[10] * b2[11] + a[11] * b2[15], a[12] * b2[0] + a[13] * b2[4] + a[14] * b2[8] + a[15] * b2[12], a[12] * b2[1] + a[13] * b2[5] + a[14] * b2[9] + a[15] * b2[13], a[12] * b2[2] + a[13] * b2[6] + a[14] * b2[10] + a[15] * b2[14], a[12] * b2[3] + a[13] * b2[7] + a[14] * b2[11] + a[15] * b2[15]);
          },
          premultiply: function(m2) {
            return this.multiplyMatrices(m2, this);
          },
          multiplyMatrices: function(a, b2) {
            var am = a.val;
            var bm = b2.val;
            var a11 = am[0];
            var a12 = am[4];
            var a13 = am[8];
            var a14 = am[12];
            var a21 = am[1];
            var a22 = am[5];
            var a23 = am[9];
            var a24 = am[13];
            var a31 = am[2];
            var a32 = am[6];
            var a33 = am[10];
            var a34 = am[14];
            var a41 = am[3];
            var a42 = am[7];
            var a43 = am[11];
            var a44 = am[15];
            var b11 = bm[0];
            var b12 = bm[4];
            var b13 = bm[8];
            var b14 = bm[12];
            var b21 = bm[1];
            var b22 = bm[5];
            var b23 = bm[9];
            var b24 = bm[13];
            var b31 = bm[2];
            var b32 = bm[6];
            var b33 = bm[10];
            var b34 = bm[14];
            var b41 = bm[3];
            var b42 = bm[7];
            var b43 = bm[11];
            var b44 = bm[15];
            return this.setValues(a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41, a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41, a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41, a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41, a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42, a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42, a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42, a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42, a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43, a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43, a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43, a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43, a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44, a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44, a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44, a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44);
          },
          translate: function(v2) {
            return this.translateXYZ(v2.x, v2.y, v2.z);
          },
          translateXYZ: function(x2, y2, z2) {
            var a = this.val;
            a[12] = a[0] * x2 + a[4] * y2 + a[8] * z2 + a[12];
            a[13] = a[1] * x2 + a[5] * y2 + a[9] * z2 + a[13];
            a[14] = a[2] * x2 + a[6] * y2 + a[10] * z2 + a[14];
            a[15] = a[3] * x2 + a[7] * y2 + a[11] * z2 + a[15];
            return this;
          },
          scale: function(v2) {
            return this.scaleXYZ(v2.x, v2.y, v2.z);
          },
          scaleXYZ: function(x2, y2, z2) {
            var a = this.val;
            a[0] = a[0] * x2;
            a[1] = a[1] * x2;
            a[2] = a[2] * x2;
            a[3] = a[3] * x2;
            a[4] = a[4] * y2;
            a[5] = a[5] * y2;
            a[6] = a[6] * y2;
            a[7] = a[7] * y2;
            a[8] = a[8] * z2;
            a[9] = a[9] * z2;
            a[10] = a[10] * z2;
            a[11] = a[11] * z2;
            return this;
          },
          makeRotationAxis: function(axis, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var t2 = 1 - c;
            var x2 = axis.x;
            var y2 = axis.y;
            var z2 = axis.z;
            var tx = t2 * x2;
            var ty = t2 * y2;
            return this.setValues(tx * x2 + c, tx * y2 - s * z2, tx * z2 + s * y2, 0, tx * y2 + s * z2, ty * y2 + c, ty * z2 - s * x2, 0, tx * z2 - s * y2, ty * z2 + s * x2, t2 * z2 * z2 + c, 0, 0, 0, 0, 1);
          },
          rotate: function(rad, axis) {
            var a = this.val;
            var x2 = axis.x;
            var y2 = axis.y;
            var z2 = axis.z;
            var len = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
            if (Math.abs(len) < EPSILON) {
              return this;
            }
            len = 1 / len;
            x2 *= len;
            y2 *= len;
            z2 *= len;
            var s = Math.sin(rad);
            var c = Math.cos(rad);
            var t2 = 1 - c;
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a03 = a[3];
            var a10 = a[4];
            var a11 = a[5];
            var a12 = a[6];
            var a13 = a[7];
            var a20 = a[8];
            var a21 = a[9];
            var a22 = a[10];
            var a23 = a[11];
            var a30 = a[12];
            var a31 = a[13];
            var a32 = a[14];
            var a33 = a[15];
            var b00 = x2 * x2 * t2 + c;
            var b01 = y2 * x2 * t2 + z2 * s;
            var b02 = z2 * x2 * t2 - y2 * s;
            var b10 = x2 * y2 * t2 - z2 * s;
            var b11 = y2 * y2 * t2 + c;
            var b12 = z2 * y2 * t2 + x2 * s;
            var b20 = x2 * z2 * t2 + y2 * s;
            var b21 = y2 * z2 * t2 - x2 * s;
            var b22 = z2 * z2 * t2 + c;
            return this.setValues(a00 * b00 + a10 * b01 + a20 * b02, a01 * b00 + a11 * b01 + a21 * b02, a02 * b00 + a12 * b01 + a22 * b02, a03 * b00 + a13 * b01 + a23 * b02, a00 * b10 + a10 * b11 + a20 * b12, a01 * b10 + a11 * b11 + a21 * b12, a02 * b10 + a12 * b11 + a22 * b12, a03 * b10 + a13 * b11 + a23 * b12, a00 * b20 + a10 * b21 + a20 * b22, a01 * b20 + a11 * b21 + a21 * b22, a02 * b20 + a12 * b21 + a22 * b22, a03 * b20 + a13 * b21 + a23 * b22, a30, a31, a32, a33);
          },
          rotateX: function(rad) {
            var a = this.val;
            var s = Math.sin(rad);
            var c = Math.cos(rad);
            var a10 = a[4];
            var a11 = a[5];
            var a12 = a[6];
            var a13 = a[7];
            var a20 = a[8];
            var a21 = a[9];
            var a22 = a[10];
            var a23 = a[11];
            a[4] = a10 * c + a20 * s;
            a[5] = a11 * c + a21 * s;
            a[6] = a12 * c + a22 * s;
            a[7] = a13 * c + a23 * s;
            a[8] = a20 * c - a10 * s;
            a[9] = a21 * c - a11 * s;
            a[10] = a22 * c - a12 * s;
            a[11] = a23 * c - a13 * s;
            return this;
          },
          rotateY: function(rad) {
            var a = this.val;
            var s = Math.sin(rad);
            var c = Math.cos(rad);
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a03 = a[3];
            var a20 = a[8];
            var a21 = a[9];
            var a22 = a[10];
            var a23 = a[11];
            a[0] = a00 * c - a20 * s;
            a[1] = a01 * c - a21 * s;
            a[2] = a02 * c - a22 * s;
            a[3] = a03 * c - a23 * s;
            a[8] = a00 * s + a20 * c;
            a[9] = a01 * s + a21 * c;
            a[10] = a02 * s + a22 * c;
            a[11] = a03 * s + a23 * c;
            return this;
          },
          rotateZ: function(rad) {
            var a = this.val;
            var s = Math.sin(rad);
            var c = Math.cos(rad);
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a03 = a[3];
            var a10 = a[4];
            var a11 = a[5];
            var a12 = a[6];
            var a13 = a[7];
            a[0] = a00 * c + a10 * s;
            a[1] = a01 * c + a11 * s;
            a[2] = a02 * c + a12 * s;
            a[3] = a03 * c + a13 * s;
            a[4] = a10 * c - a00 * s;
            a[5] = a11 * c - a01 * s;
            a[6] = a12 * c - a02 * s;
            a[7] = a13 * c - a03 * s;
            return this;
          },
          fromRotationTranslation: function(q2, v2) {
            var x2 = q2.x;
            var y2 = q2.y;
            var z2 = q2.z;
            var w2 = q2.w;
            var x22 = x2 + x2;
            var y22 = y2 + y2;
            var z22 = z2 + z2;
            var xx = x2 * x22;
            var xy = x2 * y22;
            var xz = x2 * z22;
            var yy = y2 * y22;
            var yz = y2 * z22;
            var zz = z2 * z22;
            var wx = w2 * x22;
            var wy = w2 * y22;
            var wz = w2 * z22;
            return this.setValues(1 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1 - (xx + yy), 0, v2.x, v2.y, v2.z, 1);
          },
          fromQuat: function(q2) {
            var x2 = q2.x;
            var y2 = q2.y;
            var z2 = q2.z;
            var w2 = q2.w;
            var x22 = x2 + x2;
            var y22 = y2 + y2;
            var z22 = z2 + z2;
            var xx = x2 * x22;
            var xy = x2 * y22;
            var xz = x2 * z22;
            var yy = y2 * y22;
            var yz = y2 * z22;
            var zz = z2 * z22;
            var wx = w2 * x22;
            var wy = w2 * y22;
            var wz = w2 * z22;
            return this.setValues(1 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1 - (xx + yy), 0, 0, 0, 0, 1);
          },
          frustum: function(left, right, bottom, top, near, far) {
            var rl2 = 1 / (right - left);
            var tb2 = 1 / (top - bottom);
            var nf2 = 1 / (near - far);
            return this.setValues(near * 2 * rl2, 0, 0, 0, 0, near * 2 * tb2, 0, 0, (right + left) * rl2, (top + bottom) * tb2, (far + near) * nf2, -1, 0, 0, far * near * 2 * nf2, 0);
          },
          perspective: function(fovy, aspect, near, far) {
            var f2 = 1 / Math.tan(fovy / 2);
            var nf2 = 1 / (near - far);
            return this.setValues(f2 / aspect, 0, 0, 0, 0, f2, 0, 0, 0, 0, (far + near) * nf2, -1, 0, 0, 2 * far * near * nf2, 0);
          },
          perspectiveLH: function(width, height, near, far) {
            return this.setValues(2 * near / width, 0, 0, 0, 0, 2 * near / height, 0, 0, 0, 0, -far / (near - far), 1, 0, 0, near * far / (near - far), 0);
          },
          ortho: function(left, right, bottom, top, near, far) {
            var lr = left - right;
            var bt = bottom - top;
            var nf2 = near - far;
            lr = lr === 0 ? lr : 1 / lr;
            bt = bt === 0 ? bt : 1 / bt;
            nf2 = nf2 === 0 ? nf2 : 1 / nf2;
            return this.setValues(-2 * lr, 0, 0, 0, 0, -2 * bt, 0, 0, 0, 0, 2 * nf2, 0, (left + right) * lr, (top + bottom) * bt, (far + near) * nf2, 1);
          },
          lookAtRH: function(eye, target, up) {
            var m2 = this.val;
            _z.subVectors(eye, target);
            if (_z.getLengthSquared() === 0) {
              _z.z = 1;
            }
            _z.normalize();
            _x.crossVectors(up, _z);
            if (_x.getLengthSquared() === 0) {
              if (Math.abs(up.z) === 1) {
                _z.x += 1e-4;
              } else {
                _z.z += 1e-4;
              }
              _z.normalize();
              _x.crossVectors(up, _z);
            }
            _x.normalize();
            _y.crossVectors(_z, _x);
            m2[0] = _x.x;
            m2[1] = _x.y;
            m2[2] = _x.z;
            m2[4] = _y.x;
            m2[5] = _y.y;
            m2[6] = _y.z;
            m2[8] = _z.x;
            m2[9] = _z.y;
            m2[10] = _z.z;
            return this;
          },
          lookAt: function(eye, center, up) {
            var eyex = eye.x;
            var eyey = eye.y;
            var eyez = eye.z;
            var upx = up.x;
            var upy = up.y;
            var upz = up.z;
            var centerx = center.x;
            var centery = center.y;
            var centerz = center.z;
            if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
              return this.identity();
            }
            var z0 = eyex - centerx;
            var z1 = eyey - centery;
            var z2 = eyez - centerz;
            var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            z0 *= len;
            z1 *= len;
            z2 *= len;
            var x0 = upy * z2 - upz * z1;
            var x1 = upz * z0 - upx * z2;
            var x2 = upx * z1 - upy * z0;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            if (!len) {
              x0 = 0;
              x1 = 0;
              x2 = 0;
            } else {
              len = 1 / len;
              x0 *= len;
              x1 *= len;
              x2 *= len;
            }
            var y0 = z1 * x2 - z2 * x1;
            var y1 = z2 * x0 - z0 * x2;
            var y2 = z0 * x1 - z1 * x0;
            len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
            if (!len) {
              y0 = 0;
              y1 = 0;
              y2 = 0;
            } else {
              len = 1 / len;
              y0 *= len;
              y1 *= len;
              y2 *= len;
            }
            return this.setValues(x0, y0, z0, 0, x1, y1, z1, 0, x2, y2, z2, 0, -(x0 * eyex + x1 * eyey + x2 * eyez), -(y0 * eyex + y1 * eyey + y2 * eyez), -(z0 * eyex + z1 * eyey + z2 * eyez), 1);
          },
          yawPitchRoll: function(yaw, pitch, roll) {
            this.zero();
            _tempMat1.zero();
            _tempMat2.zero();
            var m0 = this.val;
            var m1 = _tempMat1.val;
            var m2 = _tempMat2.val;
            var s = Math.sin(roll);
            var c = Math.cos(roll);
            m0[10] = 1;
            m0[15] = 1;
            m0[0] = c;
            m0[1] = s;
            m0[4] = -s;
            m0[5] = c;
            s = Math.sin(pitch);
            c = Math.cos(pitch);
            m1[0] = 1;
            m1[15] = 1;
            m1[5] = c;
            m1[10] = c;
            m1[9] = -s;
            m1[6] = s;
            s = Math.sin(yaw);
            c = Math.cos(yaw);
            m2[5] = 1;
            m2[15] = 1;
            m2[0] = c;
            m2[2] = -s;
            m2[8] = s;
            m2[10] = c;
            this.multiplyLocal(_tempMat1);
            this.multiplyLocal(_tempMat2);
            return this;
          },
          setWorldMatrix: function(rotation, position, scale, viewMatrix, projectionMatrix) {
            this.yawPitchRoll(rotation.y, rotation.x, rotation.z);
            _tempMat1.scaling(scale.x, scale.y, scale.z);
            _tempMat2.xyz(position.x, position.y, position.z);
            this.multiplyLocal(_tempMat1);
            this.multiplyLocal(_tempMat2);
            if (viewMatrix) {
              this.multiplyLocal(viewMatrix);
            }
            if (projectionMatrix) {
              this.multiplyLocal(projectionMatrix);
            }
            return this;
          },
          multiplyToMat4: function(src, out) {
            var a = this.val;
            var b2 = src.val;
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a03 = a[3];
            var a10 = a[4];
            var a11 = a[5];
            var a12 = a[6];
            var a13 = a[7];
            var a20 = a[8];
            var a21 = a[9];
            var a22 = a[10];
            var a23 = a[11];
            var a30 = a[12];
            var a31 = a[13];
            var a32 = a[14];
            var a33 = a[15];
            var b00 = b2[0];
            var b01 = b2[1];
            var b02 = b2[2];
            var b03 = b2[3];
            var b10 = b2[4];
            var b11 = b2[5];
            var b12 = b2[6];
            var b13 = b2[7];
            var b20 = b2[8];
            var b21 = b2[9];
            var b22 = b2[10];
            var b23 = b2[11];
            var b30 = b2[12];
            var b31 = b2[13];
            var b32 = b2[14];
            var b33 = b2[15];
            return out.setValues(b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30, b01 * a01 + b01 * a11 + b02 * a21 + b03 * a31, b02 * a02 + b01 * a12 + b02 * a22 + b03 * a32, b03 * a03 + b01 * a13 + b02 * a23 + b03 * a33, b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30, b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31, b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32, b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33, b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30, b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31, b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32, b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33, b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30, b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31, b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32, b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33);
          },
          fromRotationXYTranslation: function(rotation, position, translateFirst) {
            var x2 = position.x;
            var y2 = position.y;
            var z2 = position.z;
            var sx = Math.sin(rotation.x);
            var cx = Math.cos(rotation.x);
            var sy = Math.sin(rotation.y);
            var cy = Math.cos(rotation.y);
            var a30 = x2;
            var a31 = y2;
            var a32 = z2;
            var b21 = -sx;
            var c01 = 0 - b21 * sy;
            var c02 = 0 - cx * sy;
            var c21 = b21 * cy;
            var c22 = cx * cy;
            if (!translateFirst) {
              a30 = cy * x2 + sy * z2;
              a31 = c01 * x2 + cx * y2 + c21 * z2;
              a32 = c02 * x2 + sx * y2 + c22 * z2;
            }
            return this.setValues(cy, c01, c02, 0, 0, cx, sx, 0, sy, c21, c22, 0, a30, a31, a32, 1);
          },
          getMaxScaleOnAxis: function() {
            var m2 = this.val;
            var scaleXSq = m2[0] * m2[0] + m2[1] * m2[1] + m2[2] * m2[2];
            var scaleYSq = m2[4] * m2[4] + m2[5] * m2[5] + m2[6] * m2[6];
            var scaleZSq = m2[8] * m2[8] + m2[9] * m2[9] + m2[10] * m2[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
          }
        });
        var _tempMat1 = new Matrix4();
        var _tempMat2 = new Matrix4();
        var _x = new Vector3();
        var _y = new Vector3();
        var _z = new Vector3();
        module2.exports = Matrix4;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          COMPLETE: __webpack_require__(987),
          DECODED: __webpack_require__(988),
          DECODED_ALL: __webpack_require__(989),
          DESTROY: __webpack_require__(990),
          DETUNE: __webpack_require__(991),
          GLOBAL_DETUNE: __webpack_require__(992),
          GLOBAL_MUTE: __webpack_require__(993),
          GLOBAL_RATE: __webpack_require__(994),
          GLOBAL_VOLUME: __webpack_require__(995),
          LOOP: __webpack_require__(996),
          LOOPED: __webpack_require__(997),
          MUTE: __webpack_require__(998),
          PAN: __webpack_require__(999),
          PAUSE_ALL: __webpack_require__(1e3),
          PAUSE: __webpack_require__(1001),
          PLAY: __webpack_require__(1002),
          RATE: __webpack_require__(1003),
          RESUME_ALL: __webpack_require__(1004),
          RESUME: __webpack_require__(1005),
          SEEK: __webpack_require__(1006),
          STOP_ALL: __webpack_require__(1007),
          STOP: __webpack_require__(1008),
          UNLOCKED: __webpack_require__(1009),
          VOLUME: __webpack_require__(1010)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var ImageFile = new Class({
          Extends: File,
          initialize: function ImageFile2(loader, key, url, xhrSettings, frameConfig) {
            var extension = "png";
            var normalMapURL;
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              normalMapURL = GetFastValue(config, "normalMap");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
              frameConfig = GetFastValue(config, "frameConfig");
            }
            if (Array.isArray(url)) {
              normalMapURL = url[1];
              url = url[0];
            }
            var fileConfig = {
              type: "image",
              cache: loader.textureManager,
              extension,
              responseType: "blob",
              key,
              url,
              xhrSettings,
              config: frameConfig
            };
            File.call(this, loader, fileConfig);
            if (normalMapURL) {
              var normalMap = new ImageFile2(loader, this.key, normalMapURL, xhrSettings, frameConfig);
              normalMap.type = "normalMap";
              this.setLink(normalMap);
              loader.addFile(normalMap);
            }
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            this.data = new Image();
            this.data.crossOrigin = this.crossOrigin;
            var _this = this;
            this.data.onload = function() {
              File.revokeObjectURL(_this.data);
              _this.onProcessComplete();
            };
            this.data.onerror = function() {
              File.revokeObjectURL(_this.data);
              _this.onProcessError();
            };
            File.createObjectURL(this.data, this.xhrLoader.response, "image/png");
          },
          addToCache: function() {
            var texture;
            var linkFile = this.linkFile;
            if (linkFile && linkFile.state === CONST.FILE_COMPLETE) {
              if (this.type === "image") {
                texture = this.cache.addImage(this.key, this.data, linkFile.data);
              } else {
                texture = this.cache.addImage(linkFile.key, linkFile.data, this.data);
              }
              this.pendingDestroy(texture);
              linkFile.pendingDestroy(texture);
            } else if (!linkFile) {
              texture = this.cache.addImage(this.key, this.data);
              this.pendingDestroy(texture);
            }
          }
        });
        FileTypesManager.register("image", function(key, url, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new ImageFile(this, key[i2]));
            }
          } else {
            this.addFile(new ImageFile(this, key, url, xhrSettings));
          }
          return this;
        });
        module2.exports = ImageFile;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetTileCollision = function(tile, collides) {
          if (collides) {
            tile.setCollision(true, true, true, true, false);
          } else {
            tile.resetCollision(false);
          }
        };
        module2.exports = SetTileCollision;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AnimationState = __webpack_require__(164);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var GameObject = __webpack_require__(15);
        var SpriteRender = __webpack_require__(1065);
        var Sprite = new Class({
          Extends: GameObject,
          Mixins: [
            Components.Alpha,
            Components.BlendMode,
            Components.Depth,
            Components.Flip,
            Components.GetBounds,
            Components.Mask,
            Components.Origin,
            Components.Pipeline,
            Components.ScrollFactor,
            Components.Size,
            Components.TextureCrop,
            Components.Tint,
            Components.Transform,
            Components.Visible,
            SpriteRender
          ],
          initialize: function Sprite2(scene, x2, y2, texture, frame) {
            GameObject.call(this, scene, "Sprite");
            this._crop = this.resetCropObject();
            this.anims = new AnimationState(this);
            this.setTexture(texture, frame);
            this.setPosition(x2, y2);
            this.setSizeToFrame();
            this.setOriginFromFrame();
            this.initPipeline();
          },
          addedToScene: function() {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function() {
            this.scene.sys.updateList.remove(this);
          },
          preUpdate: function(time, delta) {
            this.anims.update(time, delta);
          },
          play: function(key, ignoreIfPlaying) {
            return this.anims.play(key, ignoreIfPlaying);
          },
          playReverse: function(key, ignoreIfPlaying) {
            return this.anims.playReverse(key, ignoreIfPlaying);
          },
          playAfterDelay: function(key, delay) {
            return this.anims.playAfterDelay(key, delay);
          },
          playAfterRepeat: function(key, repeatCount) {
            return this.anims.playAfterRepeat(key, repeatCount);
          },
          chain: function(key) {
            return this.anims.chain(key);
          },
          stop: function() {
            return this.anims.stop();
          },
          stopAfterDelay: function(delay) {
            return this.anims.stopAfterDelay(delay);
          },
          stopAfterRepeat: function(repeatCount) {
            return this.anims.stopAfterRepeat(repeatCount);
          },
          stopOnFrame: function(frame) {
            return this.anims.stopOnFrame(frame);
          },
          toJSON: function() {
            return Components.ToJSON(this);
          },
          preDestroy: function() {
            this.anims.destroy();
            this.anims = void 0;
          }
        });
        module2.exports = Sprite;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SpliceOne = function(array, index2) {
          if (index2 >= array.length) {
            return;
          }
          var len = array.length - 1;
          var item = array[index2];
          for (var i2 = index2; i2 < len; i2++) {
            array[i2] = array[i2 + 1];
          }
          array.length = len;
          return item;
        };
        module2.exports = SpliceOne;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          ADDED_TO_SCENE: __webpack_require__(643),
          DESTROY: __webpack_require__(644),
          REMOVED_FROM_SCENE: __webpack_require__(645),
          VIDEO_COMPLETE: __webpack_require__(646),
          VIDEO_CREATED: __webpack_require__(647),
          VIDEO_ERROR: __webpack_require__(648),
          VIDEO_LOOP: __webpack_require__(649),
          VIDEO_PLAY: __webpack_require__(650),
          VIDEO_SEEKED: __webpack_require__(651),
          VIDEO_SEEKING: __webpack_require__(652),
          VIDEO_STOP: __webpack_require__(653),
          VIDEO_TIMEOUT: __webpack_require__(654),
          VIDEO_UNLOCKED: __webpack_require__(655)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SnapFloor = function(value, gap, start, divide) {
          if (start === void 0) {
            start = 0;
          }
          if (gap === 0) {
            return value;
          }
          value -= start;
          value = gap * Math.floor(value / gap);
          return divide ? (start + value) / gap : start + value;
        };
        module2.exports = SnapFloor;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clone = function(obj) {
          var clone = {};
          for (var key in obj) {
            if (Array.isArray(obj[key])) {
              clone[key] = obj[key].slice(0);
            } else {
              clone[key] = obj[key];
            }
          }
          return clone;
        };
        module2.exports = Clone;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SafeRange = function(array, startIndex, endIndex, throwError) {
          var len = array.length;
          if (startIndex < 0 || startIndex > len || startIndex >= endIndex || endIndex > len || startIndex + endIndex > len) {
            if (throwError) {
              throw new Error("Range Error: Values outside acceptable range");
            }
            return false;
          } else {
            return true;
          }
        };
        module2.exports = SafeRange;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Angry Bytes (and contributors)
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        function Compare(a, b2) {
          return String(a).localeCompare(b2);
        }
        function Process(array, compare) {
          var len = array.length;
          if (len <= 1) {
            return array;
          }
          var buffer = new Array(len);
          for (var chk = 1; chk < len; chk *= 2) {
            RunPass(array, compare, chk, buffer);
            var tmp = array;
            array = buffer;
            buffer = tmp;
          }
          return array;
        }
        function RunPass(arr, comp, chk, result) {
          var len = arr.length;
          var i2 = 0;
          var dbl = chk * 2;
          var l2, r2, e;
          var li2, ri2;
          for (l2 = 0; l2 < len; l2 += dbl) {
            r2 = l2 + chk;
            e = r2 + chk;
            if (r2 > len) {
              r2 = len;
            }
            if (e > len) {
              e = len;
            }
            li2 = l2;
            ri2 = r2;
            while (true) {
              if (li2 < r2 && ri2 < e) {
                if (comp(arr[li2], arr[ri2]) <= 0) {
                  result[i2++] = arr[li2++];
                } else {
                  result[i2++] = arr[ri2++];
                }
              } else if (li2 < r2) {
                result[i2++] = arr[li2++];
              } else if (ri2 < e) {
                result[i2++] = arr[ri2++];
              } else {
                break;
              }
            }
          }
        }
        var StableSort = function(array, compare) {
          if (compare === void 0) {
            compare = Compare;
          }
          var result = Process(array, compare);
          if (result !== array) {
            RunPass(result, null, array.length, array);
          }
          return array;
        };
        module2.exports = StableSort;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var EaseMap = __webpack_require__(134);
        var UppercaseFirst = __webpack_require__(205);
        var GetEaseFunction = function(ease, easeParams) {
          var easeFunction = EaseMap.Power0;
          if (typeof ease === "string") {
            if (EaseMap.hasOwnProperty(ease)) {
              easeFunction = EaseMap[ease];
            } else {
              var direction = "";
              if (ease.indexOf(".")) {
                direction = ease.substr(ease.indexOf(".") + 1);
                if (direction.toLowerCase() === "in") {
                  direction = "easeIn";
                } else if (direction.toLowerCase() === "out") {
                  direction = "easeOut";
                } else if (direction.toLowerCase() === "inout") {
                  direction = "easeInOut";
                }
              }
              ease = UppercaseFirst(ease.substr(0, ease.indexOf(".") + 1) + direction);
              if (EaseMap.hasOwnProperty(ease)) {
                easeFunction = EaseMap[ease];
              }
            }
          } else if (typeof ease === "function") {
            easeFunction = ease;
          } else if (Array.isArray(ease) && ease.length === 4)
            ;
          if (!easeParams) {
            return easeFunction;
          }
          var cloneParams = easeParams.slice(0);
          cloneParams.unshift(0);
          return function(v2) {
            cloneParams[0] = v2;
            return easeFunction.apply(this, cloneParams);
          };
        };
        module2.exports = GetEaseFunction;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Utils = __webpack_require__(12);
        var StrokePathWebGL = function(pipeline, src, alpha, dx, dy) {
          var strokeTint = pipeline.strokeTint;
          var strokeTintColor = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
          strokeTint.TL = strokeTintColor;
          strokeTint.TR = strokeTintColor;
          strokeTint.BL = strokeTintColor;
          strokeTint.BR = strokeTintColor;
          var path = src.pathData;
          var pathLength = path.length - 1;
          var lineWidth = src.lineWidth;
          var halfLineWidth = lineWidth / 2;
          var px1 = path[0] - dx;
          var py1 = path[1] - dy;
          if (!src.closePath) {
            pathLength -= 2;
          }
          for (var i2 = 2; i2 < pathLength; i2 += 2) {
            var px2 = path[i2] - dx;
            var py2 = path[i2 + 1] - dy;
            pipeline.batchLine(px1, py1, px2, py2, halfLineWidth, halfLineWidth, lineWidth, i2 - 2, src.closePath ? i2 === pathLength - 1 : false);
            px1 = px2;
            py1 = py2;
          }
        };
        module2.exports = StrokePathWebGL;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Contains = __webpack_require__(115);
        var GetPoint = __webpack_require__(476);
        var GetPoints = __webpack_require__(477);
        var GEOM_CONST = __webpack_require__(56);
        var Line = __webpack_require__(47);
        var Random = __webpack_require__(181);
        var Triangle = new Class({
          initialize: function Triangle2(x1, y1, x2, y2, x3, y3) {
            if (x1 === void 0) {
              x1 = 0;
            }
            if (y1 === void 0) {
              y1 = 0;
            }
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (x3 === void 0) {
              x3 = 0;
            }
            if (y3 === void 0) {
              y3 = 0;
            }
            this.type = GEOM_CONST.TRIANGLE;
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
            this.x3 = x3;
            this.y3 = y3;
          },
          contains: function(x2, y2) {
            return Contains(this, x2, y2);
          },
          getPoint: function(position, output) {
            return GetPoint(this, position, output);
          },
          getPoints: function(quantity, stepRate, output) {
            return GetPoints(this, quantity, stepRate, output);
          },
          getRandomPoint: function(point) {
            return Random(this, point);
          },
          setTo: function(x1, y1, x2, y2, x3, y3) {
            if (x1 === void 0) {
              x1 = 0;
            }
            if (y1 === void 0) {
              y1 = 0;
            }
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (x3 === void 0) {
              x3 = 0;
            }
            if (y3 === void 0) {
              y3 = 0;
            }
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
            this.x3 = x3;
            this.y3 = y3;
            return this;
          },
          getLineA: function(line) {
            if (line === void 0) {
              line = new Line();
            }
            line.setTo(this.x1, this.y1, this.x2, this.y2);
            return line;
          },
          getLineB: function(line) {
            if (line === void 0) {
              line = new Line();
            }
            line.setTo(this.x2, this.y2, this.x3, this.y3);
            return line;
          },
          getLineC: function(line) {
            if (line === void 0) {
              line = new Line();
            }
            line.setTo(this.x3, this.y3, this.x1, this.y1);
            return line;
          },
          left: {
            get: function() {
              return Math.min(this.x1, this.x2, this.x3);
            },
            set: function(value) {
              var diff = 0;
              if (this.x1 <= this.x2 && this.x1 <= this.x3) {
                diff = this.x1 - value;
              } else if (this.x2 <= this.x1 && this.x2 <= this.x3) {
                diff = this.x2 - value;
              } else {
                diff = this.x3 - value;
              }
              this.x1 -= diff;
              this.x2 -= diff;
              this.x3 -= diff;
            }
          },
          right: {
            get: function() {
              return Math.max(this.x1, this.x2, this.x3);
            },
            set: function(value) {
              var diff = 0;
              if (this.x1 >= this.x2 && this.x1 >= this.x3) {
                diff = this.x1 - value;
              } else if (this.x2 >= this.x1 && this.x2 >= this.x3) {
                diff = this.x2 - value;
              } else {
                diff = this.x3 - value;
              }
              this.x1 -= diff;
              this.x2 -= diff;
              this.x3 -= diff;
            }
          },
          top: {
            get: function() {
              return Math.min(this.y1, this.y2, this.y3);
            },
            set: function(value) {
              var diff = 0;
              if (this.y1 <= this.y2 && this.y1 <= this.y3) {
                diff = this.y1 - value;
              } else if (this.y2 <= this.y1 && this.y2 <= this.y3) {
                diff = this.y2 - value;
              } else {
                diff = this.y3 - value;
              }
              this.y1 -= diff;
              this.y2 -= diff;
              this.y3 -= diff;
            }
          },
          bottom: {
            get: function() {
              return Math.max(this.y1, this.y2, this.y3);
            },
            set: function(value) {
              var diff = 0;
              if (this.y1 >= this.y2 && this.y1 >= this.y3) {
                diff = this.y1 - value;
              } else if (this.y2 >= this.y1 && this.y2 >= this.y3) {
                diff = this.y2 - value;
              } else {
                diff = this.y3 - value;
              }
              this.y1 -= diff;
              this.y2 -= diff;
              this.y3 -= diff;
            }
          }
        });
        module2.exports = Triangle;
      },
      function(module2, exports2) {
        var Vector = {};
        module2.exports = Vector;
        (function() {
          Vector.create = function(x2, y2) {
            return { x: x2 || 0, y: y2 || 0 };
          };
          Vector.clone = function(vector) {
            return { x: vector.x, y: vector.y };
          };
          Vector.magnitude = function(vector) {
            return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
          };
          Vector.magnitudeSquared = function(vector) {
            return vector.x * vector.x + vector.y * vector.y;
          };
          Vector.rotate = function(vector, angle, output) {
            var cos = Math.cos(angle), sin = Math.sin(angle);
            if (!output)
              output = {};
            var x2 = vector.x * cos - vector.y * sin;
            output.y = vector.x * sin + vector.y * cos;
            output.x = x2;
            return output;
          };
          Vector.rotateAbout = function(vector, angle, point, output) {
            var cos = Math.cos(angle), sin = Math.sin(angle);
            if (!output)
              output = {};
            var x2 = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);
            output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);
            output.x = x2;
            return output;
          };
          Vector.normalise = function(vector) {
            var magnitude = Vector.magnitude(vector);
            if (magnitude === 0)
              return { x: 0, y: 0 };
            return { x: vector.x / magnitude, y: vector.y / magnitude };
          };
          Vector.dot = function(vectorA, vectorB) {
            return vectorA.x * vectorB.x + vectorA.y * vectorB.y;
          };
          Vector.cross = function(vectorA, vectorB) {
            return vectorA.x * vectorB.y - vectorA.y * vectorB.x;
          };
          Vector.cross3 = function(vectorA, vectorB, vectorC) {
            return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);
          };
          Vector.add = function(vectorA, vectorB, output) {
            if (!output)
              output = {};
            output.x = vectorA.x + vectorB.x;
            output.y = vectorA.y + vectorB.y;
            return output;
          };
          Vector.sub = function(vectorA, vectorB, output) {
            if (!output)
              output = {};
            output.x = vectorA.x - vectorB.x;
            output.y = vectorA.y - vectorB.y;
            return output;
          };
          Vector.mult = function(vector, scalar) {
            return { x: vector.x * scalar, y: vector.y * scalar };
          };
          Vector.div = function(vector, scalar) {
            return { x: vector.x / scalar, y: vector.y / scalar };
          };
          Vector.perp = function(vector, negate) {
            negate = negate === true ? -1 : 1;
            return { x: negate * -vector.y, y: negate * vector.x };
          };
          Vector.neg = function(vector) {
            return { x: -vector.x, y: -vector.y };
          };
          Vector.angle = function(vectorA, vectorB) {
            return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);
          };
          Vector._temp = [
            Vector.create(),
            Vector.create(),
            Vector.create(),
            Vector.create(),
            Vector.create(),
            Vector.create()
          ];
        })();
      },
      function(module2, exports2) {
        var Bounds = {};
        module2.exports = Bounds;
        (function() {
          Bounds.create = function(vertices) {
            var bounds = {
              min: { x: 0, y: 0 },
              max: { x: 0, y: 0 }
            };
            if (vertices)
              Bounds.update(bounds, vertices);
            return bounds;
          };
          Bounds.update = function(bounds, vertices, velocity) {
            bounds.min.x = Infinity;
            bounds.max.x = -Infinity;
            bounds.min.y = Infinity;
            bounds.max.y = -Infinity;
            for (var i2 = 0; i2 < vertices.length; i2++) {
              var vertex = vertices[i2];
              if (vertex.x > bounds.max.x)
                bounds.max.x = vertex.x;
              if (vertex.x < bounds.min.x)
                bounds.min.x = vertex.x;
              if (vertex.y > bounds.max.y)
                bounds.max.y = vertex.y;
              if (vertex.y < bounds.min.y)
                bounds.min.y = vertex.y;
            }
            if (velocity) {
              if (velocity.x > 0) {
                bounds.max.x += velocity.x;
              } else {
                bounds.min.x += velocity.x;
              }
              if (velocity.y > 0) {
                bounds.max.y += velocity.y;
              } else {
                bounds.min.y += velocity.y;
              }
            }
          };
          Bounds.contains = function(bounds, point) {
            return point.x >= bounds.min.x && point.x <= bounds.max.x && point.y >= bounds.min.y && point.y <= bounds.max.y;
          };
          Bounds.overlaps = function(boundsA, boundsB) {
            return boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y;
          };
          Bounds.translate = function(bounds, vector) {
            bounds.min.x += vector.x;
            bounds.max.x += vector.x;
            bounds.min.y += vector.y;
            bounds.max.y += vector.y;
          };
          Bounds.shift = function(bounds, position) {
            var deltaX = bounds.max.x - bounds.min.x, deltaY = bounds.max.y - bounds.min.y;
            bounds.min.x = position.x;
            bounds.max.x = position.x + deltaX;
            bounds.min.y = position.y;
            bounds.max.y = position.y + deltaY;
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(29);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var Rectangle = __webpack_require__(502);
        var Tile = new Class({
          Mixins: [
            Components.Alpha,
            Components.Flip,
            Components.Visible
          ],
          initialize: function Tile2(layer, index2, x2, y2, width, height, baseWidth, baseHeight) {
            this.layer = layer;
            this.index = index2;
            this.x = x2;
            this.y = y2;
            this.width = width;
            this.height = height;
            this.right;
            this.bottom;
            this.baseWidth = baseWidth !== void 0 ? baseWidth : width;
            this.baseHeight = baseHeight !== void 0 ? baseHeight : height;
            this.pixelX = 0;
            this.pixelY = 0;
            this.updatePixelXY();
            this.properties = {};
            this.rotation = 0;
            this.collideLeft = false;
            this.collideRight = false;
            this.collideUp = false;
            this.collideDown = false;
            this.faceLeft = false;
            this.faceRight = false;
            this.faceTop = false;
            this.faceBottom = false;
            this.collisionCallback = void 0;
            this.collisionCallbackContext = this;
            this.tint = 16777215;
            this.physics = {};
          },
          containsPoint: function(x2, y2) {
            return !(x2 < this.pixelX || y2 < this.pixelY || x2 > this.right || y2 > this.bottom);
          },
          copy: function(tile) {
            this.index = tile.index;
            this.alpha = tile.alpha;
            this.properties = tile.properties;
            this.visible = tile.visible;
            this.setFlip(tile.flipX, tile.flipY);
            this.tint = tile.tint;
            this.rotation = tile.rotation;
            this.collideUp = tile.collideUp;
            this.collideDown = tile.collideDown;
            this.collideLeft = tile.collideLeft;
            this.collideRight = tile.collideRight;
            this.collisionCallback = tile.collisionCallback;
            this.collisionCallbackContext = tile.collisionCallbackContext;
            return this;
          },
          getCollisionGroup: function() {
            return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null;
          },
          getTileData: function() {
            return this.tileset ? this.tileset.getTileData(this.index) : null;
          },
          getLeft: function(camera) {
            var tilemapLayer = this.tilemapLayer;
            return tilemapLayer ? tilemapLayer.tileToWorldX(this.x, camera) : this.x * this.baseWidth;
          },
          getRight: function(camera) {
            var tilemapLayer = this.tilemapLayer;
            return tilemapLayer ? this.getLeft(camera) + this.width * tilemapLayer.scaleX : this.getLeft(camera) + this.width;
          },
          getTop: function(camera) {
            var tilemapLayer = this.tilemapLayer;
            return tilemapLayer ? tilemapLayer.tileToWorldY(this.y, camera) - (this.height - this.baseHeight) * tilemapLayer.scaleY : this.y * this.baseHeight - (this.height - this.baseHeight);
          },
          getBottom: function(camera) {
            var tilemapLayer = this.tilemapLayer;
            return tilemapLayer ? this.getTop(camera) + this.height * tilemapLayer.scaleY : this.getTop(camera) + this.height;
          },
          getBounds: function(camera, output) {
            if (output === void 0) {
              output = new Rectangle();
            }
            output.x = this.getLeft();
            output.y = this.getTop();
            output.width = this.getRight() - output.x;
            output.height = this.getBottom() - output.y;
            return output;
          },
          getCenterX: function(camera) {
            return (this.getLeft(camera) + this.getRight(camera)) / 2;
          },
          getCenterY: function(camera) {
            return (this.getTop(camera) + this.getBottom(camera)) / 2;
          },
          intersects: function(x2, y2, right, bottom) {
            return !(right <= this.pixelX || bottom <= this.pixelY || x2 >= this.right || y2 >= this.bottom);
          },
          isInteresting: function(collides, faces) {
            if (collides && faces) {
              return this.canCollide || this.hasInterestingFace;
            } else if (collides) {
              return this.collides;
            } else if (faces) {
              return this.hasInterestingFace;
            }
            return false;
          },
          resetCollision: function(recalculateFaces) {
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            this.collideLeft = false;
            this.collideRight = false;
            this.collideUp = false;
            this.collideDown = false;
            this.faceTop = false;
            this.faceBottom = false;
            this.faceLeft = false;
            this.faceRight = false;
            if (recalculateFaces) {
              var tilemapLayer = this.tilemapLayer;
              if (tilemapLayer) {
                this.tilemapLayer.calculateFacesAt(this.x, this.y);
              }
            }
            return this;
          },
          resetFaces: function() {
            this.faceTop = false;
            this.faceBottom = false;
            this.faceLeft = false;
            this.faceRight = false;
            return this;
          },
          setCollision: function(left, right, up, down, recalculateFaces) {
            if (right === void 0) {
              right = left;
            }
            if (up === void 0) {
              up = left;
            }
            if (down === void 0) {
              down = left;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            this.collideLeft = left;
            this.collideRight = right;
            this.collideUp = up;
            this.collideDown = down;
            this.faceLeft = left;
            this.faceRight = right;
            this.faceTop = up;
            this.faceBottom = down;
            if (recalculateFaces) {
              var tilemapLayer = this.tilemapLayer;
              if (tilemapLayer) {
                this.tilemapLayer.calculateFacesAt(this.x, this.y);
              }
            }
            return this;
          },
          setCollisionCallback: function(callback, context) {
            if (callback === null) {
              this.collisionCallback = void 0;
              this.collisionCallbackContext = void 0;
            } else {
              this.collisionCallback = callback;
              this.collisionCallbackContext = context;
            }
            return this;
          },
          setSize: function(tileWidth, tileHeight, baseWidth, baseHeight) {
            if (tileWidth !== void 0) {
              this.width = tileWidth;
            }
            if (tileHeight !== void 0) {
              this.height = tileHeight;
            }
            if (baseWidth !== void 0) {
              this.baseWidth = baseWidth;
            }
            if (baseHeight !== void 0) {
              this.baseHeight = baseHeight;
            }
            this.updatePixelXY();
            return this;
          },
          updatePixelXY: function() {
            var orientation = this.layer.orientation;
            if (orientation === CONST.ORTHOGONAL) {
              this.pixelX = this.x * this.baseWidth;
              this.pixelY = this.y * this.baseHeight;
            } else if (orientation === CONST.ISOMETRIC) {
              this.pixelX = (this.x - this.y) * this.baseWidth * 0.5;
              this.pixelY = (this.x + this.y) * this.baseHeight * 0.5;
            } else if (orientation === CONST.STAGGERED) {
              this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);
              this.pixelY = this.y * (this.baseHeight / 2);
            } else if (orientation === CONST.HEXAGONAL) {
              var len = this.layer.hexSideLength;
              var rowHeight = (this.baseHeight - len) / 2 + len;
              this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);
              this.pixelY = this.y * rowHeight;
            }
            this.right = this.pixelX + this.baseWidth;
            this.bottom = this.pixelY + this.baseHeight;
            return this;
          },
          destroy: function() {
            this.collisionCallback = void 0;
            this.collisionCallbackContext = void 0;
            this.properties = void 0;
          },
          canCollide: {
            get: function() {
              return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback !== void 0;
            }
          },
          collides: {
            get: function() {
              return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
            }
          },
          hasInterestingFace: {
            get: function() {
              return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight;
            }
          },
          tileset: {
            get: function() {
              var tilemapLayer = this.layer.tilemapLayer;
              if (tilemapLayer) {
                var tileset = tilemapLayer.gidMap[this.index];
                if (tileset) {
                  return tileset;
                }
              }
              return null;
            }
          },
          tilemapLayer: {
            get: function() {
              return this.layer.tilemapLayer;
            }
          },
          tilemap: {
            get: function() {
              var tilemapLayer = this.tilemapLayer;
              return tilemapLayer ? tilemapLayer.tilemap : null;
            }
          }
        });
        module2.exports = Tile;
      },
      function(module2, exports2, __webpack_require__) {
        var Bodies = {};
        module2.exports = Bodies;
        var Vertices = __webpack_require__(64);
        var Common = __webpack_require__(32);
        var Body = __webpack_require__(41);
        var Bounds = __webpack_require__(84);
        var Vector = __webpack_require__(83);
        var decomp = __webpack_require__(1393);
        (function() {
          Bodies.rectangle = function(x2, y2, width, height, options) {
            options = options || {};
            var rectangle = {
              label: "Rectangle Body",
              position: { x: x2, y: y2 },
              vertices: Vertices.fromPath("L 0 0 L " + width + " 0 L " + width + " " + height + " L 0 " + height)
            };
            if (options.chamfer) {
              var chamfer = options.chamfer;
              rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
              delete options.chamfer;
            }
            return Body.create(Common.extend({}, rectangle, options));
          };
          Bodies.trapezoid = function(x2, y2, width, height, slope, options) {
            options = options || {};
            slope *= 0.5;
            var roof = (1 - slope * 2) * width;
            var x1 = width * slope, x22 = x1 + roof, x3 = x22 + x1, verticesPath;
            if (slope < 0.5) {
              verticesPath = "L 0 0 L " + x1 + " " + -height + " L " + x22 + " " + -height + " L " + x3 + " 0";
            } else {
              verticesPath = "L 0 0 L " + x22 + " " + -height + " L " + x3 + " 0";
            }
            var trapezoid = {
              label: "Trapezoid Body",
              position: { x: x2, y: y2 },
              vertices: Vertices.fromPath(verticesPath)
            };
            if (options.chamfer) {
              var chamfer = options.chamfer;
              trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
              delete options.chamfer;
            }
            return Body.create(Common.extend({}, trapezoid, options));
          };
          Bodies.circle = function(x2, y2, radius, options, maxSides) {
            options = options || {};
            var circle = {
              label: "Circle Body",
              circleRadius: radius
            };
            maxSides = maxSides || 25;
            var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));
            if (sides % 2 === 1)
              sides += 1;
            return Bodies.polygon(x2, y2, sides, radius, Common.extend({}, circle, options));
          };
          Bodies.polygon = function(x2, y2, sides, radius, options) {
            options = options || {};
            if (sides < 3)
              return Bodies.circle(x2, y2, radius, options);
            var theta = 2 * Math.PI / sides, path = "", offset = theta * 0.5;
            for (var i2 = 0; i2 < sides; i2 += 1) {
              var angle = offset + i2 * theta, xx = Math.cos(angle) * radius, yy = Math.sin(angle) * radius;
              path += "L " + xx.toFixed(3) + " " + yy.toFixed(3) + " ";
            }
            var polygon = {
              label: "Polygon Body",
              position: { x: x2, y: y2 },
              vertices: Vertices.fromPath(path)
            };
            if (options.chamfer) {
              var chamfer = options.chamfer;
              polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
              delete options.chamfer;
            }
            return Body.create(Common.extend({}, polygon, options));
          };
          Bodies.fromVertices = function(x2, y2, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
            var body, parts, isConvex, vertices, i2, v2;
            options = options || {};
            parts = [];
            flagInternal = typeof flagInternal !== "undefined" ? flagInternal : false;
            removeCollinear = typeof removeCollinear !== "undefined" ? removeCollinear : 0.01;
            minimumArea = typeof minimumArea !== "undefined" ? minimumArea : 10;
            if (!decomp) {
              Common.warn("Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.");
            }
            if (!Common.isArray(vertexSets[0])) {
              vertexSets = [vertexSets];
            }
            for (v2 = 0; v2 < vertexSets.length; v2 += 1) {
              vertices = vertexSets[v2];
              isConvex = Vertices.isConvex(vertices);
              if (isConvex || !decomp) {
                if (isConvex) {
                  vertices = Vertices.clockwiseSort(vertices);
                } else {
                  vertices = Vertices.hull(vertices);
                }
                parts.push({
                  position: { x: x2, y: y2 },
                  vertices
                });
              } else {
                var concave = vertices.map(function(vertex) {
                  return [vertex.x, vertex.y];
                });
                decomp.makeCCW(concave);
                if (removeCollinear !== false)
                  decomp.removeCollinearPoints(concave, removeCollinear);
                var decomposed = decomp.quickDecomp(concave);
                for (i2 = 0; i2 < decomposed.length; i2++) {
                  var chunk = decomposed[i2];
                  var chunkVertices = chunk.map(function(vertices2) {
                    return {
                      x: vertices2[0],
                      y: vertices2[1]
                    };
                  });
                  if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)
                    continue;
                  parts.push({
                    position: Vertices.centre(chunkVertices),
                    vertices: chunkVertices
                  });
                }
              }
            }
            for (i2 = 0; i2 < parts.length; i2++) {
              parts[i2] = Body.create(Common.extend(parts[i2], options));
            }
            if (flagInternal) {
              Bodies.flagCoincidentParts(parts, 5);
            }
            if (parts.length > 1) {
              body = Body.create(Common.extend({ parts: parts.slice(0) }, options));
              Body.setPosition(body, { x: x2, y: y2 });
              return body;
            } else {
              return parts[0];
            }
          };
          Bodies.flagCoincidentParts = function(parts, maxDistance) {
            if (maxDistance === void 0) {
              maxDistance = 5;
            }
            for (var i2 = 0; i2 < parts.length; i2++) {
              var partA = parts[i2];
              for (var j = i2 + 1; j < parts.length; j++) {
                var partB = parts[j];
                if (Bounds.overlaps(partA.bounds, partB.bounds)) {
                  var pav = partA.vertices;
                  var pbv = partB.vertices;
                  for (var k2 = 0; k2 < partA.vertices.length; k2++) {
                    for (var z2 = 0; z2 < partB.vertices.length; z2++) {
                      var da2 = Vector.magnitudeSquared(Vector.sub(pav[(k2 + 1) % pav.length], pbv[z2]));
                      var db2 = Vector.magnitudeSquared(Vector.sub(pav[k2], pbv[(z2 + 1) % pbv.length]));
                      if (da2 < maxDistance && db2 < maxDistance) {
                        pav[k2].isInternal = true;
                        pbv[z2].isInternal = true;
                      }
                    }
                  }
                }
              }
            }
            return parts;
          };
        })();
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCenterX = function(gameObject) {
          return gameObject.x - gameObject.width * gameObject.originX + gameObject.width * 0.5;
        };
        module2.exports = GetCenterX;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetCenterX = function(gameObject, x2) {
          var offsetX = gameObject.width * gameObject.originX;
          gameObject.x = x2 + offsetX - gameObject.width * 0.5;
          return gameObject;
        };
        module2.exports = SetCenterX;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCenterY = function(gameObject) {
          return gameObject.y - gameObject.height * gameObject.originY + gameObject.height * 0.5;
        };
        module2.exports = GetCenterY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetCenterY = function(gameObject, y2) {
          var offsetY = gameObject.height * gameObject.originY;
          gameObject.y = y2 + offsetY - gameObject.height * 0.5;
          return gameObject;
        };
        module2.exports = SetCenterY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          POST_RENDER: __webpack_require__(628),
          PRE_RENDER: __webpack_require__(629),
          RENDER: __webpack_require__(630),
          RESIZE: __webpack_require__(631)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PIPELINE_CONST = {
          BITMAPMASK_PIPELINE: "BitmapMaskPipeline",
          LIGHT_PIPELINE: "Light2D",
          POINTLIGHT_PIPELINE: "PointLightPipeline",
          SINGLE_PIPELINE: "SinglePipeline",
          MULTI_PIPELINE: "MultiPipeline",
          ROPE_PIPELINE: "RopePipeline",
          GRAPHICS_PIPELINE: "GraphicsPipeline",
          POSTFX_PIPELINE: "PostFXPipeline",
          UTILITY_PIPELINE: "UtilityPipeline"
        };
        module2.exports = PIPELINE_CONST;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SpliceOne = __webpack_require__(74);
        var Remove = function(array, item, callback, context) {
          if (context === void 0) {
            context = array;
          }
          var index2;
          if (!Array.isArray(item)) {
            index2 = array.indexOf(item);
            if (index2 !== -1) {
              SpliceOne(array, index2);
              if (callback) {
                callback.call(context, item);
              }
              return item;
            } else {
              return null;
            }
          }
          var itemLength = item.length - 1;
          var removed = [];
          while (itemLength >= 0) {
            var entry = item[itemLength];
            index2 = array.indexOf(entry);
            if (index2 !== -1) {
              SpliceOne(array, index2);
              removed.push(entry);
              if (callback) {
                callback.call(context, entry);
              }
            }
            itemLength--;
          }
          return removed;
        };
        module2.exports = Remove;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FromPoints = __webpack_require__(199);
        var Rectangle = __webpack_require__(10);
        var Vector2 = __webpack_require__(3);
        var Curve = new Class({
          initialize: function Curve2(type) {
            this.type = type;
            this.defaultDivisions = 5;
            this.arcLengthDivisions = 100;
            this.cacheArcLengths = [];
            this.needsUpdate = true;
            this.active = true;
            this._tmpVec2A = new Vector2();
            this._tmpVec2B = new Vector2();
          },
          draw: function(graphics, pointsTotal) {
            if (pointsTotal === void 0) {
              pointsTotal = 32;
            }
            return graphics.strokePoints(this.getPoints(pointsTotal));
          },
          getBounds: function(out, accuracy) {
            if (!out) {
              out = new Rectangle();
            }
            if (accuracy === void 0) {
              accuracy = 16;
            }
            var len = this.getLength();
            if (accuracy > len) {
              accuracy = len / 2;
            }
            var spaced = Math.max(1, Math.round(len / accuracy));
            return FromPoints(this.getSpacedPoints(spaced), out);
          },
          getDistancePoints: function(distance) {
            var len = this.getLength();
            var spaced = Math.max(1, len / distance);
            return this.getSpacedPoints(spaced);
          },
          getEndPoint: function(out) {
            if (out === void 0) {
              out = new Vector2();
            }
            return this.getPointAt(1, out);
          },
          getLength: function() {
            var lengths = this.getLengths();
            return lengths[lengths.length - 1];
          },
          getLengths: function(divisions) {
            if (divisions === void 0) {
              divisions = this.arcLengthDivisions;
            }
            if (this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
              return this.cacheArcLengths;
            }
            this.needsUpdate = false;
            var cache = [];
            var current;
            var last = this.getPoint(0, this._tmpVec2A);
            var sum = 0;
            cache.push(0);
            for (var p2 = 1; p2 <= divisions; p2++) {
              current = this.getPoint(p2 / divisions, this._tmpVec2B);
              sum += current.distance(last);
              cache.push(sum);
              last.copy(current);
            }
            this.cacheArcLengths = cache;
            return cache;
          },
          getPointAt: function(u2, out) {
            var t2 = this.getUtoTmapping(u2);
            return this.getPoint(t2, out);
          },
          getPoints: function(divisions, stepRate, out) {
            if (out === void 0) {
              out = [];
            }
            if (!divisions) {
              if (!stepRate) {
                divisions = this.defaultDivisions;
              } else {
                divisions = this.getLength() / stepRate;
              }
            }
            for (var d = 0; d <= divisions; d++) {
              out.push(this.getPoint(d / divisions));
            }
            return out;
          },
          getRandomPoint: function(out) {
            if (out === void 0) {
              out = new Vector2();
            }
            return this.getPoint(Math.random(), out);
          },
          getSpacedPoints: function(divisions, stepRate, out) {
            if (out === void 0) {
              out = [];
            }
            if (!divisions) {
              if (!stepRate) {
                divisions = this.defaultDivisions;
              } else {
                divisions = this.getLength() / stepRate;
              }
            }
            for (var d = 0; d <= divisions; d++) {
              var t2 = this.getUtoTmapping(d / divisions, null, divisions);
              out.push(this.getPoint(t2));
            }
            return out;
          },
          getStartPoint: function(out) {
            if (out === void 0) {
              out = new Vector2();
            }
            return this.getPointAt(0, out);
          },
          getTangent: function(t2, out) {
            if (out === void 0) {
              out = new Vector2();
            }
            var delta = 1e-4;
            var t1 = t2 - delta;
            var t22 = t2 + delta;
            if (t1 < 0) {
              t1 = 0;
            }
            if (t22 > 1) {
              t22 = 1;
            }
            this.getPoint(t1, this._tmpVec2A);
            this.getPoint(t22, out);
            return out.subtract(this._tmpVec2A).normalize();
          },
          getTangentAt: function(u2, out) {
            var t2 = this.getUtoTmapping(u2);
            return this.getTangent(t2, out);
          },
          getTFromDistance: function(distance, divisions) {
            if (distance <= 0) {
              return 0;
            }
            return this.getUtoTmapping(0, distance, divisions);
          },
          getUtoTmapping: function(u2, distance, divisions) {
            var arcLengths = this.getLengths(divisions);
            var i2 = 0;
            var il2 = arcLengths.length;
            var targetArcLength;
            if (distance) {
              targetArcLength = Math.min(distance, arcLengths[il2 - 1]);
            } else {
              targetArcLength = u2 * arcLengths[il2 - 1];
            }
            var low = 0;
            var high = il2 - 1;
            var comparison;
            while (low <= high) {
              i2 = Math.floor(low + (high - low) / 2);
              comparison = arcLengths[i2] - targetArcLength;
              if (comparison < 0) {
                low = i2 + 1;
              } else if (comparison > 0) {
                high = i2 - 1;
              } else {
                high = i2;
                break;
              }
            }
            i2 = high;
            if (arcLengths[i2] === targetArcLength) {
              return i2 / (il2 - 1);
            }
            var lengthBefore = arcLengths[i2];
            var lengthAfter = arcLengths[i2 + 1];
            var segmentLength = lengthAfter - lengthBefore;
            var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
            return (i2 + segmentFraction) / (il2 - 1);
          },
          updateArcLengths: function() {
            this.needsUpdate = true;
            this.getLengths();
          }
        });
        module2.exports = Curve;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          ADD: __webpack_require__(968),
          COMPLETE: __webpack_require__(969),
          FILE_COMPLETE: __webpack_require__(970),
          FILE_KEY_COMPLETE: __webpack_require__(971),
          FILE_LOAD_ERROR: __webpack_require__(972),
          FILE_LOAD: __webpack_require__(973),
          FILE_PROGRESS: __webpack_require__(974),
          POST_PROCESS: __webpack_require__(975),
          PROGRESS: __webpack_require__(976),
          START: __webpack_require__(977)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var LineToLine = function(line1, line2, out) {
          if (out === void 0) {
            out = new Point();
          }
          var x1 = line1.x1;
          var y1 = line1.y1;
          var x2 = line1.x2;
          var y2 = line1.y2;
          var x3 = line2.x1;
          var y3 = line2.y1;
          var x4 = line2.x2;
          var y4 = line2.y2;
          var numA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
          var numB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
          var deNom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
          if (deNom === 0) {
            return false;
          }
          var uA = numA / deNom;
          var uB = numB / deNom;
          if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
            out.x = x1 + uA * (x2 - x1);
            out.y = y1 + uA * (y2 - y1);
            return true;
          }
          return false;
        };
        module2.exports = LineToLine;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Angle = function(line) {
          return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
        };
        module2.exports = Angle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clamp = __webpack_require__(18);
        var FromPercent = function(percent, min, max) {
          percent = Clamp(percent, 0, 1);
          return (max - min) * percent + min;
        };
        module2.exports = FromPercent;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetBoolean = function(source, key, defaultValue) {
          if (!source) {
            return defaultValue;
          } else if (source.hasOwnProperty(key)) {
            return source[key];
          } else {
            return defaultValue;
          }
        };
        module2.exports = GetBoolean;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TWEEN_CONST = {
          CREATED: 0,
          INIT: 1,
          DELAY: 2,
          OFFSET_DELAY: 3,
          PENDING_RENDER: 4,
          PLAYING_FORWARD: 5,
          PLAYING_BACKWARD: 6,
          HOLD_DELAY: 7,
          REPEAT_DELAY: 8,
          COMPLETE: 9,
          PENDING_ADD: 20,
          PAUSED: 21,
          LOOP_DELAY: 22,
          ACTIVE: 23,
          COMPLETE_DELAY: 24,
          PENDING_REMOVE: 25,
          REMOVED: 26
        };
        module2.exports = TWEEN_CONST;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(315);
        var DataManager = new Class({
          initialize: function DataManager2(parent, eventEmitter) {
            this.parent = parent;
            this.events = eventEmitter;
            if (!eventEmitter) {
              this.events = parent.events ? parent.events : parent;
            }
            this.list = {};
            this.values = {};
            this._frozen = false;
            if (!parent.hasOwnProperty("sys") && this.events) {
              this.events.once(Events.DESTROY, this.destroy, this);
            }
          },
          get: function(key) {
            var list = this.list;
            if (Array.isArray(key)) {
              var output = [];
              for (var i2 = 0; i2 < key.length; i2++) {
                output.push(list[key[i2]]);
              }
              return output;
            } else {
              return list[key];
            }
          },
          getAll: function() {
            var results = {};
            for (var key in this.list) {
              if (this.list.hasOwnProperty(key)) {
                results[key] = this.list[key];
              }
            }
            return results;
          },
          query: function(search) {
            var results = {};
            for (var key in this.list) {
              if (this.list.hasOwnProperty(key) && key.match(search)) {
                results[key] = this.list[key];
              }
            }
            return results;
          },
          set: function(key, data) {
            if (this._frozen) {
              return this;
            }
            if (typeof key === "string") {
              return this.setValue(key, data);
            } else {
              for (var entry in key) {
                this.setValue(entry, key[entry]);
              }
            }
            return this;
          },
          inc: function(key, data) {
            if (this._frozen) {
              return this;
            }
            if (data === void 0) {
              data = 1;
            }
            var value = this.get(key);
            if (value === void 0) {
              value = 0;
            }
            this.set(key, value + data);
            return this;
          },
          toggle: function(key) {
            if (this._frozen) {
              return this;
            }
            this.set(key, !this.get(key));
            return this;
          },
          setValue: function(key, data) {
            if (this._frozen) {
              return this;
            }
            if (this.has(key)) {
              this.values[key] = data;
            } else {
              var _this = this;
              var list = this.list;
              var events = this.events;
              var parent = this.parent;
              Object.defineProperty(this.values, key, {
                enumerable: true,
                configurable: true,
                get: function() {
                  return list[key];
                },
                set: function(value) {
                  if (!_this._frozen) {
                    var previousValue = list[key];
                    list[key] = value;
                    events.emit(Events.CHANGE_DATA, parent, key, value, previousValue);
                    events.emit(Events.CHANGE_DATA_KEY + key, parent, value, previousValue);
                  }
                }
              });
              list[key] = data;
              events.emit(Events.SET_DATA, parent, key, data);
            }
            return this;
          },
          each: function(callback, context) {
            var args = [this.parent, null, void 0];
            for (var i2 = 1; i2 < arguments.length; i2++) {
              args.push(arguments[i2]);
            }
            for (var key in this.list) {
              args[1] = key;
              args[2] = this.list[key];
              callback.apply(context, args);
            }
            return this;
          },
          merge: function(data, overwrite) {
            if (overwrite === void 0) {
              overwrite = true;
            }
            for (var key in data) {
              if (data.hasOwnProperty(key) && (overwrite || !overwrite && !this.has(key))) {
                this.setValue(key, data[key]);
              }
            }
            return this;
          },
          remove: function(key) {
            if (this._frozen) {
              return this;
            }
            if (Array.isArray(key)) {
              for (var i2 = 0; i2 < key.length; i2++) {
                this.removeValue(key[i2]);
              }
            } else {
              return this.removeValue(key);
            }
            return this;
          },
          removeValue: function(key) {
            if (this.has(key)) {
              var data = this.list[key];
              delete this.list[key];
              delete this.values[key];
              this.events.emit(Events.REMOVE_DATA, this.parent, key, data);
            }
            return this;
          },
          pop: function(key) {
            var data = void 0;
            if (!this._frozen && this.has(key)) {
              data = this.list[key];
              delete this.list[key];
              delete this.values[key];
              this.events.emit(Events.REMOVE_DATA, this.parent, key, data);
            }
            return data;
          },
          has: function(key) {
            return this.list.hasOwnProperty(key);
          },
          setFreeze: function(value) {
            this._frozen = value;
            return this;
          },
          reset: function() {
            for (var key in this.list) {
              delete this.list[key];
              delete this.values[key];
            }
            this._frozen = false;
            return this;
          },
          destroy: function() {
            this.reset();
            this.events.off(Events.CHANGE_DATA);
            this.events.off(Events.SET_DATA);
            this.events.off(Events.REMOVE_DATA);
            this.parent = null;
          },
          freeze: {
            get: function() {
              return this._frozen;
            },
            set: function(value) {
              this._frozen = value ? true : false;
            }
          },
          count: {
            get: function() {
              var i2 = 0;
              for (var key in this.list) {
                if (this.list[key] !== void 0) {
                  i2++;
                }
              }
              return i2;
            }
          }
        });
        module2.exports = DataManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Map2 = new Class({
          initialize: function Map3(elements) {
            this.entries = {};
            this.size = 0;
            if (Array.isArray(elements)) {
              for (var i2 = 0; i2 < elements.length; i2++) {
                this.set(elements[i2][0], elements[i2][1]);
              }
            }
          },
          set: function(key, value) {
            if (!this.has(key)) {
              this.size++;
            }
            this.entries[key] = value;
            return this;
          },
          get: function(key) {
            if (this.has(key)) {
              return this.entries[key];
            }
          },
          getArray: function() {
            var output = [];
            var entries = this.entries;
            for (var key in entries) {
              output.push(entries[key]);
            }
            return output;
          },
          has: function(key) {
            return this.entries.hasOwnProperty(key);
          },
          delete: function(key) {
            if (this.has(key)) {
              delete this.entries[key];
              this.size--;
            }
            return this;
          },
          clear: function() {
            Object.keys(this.entries).forEach(function(prop) {
              delete this.entries[prop];
            }, this);
            this.size = 0;
            return this;
          },
          keys: function() {
            return Object.keys(this.entries);
          },
          values: function() {
            var output = [];
            var entries = this.entries;
            for (var key in entries) {
              output.push(entries[key]);
            }
            return output;
          },
          dump: function() {
            var entries = this.entries;
            console.group("Map");
            for (var key in entries) {
              console.log(key, entries[key]);
            }
            console.groupEnd();
          },
          each: function(callback) {
            var entries = this.entries;
            for (var key in entries) {
              if (callback(key, entries[key]) === false) {
                break;
              }
            }
            return this;
          },
          contains: function(value) {
            var entries = this.entries;
            for (var key in entries) {
              if (entries[key] === value) {
                return true;
              }
            }
            return false;
          },
          merge: function(map, override) {
            if (override === void 0) {
              override = false;
            }
            var local = this.entries;
            var source = map.entries;
            for (var key in source) {
              if (local.hasOwnProperty(key) && override) {
                local[key] = source[key];
              } else {
                this.set(key, source[key]);
              }
            }
            return this;
          }
        });
        module2.exports = Map2;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetColor = function(red, green, blue) {
          return red << 16 | green << 8 | blue;
        };
        module2.exports = GetColor;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          ENTER_FULLSCREEN: __webpack_require__(800),
          FULLSCREEN_FAILED: __webpack_require__(801),
          FULLSCREEN_UNSUPPORTED: __webpack_require__(802),
          LEAVE_FULLSCREEN: __webpack_require__(803),
          ORIENTATION_CHANGE: __webpack_require__(804),
          RESIZE: __webpack_require__(805)
        };
      },
      function(module2, exports2, __webpack_require__) {
        (function(process) {
          /**
          * @author       Richard Davey <rich@photonstorm.com>
          * @copyright    2020 Photon Storm Ltd.
          * @license      {@link https://opensource.org/licenses/MIT|MIT License}
          */
          var OS = {
            android: false,
            chromeOS: false,
            cordova: false,
            crosswalk: false,
            desktop: false,
            ejecta: false,
            electron: false,
            iOS: false,
            iOSVersion: 0,
            iPad: false,
            iPhone: false,
            kindle: false,
            linux: false,
            macOS: false,
            node: false,
            nodeWebkit: false,
            pixelRatio: 1,
            webApp: false,
            windows: false,
            windowsPhone: false
          };
          function init() {
            if (typeof importScripts === "function") {
              return OS;
            }
            var ua2 = navigator.userAgent;
            if (/Windows/.test(ua2)) {
              OS.windows = true;
            } else if (/Mac OS/.test(ua2) && !/like Mac OS/.test(ua2)) {
              if (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) {
                OS.iOS = true;
                OS.iPad = true;
                navigator.appVersion.match(/Version\/(\d+)/);
                OS.iOSVersion = parseInt(RegExp.$1, 10);
              } else {
                OS.macOS = true;
              }
            } else if (/Android/.test(ua2)) {
              OS.android = true;
            } else if (/Linux/.test(ua2)) {
              OS.linux = true;
            } else if (/iP[ao]d|iPhone/i.test(ua2)) {
              OS.iOS = true;
              navigator.appVersion.match(/OS (\d+)/);
              OS.iOSVersion = parseInt(RegExp.$1, 10);
              OS.iPhone = ua2.toLowerCase().indexOf("iphone") !== -1;
              OS.iPad = ua2.toLowerCase().indexOf("ipad") !== -1;
            } else if (/Kindle/.test(ua2) || /\bKF[A-Z][A-Z]+/.test(ua2) || /Silk.*Mobile Safari/.test(ua2)) {
              OS.kindle = true;
            } else if (/CrOS/.test(ua2)) {
              OS.chromeOS = true;
            }
            if (/Windows Phone/i.test(ua2) || /IEMobile/i.test(ua2)) {
              OS.android = false;
              OS.iOS = false;
              OS.macOS = false;
              OS.windows = true;
              OS.windowsPhone = true;
            }
            var silk = /Silk/.test(ua2);
            if (OS.windows || OS.macOS || OS.linux && !silk || OS.chromeOS) {
              OS.desktop = true;
            }
            if (OS.windowsPhone || /Windows NT/i.test(ua2) && /Touch/i.test(ua2)) {
              OS.desktop = false;
            }
            if (navigator.standalone) {
              OS.webApp = true;
            }
            if (typeof importScripts !== "function") {
              if (window.cordova !== void 0) {
                OS.cordova = true;
              }
              if (window.ejecta !== void 0) {
                OS.ejecta = true;
              }
            }
            if (typeof process !== "undefined" && process.versions && process.versions.node) {
              OS.node = true;
            }
            if (OS.node && typeof process.versions === "object") {
              OS.nodeWebkit = !!process.versions["node-webkit"];
              OS.electron = !!process.versions.electron;
            }
            if (/Crosswalk/.test(ua2)) {
              OS.crosswalk = true;
            }
            OS.pixelRatio = window["devicePixelRatio"] || 1;
            return OS;
          }
          module2.exports = init();
        }).call(this, __webpack_require__(807));
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          ADD: __webpack_require__(861),
          ERROR: __webpack_require__(862),
          LOAD: __webpack_require__(863),
          READY: __webpack_require__(864),
          REMOVE: __webpack_require__(865)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var WEBGL_CONST = {
          BYTE: { enum: 5120, size: 1 },
          UNSIGNED_BYTE: { enum: 5121, size: 1 },
          SHORT: { enum: 5122, size: 2 },
          UNSIGNED_SHORT: { enum: 5123, size: 2 },
          INT: { enum: 5124, size: 4 },
          UNSIGNED_INT: { enum: 5125, size: 4 },
          FLOAT: { enum: 5126, size: 4 }
        };
        module2.exports = WEBGL_CONST;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Felipe Alfonso <@bitnenfer>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Earcut = __webpack_require__(59);
        var GetFastValue = __webpack_require__(2);
        var ShaderSourceFS = __webpack_require__(878);
        var ShaderSourceVS = __webpack_require__(879);
        var TransformMatrix = __webpack_require__(25);
        var Utils = __webpack_require__(12);
        var WEBGL_CONST = __webpack_require__(107);
        var WebGLPipeline = __webpack_require__(58);
        var MultiPipeline = new Class({
          Extends: WebGLPipeline,
          initialize: function MultiPipeline2(config) {
            var renderer = config.game.renderer;
            var fragmentShaderSource = GetFastValue(config, "fragShader", ShaderSourceFS);
            config.fragShader = Utils.parseFragmentShaderMaxTextures(fragmentShaderSource, renderer.maxTextures);
            config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS);
            config.attributes = GetFastValue(config, "attributes", [
              {
                name: "inPosition",
                size: 2
              },
              {
                name: "inTexCoord",
                size: 2
              },
              {
                name: "inTexId"
              },
              {
                name: "inTintEffect"
              },
              {
                name: "inTint",
                size: 4,
                type: WEBGL_CONST.UNSIGNED_BYTE,
                normalized: true
              }
            ]);
            WebGLPipeline.call(this, config);
            this._tempMatrix1 = new TransformMatrix();
            this._tempMatrix2 = new TransformMatrix();
            this._tempMatrix3 = new TransformMatrix();
            this.calcMatrix = new TransformMatrix();
            this.tempTriangle = [
              { x: 0, y: 0, width: 0 },
              { x: 0, y: 0, width: 0 },
              { x: 0, y: 0, width: 0 },
              { x: 0, y: 0, width: 0 }
            ];
            this.strokeTint = { TL: 0, TR: 0, BL: 0, BR: 0 };
            this.fillTint = { TL: 0, TR: 0, BL: 0, BR: 0 };
            this.currentFrame = { u0: 0, v0: 0, u1: 1, v1: 1 };
            this.firstQuad = [0, 0, 0, 0, 0];
            this.prevQuad = [0, 0, 0, 0, 0];
            this.polygonCache = [];
          },
          boot: function() {
            WebGLPipeline.prototype.boot.call(this);
            this.currentShader.set1iv("uMainSampler", this.renderer.textureIndexes);
          },
          batchSprite: function(gameObject, camera, parentTransformMatrix) {
            this.manager.set(this, gameObject);
            var camMatrix = this._tempMatrix1;
            var spriteMatrix = this._tempMatrix2;
            var calcMatrix = this._tempMatrix3;
            var frame = gameObject.frame;
            var texture = frame.glTexture;
            var u0 = frame.u0;
            var v0 = frame.v0;
            var u1 = frame.u1;
            var v1 = frame.v1;
            var frameX = frame.x;
            var frameY = frame.y;
            var frameWidth = frame.cutWidth;
            var frameHeight = frame.cutHeight;
            var customPivot = frame.customPivot;
            var displayOriginX = gameObject.displayOriginX;
            var displayOriginY = gameObject.displayOriginY;
            var x2 = -displayOriginX + frameX;
            var y2 = -displayOriginY + frameY;
            if (gameObject.isCropped) {
              var crop = gameObject._crop;
              if (crop.flipX !== gameObject.flipX || crop.flipY !== gameObject.flipY) {
                frame.updateCropUVs(crop, gameObject.flipX, gameObject.flipY);
              }
              u0 = crop.u0;
              v0 = crop.v0;
              u1 = crop.u1;
              v1 = crop.v1;
              frameWidth = crop.width;
              frameHeight = crop.height;
              frameX = crop.x;
              frameY = crop.y;
              x2 = -displayOriginX + frameX;
              y2 = -displayOriginY + frameY;
            }
            var flipX = 1;
            var flipY = 1;
            if (gameObject.flipX) {
              if (!customPivot) {
                x2 += -frame.realWidth + displayOriginX * 2;
              }
              flipX = -1;
            }
            if (gameObject.flipY || frame.source.isGLTexture && !texture.flipY) {
              if (!customPivot) {
                y2 += -frame.realHeight + displayOriginY * 2;
              }
              flipY = -1;
            }
            spriteMatrix.applyITRS(gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX * flipX, gameObject.scaleY * flipY);
            camMatrix.copyFrom(camera.matrix);
            if (parentTransformMatrix) {
              camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * gameObject.scrollFactorX, -camera.scrollY * gameObject.scrollFactorY);
              spriteMatrix.e = gameObject.x;
              spriteMatrix.f = gameObject.y;
            } else {
              spriteMatrix.e -= camera.scrollX * gameObject.scrollFactorX;
              spriteMatrix.f -= camera.scrollY * gameObject.scrollFactorY;
            }
            camMatrix.multiply(spriteMatrix, calcMatrix);
            var xw = x2 + frameWidth;
            var yh2 = y2 + frameHeight;
            var roundPixels = camera.roundPixels;
            var tx0 = calcMatrix.getXRound(x2, y2, roundPixels);
            var ty0 = calcMatrix.getYRound(x2, y2, roundPixels);
            var tx1 = calcMatrix.getXRound(x2, yh2, roundPixels);
            var ty1 = calcMatrix.getYRound(x2, yh2, roundPixels);
            var tx2 = calcMatrix.getXRound(xw, yh2, roundPixels);
            var ty2 = calcMatrix.getYRound(xw, yh2, roundPixels);
            var tx3 = calcMatrix.getXRound(xw, y2, roundPixels);
            var ty3 = calcMatrix.getYRound(xw, y2, roundPixels);
            var getTint = Utils.getTintAppendFloatAlpha;
            var cameraAlpha = camera.alpha;
            var tintTL = getTint(gameObject.tintTopLeft, cameraAlpha * gameObject._alphaTL);
            var tintTR = getTint(gameObject.tintTopRight, cameraAlpha * gameObject._alphaTR);
            var tintBL = getTint(gameObject.tintBottomLeft, cameraAlpha * gameObject._alphaBL);
            var tintBR = getTint(gameObject.tintBottomRight, cameraAlpha * gameObject._alphaBR);
            if (this.shouldFlush(6)) {
              this.flush();
            }
            var unit = this.setGameObject(gameObject, frame);
            this.manager.preBatch(gameObject);
            this.batchQuad(gameObject, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, gameObject.tintFill, texture, unit);
            this.manager.postBatch(gameObject);
          },
          batchTexture: function(gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit) {
            this.manager.set(this, gameObject);
            var camMatrix = this._tempMatrix1;
            var spriteMatrix = this._tempMatrix2;
            var calcMatrix = this._tempMatrix3;
            var u0 = frameX / textureWidth + uOffset;
            var v0 = frameY / textureHeight + vOffset;
            var u1 = (frameX + frameWidth) / textureWidth + uOffset;
            var v1 = (frameY + frameHeight) / textureHeight + vOffset;
            var width = srcWidth;
            var height = srcHeight;
            var x2 = -displayOriginX;
            var y2 = -displayOriginY;
            if (gameObject.isCropped) {
              var crop = gameObject._crop;
              var cropWidth = crop.width;
              var cropHeight = crop.height;
              width = cropWidth;
              height = cropHeight;
              srcWidth = cropWidth;
              srcHeight = cropHeight;
              frameX = crop.x;
              frameY = crop.y;
              var ox = frameX;
              var oy = frameY;
              if (flipX) {
                ox = frameWidth - crop.x - cropWidth;
              }
              if (flipY) {
                oy = frameHeight - crop.y - cropHeight;
              }
              u0 = ox / textureWidth + uOffset;
              v0 = oy / textureHeight + vOffset;
              u1 = (ox + cropWidth) / textureWidth + uOffset;
              v1 = (oy + cropHeight) / textureHeight + vOffset;
              x2 = -displayOriginX + frameX;
              y2 = -displayOriginY + frameY;
            }
            flipY = flipY ^ (!skipFlip && texture.isRenderTexture ? 1 : 0);
            if (flipX) {
              width *= -1;
              x2 += srcWidth;
            }
            if (flipY) {
              height *= -1;
              y2 += srcHeight;
            }
            var xw = x2 + width;
            var yh2 = y2 + height;
            spriteMatrix.applyITRS(srcX, srcY, rotation, scaleX, scaleY);
            camMatrix.copyFrom(camera.matrix);
            if (parentTransformMatrix) {
              camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
              spriteMatrix.e = srcX;
              spriteMatrix.f = srcY;
            } else {
              spriteMatrix.e -= camera.scrollX * scrollFactorX;
              spriteMatrix.f -= camera.scrollY * scrollFactorY;
            }
            camMatrix.multiply(spriteMatrix, calcMatrix);
            var roundPixels = camera.roundPixels;
            var tx0 = calcMatrix.getXRound(x2, y2, roundPixels);
            var ty0 = calcMatrix.getYRound(x2, y2, roundPixels);
            var tx1 = calcMatrix.getXRound(x2, yh2, roundPixels);
            var ty1 = calcMatrix.getYRound(x2, yh2, roundPixels);
            var tx2 = calcMatrix.getXRound(xw, yh2, roundPixels);
            var ty2 = calcMatrix.getYRound(xw, yh2, roundPixels);
            var tx3 = calcMatrix.getXRound(xw, y2, roundPixels);
            var ty3 = calcMatrix.getYRound(xw, y2, roundPixels);
            if (textureUnit === void 0) {
              textureUnit = this.renderer.setTexture2D(texture);
            }
            if (gameObject) {
              this.manager.preBatch(gameObject);
            }
            this.batchQuad(gameObject, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
            if (gameObject) {
              this.manager.postBatch(gameObject);
            }
          },
          batchTextureFrame: function(frame, x2, y2, tint, alpha, transformMatrix, parentTransformMatrix) {
            this.manager.set(this);
            var spriteMatrix = this._tempMatrix1.copyFrom(transformMatrix);
            var calcMatrix = this._tempMatrix2;
            var xw = x2 + frame.width;
            var yh2 = y2 + frame.height;
            if (parentTransformMatrix) {
              spriteMatrix.multiply(parentTransformMatrix, calcMatrix);
            } else {
              calcMatrix = spriteMatrix;
            }
            var tx0 = calcMatrix.getX(x2, y2);
            var ty0 = calcMatrix.getY(x2, y2);
            var tx1 = calcMatrix.getX(x2, yh2);
            var ty1 = calcMatrix.getY(x2, yh2);
            var tx2 = calcMatrix.getX(xw, yh2);
            var ty2 = calcMatrix.getY(xw, yh2);
            var tx3 = calcMatrix.getX(xw, y2);
            var ty3 = calcMatrix.getY(xw, y2);
            var unit = this.renderer.setTextureSource(frame.source);
            tint = Utils.getTintAppendFloatAlpha(tint, alpha);
            this.batchQuad(null, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, 0, frame.glTexture, unit);
          },
          batchFillRect: function(x2, y2, width, height, currentMatrix, parentMatrix) {
            this.renderer.pipelines.set(this);
            var calcMatrix = this.calcMatrix;
            if (parentMatrix) {
              parentMatrix.multiply(currentMatrix, calcMatrix);
            }
            var xw = x2 + width;
            var yh2 = y2 + height;
            var x0 = calcMatrix.getX(x2, y2);
            var y0 = calcMatrix.getY(x2, y2);
            var x1 = calcMatrix.getX(x2, yh2);
            var y1 = calcMatrix.getY(x2, yh2);
            var x22 = calcMatrix.getX(xw, yh2);
            var y22 = calcMatrix.getY(xw, yh2);
            var x3 = calcMatrix.getX(xw, y2);
            var y3 = calcMatrix.getY(xw, y2);
            var tint = this.fillTint;
            this.batchQuad(null, x0, y0, x1, y1, x22, y22, x3, y3, 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, tint.BR, 2);
          },
          batchFillTriangle: function(x0, y0, x1, y1, x2, y2, currentMatrix, parentMatrix) {
            this.renderer.pipelines.set(this);
            var calcMatrix = this.calcMatrix;
            if (parentMatrix) {
              parentMatrix.multiply(currentMatrix, calcMatrix);
            }
            var tx0 = calcMatrix.getX(x0, y0);
            var ty0 = calcMatrix.getY(x0, y0);
            var tx1 = calcMatrix.getX(x1, y1);
            var ty1 = calcMatrix.getY(x1, y1);
            var tx2 = calcMatrix.getX(x2, y2);
            var ty2 = calcMatrix.getY(x2, y2);
            var tint = this.fillTint;
            this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, 2);
          },
          batchStrokeTriangle: function(x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix) {
            var tempTriangle = this.tempTriangle;
            tempTriangle[0].x = x0;
            tempTriangle[0].y = y0;
            tempTriangle[0].width = lineWidth;
            tempTriangle[1].x = x1;
            tempTriangle[1].y = y1;
            tempTriangle[1].width = lineWidth;
            tempTriangle[2].x = x2;
            tempTriangle[2].y = y2;
            tempTriangle[2].width = lineWidth;
            tempTriangle[3].x = x0;
            tempTriangle[3].y = y0;
            tempTriangle[3].width = lineWidth;
            this.batchStrokePath(tempTriangle, lineWidth, false, currentMatrix, parentMatrix);
          },
          batchFillPath: function(path, currentMatrix, parentMatrix) {
            this.renderer.pipelines.set(this);
            var calcMatrix = this.calcMatrix;
            if (parentMatrix) {
              parentMatrix.multiply(currentMatrix, calcMatrix);
            }
            var length = path.length;
            var polygonCache = this.polygonCache;
            var polygonIndexArray;
            var point;
            var tintTL = this.fillTint.TL;
            var tintTR = this.fillTint.TR;
            var tintBL = this.fillTint.BL;
            for (var pathIndex = 0; pathIndex < length; ++pathIndex) {
              point = path[pathIndex];
              polygonCache.push(point.x, point.y);
            }
            polygonIndexArray = Earcut(polygonCache);
            length = polygonIndexArray.length;
            for (var index2 = 0; index2 < length; index2 += 3) {
              var p0 = polygonIndexArray[index2 + 0] * 2;
              var p1 = polygonIndexArray[index2 + 1] * 2;
              var p2 = polygonIndexArray[index2 + 2] * 2;
              var x0 = polygonCache[p0 + 0];
              var y0 = polygonCache[p0 + 1];
              var x1 = polygonCache[p1 + 0];
              var y1 = polygonCache[p1 + 1];
              var x2 = polygonCache[p2 + 0];
              var y2 = polygonCache[p2 + 1];
              var tx0 = calcMatrix.getX(x0, y0);
              var ty0 = calcMatrix.getY(x0, y0);
              var tx1 = calcMatrix.getX(x1, y1);
              var ty1 = calcMatrix.getY(x1, y1);
              var tx2 = calcMatrix.getX(x2, y2);
              var ty2 = calcMatrix.getY(x2, y2);
              this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tintTL, tintTR, tintBL, 2);
            }
            polygonCache.length = 0;
          },
          batchStrokePath: function(path, lineWidth, pathOpen, currentMatrix, parentMatrix) {
            this.renderer.pipelines.set(this);
            this.prevQuad[4] = 0;
            this.firstQuad[4] = 0;
            var pathLength = path.length - 1;
            for (var pathIndex = 0; pathIndex < pathLength; pathIndex++) {
              var point0 = path[pathIndex];
              var point1 = path[pathIndex + 1];
              this.batchLine(point0.x, point0.y, point1.x, point1.y, point0.width / 2, point1.width / 2, lineWidth, pathIndex, !pathOpen && pathIndex === pathLength - 1, currentMatrix, parentMatrix);
            }
          },
          batchLine: function(ax, ay, bx, by, aLineWidth, bLineWidth, lineWidth, index2, closePath, currentMatrix, parentMatrix) {
            this.renderer.pipelines.set(this);
            var calcMatrix = this.calcMatrix;
            if (parentMatrix) {
              parentMatrix.multiply(currentMatrix, calcMatrix);
            }
            var dx = bx - ax;
            var dy = by - ay;
            var len = Math.sqrt(dx * dx + dy * dy);
            var al0 = aLineWidth * (by - ay) / len;
            var al1 = aLineWidth * (ax - bx) / len;
            var bl0 = bLineWidth * (by - ay) / len;
            var bl1 = bLineWidth * (ax - bx) / len;
            var lx0 = bx - bl0;
            var ly0 = by - bl1;
            var lx1 = ax - al0;
            var ly1 = ay - al1;
            var lx2 = bx + bl0;
            var ly2 = by + bl1;
            var lx3 = ax + al0;
            var ly3 = ay + al1;
            var brX = calcMatrix.getX(lx0, ly0);
            var brY = calcMatrix.getY(lx0, ly0);
            var blX = calcMatrix.getX(lx1, ly1);
            var blY = calcMatrix.getY(lx1, ly1);
            var trX = calcMatrix.getX(lx2, ly2);
            var trY = calcMatrix.getY(lx2, ly2);
            var tlX = calcMatrix.getX(lx3, ly3);
            var tlY = calcMatrix.getY(lx3, ly3);
            var tint = this.strokeTint;
            var tintTL = tint.TL;
            var tintTR = tint.TR;
            var tintBL = tint.BL;
            var tintBR = tint.BR;
            this.batchQuad(null, tlX, tlY, blX, blY, brX, brY, trX, trY, 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
            if (lineWidth <= 2) {
              return;
            }
            var prev = this.prevQuad;
            var first = this.firstQuad;
            if (index2 > 0 && prev[4]) {
              this.batchQuad(null, tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
            } else {
              first[0] = tlX;
              first[1] = tlY;
              first[2] = blX;
              first[3] = blY;
              first[4] = 1;
            }
            if (closePath && first[4]) {
              this.batchQuad(null, brX, brY, trX, trY, first[0], first[1], first[2], first[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
            } else {
              prev[0] = brX;
              prev[1] = brY;
              prev[2] = trX;
              prev[3] = trY;
              prev[4] = 1;
            }
          }
        });
        module2.exports = MultiPipeline;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Clamp = __webpack_require__(18);
        var Extend = __webpack_require__(17);
        var Frame = new Class({
          initialize: function Frame2(texture, name, sourceIndex, x2, y2, width, height) {
            this.texture = texture;
            this.name = name;
            this.source = texture.source[sourceIndex];
            this.sourceIndex = sourceIndex;
            this.glTexture = this.source.glTexture;
            this.cutX;
            this.cutY;
            this.cutWidth;
            this.cutHeight;
            this.x = 0;
            this.y = 0;
            this.width;
            this.height;
            this.halfWidth;
            this.halfHeight;
            this.centerX;
            this.centerY;
            this.pivotX = 0;
            this.pivotY = 0;
            this.customPivot = false;
            this.rotated = false;
            this.autoRound = -1;
            this.customData = {};
            this.u0 = 0;
            this.v0 = 0;
            this.u1 = 0;
            this.v1 = 0;
            this.data = {
              cut: {
                x: 0,
                y: 0,
                w: 0,
                h: 0,
                r: 0,
                b: 0
              },
              trim: false,
              sourceSize: {
                w: 0,
                h: 0
              },
              spriteSourceSize: {
                x: 0,
                y: 0,
                w: 0,
                h: 0,
                r: 0,
                b: 0
              },
              radius: 0,
              drawImage: {
                x: 0,
                y: 0,
                width: 0,
                height: 0
              }
            };
            this.setSize(width, height, x2, y2);
          },
          setSize: function(width, height, x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            this.cutX = x2;
            this.cutY = y2;
            this.cutWidth = width;
            this.cutHeight = height;
            this.width = width;
            this.height = height;
            this.halfWidth = Math.floor(width * 0.5);
            this.halfHeight = Math.floor(height * 0.5);
            this.centerX = Math.floor(width / 2);
            this.centerY = Math.floor(height / 2);
            var data = this.data;
            var cut = data.cut;
            cut.x = x2;
            cut.y = y2;
            cut.w = width;
            cut.h = height;
            cut.r = x2 + width;
            cut.b = y2 + height;
            data.sourceSize.w = width;
            data.sourceSize.h = height;
            data.spriteSourceSize.w = width;
            data.spriteSourceSize.h = height;
            data.radius = 0.5 * Math.sqrt(width * width + height * height);
            var drawImage = data.drawImage;
            drawImage.x = x2;
            drawImage.y = y2;
            drawImage.width = width;
            drawImage.height = height;
            return this.updateUVs();
          },
          setTrim: function(actualWidth, actualHeight, destX, destY, destWidth, destHeight) {
            var data = this.data;
            var ss = data.spriteSourceSize;
            data.trim = true;
            data.sourceSize.w = actualWidth;
            data.sourceSize.h = actualHeight;
            ss.x = destX;
            ss.y = destY;
            ss.w = destWidth;
            ss.h = destHeight;
            ss.r = destX + destWidth;
            ss.b = destY + destHeight;
            this.x = destX;
            this.y = destY;
            this.width = destWidth;
            this.height = destHeight;
            this.halfWidth = destWidth * 0.5;
            this.halfHeight = destHeight * 0.5;
            this.centerX = Math.floor(destWidth / 2);
            this.centerY = Math.floor(destHeight / 2);
            return this.updateUVs();
          },
          setCropUVs: function(crop, x2, y2, width, height, flipX, flipY) {
            var cx = this.cutX;
            var cy = this.cutY;
            var cw = this.cutWidth;
            var ch2 = this.cutHeight;
            var rw = this.realWidth;
            var rh2 = this.realHeight;
            x2 = Clamp(x2, 0, rw);
            y2 = Clamp(y2, 0, rh2);
            width = Clamp(width, 0, rw - x2);
            height = Clamp(height, 0, rh2 - y2);
            var ox = cx + x2;
            var oy = cy + y2;
            var ow = width;
            var oh2 = height;
            var data = this.data;
            if (data.trim) {
              var ss = data.spriteSourceSize;
              width = Clamp(width, 0, cw - x2);
              height = Clamp(height, 0, ch2 - y2);
              var cropRight = x2 + width;
              var cropBottom = y2 + height;
              var intersects = !(ss.r < x2 || ss.b < y2 || ss.x > cropRight || ss.y > cropBottom);
              if (intersects) {
                var ix = Math.max(ss.x, x2);
                var iy = Math.max(ss.y, y2);
                var iw = Math.min(ss.r, cropRight) - ix;
                var ih2 = Math.min(ss.b, cropBottom) - iy;
                ow = iw;
                oh2 = ih2;
                if (flipX) {
                  ox = cx + (cw - (ix - ss.x) - iw);
                } else {
                  ox = cx + (ix - ss.x);
                }
                if (flipY) {
                  oy = cy + (ch2 - (iy - ss.y) - ih2);
                } else {
                  oy = cy + (iy - ss.y);
                }
                x2 = ix;
                y2 = iy;
                width = iw;
                height = ih2;
              } else {
                ox = 0;
                oy = 0;
                ow = 0;
                oh2 = 0;
              }
            } else {
              if (flipX) {
                ox = cx + (cw - x2 - width);
              }
              if (flipY) {
                oy = cy + (ch2 - y2 - height);
              }
            }
            var tw = this.source.width;
            var th2 = this.source.height;
            crop.u0 = Math.max(0, ox / tw);
            crop.v0 = Math.max(0, oy / th2);
            crop.u1 = Math.min(1, (ox + ow) / tw);
            crop.v1 = Math.min(1, (oy + oh2) / th2);
            crop.x = x2;
            crop.y = y2;
            crop.cx = ox;
            crop.cy = oy;
            crop.cw = ow;
            crop.ch = oh2;
            crop.width = width;
            crop.height = height;
            crop.flipX = flipX;
            crop.flipY = flipY;
            return crop;
          },
          updateCropUVs: function(crop, flipX, flipY) {
            return this.setCropUVs(crop, crop.x, crop.y, crop.width, crop.height, flipX, flipY);
          },
          setUVs: function(width, height, u0, v0, u1, v1) {
            var cd2 = this.data.drawImage;
            cd2.width = width;
            cd2.height = height;
            this.u0 = u0;
            this.v0 = v0;
            this.u1 = u1;
            this.v1 = v1;
            return this;
          },
          updateUVs: function() {
            var cx = this.cutX;
            var cy = this.cutY;
            var cw = this.cutWidth;
            var ch2 = this.cutHeight;
            var cd2 = this.data.drawImage;
            cd2.width = cw;
            cd2.height = ch2;
            var tw = this.source.width;
            var th2 = this.source.height;
            this.u0 = cx / tw;
            this.v0 = cy / th2;
            this.u1 = (cx + cw) / tw;
            this.v1 = (cy + ch2) / th2;
            return this;
          },
          updateUVsInverted: function() {
            var tw = this.source.width;
            var th2 = this.source.height;
            this.u0 = (this.cutX + this.cutHeight) / tw;
            this.v0 = this.cutY / th2;
            this.u1 = this.cutX / tw;
            this.v1 = (this.cutY + this.cutWidth) / th2;
            return this;
          },
          clone: function() {
            var clone = new Frame(this.texture, this.name, this.sourceIndex);
            clone.cutX = this.cutX;
            clone.cutY = this.cutY;
            clone.cutWidth = this.cutWidth;
            clone.cutHeight = this.cutHeight;
            clone.x = this.x;
            clone.y = this.y;
            clone.width = this.width;
            clone.height = this.height;
            clone.halfWidth = this.halfWidth;
            clone.halfHeight = this.halfHeight;
            clone.centerX = this.centerX;
            clone.centerY = this.centerY;
            clone.rotated = this.rotated;
            clone.data = Extend(true, clone.data, this.data);
            clone.updateUVs();
            return clone;
          },
          destroy: function() {
            this.source = null;
            this.texture = null;
            this.glTexture = null;
            this.customData = null;
            this.data = null;
          },
          realWidth: {
            get: function() {
              return this.data.sourceSize.w;
            }
          },
          realHeight: {
            get: function() {
              return this.data.sourceSize.h;
            }
          },
          radius: {
            get: function() {
              return this.data.radius;
            }
          },
          trimmed: {
            get: function() {
              return this.data.trim;
            }
          },
          canvasData: {
            get: function() {
              return this.data.drawImage;
            }
          }
        });
        module2.exports = Frame;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ArrayUtils = __webpack_require__(208);
        var Class = __webpack_require__(0);
        var NOOP = __webpack_require__(1);
        var StableSort = __webpack_require__(79);
        var List = new Class({
          initialize: function List2(parent) {
            this.parent = parent;
            this.list = [];
            this.position = 0;
            this.addCallback = NOOP;
            this.removeCallback = NOOP;
            this._sortKey = "";
          },
          add: function(child, skipCallback) {
            if (skipCallback) {
              return ArrayUtils.Add(this.list, child);
            } else {
              return ArrayUtils.Add(this.list, child, 0, this.addCallback, this);
            }
          },
          addAt: function(child, index2, skipCallback) {
            if (skipCallback) {
              return ArrayUtils.AddAt(this.list, child, index2);
            } else {
              return ArrayUtils.AddAt(this.list, child, index2, 0, this.addCallback, this);
            }
          },
          getAt: function(index2) {
            return this.list[index2];
          },
          getIndex: function(child) {
            return this.list.indexOf(child);
          },
          sort: function(property, handler) {
            if (!property) {
              return this;
            }
            if (handler === void 0) {
              handler = function(childA, childB) {
                return childA[property] - childB[property];
              };
            }
            StableSort(this.list, handler);
            return this;
          },
          getByName: function(name) {
            return ArrayUtils.GetFirst(this.list, "name", name);
          },
          getRandom: function(startIndex, length) {
            return ArrayUtils.GetRandom(this.list, startIndex, length);
          },
          getFirst: function(property, value, startIndex, endIndex) {
            return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
          },
          getAll: function(property, value, startIndex, endIndex) {
            return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
          },
          count: function(property, value) {
            return ArrayUtils.CountAllMatching(this.list, property, value);
          },
          swap: function(child1, child2) {
            ArrayUtils.Swap(this.list, child1, child2);
          },
          moveTo: function(child, index2) {
            return ArrayUtils.MoveTo(this.list, child, index2);
          },
          moveAbove: function(child1, child2) {
            return ArrayUtils.MoveAbove(this.list, child1, child2);
          },
          moveBelow: function(child1, child2) {
            return ArrayUtils.MoveBelow(this.list, child1, child2);
          },
          remove: function(child, skipCallback) {
            if (skipCallback) {
              return ArrayUtils.Remove(this.list, child);
            } else {
              return ArrayUtils.Remove(this.list, child, this.removeCallback, this);
            }
          },
          removeAt: function(index2, skipCallback) {
            if (skipCallback) {
              return ArrayUtils.RemoveAt(this.list, index2);
            } else {
              return ArrayUtils.RemoveAt(this.list, index2, this.removeCallback, this);
            }
          },
          removeBetween: function(startIndex, endIndex, skipCallback) {
            if (skipCallback) {
              return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex);
            } else {
              return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeCallback, this);
            }
          },
          removeAll: function(skipCallback) {
            var i2 = this.list.length;
            while (i2--) {
              this.remove(this.list[i2], skipCallback);
            }
            return this;
          },
          bringToTop: function(child) {
            return ArrayUtils.BringToTop(this.list, child);
          },
          sendToBack: function(child) {
            return ArrayUtils.SendToBack(this.list, child);
          },
          moveUp: function(child) {
            ArrayUtils.MoveUp(this.list, child);
            return child;
          },
          moveDown: function(child) {
            ArrayUtils.MoveDown(this.list, child);
            return child;
          },
          reverse: function() {
            this.list.reverse();
            return this;
          },
          shuffle: function() {
            ArrayUtils.Shuffle(this.list);
            return this;
          },
          replace: function(oldChild, newChild) {
            return ArrayUtils.Replace(this.list, oldChild, newChild);
          },
          exists: function(child) {
            return this.list.indexOf(child) > -1;
          },
          setAll: function(property, value, startIndex, endIndex) {
            ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);
            return this;
          },
          each: function(callback, context) {
            var args = [null];
            for (var i2 = 2; i2 < arguments.length; i2++) {
              args.push(arguments[i2]);
            }
            for (i2 = 0; i2 < this.list.length; i2++) {
              args[0] = this.list[i2];
              callback.apply(context, args);
            }
          },
          shutdown: function() {
            this.removeAll();
            this.list = [];
          },
          destroy: function() {
            this.removeAll();
            this.parent = null;
            this.addCallback = null;
            this.removeCallback = null;
          },
          length: {
            get: function() {
              return this.list.length;
            }
          },
          first: {
            get: function() {
              this.position = 0;
              if (this.list.length > 0) {
                return this.list[0];
              } else {
                return null;
              }
            }
          },
          last: {
            get: function() {
              if (this.list.length > 0) {
                this.position = this.list.length - 1;
                return this.list[this.position];
              } else {
                return null;
              }
            }
          },
          next: {
            get: function() {
              if (this.position < this.list.length) {
                this.position++;
                return this.list[this.position];
              } else {
                return null;
              }
            }
          },
          previous: {
            get: function() {
              if (this.position > 0) {
                this.position--;
                return this.list[this.position];
              } else {
                return null;
              }
            }
          }
        });
        module2.exports = List;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Contains = __webpack_require__(112);
        var GetPoint = __webpack_require__(445);
        var GetPoints = __webpack_require__(446);
        var GEOM_CONST = __webpack_require__(56);
        var Random = __webpack_require__(180);
        var Ellipse = new Class({
          initialize: function Ellipse2(x2, y2, width, height) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = 0;
            }
            if (height === void 0) {
              height = 0;
            }
            this.type = GEOM_CONST.ELLIPSE;
            this.x = x2;
            this.y = y2;
            this.width = width;
            this.height = height;
          },
          contains: function(x2, y2) {
            return Contains(this, x2, y2);
          },
          getPoint: function(position, point) {
            return GetPoint(this, position, point);
          },
          getPoints: function(quantity, stepRate, output) {
            return GetPoints(this, quantity, stepRate, output);
          },
          getRandomPoint: function(point) {
            return Random(this, point);
          },
          setTo: function(x2, y2, width, height) {
            this.x = x2;
            this.y = y2;
            this.width = width;
            this.height = height;
            return this;
          },
          setEmpty: function() {
            this.width = 0;
            this.height = 0;
            return this;
          },
          setPosition: function(x2, y2) {
            if (y2 === void 0) {
              y2 = x2;
            }
            this.x = x2;
            this.y = y2;
            return this;
          },
          setSize: function(width, height) {
            if (height === void 0) {
              height = width;
            }
            this.width = width;
            this.height = height;
            return this;
          },
          isEmpty: function() {
            return this.width <= 0 || this.height <= 0;
          },
          getMinorRadius: function() {
            return Math.min(this.width, this.height) / 2;
          },
          getMajorRadius: function() {
            return Math.max(this.width, this.height) / 2;
          },
          left: {
            get: function() {
              return this.x - this.width / 2;
            },
            set: function(value) {
              this.x = value + this.width / 2;
            }
          },
          right: {
            get: function() {
              return this.x + this.width / 2;
            },
            set: function(value) {
              this.x = value - this.width / 2;
            }
          },
          top: {
            get: function() {
              return this.y - this.height / 2;
            },
            set: function(value) {
              this.y = value + this.height / 2;
            }
          },
          bottom: {
            get: function() {
              return this.y + this.height / 2;
            },
            set: function(value) {
              this.y = value - this.height / 2;
            }
          }
        });
        module2.exports = Ellipse;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Contains = function(ellipse, x2, y2) {
          if (ellipse.width <= 0 || ellipse.height <= 0) {
            return false;
          }
          var normx = (x2 - ellipse.x) / ellipse.width;
          var normy = (y2 - ellipse.y) / ellipse.height;
          normx *= normx;
          normy *= normy;
          return normx + normy < 0.25;
        };
        module2.exports = Contains;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Actions = __webpack_require__(275);
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(75);
        var EventEmitter = __webpack_require__(9);
        var GetAll = __webpack_require__(207);
        var GetFastValue = __webpack_require__(2);
        var GetValue = __webpack_require__(6);
        var IsPlainObject2 = __webpack_require__(7);
        var Range = __webpack_require__(437);
        var Set2 = __webpack_require__(149);
        var Sprite = __webpack_require__(73);
        var Group = new Class({
          Extends: EventEmitter,
          initialize: function Group2(scene, children, config) {
            EventEmitter.call(this);
            if (config) {
              if (children && !Array.isArray(children)) {
                children = [children];
              }
            } else if (Array.isArray(children)) {
              if (IsPlainObject2(children[0])) {
                config = children;
                children = null;
              }
            } else if (IsPlainObject2(children)) {
              config = children;
              children = null;
            }
            this.scene = scene;
            this.children = new Set2();
            this.isParent = true;
            this.type = "Group";
            this.classType = GetFastValue(config, "classType", Sprite);
            this.name = GetFastValue(config, "name", "");
            this.active = GetFastValue(config, "active", true);
            this.maxSize = GetFastValue(config, "maxSize", -1);
            this.defaultKey = GetFastValue(config, "defaultKey", null);
            this.defaultFrame = GetFastValue(config, "defaultFrame", null);
            this.runChildUpdate = GetFastValue(config, "runChildUpdate", false);
            this.createCallback = GetFastValue(config, "createCallback", null);
            this.removeCallback = GetFastValue(config, "removeCallback", null);
            this.createMultipleCallback = GetFastValue(config, "createMultipleCallback", null);
            this.internalCreateCallback = GetFastValue(config, "internalCreateCallback", null);
            this.internalRemoveCallback = GetFastValue(config, "internalRemoveCallback", null);
            if (children) {
              this.addMultiple(children);
            }
            if (config) {
              this.createMultiple(config);
            }
            this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);
            this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);
          },
          addedToScene: function() {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function() {
            this.scene.sys.updateList.remove(this);
          },
          create: function(x2, y2, key, frame, visible, active) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (key === void 0) {
              key = this.defaultKey;
            }
            if (frame === void 0) {
              frame = this.defaultFrame;
            }
            if (visible === void 0) {
              visible = true;
            }
            if (active === void 0) {
              active = true;
            }
            if (this.isFull()) {
              return null;
            }
            var child = new this.classType(this.scene, x2, y2, key, frame);
            child.addToDisplayList(this.scene.sys.displayList);
            child.addToUpdateList();
            child.visible = visible;
            child.setActive(active);
            this.add(child);
            return child;
          },
          createMultiple: function(config) {
            if (this.isFull()) {
              return [];
            }
            if (!Array.isArray(config)) {
              config = [config];
            }
            var output = [];
            if (config[0].key) {
              for (var i2 = 0; i2 < config.length; i2++) {
                var entries = this.createFromConfig(config[i2]);
                output = output.concat(entries);
              }
            }
            return output;
          },
          createFromConfig: function(options) {
            if (this.isFull()) {
              return [];
            }
            this.classType = GetFastValue(options, "classType", this.classType);
            var key = GetFastValue(options, "key", void 0);
            var frame = GetFastValue(options, "frame", null);
            var visible = GetFastValue(options, "visible", true);
            var active = GetFastValue(options, "active", true);
            var entries = [];
            if (key === void 0) {
              return entries;
            } else {
              if (!Array.isArray(key)) {
                key = [key];
              }
              if (!Array.isArray(frame)) {
                frame = [frame];
              }
            }
            var repeat = GetFastValue(options, "repeat", 0);
            var randomKey = GetFastValue(options, "randomKey", false);
            var randomFrame = GetFastValue(options, "randomFrame", false);
            var yoyo = GetFastValue(options, "yoyo", false);
            var quantity = GetFastValue(options, "quantity", false);
            var frameQuantity = GetFastValue(options, "frameQuantity", 1);
            var max = GetFastValue(options, "max", 0);
            var range = Range(key, frame, {
              max,
              qty: quantity ? quantity : frameQuantity,
              random: randomKey,
              randomB: randomFrame,
              repeat,
              yoyo
            });
            if (options.createCallback) {
              this.createCallback = options.createCallback;
            }
            if (options.removeCallback) {
              this.removeCallback = options.removeCallback;
            }
            for (var c = 0; c < range.length; c++) {
              var created = this.create(0, 0, range[c].a, range[c].b, visible, active);
              if (!created) {
                break;
              }
              entries.push(created);
            }
            var x2 = GetValue(options, "setXY.x", 0);
            var y2 = GetValue(options, "setXY.y", 0);
            var stepX = GetValue(options, "setXY.stepX", 0);
            var stepY = GetValue(options, "setXY.stepY", 0);
            Actions.SetXY(entries, x2, y2, stepX, stepY);
            var rotation = GetValue(options, "setRotation.value", 0);
            var stepRotation = GetValue(options, "setRotation.step", 0);
            Actions.SetRotation(entries, rotation, stepRotation);
            var scaleX = GetValue(options, "setScale.x", 1);
            var scaleY = GetValue(options, "setScale.y", scaleX);
            var stepScaleX = GetValue(options, "setScale.stepX", 0);
            var stepScaleY = GetValue(options, "setScale.stepY", 0);
            Actions.SetScale(entries, scaleX, scaleY, stepScaleX, stepScaleY);
            var originX = GetValue(options, "setOrigin.x", 0.5);
            var originY = GetValue(options, "setOrigin.y", originX);
            var stepOriginX = GetValue(options, "setOrigin.stepX", 0);
            var stepOriginY = GetValue(options, "setOrigin.stepY", 0);
            Actions.SetOrigin(entries, originX, originY, stepOriginX, stepOriginY);
            var alpha = GetValue(options, "setAlpha.value", 1);
            var stepAlpha = GetValue(options, "setAlpha.step", 0);
            Actions.SetAlpha(entries, alpha, stepAlpha);
            var depth = GetValue(options, "setDepth.value", 0);
            var stepDepth = GetValue(options, "setDepth.step", 0);
            Actions.SetDepth(entries, depth, stepDepth);
            var scrollFactorX = GetValue(options, "setScrollFactor.x", 1);
            var scrollFactorY = GetValue(options, "setScrollFactor.y", scrollFactorX);
            var stepScrollFactorX = GetValue(options, "setScrollFactor.stepX", 0);
            var stepScrollFactorY = GetValue(options, "setScrollFactor.stepY", 0);
            Actions.SetScrollFactor(entries, scrollFactorX, scrollFactorY, stepScrollFactorX, stepScrollFactorY);
            var hitArea = GetFastValue(options, "hitArea", null);
            var hitAreaCallback = GetFastValue(options, "hitAreaCallback", null);
            if (hitArea) {
              Actions.SetHitArea(entries, hitArea, hitAreaCallback);
            }
            var grid = GetFastValue(options, "gridAlign", false);
            if (grid) {
              Actions.GridAlign(entries, grid);
            }
            if (this.createMultipleCallback) {
              this.createMultipleCallback.call(this, entries);
            }
            return entries;
          },
          preUpdate: function(time, delta) {
            if (!this.runChildUpdate || this.children.size === 0) {
              return;
            }
            var temp = this.children.entries.slice();
            for (var i2 = 0; i2 < temp.length; i2++) {
              var item = temp[i2];
              if (item.active) {
                item.update(time, delta);
              }
            }
          },
          add: function(child, addToScene) {
            if (addToScene === void 0) {
              addToScene = false;
            }
            if (this.isFull()) {
              return this;
            }
            this.children.set(child);
            if (this.internalCreateCallback) {
              this.internalCreateCallback.call(this, child);
            }
            if (this.createCallback) {
              this.createCallback.call(this, child);
            }
            if (addToScene) {
              child.addToDisplayList(this.scene.sys.displayList);
              child.addToUpdateList();
            }
            child.on(Events.DESTROY, this.remove, this);
            return this;
          },
          addMultiple: function(children, addToScene) {
            if (addToScene === void 0) {
              addToScene = false;
            }
            if (Array.isArray(children)) {
              for (var i2 = 0; i2 < children.length; i2++) {
                this.add(children[i2], addToScene);
              }
            }
            return this;
          },
          remove: function(child, removeFromScene, destroyChild) {
            if (removeFromScene === void 0) {
              removeFromScene = false;
            }
            if (destroyChild === void 0) {
              destroyChild = false;
            }
            if (!this.children.contains(child)) {
              return this;
            }
            this.children.delete(child);
            if (this.internalRemoveCallback) {
              this.internalRemoveCallback.call(this, child);
            }
            if (this.removeCallback) {
              this.removeCallback.call(this, child);
            }
            child.off(Events.DESTROY, this.remove, this);
            if (destroyChild) {
              child.destroy();
            } else if (removeFromScene) {
              child.removeFromDisplayList();
              child.removeFromUpdateList();
            }
            return this;
          },
          clear: function(removeFromScene, destroyChild) {
            if (removeFromScene === void 0) {
              removeFromScene = false;
            }
            if (destroyChild === void 0) {
              destroyChild = false;
            }
            var children = this.children;
            for (var i2 = 0; i2 < children.size; i2++) {
              var gameObject = children.entries[i2];
              gameObject.off(Events.DESTROY, this.remove, this);
              if (destroyChild) {
                gameObject.destroy();
              } else if (removeFromScene) {
                gameObject.removeFromDisplayList();
                gameObject.removeFromUpdateList();
              }
            }
            this.children.clear();
            return this;
          },
          contains: function(child) {
            return this.children.contains(child);
          },
          getChildren: function() {
            return this.children.entries;
          },
          getLength: function() {
            return this.children.size;
          },
          getMatching: function(property, value, startIndex, endIndex) {
            return GetAll(this.children.entries, property, value, startIndex, endIndex);
          },
          getFirst: function(state, createIfNull, x2, y2, key, frame, visible) {
            return this.getHandler(true, 1, state, createIfNull, x2, y2, key, frame, visible);
          },
          getFirstNth: function(nth, state, createIfNull, x2, y2, key, frame, visible) {
            return this.getHandler(true, nth, state, createIfNull, x2, y2, key, frame, visible);
          },
          getLast: function(state, createIfNull, x2, y2, key, frame, visible) {
            return this.getHandler(false, 1, state, createIfNull, x2, y2, key, frame, visible);
          },
          getLastNth: function(nth, state, createIfNull, x2, y2, key, frame, visible) {
            return this.getHandler(false, nth, state, createIfNull, x2, y2, key, frame, visible);
          },
          getHandler: function(forwards, nth, state, createIfNull, x2, y2, key, frame, visible) {
            if (state === void 0) {
              state = false;
            }
            if (createIfNull === void 0) {
              createIfNull = false;
            }
            var gameObject;
            var i2;
            var total = 0;
            var children = this.children.entries;
            if (forwards) {
              for (i2 = 0; i2 < children.length; i2++) {
                gameObject = children[i2];
                if (gameObject.active === state) {
                  total++;
                  if (total === nth) {
                    break;
                  }
                } else {
                  gameObject = null;
                }
              }
            } else {
              for (i2 = children.length - 1; i2 >= 0; i2--) {
                gameObject = children[i2];
                if (gameObject.active === state) {
                  total++;
                  if (total === nth) {
                    break;
                  }
                } else {
                  gameObject = null;
                }
              }
            }
            if (gameObject) {
              if (typeof x2 === "number") {
                gameObject.x = x2;
              }
              if (typeof y2 === "number") {
                gameObject.y = y2;
              }
              return gameObject;
            }
            if (createIfNull) {
              return this.create(x2, y2, key, frame, visible);
            } else {
              return null;
            }
          },
          get: function(x2, y2, key, frame, visible) {
            return this.getFirst(false, true, x2, y2, key, frame, visible);
          },
          getFirstAlive: function(createIfNull, x2, y2, key, frame, visible) {
            return this.getFirst(true, createIfNull, x2, y2, key, frame, visible);
          },
          getFirstDead: function(createIfNull, x2, y2, key, frame, visible) {
            return this.getFirst(false, createIfNull, x2, y2, key, frame, visible);
          },
          playAnimation: function(key, startFrame) {
            Actions.PlayAnimation(this.children.entries, key, startFrame);
            return this;
          },
          isFull: function() {
            if (this.maxSize === -1) {
              return false;
            } else {
              return this.children.size >= this.maxSize;
            }
          },
          countActive: function(value) {
            if (value === void 0) {
              value = true;
            }
            var total = 0;
            for (var i2 = 0; i2 < this.children.size; i2++) {
              if (this.children.entries[i2].active === value) {
                total++;
              }
            }
            return total;
          },
          getTotalUsed: function() {
            return this.countActive();
          },
          getTotalFree: function() {
            var used = this.getTotalUsed();
            var capacity = this.maxSize === -1 ? 999999999999 : this.maxSize;
            return capacity - used;
          },
          setActive: function(value) {
            this.active = value;
            return this;
          },
          setName: function(value) {
            this.name = value;
            return this;
          },
          propertyValueSet: function(key, value, step, index2, direction) {
            Actions.PropertyValueSet(this.children.entries, key, value, step, index2, direction);
            return this;
          },
          propertyValueInc: function(key, value, step, index2, direction) {
            Actions.PropertyValueInc(this.children.entries, key, value, step, index2, direction);
            return this;
          },
          setX: function(value, step) {
            Actions.SetX(this.children.entries, value, step);
            return this;
          },
          setY: function(value, step) {
            Actions.SetY(this.children.entries, value, step);
            return this;
          },
          setXY: function(x2, y2, stepX, stepY) {
            Actions.SetXY(this.children.entries, x2, y2, stepX, stepY);
            return this;
          },
          incX: function(value, step) {
            Actions.IncX(this.children.entries, value, step);
            return this;
          },
          incY: function(value, step) {
            Actions.IncY(this.children.entries, value, step);
            return this;
          },
          incXY: function(x2, y2, stepX, stepY) {
            Actions.IncXY(this.children.entries, x2, y2, stepX, stepY);
            return this;
          },
          shiftPosition: function(x2, y2, direction) {
            Actions.ShiftPosition(this.children.entries, x2, y2, direction);
            return this;
          },
          angle: function(value, step) {
            Actions.Angle(this.children.entries, value, step);
            return this;
          },
          rotate: function(value, step) {
            Actions.Rotate(this.children.entries, value, step);
            return this;
          },
          rotateAround: function(point, angle) {
            Actions.RotateAround(this.children.entries, point, angle);
            return this;
          },
          rotateAroundDistance: function(point, angle, distance) {
            Actions.RotateAroundDistance(this.children.entries, point, angle, distance);
            return this;
          },
          setAlpha: function(value, step) {
            Actions.SetAlpha(this.children.entries, value, step);
            return this;
          },
          setTint: function(topLeft, topRight, bottomLeft, bottomRight) {
            Actions.SetTint(this.children.entries, topLeft, topRight, bottomLeft, bottomRight);
            return this;
          },
          setOrigin: function(originX, originY, stepX, stepY) {
            Actions.SetOrigin(this.children.entries, originX, originY, stepX, stepY);
            return this;
          },
          scaleX: function(value, step) {
            Actions.ScaleX(this.children.entries, value, step);
            return this;
          },
          scaleY: function(value, step) {
            Actions.ScaleY(this.children.entries, value, step);
            return this;
          },
          scaleXY: function(scaleX, scaleY, stepX, stepY) {
            Actions.ScaleXY(this.children.entries, scaleX, scaleY, stepX, stepY);
            return this;
          },
          setDepth: function(value, step) {
            Actions.SetDepth(this.children.entries, value, step);
            return this;
          },
          setBlendMode: function(value) {
            Actions.SetBlendMode(this.children.entries, value);
            return this;
          },
          setHitArea: function(hitArea, hitAreaCallback) {
            Actions.SetHitArea(this.children.entries, hitArea, hitAreaCallback);
            return this;
          },
          shuffle: function() {
            Actions.Shuffle(this.children.entries);
            return this;
          },
          kill: function(gameObject) {
            if (this.children.contains(gameObject)) {
              gameObject.setActive(false);
            }
          },
          killAndHide: function(gameObject) {
            if (this.children.contains(gameObject)) {
              gameObject.setActive(false);
              gameObject.setVisible(false);
            }
          },
          setVisible: function(value, index2, direction) {
            Actions.SetVisible(this.children.entries, value, index2, direction);
            return this;
          },
          toggleVisible: function() {
            Actions.ToggleVisible(this.children.entries);
            return this;
          },
          destroy: function(destroyChildren, removeFromScene) {
            if (destroyChildren === void 0) {
              destroyChildren = false;
            }
            if (removeFromScene === void 0) {
              removeFromScene = false;
            }
            if (!this.scene || this.ignoreDestroy) {
              return;
            }
            this.emit(Events.DESTROY, this);
            this.removeAllListeners();
            this.scene.sys.updateList.remove(this);
            this.clear(removeFromScene, destroyChildren);
            this.scene = void 0;
            this.children = void 0;
          }
        });
        module2.exports = Group;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Utils = __webpack_require__(12);
        var FillPathWebGL = function(pipeline, calcMatrix, src, alpha, dx, dy) {
          var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
          var path = src.pathData;
          var pathIndexes = src.pathIndexes;
          for (var i2 = 0; i2 < pathIndexes.length; i2 += 3) {
            var p0 = pathIndexes[i2] * 2;
            var p1 = pathIndexes[i2 + 1] * 2;
            var p2 = pathIndexes[i2 + 2] * 2;
            var x0 = path[p0 + 0] - dx;
            var y0 = path[p0 + 1] - dy;
            var x1 = path[p1 + 0] - dx;
            var y1 = path[p1 + 1] - dy;
            var x2 = path[p2 + 0] - dx;
            var y2 = path[p2 + 1] - dy;
            var tx0 = calcMatrix.getX(x0, y0);
            var ty0 = calcMatrix.getY(x0, y0);
            var tx1 = calcMatrix.getX(x1, y1);
            var ty1 = calcMatrix.getY(x1, y1);
            var tx2 = calcMatrix.getX(x2, y2);
            var ty2 = calcMatrix.getY(x2, y2);
            pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
          }
        };
        module2.exports = FillPathWebGL;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Contains = function(triangle, x2, y2) {
          var v0x = triangle.x3 - triangle.x1;
          var v0y = triangle.y3 - triangle.y1;
          var v1x = triangle.x2 - triangle.x1;
          var v1y = triangle.y2 - triangle.y1;
          var v2x = x2 - triangle.x1;
          var v2y = y2 - triangle.y1;
          var dot00 = v0x * v0x + v0y * v0y;
          var dot01 = v0x * v1x + v0y * v1y;
          var dot02 = v0x * v2x + v0y * v2y;
          var dot11 = v1x * v1x + v1y * v1y;
          var dot12 = v1x * v2x + v1y * v2y;
          var b2 = dot00 * dot11 - dot01 * dot01;
          var inv = b2 === 0 ? 0 : 1 / b2;
          var u2 = (dot11 * dot02 - dot01 * dot12) * inv;
          var v2 = (dot00 * dot12 - dot01 * dot02) * inv;
          return u2 >= 0 && v2 >= 0 && u2 + v2 < 1;
        };
        module2.exports = Contains;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Rectangle = __webpack_require__(10);
        var Vector2 = __webpack_require__(3);
        function GetLength(x1, y1, x2, y2) {
          var x3 = x1 - x2;
          var y3 = y1 - y2;
          var magnitude = x3 * x3 + y3 * y3;
          return Math.sqrt(magnitude);
        }
        var Face = new Class({
          initialize: function Face2(vertex1, vertex2, vertex3) {
            this.vertex1 = vertex1;
            this.vertex2 = vertex2;
            this.vertex3 = vertex3;
            this.bounds = new Rectangle();
            this._inCenter = new Vector2();
          },
          getInCenter: function(local) {
            if (local === void 0) {
              local = true;
            }
            var v1 = this.vertex1;
            var v2 = this.vertex2;
            var v3 = this.vertex3;
            var v1x;
            var v1y;
            var v2x;
            var v2y;
            var v3x;
            var v3y;
            if (local) {
              v1x = v1.x;
              v1y = v1.y;
              v2x = v2.x;
              v2y = v2.y;
              v3x = v3.x;
              v3y = v3.y;
            } else {
              v1x = v1.vx;
              v1y = v1.vy;
              v2x = v2.vx;
              v2y = v2.vy;
              v3x = v3.vx;
              v3y = v3.vy;
            }
            var d1 = GetLength(v3x, v3y, v2x, v2y);
            var d2 = GetLength(v1x, v1y, v3x, v3y);
            var d3 = GetLength(v2x, v2y, v1x, v1y);
            var p2 = d1 + d2 + d3;
            return this._inCenter.set((v1x * d1 + v2x * d2 + v3x * d3) / p2, (v1y * d1 + v2y * d2 + v3y * d3) / p2);
          },
          contains: function(x2, y2, calcMatrix) {
            var vertex1 = this.vertex1;
            var vertex2 = this.vertex2;
            var vertex3 = this.vertex3;
            var v1x = vertex1.vx;
            var v1y = vertex1.vy;
            var v2x = vertex2.vx;
            var v2y = vertex2.vy;
            var v3x = vertex3.vx;
            var v3y = vertex3.vy;
            if (calcMatrix) {
              var a = calcMatrix.a;
              var b2 = calcMatrix.b;
              var c = calcMatrix.c;
              var d = calcMatrix.d;
              var e = calcMatrix.e;
              var f2 = calcMatrix.f;
              v1x = vertex1.vx * a + vertex1.vy * c + e;
              v1y = vertex1.vx * b2 + vertex1.vy * d + f2;
              v2x = vertex2.vx * a + vertex2.vy * c + e;
              v2y = vertex2.vx * b2 + vertex2.vy * d + f2;
              v3x = vertex3.vx * a + vertex3.vy * c + e;
              v3y = vertex3.vx * b2 + vertex3.vy * d + f2;
            }
            var t0x = v3x - v1x;
            var t0y = v3y - v1y;
            var t1x = v2x - v1x;
            var t1y = v2y - v1y;
            var t2x = x2 - v1x;
            var t2y = y2 - v1y;
            var dot00 = t0x * t0x + t0y * t0y;
            var dot01 = t0x * t1x + t0y * t1y;
            var dot02 = t0x * t2x + t0y * t2y;
            var dot11 = t1x * t1x + t1y * t1y;
            var dot12 = t1x * t2x + t1y * t2y;
            var bc2 = dot00 * dot11 - dot01 * dot01;
            var inv = bc2 === 0 ? 0 : 1 / bc2;
            var u2 = (dot11 * dot02 - dot01 * dot12) * inv;
            var v2 = (dot00 * dot12 - dot01 * dot02) * inv;
            return u2 >= 0 && v2 >= 0 && u2 + v2 < 1;
          },
          isCounterClockwise: function(z2) {
            var v1 = this.vertex1;
            var v2 = this.vertex2;
            var v3 = this.vertex3;
            var d = (v2.vx - v1.vx) * (v3.vy - v1.vy) - (v2.vy - v1.vy) * (v3.vx - v1.vx);
            return z2 <= 0 ? d >= 0 : d < 0;
          },
          load: function(F32, U32, offset, textureUnit, tintEffect) {
            offset = this.vertex1.load(F32, U32, offset, textureUnit, tintEffect);
            offset = this.vertex2.load(F32, U32, offset, textureUnit, tintEffect);
            offset = this.vertex3.load(F32, U32, offset, textureUnit, tintEffect);
            return offset;
          },
          transformCoordinatesLocal: function(transformMatrix, width, height, cameraZ) {
            this.vertex1.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
            this.vertex2.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
            this.vertex3.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
            return this;
          },
          updateBounds: function() {
            var v1 = this.vertex1;
            var v2 = this.vertex2;
            var v3 = this.vertex3;
            var bounds = this.bounds;
            bounds.x = Math.min(v1.vx, v2.vx, v3.vx);
            bounds.y = Math.min(v1.vy, v2.vy, v3.vy);
            bounds.width = Math.max(v1.vx, v2.vx, v3.vx) - bounds.x;
            bounds.height = Math.max(v1.vy, v2.vy, v3.vy) - bounds.y;
            return this;
          },
          isInView: function(camera, hideCCW, z2, alpha, a, b2, c, d, e, f2, roundPixels) {
            var v1 = this.vertex1.update(a, b2, c, d, e, f2, roundPixels, alpha);
            var v2 = this.vertex2.update(a, b2, c, d, e, f2, roundPixels, alpha);
            var v3 = this.vertex3.update(a, b2, c, d, e, f2, roundPixels, alpha);
            if (v1.ta <= 0 && v2.ta <= 0 && v3.ta <= 0) {
              return false;
            }
            if (hideCCW && !this.isCounterClockwise(z2)) {
              return false;
            }
            var bounds = this.bounds;
            bounds.x = Math.min(v1.tx, v2.tx, v3.tx);
            bounds.y = Math.min(v1.ty, v2.ty, v3.ty);
            bounds.width = Math.max(v1.tx, v2.tx, v3.tx) - bounds.x;
            bounds.height = Math.max(v1.ty, v2.ty, v3.ty) - bounds.y;
            var cr = camera.x + camera.width;
            var cb2 = camera.y + camera.height;
            if (bounds.width <= 0 || bounds.height <= 0 || camera.width <= 0 || camera.height <= 0) {
              return false;
            }
            return !(bounds.right < camera.x || bounds.bottom < camera.y || bounds.x > cr || bounds.y > cb2);
          },
          translate: function(x2, y2) {
            if (y2 === void 0) {
              y2 = 0;
            }
            var v1 = this.vertex1;
            var v2 = this.vertex2;
            var v3 = this.vertex3;
            v1.x += x2;
            v1.y += y2;
            v2.x += x2;
            v2.y += y2;
            v3.x += x2;
            v3.y += y2;
            return this;
          },
          x: {
            get: function() {
              return this.getInCenter().x;
            },
            set: function(value) {
              var current = this.getInCenter();
              this.translate(value - current.x, 0);
            }
          },
          y: {
            get: function() {
              return this.getInCenter().y;
            },
            set: function(value) {
              var current = this.getInCenter();
              this.translate(0, value - current.y);
            }
          },
          alpha: {
            get: function() {
              var v1 = this.vertex1;
              var v2 = this.vertex2;
              var v3 = this.vertex3;
              return (v1.alpha + v2.alpha + v3.alpha) / 3;
            },
            set: function(value) {
              this.vertex1.alpha = value;
              this.vertex2.alpha = value;
              this.vertex3.alpha = value;
            }
          },
          depth: {
            get: function() {
              var v1 = this.vertex1;
              var v2 = this.vertex2;
              var v3 = this.vertex3;
              return (v1.vz + v2.vz + v3.vz) / 3;
            }
          },
          destroy: function() {
            this.vertex1 = null;
            this.vertex2 = null;
            this.vertex3 = null;
          }
        });
        module2.exports = Face;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Utils = __webpack_require__(12);
        var Vector3 = __webpack_require__(39);
        var Vertex = new Class({
          Extends: Vector3,
          initialize: function Vertex2(x2, y2, z2, u2, v2, color, alpha, nx, ny, nz) {
            if (color === void 0) {
              color = 16777215;
            }
            if (alpha === void 0) {
              alpha = 1;
            }
            if (nx === void 0) {
              nx = 0;
            }
            if (ny === void 0) {
              ny = 0;
            }
            if (nz === void 0) {
              nz = 0;
            }
            Vector3.call(this, x2, y2, z2);
            this.vx = 0;
            this.vy = 0;
            this.vz = 0;
            this.nx = nx;
            this.ny = ny;
            this.nz = nz;
            this.u = u2;
            this.v = v2;
            this.color = color;
            this.alpha = alpha;
            this.tx = 0;
            this.ty = 0;
            this.ta = 0;
          },
          setUVs: function(u2, v2) {
            this.u = u2;
            this.v = v2;
            return this;
          },
          transformCoordinatesLocal: function(transformMatrix, width, height, cameraZ) {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var m2 = transformMatrix.val;
            var tx = x2 * m2[0] + y2 * m2[4] + z2 * m2[8] + m2[12];
            var ty = x2 * m2[1] + y2 * m2[5] + z2 * m2[9] + m2[13];
            var tz = x2 * m2[2] + y2 * m2[6] + z2 * m2[10] + m2[14];
            var tw = x2 * m2[3] + y2 * m2[7] + z2 * m2[11] + m2[15];
            this.vx = tx / tw * width;
            this.vy = -(ty / tw) * height;
            if (cameraZ <= 0) {
              this.vz = tz / tw;
            } else {
              this.vz = -(tz / tw);
            }
          },
          update: function(a, b2, c, d, e, f2, roundPixels, alpha) {
            var tx = this.vx * a + this.vy * c + e;
            var ty = this.vx * b2 + this.vy * d + f2;
            if (roundPixels) {
              tx = Math.round(tx);
              ty = Math.round(ty);
            }
            this.tx = tx;
            this.ty = ty;
            this.ta = this.alpha * alpha;
            return this;
          },
          load: function(F32, U32, offset, textureUnit, tintEffect) {
            F32[++offset] = this.tx;
            F32[++offset] = this.ty;
            F32[++offset] = this.u;
            F32[++offset] = this.v;
            F32[++offset] = textureUnit;
            F32[++offset] = tintEffect;
            U32[++offset] = Utils.getTintAppendFloatAlpha(this.color, this.ta);
            return offset;
          }
        });
        module2.exports = Vertex;
      },
      function(module2, exports2, __webpack_require__) {
        var Composite = {};
        module2.exports = Composite;
        var Events = __webpack_require__(166);
        var Common = __webpack_require__(32);
        var Bounds = __webpack_require__(84);
        var Body = __webpack_require__(41);
        (function() {
          Composite.create = function(options) {
            return Common.extend({
              id: Common.nextId(),
              type: "composite",
              parent: null,
              isModified: false,
              bodies: [],
              constraints: [],
              composites: [],
              label: "Composite",
              plugin: {}
            }, options);
          };
          Composite.setModified = function(composite, isModified, updateParents, updateChildren) {
            Events.trigger(composite, "compositeModified", composite);
            composite.isModified = isModified;
            if (updateParents && composite.parent) {
              Composite.setModified(composite.parent, isModified, updateParents, updateChildren);
            }
            if (updateChildren) {
              for (var i2 = 0; i2 < composite.composites.length; i2++) {
                var childComposite = composite.composites[i2];
                Composite.setModified(childComposite, isModified, updateParents, updateChildren);
              }
            }
          };
          Composite.add = function(composite, object) {
            var objects = [].concat(object);
            Events.trigger(composite, "beforeAdd", { object });
            for (var i2 = 0; i2 < objects.length; i2++) {
              var obj = objects[i2];
              switch (obj.type) {
                case "body":
                  if (obj.parent !== obj) {
                    Common.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                    break;
                  }
                  Composite.addBody(composite, obj);
                  break;
                case "constraint":
                  Composite.addConstraint(composite, obj);
                  break;
                case "composite":
                  Composite.addComposite(composite, obj);
                  break;
                case "mouseConstraint":
                  Composite.addConstraint(composite, obj.constraint);
                  break;
              }
            }
            Events.trigger(composite, "afterAdd", { object });
            return composite;
          };
          Composite.remove = function(composite, object, deep) {
            var objects = [].concat(object);
            Events.trigger(composite, "beforeRemove", { object });
            for (var i2 = 0; i2 < objects.length; i2++) {
              var obj = objects[i2];
              switch (obj.type) {
                case "body":
                  Composite.removeBody(composite, obj, deep);
                  break;
                case "constraint":
                  Composite.removeConstraint(composite, obj, deep);
                  break;
                case "composite":
                  Composite.removeComposite(composite, obj, deep);
                  break;
                case "mouseConstraint":
                  Composite.removeConstraint(composite, obj.constraint);
                  break;
              }
            }
            Events.trigger(composite, "afterRemove", { object });
            return composite;
          };
          Composite.addComposite = function(compositeA, compositeB) {
            compositeA.composites.push(compositeB);
            compositeB.parent = compositeA;
            Composite.setModified(compositeA, true, true, false);
            return compositeA;
          };
          Composite.removeComposite = function(compositeA, compositeB, deep) {
            var position = compositeA.composites.indexOf(compositeB);
            if (position !== -1) {
              Composite.removeCompositeAt(compositeA, position);
              Composite.setModified(compositeA, true, true, false);
            }
            if (deep) {
              for (var i2 = 0; i2 < compositeA.composites.length; i2++) {
                Composite.removeComposite(compositeA.composites[i2], compositeB, true);
              }
            }
            return compositeA;
          };
          Composite.removeCompositeAt = function(composite, position) {
            composite.composites.splice(position, 1);
            Composite.setModified(composite, true, true, false);
            return composite;
          };
          Composite.addBody = function(composite, body) {
            composite.bodies.push(body);
            Composite.setModified(composite, true, true, false);
            return composite;
          };
          Composite.removeBody = function(composite, body, deep) {
            var position = composite.bodies.indexOf(body);
            if (position !== -1) {
              Composite.removeBodyAt(composite, position);
              Composite.setModified(composite, true, true, false);
            }
            if (deep) {
              for (var i2 = 0; i2 < composite.composites.length; i2++) {
                Composite.removeBody(composite.composites[i2], body, true);
              }
            }
            return composite;
          };
          Composite.removeBodyAt = function(composite, position) {
            composite.bodies.splice(position, 1);
            Composite.setModified(composite, true, true, false);
            return composite;
          };
          Composite.addConstraint = function(composite, constraint) {
            composite.constraints.push(constraint);
            Composite.setModified(composite, true, true, false);
            return composite;
          };
          Composite.removeConstraint = function(composite, constraint, deep) {
            var position = composite.constraints.indexOf(constraint);
            if (position !== -1) {
              Composite.removeConstraintAt(composite, position);
            }
            if (deep) {
              for (var i2 = 0; i2 < composite.composites.length; i2++) {
                Composite.removeConstraint(composite.composites[i2], constraint, true);
              }
            }
            return composite;
          };
          Composite.removeConstraintAt = function(composite, position) {
            composite.constraints.splice(position, 1);
            Composite.setModified(composite, true, true, false);
            return composite;
          };
          Composite.clear = function(composite, keepStatic, deep) {
            if (deep) {
              for (var i2 = 0; i2 < composite.composites.length; i2++) {
                Composite.clear(composite.composites[i2], keepStatic, true);
              }
            }
            if (keepStatic) {
              composite.bodies = composite.bodies.filter(function(body) {
                return body.isStatic;
              });
            } else {
              composite.bodies.length = 0;
            }
            composite.constraints.length = 0;
            composite.composites.length = 0;
            Composite.setModified(composite, true, true, false);
            return composite;
          };
          Composite.allBodies = function(composite) {
            var bodies = [].concat(composite.bodies);
            for (var i2 = 0; i2 < composite.composites.length; i2++)
              bodies = bodies.concat(Composite.allBodies(composite.composites[i2]));
            return bodies;
          };
          Composite.allConstraints = function(composite) {
            var constraints = [].concat(composite.constraints);
            for (var i2 = 0; i2 < composite.composites.length; i2++)
              constraints = constraints.concat(Composite.allConstraints(composite.composites[i2]));
            return constraints;
          };
          Composite.allComposites = function(composite) {
            var composites = [].concat(composite.composites);
            for (var i2 = 0; i2 < composite.composites.length; i2++)
              composites = composites.concat(Composite.allComposites(composite.composites[i2]));
            return composites;
          };
          Composite.get = function(composite, id2, type) {
            var objects, object;
            switch (type) {
              case "body":
                objects = Composite.allBodies(composite);
                break;
              case "constraint":
                objects = Composite.allConstraints(composite);
                break;
              case "composite":
                objects = Composite.allComposites(composite).concat(composite);
                break;
            }
            if (!objects)
              return null;
            object = objects.filter(function(object2) {
              return object2.id.toString() === id2.toString();
            });
            return object.length === 0 ? null : object[0];
          };
          Composite.move = function(compositeA, objects, compositeB) {
            Composite.remove(compositeA, objects);
            Composite.add(compositeB, objects);
            return compositeA;
          };
          Composite.rebase = function(composite) {
            var objects = Composite.allBodies(composite).concat(Composite.allConstraints(composite)).concat(Composite.allComposites(composite));
            for (var i2 = 0; i2 < objects.length; i2++) {
              objects[i2].id = Common.nextId();
            }
            Composite.setModified(composite, true, true, false);
            return composite;
          };
          Composite.translate = function(composite, translation, recursive) {
            var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
            for (var i2 = 0; i2 < bodies.length; i2++) {
              Body.translate(bodies[i2], translation);
            }
            Composite.setModified(composite, true, true, false);
            return composite;
          };
          Composite.rotate = function(composite, rotation, point, recursive) {
            var cos = Math.cos(rotation), sin = Math.sin(rotation), bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2], dx = body.position.x - point.x, dy = body.position.y - point.y;
              Body.setPosition(body, {
                x: point.x + (dx * cos - dy * sin),
                y: point.y + (dx * sin + dy * cos)
              });
              Body.rotate(body, rotation);
            }
            Composite.setModified(composite, true, true, false);
            return composite;
          };
          Composite.scale = function(composite, scaleX, scaleY, point, recursive) {
            var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2], dx = body.position.x - point.x, dy = body.position.y - point.y;
              Body.setPosition(body, {
                x: point.x + dx * scaleX,
                y: point.y + dy * scaleY
              });
              Body.scale(body, scaleX, scaleY);
            }
            Composite.setModified(composite, true, true, false);
            return composite;
          };
          Composite.bounds = function(composite) {
            var bodies = Composite.allBodies(composite), vertices = [];
            for (var i2 = 0; i2 < bodies.length; i2 += 1) {
              var body = bodies[i2];
              vertices.push(body.bounds.min, body.bounds.max);
            }
            return Bounds.create(vertices);
          };
        })();
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var IsInLayerBounds = function(tileX, tileY, layer) {
          return tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height;
        };
        module2.exports = IsInLayerBounds;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(29);
        var GetFastValue = __webpack_require__(2);
        var LayerData = new Class({
          initialize: function LayerData2(config) {
            if (config === void 0) {
              config = {};
            }
            this.name = GetFastValue(config, "name", "layer");
            this.x = GetFastValue(config, "x", 0);
            this.y = GetFastValue(config, "y", 0);
            this.width = GetFastValue(config, "width", 0);
            this.height = GetFastValue(config, "height", 0);
            this.tileWidth = GetFastValue(config, "tileWidth", 0);
            this.tileHeight = GetFastValue(config, "tileHeight", 0);
            this.baseTileWidth = GetFastValue(config, "baseTileWidth", this.tileWidth);
            this.baseTileHeight = GetFastValue(config, "baseTileHeight", this.tileHeight);
            this.orientation = GetFastValue(config, "orientation", CONST.ORTHOGONAL);
            this.widthInPixels = GetFastValue(config, "widthInPixels", this.width * this.baseTileWidth);
            this.heightInPixels = GetFastValue(config, "heightInPixels", this.height * this.baseTileHeight);
            this.alpha = GetFastValue(config, "alpha", 1);
            this.visible = GetFastValue(config, "visible", true);
            this.properties = GetFastValue(config, "properties", []);
            this.indexes = GetFastValue(config, "indexes", []);
            this.collideIndexes = GetFastValue(config, "collideIndexes", []);
            this.callbacks = GetFastValue(config, "callbacks", []);
            this.bodies = GetFastValue(config, "bodies", []);
            this.data = GetFastValue(config, "data", []);
            this.tilemapLayer = GetFastValue(config, "tilemapLayer", null);
            this.hexSideLength = GetFastValue(config, "hexSideLength", 0);
          }
        });
        module2.exports = LayerData;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(29);
        var GetFastValue = __webpack_require__(2);
        var MapData = new Class({
          initialize: function MapData2(config) {
            if (config === void 0) {
              config = {};
            }
            this.name = GetFastValue(config, "name", "map");
            this.width = GetFastValue(config, "width", 0);
            this.height = GetFastValue(config, "height", 0);
            this.infinite = GetFastValue(config, "infinite", false);
            this.tileWidth = GetFastValue(config, "tileWidth", 0);
            this.tileHeight = GetFastValue(config, "tileHeight", 0);
            this.widthInPixels = GetFastValue(config, "widthInPixels", this.width * this.tileWidth);
            this.heightInPixels = GetFastValue(config, "heightInPixels", this.height * this.tileHeight);
            this.format = GetFastValue(config, "format", null);
            this.orientation = GetFastValue(config, "orientation", CONST.ORTHOGONAL);
            this.renderOrder = GetFastValue(config, "renderOrder", "right-down");
            this.version = GetFastValue(config, "version", "1");
            this.properties = GetFastValue(config, "properties", {});
            this.layers = GetFastValue(config, "layers", []);
            this.images = GetFastValue(config, "images", []);
            this.objects = GetFastValue(config, "objects", {});
            this.collision = GetFastValue(config, "collision", {});
            this.tilesets = GetFastValue(config, "tilesets", []);
            this.imageCollections = GetFastValue(config, "imageCollections", []);
            this.tiles = GetFastValue(config, "tiles", []);
            this.hexSideLength = GetFastValue(config, "hexSideLength", 0);
          }
        });
        module2.exports = MapData;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Tileset = new Class({
          initialize: function Tileset2(name, firstgid, tileWidth, tileHeight, tileMargin, tileSpacing, tileProperties, tileData) {
            if (tileWidth === void 0 || tileWidth <= 0) {
              tileWidth = 32;
            }
            if (tileHeight === void 0 || tileHeight <= 0) {
              tileHeight = 32;
            }
            if (tileMargin === void 0) {
              tileMargin = 0;
            }
            if (tileSpacing === void 0) {
              tileSpacing = 0;
            }
            if (tileProperties === void 0) {
              tileProperties = {};
            }
            if (tileData === void 0) {
              tileData = {};
            }
            this.name = name;
            this.firstgid = firstgid;
            this.tileWidth = tileWidth;
            this.tileHeight = tileHeight;
            this.tileMargin = tileMargin;
            this.tileSpacing = tileSpacing;
            this.tileProperties = tileProperties;
            this.tileData = tileData;
            this.image = null;
            this.glTexture = null;
            this.rows = 0;
            this.columns = 0;
            this.total = 0;
            this.texCoordinates = [];
          },
          getTileProperties: function(tileIndex) {
            if (!this.containsTileIndex(tileIndex)) {
              return null;
            }
            return this.tileProperties[tileIndex - this.firstgid];
          },
          getTileData: function(tileIndex) {
            if (!this.containsTileIndex(tileIndex)) {
              return null;
            }
            return this.tileData[tileIndex - this.firstgid];
          },
          getTileCollisionGroup: function(tileIndex) {
            var data = this.getTileData(tileIndex);
            return data && data.objectgroup ? data.objectgroup : null;
          },
          containsTileIndex: function(tileIndex) {
            return tileIndex >= this.firstgid && tileIndex < this.firstgid + this.total;
          },
          getTileTextureCoordinates: function(tileIndex) {
            if (!this.containsTileIndex(tileIndex)) {
              return null;
            }
            return this.texCoordinates[tileIndex - this.firstgid];
          },
          setImage: function(texture) {
            this.image = texture;
            this.glTexture = texture.get().source.glTexture;
            this.updateTileData(this.image.source[0].width, this.image.source[0].height);
            return this;
          },
          setTileSize: function(tileWidth, tileHeight) {
            if (tileWidth !== void 0) {
              this.tileWidth = tileWidth;
            }
            if (tileHeight !== void 0) {
              this.tileHeight = tileHeight;
            }
            if (this.image) {
              this.updateTileData(this.image.source[0].width, this.image.source[0].height);
            }
            return this;
          },
          setSpacing: function(margin, spacing) {
            if (margin !== void 0) {
              this.tileMargin = margin;
            }
            if (spacing !== void 0) {
              this.tileSpacing = spacing;
            }
            if (this.image) {
              this.updateTileData(this.image.source[0].width, this.image.source[0].height);
            }
            return this;
          },
          updateTileData: function(imageWidth, imageHeight) {
            var rowCount = (imageHeight - this.tileMargin * 2 + this.tileSpacing) / (this.tileHeight + this.tileSpacing);
            var colCount = (imageWidth - this.tileMargin * 2 + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
            if (rowCount % 1 !== 0 || colCount % 1 !== 0) {
              console.warn("Image tile area not tile size multiple in: " + this.name);
            }
            rowCount = Math.floor(rowCount);
            colCount = Math.floor(colCount);
            this.rows = rowCount;
            this.columns = colCount;
            this.total = rowCount * colCount;
            this.texCoordinates.length = 0;
            var tx = this.tileMargin;
            var ty = this.tileMargin;
            for (var y2 = 0; y2 < this.rows; y2++) {
              for (var x2 = 0; x2 < this.columns; x2++) {
                this.texCoordinates.push({ x: tx, y: ty });
                tx += this.tileWidth + this.tileSpacing;
              }
              tx = this.tileMargin;
              ty += this.tileHeight + this.tileSpacing;
            }
            return this;
          }
        });
        module2.exports = Tileset;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ALIGN_CONST = {
          TOP_LEFT: 0,
          TOP_CENTER: 1,
          TOP_RIGHT: 2,
          LEFT_TOP: 3,
          LEFT_CENTER: 4,
          LEFT_BOTTOM: 5,
          CENTER: 6,
          RIGHT_TOP: 7,
          RIGHT_CENTER: 8,
          RIGHT_BOTTOM: 9,
          BOTTOM_LEFT: 10,
          BOTTOM_CENTER: 11,
          BOTTOM_RIGHT: 12
        };
        module2.exports = ALIGN_CONST;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Equal = function(a, b2, epsilon) {
          if (epsilon === void 0) {
            epsilon = 1e-4;
          }
          return Math.abs(a - b2) < epsilon;
        };
        module2.exports = Equal;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var GameObject = __webpack_require__(15);
        var ImageRender = __webpack_require__(1068);
        var Image2 = new Class({
          Extends: GameObject,
          Mixins: [
            Components.Alpha,
            Components.BlendMode,
            Components.Depth,
            Components.Flip,
            Components.GetBounds,
            Components.Mask,
            Components.Origin,
            Components.Pipeline,
            Components.ScrollFactor,
            Components.Size,
            Components.TextureCrop,
            Components.Tint,
            Components.Transform,
            Components.Visible,
            ImageRender
          ],
          initialize: function Image3(scene, x2, y2, texture, frame) {
            GameObject.call(this, scene, "Image");
            this._crop = this.resetCropObject();
            this.setTexture(texture, frame);
            this.setPosition(x2, y2);
            this.setSizeToFrame();
            this.setOriginFromFrame();
            this.initPipeline();
          }
        });
        module2.exports = Image2;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var HasValue = function(source, key) {
          return source.hasOwnProperty(key);
        };
        module2.exports = HasValue;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clone = __webpack_require__(77);
        var Merge = function(obj1, obj2) {
          var clone = Clone(obj1);
          for (var key in obj2) {
            if (!clone.hasOwnProperty(key)) {
              clone[key] = obj2[key];
            }
          }
          return clone;
        };
        module2.exports = Merge;
      },
      function(module2, exports2, __webpack_require__) {
        var Constraint = {};
        module2.exports = Constraint;
        var Vertices = __webpack_require__(64);
        var Vector = __webpack_require__(83);
        var Sleeping = __webpack_require__(165);
        var Bounds = __webpack_require__(84);
        var Axes = __webpack_require__(271);
        var Common = __webpack_require__(32);
        (function() {
          Constraint._warming = 0.4;
          Constraint._torqueDampen = 1;
          Constraint._minLength = 1e-6;
          Constraint.create = function(options) {
            var constraint = options;
            if (constraint.bodyA && !constraint.pointA)
              constraint.pointA = { x: 0, y: 0 };
            if (constraint.bodyB && !constraint.pointB)
              constraint.pointB = { x: 0, y: 0 };
            var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA, initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB, length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));
            constraint.length = typeof constraint.length !== "undefined" ? constraint.length : length;
            constraint.id = constraint.id || Common.nextId();
            constraint.label = constraint.label || "Constraint";
            constraint.type = "constraint";
            constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);
            constraint.damping = constraint.damping || 0;
            constraint.angularStiffness = constraint.angularStiffness || 0;
            constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;
            constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;
            constraint.plugin = {};
            var render = {
              visible: true,
              type: "line",
              anchors: true,
              lineColor: null,
              lineOpacity: null,
              lineThickness: null,
              pinSize: null,
              anchorColor: null,
              anchorSize: null
            };
            if (constraint.length === 0 && constraint.stiffness > 0.1) {
              render.type = "pin";
              render.anchors = false;
            } else if (constraint.stiffness < 0.9) {
              render.type = "spring";
            }
            constraint.render = Common.extend(render, constraint.render);
            return constraint;
          };
          Constraint.preSolveAll = function(bodies) {
            for (var i2 = 0; i2 < bodies.length; i2 += 1) {
              var body = bodies[i2], impulse = body.constraintImpulse;
              if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                continue;
              }
              body.position.x += impulse.x;
              body.position.y += impulse.y;
              body.angle += impulse.angle;
            }
          };
          Constraint.solveAll = function(constraints, timeScale) {
            for (var i2 = 0; i2 < constraints.length; i2 += 1) {
              var constraint = constraints[i2], fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic, fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
              if (fixedA || fixedB) {
                Constraint.solve(constraints[i2], timeScale);
              }
            }
            for (i2 = 0; i2 < constraints.length; i2 += 1) {
              constraint = constraints[i2];
              fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic;
              fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
              if (!fixedA && !fixedB) {
                Constraint.solve(constraints[i2], timeScale);
              }
            }
          };
          Constraint.solve = function(constraint, timeScale) {
            var bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointA = constraint.pointA, pointB = constraint.pointB;
            if (!bodyA && !bodyB)
              return;
            if (bodyA && !bodyA.isStatic) {
              Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);
              constraint.angleA = bodyA.angle;
            }
            if (bodyB && !bodyB.isStatic) {
              Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);
              constraint.angleB = bodyB.angle;
            }
            var pointAWorld = pointA, pointBWorld = pointB;
            if (bodyA)
              pointAWorld = Vector.add(bodyA.position, pointA);
            if (bodyB)
              pointBWorld = Vector.add(bodyB.position, pointB);
            if (!pointAWorld || !pointBWorld)
              return;
            var delta = Vector.sub(pointAWorld, pointBWorld), currentLength = Vector.magnitude(delta);
            if (currentLength < Constraint._minLength) {
              currentLength = Constraint._minLength;
            }
            var difference = (currentLength - constraint.length) / currentLength, stiffness = constraint.stiffness < 1 ? constraint.stiffness * timeScale : constraint.stiffness, force = Vector.mult(delta, difference * stiffness), massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0), inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0), resistanceTotal = massTotal + inertiaTotal, torque, share, normal, normalVelocity, relativeVelocity;
            if (constraint.damping) {
              var zero = Vector.create();
              normal = Vector.div(delta, currentLength);
              relativeVelocity = Vector.sub(bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero, bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero);
              normalVelocity = Vector.dot(normal, relativeVelocity);
            }
            if (bodyA && !bodyA.isStatic) {
              share = bodyA.inverseMass / massTotal;
              bodyA.constraintImpulse.x -= force.x * share;
              bodyA.constraintImpulse.y -= force.y * share;
              bodyA.position.x -= force.x * share;
              bodyA.position.y -= force.y * share;
              if (constraint.damping) {
                bodyA.positionPrev.x -= constraint.damping * normal.x * normalVelocity * share;
                bodyA.positionPrev.y -= constraint.damping * normal.y * normalVelocity * share;
              }
              torque = Vector.cross(pointA, force) / resistanceTotal * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);
              bodyA.constraintImpulse.angle -= torque;
              bodyA.angle -= torque;
            }
            if (bodyB && !bodyB.isStatic) {
              share = bodyB.inverseMass / massTotal;
              bodyB.constraintImpulse.x += force.x * share;
              bodyB.constraintImpulse.y += force.y * share;
              bodyB.position.x += force.x * share;
              bodyB.position.y += force.y * share;
              if (constraint.damping) {
                bodyB.positionPrev.x += constraint.damping * normal.x * normalVelocity * share;
                bodyB.positionPrev.y += constraint.damping * normal.y * normalVelocity * share;
              }
              torque = Vector.cross(pointB, force) / resistanceTotal * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);
              bodyB.constraintImpulse.angle += torque;
              bodyB.angle += torque;
            }
          };
          Constraint.postSolveAll = function(bodies) {
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2], impulse = body.constraintImpulse;
              if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                continue;
              }
              Sleeping.set(body, false);
              for (var j = 0; j < body.parts.length; j++) {
                var part = body.parts[j];
                Vertices.translate(part.vertices, impulse);
                if (j > 0) {
                  part.position.x += impulse.x;
                  part.position.y += impulse.y;
                }
                if (impulse.angle !== 0) {
                  Vertices.rotate(part.vertices, impulse.angle, body.position);
                  Axes.rotate(part.axes, impulse.angle);
                  if (j > 0) {
                    Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);
                  }
                }
                Bounds.update(part.bounds, part.vertices, body.velocity);
              }
              impulse.angle *= Constraint._warming;
              impulse.x *= Constraint._warming;
              impulse.y *= Constraint._warming;
            }
          };
          Constraint.pointAWorld = function(constraint) {
            return {
              x: (constraint.bodyA ? constraint.bodyA.position.x : 0) + constraint.pointA.x,
              y: (constraint.bodyA ? constraint.bodyA.position.y : 0) + constraint.pointA.y
            };
          };
          Constraint.pointBWorld = function(constraint) {
            return {
              x: (constraint.bodyB ? constraint.bodyB.position.x : 0) + constraint.pointB.x,
              y: (constraint.bodyB ? constraint.bodyB.position.y : 0) + constraint.pointB.y
            };
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BlendModes = __webpack_require__(35);
        var Circle = __webpack_require__(65);
        var CircleContains = __webpack_require__(66);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var GameObject = __webpack_require__(15);
        var Rectangle = __webpack_require__(10);
        var RectangleContains = __webpack_require__(57);
        var Zone = new Class({
          Extends: GameObject,
          Mixins: [
            Components.Depth,
            Components.GetBounds,
            Components.Origin,
            Components.Transform,
            Components.ScrollFactor,
            Components.Visible
          ],
          initialize: function Zone2(scene, x2, y2, width, height) {
            if (width === void 0) {
              width = 1;
            }
            if (height === void 0) {
              height = width;
            }
            GameObject.call(this, scene, "Zone");
            this.setPosition(x2, y2);
            this.width = width;
            this.height = height;
            this.blendMode = BlendModes.NORMAL;
            this.updateDisplayOrigin();
          },
          displayWidth: {
            get: function() {
              return this.scaleX * this.width;
            },
            set: function(value) {
              this.scaleX = value / this.width;
            }
          },
          displayHeight: {
            get: function() {
              return this.scaleY * this.height;
            },
            set: function(value) {
              this.scaleY = value / this.height;
            }
          },
          setSize: function(width, height, resizeInput) {
            if (resizeInput === void 0) {
              resizeInput = true;
            }
            this.width = width;
            this.height = height;
            this.updateDisplayOrigin();
            var input = this.input;
            if (resizeInput && input && !input.customHitArea) {
              input.hitArea.width = width;
              input.hitArea.height = height;
            }
            return this;
          },
          setDisplaySize: function(width, height) {
            this.displayWidth = width;
            this.displayHeight = height;
            return this;
          },
          setCircleDropZone: function(radius) {
            return this.setDropZone(new Circle(0, 0, radius), CircleContains);
          },
          setRectangleDropZone: function(width, height) {
            return this.setDropZone(new Rectangle(0, 0, width, height), RectangleContains);
          },
          setDropZone: function(hitArea, hitAreaCallback) {
            if (hitArea === void 0) {
              this.setRectangleDropZone(this.width, this.height);
            } else if (!this.input) {
              this.setInteractive(hitArea, hitAreaCallback, true);
            }
            return this;
          },
          setAlpha: function() {
          },
          setBlendMode: function() {
          },
          renderCanvas: function(renderer, src, camera) {
            camera.addToRenderList(src);
          },
          renderWebGL: function(renderer, src, camera) {
            camera.addToRenderList(src);
          }
        });
        module2.exports = Zone;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Perimeter = function(rect) {
          return 2 * (rect.width + rect.height);
        };
        module2.exports = Perimeter;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Shuffle = function(array) {
          for (var i2 = array.length - 1; i2 > 0; i2--) {
            var j = Math.floor(Math.random() * (i2 + 1));
            var temp = array[i2];
            array[i2] = array[j];
            array[j] = temp;
          }
          return array;
        };
        module2.exports = Shuffle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          ADD_ANIMATION: __webpack_require__(724),
          ANIMATION_COMPLETE: __webpack_require__(725),
          ANIMATION_COMPLETE_KEY: __webpack_require__(726),
          ANIMATION_REPEAT: __webpack_require__(727),
          ANIMATION_RESTART: __webpack_require__(728),
          ANIMATION_START: __webpack_require__(729),
          ANIMATION_STOP: __webpack_require__(730),
          ANIMATION_UPDATE: __webpack_require__(731),
          PAUSE_ALL: __webpack_require__(732),
          REMOVE_ANIMATION: __webpack_require__(733),
          RESUME_ALL: __webpack_require__(734)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var DegToRad = __webpack_require__(36);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(37);
        var Rectangle = __webpack_require__(10);
        var TransformMatrix = __webpack_require__(25);
        var ValueToColor = __webpack_require__(187);
        var Vector2 = __webpack_require__(3);
        var BaseCamera = new Class({
          Extends: EventEmitter,
          Mixins: [
            Components.Alpha,
            Components.Visible
          ],
          initialize: function BaseCamera2(x2, y2, width, height) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = 0;
            }
            if (height === void 0) {
              height = 0;
            }
            EventEmitter.call(this);
            this.scene;
            this.sceneManager;
            this.scaleManager;
            this.cameraManager;
            this.id = 0;
            this.name = "";
            this.roundPixels = false;
            this.useBounds = false;
            this.worldView = new Rectangle();
            this.dirty = true;
            this._x = x2;
            this._y = y2;
            this._width = width;
            this._height = height;
            this._bounds = new Rectangle();
            this._scrollX = 0;
            this._scrollY = 0;
            this._zoomX = 1;
            this._zoomY = 1;
            this._rotation = 0;
            this.matrix = new TransformMatrix();
            this.transparent = true;
            this.backgroundColor = ValueToColor("rgba(0,0,0,0)");
            this.disableCull = false;
            this.culledObjects = [];
            this.midPoint = new Vector2(width / 2, height / 2);
            this.originX = 0.5;
            this.originY = 0.5;
            this._customViewport = false;
            this.mask = null;
            this._maskCamera = null;
            this.renderList = [];
          },
          addToRenderList: function(child) {
            this.renderList.push(child);
          },
          setOrigin: function(x2, y2) {
            if (x2 === void 0) {
              x2 = 0.5;
            }
            if (y2 === void 0) {
              y2 = x2;
            }
            this.originX = x2;
            this.originY = y2;
            return this;
          },
          getScroll: function(x2, y2, out) {
            if (out === void 0) {
              out = new Vector2();
            }
            var originX = this.width * 0.5;
            var originY = this.height * 0.5;
            out.x = x2 - originX;
            out.y = y2 - originY;
            if (this.useBounds) {
              out.x = this.clampX(out.x);
              out.y = this.clampY(out.y);
            }
            return out;
          },
          centerOnX: function(x2) {
            var originX = this.width * 0.5;
            this.midPoint.x = x2;
            this.scrollX = x2 - originX;
            if (this.useBounds) {
              this.scrollX = this.clampX(this.scrollX);
            }
            return this;
          },
          centerOnY: function(y2) {
            var originY = this.height * 0.5;
            this.midPoint.y = y2;
            this.scrollY = y2 - originY;
            if (this.useBounds) {
              this.scrollY = this.clampY(this.scrollY);
            }
            return this;
          },
          centerOn: function(x2, y2) {
            this.centerOnX(x2);
            this.centerOnY(y2);
            return this;
          },
          centerToBounds: function() {
            if (this.useBounds) {
              var bounds = this._bounds;
              var originX = this.width * 0.5;
              var originY = this.height * 0.5;
              this.midPoint.set(bounds.centerX, bounds.centerY);
              this.scrollX = bounds.centerX - originX;
              this.scrollY = bounds.centerY - originY;
            }
            return this;
          },
          centerToSize: function() {
            this.scrollX = this.width * 0.5;
            this.scrollY = this.height * 0.5;
            return this;
          },
          cull: function(renderableObjects) {
            if (this.disableCull) {
              return renderableObjects;
            }
            var cameraMatrix = this.matrix.matrix;
            var mva = cameraMatrix[0];
            var mvb = cameraMatrix[1];
            var mvc = cameraMatrix[2];
            var mvd = cameraMatrix[3];
            var determinant = mva * mvd - mvb * mvc;
            if (!determinant) {
              return renderableObjects;
            }
            var mve = cameraMatrix[4];
            var mvf = cameraMatrix[5];
            var scrollX = this.scrollX;
            var scrollY = this.scrollY;
            var cameraW = this.width;
            var cameraH = this.height;
            var cullTop = this.y;
            var cullBottom = cullTop + cameraH;
            var cullLeft = this.x;
            var cullRight = cullLeft + cameraW;
            var culledObjects = this.culledObjects;
            var length = renderableObjects.length;
            determinant = 1 / determinant;
            culledObjects.length = 0;
            for (var index2 = 0; index2 < length; ++index2) {
              var object = renderableObjects[index2];
              if (!object.hasOwnProperty("width") || object.parentContainer) {
                culledObjects.push(object);
                continue;
              }
              var objectW = object.width;
              var objectH = object.height;
              var objectX = object.x - scrollX * object.scrollFactorX - objectW * object.originX;
              var objectY = object.y - scrollY * object.scrollFactorY - objectH * object.originY;
              var tx = objectX * mva + objectY * mvc + mve;
              var ty = objectX * mvb + objectY * mvd + mvf;
              var tw = (objectX + objectW) * mva + (objectY + objectH) * mvc + mve;
              var th2 = (objectX + objectW) * mvb + (objectY + objectH) * mvd + mvf;
              if (tw > cullLeft && tx < cullRight && (th2 > cullTop && ty < cullBottom)) {
                culledObjects.push(object);
              }
            }
            return culledObjects;
          },
          getWorldPoint: function(x2, y2, output) {
            if (output === void 0) {
              output = new Vector2();
            }
            var cameraMatrix = this.matrix.matrix;
            var mva = cameraMatrix[0];
            var mvb = cameraMatrix[1];
            var mvc = cameraMatrix[2];
            var mvd = cameraMatrix[3];
            var mve = cameraMatrix[4];
            var mvf = cameraMatrix[5];
            var determinant = mva * mvd - mvb * mvc;
            if (!determinant) {
              output.x = x2;
              output.y = y2;
              return output;
            }
            determinant = 1 / determinant;
            var ima = mvd * determinant;
            var imb = -mvb * determinant;
            var imc = -mvc * determinant;
            var imd = mva * determinant;
            var ime = (mvc * mvf - mvd * mve) * determinant;
            var imf = (mvb * mve - mva * mvf) * determinant;
            var c = Math.cos(this.rotation);
            var s = Math.sin(this.rotation);
            var zoomX = this.zoomX;
            var zoomY = this.zoomY;
            var scrollX = this.scrollX;
            var scrollY = this.scrollY;
            var sx = x2 + (scrollX * c - scrollY * s) * zoomX;
            var sy = y2 + (scrollX * s + scrollY * c) * zoomY;
            output.x = sx * ima + sy * imc + ime;
            output.y = sx * imb + sy * imd + imf;
            return output;
          },
          ignore: function(entries) {
            var id2 = this.id;
            if (!Array.isArray(entries)) {
              entries = [entries];
            }
            for (var i2 = 0; i2 < entries.length; i2++) {
              var entry = entries[i2];
              if (Array.isArray(entry)) {
                this.ignore(entry);
              } else if (entry.isParent) {
                this.ignore(entry.getChildren());
              } else {
                entry.cameraFilter |= id2;
              }
            }
            return this;
          },
          preRender: function() {
            this.renderList.length = 0;
            var width = this.width;
            var height = this.height;
            var halfWidth = width * 0.5;
            var halfHeight = height * 0.5;
            var zoomX = this.zoomX;
            var zoomY = this.zoomY;
            var matrix = this.matrix;
            var originX = width * this.originX;
            var originY = height * this.originY;
            var sx = this.scrollX;
            var sy = this.scrollY;
            if (this.useBounds) {
              sx = this.clampX(sx);
              sy = this.clampY(sy);
            }
            if (this.roundPixels) {
              originX = Math.round(originX);
              originY = Math.round(originY);
            }
            this.scrollX = sx;
            this.scrollY = sy;
            var midX = sx + halfWidth;
            var midY = sy + halfHeight;
            this.midPoint.set(midX, midY);
            var displayWidth = width / zoomX;
            var displayHeight = height / zoomY;
            this.worldView.setTo(midX - displayWidth / 2, midY - displayHeight / 2, displayWidth, displayHeight);
            matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoomX, zoomY);
            matrix.translate(-originX, -originY);
          },
          clampX: function(x2) {
            var bounds = this._bounds;
            var dw = this.displayWidth;
            var bx = bounds.x + (dw - this.width) / 2;
            var bw = Math.max(bx, bx + bounds.width - dw);
            if (x2 < bx) {
              x2 = bx;
            } else if (x2 > bw) {
              x2 = bw;
            }
            return x2;
          },
          clampY: function(y2) {
            var bounds = this._bounds;
            var dh2 = this.displayHeight;
            var by = bounds.y + (dh2 - this.height) / 2;
            var bh2 = Math.max(by, by + bounds.height - dh2);
            if (y2 < by) {
              y2 = by;
            } else if (y2 > bh2) {
              y2 = bh2;
            }
            return y2;
          },
          removeBounds: function() {
            this.useBounds = false;
            this.dirty = true;
            this._bounds.setEmpty();
            return this;
          },
          setAngle: function(value) {
            if (value === void 0) {
              value = 0;
            }
            this.rotation = DegToRad(value);
            return this;
          },
          setBackgroundColor: function(color) {
            if (color === void 0) {
              color = "rgba(0,0,0,0)";
            }
            this.backgroundColor = ValueToColor(color);
            this.transparent = this.backgroundColor.alpha === 0;
            return this;
          },
          setBounds: function(x2, y2, width, height, centerOn) {
            if (centerOn === void 0) {
              centerOn = false;
            }
            this._bounds.setTo(x2, y2, width, height);
            this.dirty = true;
            this.useBounds = true;
            if (centerOn) {
              this.centerToBounds();
            } else {
              this.scrollX = this.clampX(this.scrollX);
              this.scrollY = this.clampY(this.scrollY);
            }
            return this;
          },
          getBounds: function(out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            var source = this._bounds;
            out.setTo(source.x, source.y, source.width, source.height);
            return out;
          },
          setName: function(value) {
            if (value === void 0) {
              value = "";
            }
            this.name = value;
            return this;
          },
          setPosition: function(x2, y2) {
            if (y2 === void 0) {
              y2 = x2;
            }
            this.x = x2;
            this.y = y2;
            return this;
          },
          setRotation: function(value) {
            if (value === void 0) {
              value = 0;
            }
            this.rotation = value;
            return this;
          },
          setRoundPixels: function(value) {
            this.roundPixels = value;
            return this;
          },
          setScene: function(scene) {
            if (this.scene && this._customViewport) {
              this.sceneManager.customViewports--;
            }
            this.scene = scene;
            var sys = scene.sys;
            this.sceneManager = sys.game.scene;
            this.scaleManager = sys.scale;
            this.cameraManager = sys.cameras;
            this.updateSystem();
            return this;
          },
          setScroll: function(x2, y2) {
            if (y2 === void 0) {
              y2 = x2;
            }
            this.scrollX = x2;
            this.scrollY = y2;
            return this;
          },
          setSize: function(width, height) {
            if (height === void 0) {
              height = width;
            }
            this.width = width;
            this.height = height;
            return this;
          },
          setViewport: function(x2, y2, width, height) {
            this.x = x2;
            this.y = y2;
            this.width = width;
            this.height = height;
            return this;
          },
          setZoom: function(x2, y2) {
            if (x2 === void 0) {
              x2 = 1;
            }
            if (y2 === void 0) {
              y2 = x2;
            }
            if (x2 === 0) {
              x2 = 1e-3;
            }
            if (y2 === 0) {
              y2 = 1e-3;
            }
            this.zoomX = x2;
            this.zoomY = y2;
            return this;
          },
          setMask: function(mask, fixedPosition) {
            if (fixedPosition === void 0) {
              fixedPosition = true;
            }
            this.mask = mask;
            this._maskCamera = fixedPosition ? this.cameraManager.default : this;
            return this;
          },
          clearMask: function(destroyMask) {
            if (destroyMask === void 0) {
              destroyMask = false;
            }
            if (destroyMask && this.mask) {
              this.mask.destroy();
            }
            this.mask = null;
            return this;
          },
          toJSON: function() {
            var output = {
              name: this.name,
              x: this.x,
              y: this.y,
              width: this.width,
              height: this.height,
              zoom: this.zoom,
              rotation: this.rotation,
              roundPixels: this.roundPixels,
              scrollX: this.scrollX,
              scrollY: this.scrollY,
              backgroundColor: this.backgroundColor.rgba
            };
            if (this.useBounds) {
              output["bounds"] = {
                x: this._bounds.x,
                y: this._bounds.y,
                width: this._bounds.width,
                height: this._bounds.height
              };
            }
            return output;
          },
          update: function() {
          },
          updateSystem: function() {
            if (!this.scaleManager) {
              return;
            }
            var custom = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height;
            var sceneManager = this.sceneManager;
            if (custom && !this._customViewport) {
              sceneManager.customViewports++;
            } else if (!custom && this._customViewport) {
              sceneManager.customViewports--;
            }
            this.dirty = true;
            this._customViewport = custom;
          },
          destroy: function() {
            this.emit(Events.DESTROY, this);
            this.removeAllListeners();
            this.matrix.destroy();
            this.culledObjects = [];
            if (this._customViewport) {
              this.sceneManager.customViewports--;
            }
            this.renderList = [];
            this._bounds = null;
            this.scene = null;
            this.scaleManager = null;
            this.sceneManager = null;
            this.cameraManager = null;
          },
          x: {
            get: function() {
              return this._x;
            },
            set: function(value) {
              this._x = value;
              this.updateSystem();
            }
          },
          y: {
            get: function() {
              return this._y;
            },
            set: function(value) {
              this._y = value;
              this.updateSystem();
            }
          },
          width: {
            get: function() {
              return this._width;
            },
            set: function(value) {
              this._width = value;
              this.updateSystem();
            }
          },
          height: {
            get: function() {
              return this._height;
            },
            set: function(value) {
              this._height = value;
              this.updateSystem();
            }
          },
          scrollX: {
            get: function() {
              return this._scrollX;
            },
            set: function(value) {
              this._scrollX = value;
              this.dirty = true;
            }
          },
          scrollY: {
            get: function() {
              return this._scrollY;
            },
            set: function(value) {
              this._scrollY = value;
              this.dirty = true;
            }
          },
          zoom: {
            get: function() {
              return (this._zoomX + this._zoomY) / 2;
            },
            set: function(value) {
              this._zoomX = value;
              this._zoomY = value;
              this.dirty = true;
            }
          },
          zoomX: {
            get: function() {
              return this._zoomX;
            },
            set: function(value) {
              this._zoomX = value;
              this.dirty = true;
            }
          },
          zoomY: {
            get: function() {
              return this._zoomY;
            },
            set: function(value) {
              this._zoomY = value;
              this.dirty = true;
            }
          },
          rotation: {
            get: function() {
              return this._rotation;
            },
            set: function(value) {
              this._rotation = value;
              this.dirty = true;
            }
          },
          centerX: {
            get: function() {
              return this.x + 0.5 * this.width;
            }
          },
          centerY: {
            get: function() {
              return this.y + 0.5 * this.height;
            }
          },
          displayWidth: {
            get: function() {
              return this.width / this.zoomX;
            }
          },
          displayHeight: {
            get: function() {
              return this.height / this.zoomY;
            }
          }
        });
        module2.exports = BaseCamera;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Back = __webpack_require__(334);
        var Bounce = __webpack_require__(335);
        var Circular = __webpack_require__(336);
        var Cubic = __webpack_require__(337);
        var Elastic = __webpack_require__(338);
        var Expo = __webpack_require__(339);
        var Linear = __webpack_require__(340);
        var Quadratic = __webpack_require__(341);
        var Quartic = __webpack_require__(342);
        var Quintic = __webpack_require__(343);
        var Sine = __webpack_require__(344);
        var Stepped = __webpack_require__(345);
        module2.exports = {
          Power0: Linear,
          Power1: Quadratic.Out,
          Power2: Cubic.Out,
          Power3: Quartic.Out,
          Power4: Quintic.Out,
          Linear,
          Quad: Quadratic.Out,
          Cubic: Cubic.Out,
          Quart: Quartic.Out,
          Quint: Quintic.Out,
          Sine: Sine.Out,
          Expo: Expo.Out,
          Circ: Circular.Out,
          Elastic: Elastic.Out,
          Back: Back.Out,
          Bounce: Bounce.Out,
          Stepped,
          "Quad.easeIn": Quadratic.In,
          "Cubic.easeIn": Cubic.In,
          "Quart.easeIn": Quartic.In,
          "Quint.easeIn": Quintic.In,
          "Sine.easeIn": Sine.In,
          "Expo.easeIn": Expo.In,
          "Circ.easeIn": Circular.In,
          "Elastic.easeIn": Elastic.In,
          "Back.easeIn": Back.In,
          "Bounce.easeIn": Bounce.In,
          "Quad.easeOut": Quadratic.Out,
          "Cubic.easeOut": Cubic.Out,
          "Quart.easeOut": Quartic.Out,
          "Quint.easeOut": Quintic.Out,
          "Sine.easeOut": Sine.Out,
          "Expo.easeOut": Expo.Out,
          "Circ.easeOut": Circular.Out,
          "Elastic.easeOut": Elastic.Out,
          "Back.easeOut": Back.Out,
          "Bounce.easeOut": Bounce.Out,
          "Quad.easeInOut": Quadratic.InOut,
          "Cubic.easeInOut": Cubic.InOut,
          "Quart.easeInOut": Quartic.InOut,
          "Quint.easeInOut": Quintic.InOut,
          "Sine.easeInOut": Sine.InOut,
          "Expo.easeInOut": Expo.InOut,
          "Circ.easeInOut": Circular.InOut,
          "Elastic.easeInOut": Elastic.InOut,
          "Back.easeInOut": Back.InOut,
          "Bounce.easeInOut": Bounce.InOut
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Linear = function(p0, p1, t2) {
          return (p1 - p0) * t2 + p0;
        };
        module2.exports = Linear;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var OS = __webpack_require__(105);
        var Browser = {
          chrome: false,
          chromeVersion: 0,
          edge: false,
          firefox: false,
          firefoxVersion: 0,
          ie: false,
          ieVersion: 0,
          mobileSafari: false,
          opera: false,
          safari: false,
          safariVersion: 0,
          silk: false,
          trident: false,
          tridentVersion: 0
        };
        function init() {
          var ua2 = navigator.userAgent;
          if (/Edge\/\d+/.test(ua2)) {
            Browser.edge = true;
          } else if (/Chrome\/(\d+)/.test(ua2) && !OS.windowsPhone) {
            Browser.chrome = true;
            Browser.chromeVersion = parseInt(RegExp.$1, 10);
          } else if (/Firefox\D+(\d+)/.test(ua2)) {
            Browser.firefox = true;
            Browser.firefoxVersion = parseInt(RegExp.$1, 10);
          } else if (/AppleWebKit/.test(ua2) && OS.iOS) {
            Browser.mobileSafari = true;
          } else if (/MSIE (\d+\.\d+);/.test(ua2)) {
            Browser.ie = true;
            Browser.ieVersion = parseInt(RegExp.$1, 10);
          } else if (/Opera/.test(ua2)) {
            Browser.opera = true;
          } else if (/Safari/.test(ua2) && !OS.windowsPhone) {
            Browser.safari = true;
          } else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(ua2)) {
            Browser.ie = true;
            Browser.trident = true;
            Browser.tridentVersion = parseInt(RegExp.$1, 10);
            Browser.ieVersion = parseInt(RegExp.$3, 10);
          }
          if (/Silk/.test(ua2)) {
            Browser.silk = true;
          }
          return Browser;
        }
        module2.exports = init();
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FloatBetween = function(min, max) {
          return Math.random() * (max - min) + min;
        };
        module2.exports = FloatBetween;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var IsSizePowerOfTwo = function(width, height) {
          return width > 0 && (width & width - 1) === 0 && height > 0 && (height & height - 1) === 0;
        };
        module2.exports = IsSizePowerOfTwo;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SnapCeil = function(value, gap, start, divide) {
          if (start === void 0) {
            start = 0;
          }
          if (gap === 0) {
            return value;
          }
          value -= start;
          value = gap * Math.ceil(value / gap);
          return divide ? (start + value) / gap : start + value;
        };
        module2.exports = SnapCeil;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Vector4 = new Class({
          initialize: function Vector42(x2, y2, z2, w2) {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 0;
            if (typeof x2 === "object") {
              this.x = x2.x || 0;
              this.y = x2.y || 0;
              this.z = x2.z || 0;
              this.w = x2.w || 0;
            } else {
              this.x = x2 || 0;
              this.y = y2 || 0;
              this.z = z2 || 0;
              this.w = w2 || 0;
            }
          },
          clone: function() {
            return new Vector4(this.x, this.y, this.z, this.w);
          },
          copy: function(src) {
            this.x = src.x;
            this.y = src.y;
            this.z = src.z || 0;
            this.w = src.w || 0;
            return this;
          },
          equals: function(v2) {
            return this.x === v2.x && this.y === v2.y && this.z === v2.z && this.w === v2.w;
          },
          set: function(x2, y2, z2, w2) {
            if (typeof x2 === "object") {
              this.x = x2.x || 0;
              this.y = x2.y || 0;
              this.z = x2.z || 0;
              this.w = x2.w || 0;
            } else {
              this.x = x2 || 0;
              this.y = y2 || 0;
              this.z = z2 || 0;
              this.w = w2 || 0;
            }
            return this;
          },
          add: function(v2) {
            this.x += v2.x;
            this.y += v2.y;
            this.z += v2.z || 0;
            this.w += v2.w || 0;
            return this;
          },
          subtract: function(v2) {
            this.x -= v2.x;
            this.y -= v2.y;
            this.z -= v2.z || 0;
            this.w -= v2.w || 0;
            return this;
          },
          scale: function(scale) {
            this.x *= scale;
            this.y *= scale;
            this.z *= scale;
            this.w *= scale;
            return this;
          },
          length: function() {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var w2 = this.w;
            return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2);
          },
          lengthSq: function() {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var w2 = this.w;
            return x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2;
          },
          normalize: function() {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var w2 = this.w;
            var len = x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2;
            if (len > 0) {
              len = 1 / Math.sqrt(len);
              this.x = x2 * len;
              this.y = y2 * len;
              this.z = z2 * len;
              this.w = w2 * len;
            }
            return this;
          },
          dot: function(v2) {
            return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
          },
          lerp: function(v2, t2) {
            if (t2 === void 0) {
              t2 = 0;
            }
            var ax = this.x;
            var ay = this.y;
            var az = this.z;
            var aw = this.w;
            this.x = ax + t2 * (v2.x - ax);
            this.y = ay + t2 * (v2.y - ay);
            this.z = az + t2 * (v2.z - az);
            this.w = aw + t2 * (v2.w - aw);
            return this;
          },
          multiply: function(v2) {
            this.x *= v2.x;
            this.y *= v2.y;
            this.z *= v2.z || 1;
            this.w *= v2.w || 1;
            return this;
          },
          divide: function(v2) {
            this.x /= v2.x;
            this.y /= v2.y;
            this.z /= v2.z || 1;
            this.w /= v2.w || 1;
            return this;
          },
          distance: function(v2) {
            var dx = v2.x - this.x;
            var dy = v2.y - this.y;
            var dz = v2.z - this.z || 0;
            var dw = v2.w - this.w || 0;
            return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
          },
          distanceSq: function(v2) {
            var dx = v2.x - this.x;
            var dy = v2.y - this.y;
            var dz = v2.z - this.z || 0;
            var dw = v2.w - this.w || 0;
            return dx * dx + dy * dy + dz * dz + dw * dw;
          },
          negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this;
          },
          transformMat4: function(mat) {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var w2 = this.w;
            var m2 = mat.val;
            this.x = m2[0] * x2 + m2[4] * y2 + m2[8] * z2 + m2[12] * w2;
            this.y = m2[1] * x2 + m2[5] * y2 + m2[9] * z2 + m2[13] * w2;
            this.z = m2[2] * x2 + m2[6] * y2 + m2[10] * z2 + m2[14] * w2;
            this.w = m2[3] * x2 + m2[7] * y2 + m2[11] * z2 + m2[15] * w2;
            return this;
          },
          transformQuat: function(q2) {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var qx = q2.x;
            var qy = q2.y;
            var qz = q2.z;
            var qw = q2.w;
            var ix = qw * x2 + qy * z2 - qz * y2;
            var iy = qw * y2 + qz * x2 - qx * z2;
            var iz = qw * z2 + qx * y2 - qy * x2;
            var iw = -qx * x2 - qy * y2 - qz * z2;
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
          },
          reset: function() {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 0;
            return this;
          }
        });
        Vector4.prototype.sub = Vector4.prototype.subtract;
        Vector4.prototype.mul = Vector4.prototype.multiply;
        Vector4.prototype.div = Vector4.prototype.divide;
        Vector4.prototype.dist = Vector4.prototype.distance;
        Vector4.prototype.distSq = Vector4.prototype.distanceSq;
        Vector4.prototype.len = Vector4.prototype.length;
        Vector4.prototype.lenSq = Vector4.prototype.lengthSq;
        module2.exports = Vector4;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(91);
        var RenderTarget = new Class({
          initialize: function RenderTarget2(renderer, width, height, scale, minFilter, autoClear, autoResize) {
            if (scale === void 0) {
              scale = 1;
            }
            if (minFilter === void 0) {
              minFilter = 0;
            }
            if (autoClear === void 0) {
              autoClear = true;
            }
            if (autoResize === void 0) {
              autoResize = false;
            }
            this.renderer = renderer;
            this.framebuffer = null;
            this.texture = null;
            this.width = 0;
            this.height = 0;
            this.scale = scale;
            this.minFilter = minFilter;
            this.autoClear = autoClear;
            this.autoResize = false;
            this.resize(width, height);
            if (autoResize) {
              this.setAutoResize(true);
            }
          },
          setAutoResize: function(autoResize) {
            if (autoResize && !this.autoResize) {
              this.renderer.on(Events.RESIZE, this.resize, this);
              this.autoResize = true;
            } else if (!autoResize && this.autoResize) {
              this.renderer.off(Events.RESIZE, this.resize, this);
              this.autoResize = false;
            }
            return this;
          },
          resize: function(width, height) {
            var scaledWidth = width * this.scale;
            var scaledHeight = height * this.scale;
            if (scaledWidth !== this.width || scaledHeight !== this.height) {
              var renderer = this.renderer;
              renderer.deleteFramebuffer(this.framebuffer);
              renderer.deleteTexture(this.texture);
              width *= this.scale;
              height *= this.scale;
              width = Math.round(width);
              height = Math.round(height);
              if (width <= 0) {
                width = 1;
              }
              if (height <= 0) {
                height = 1;
              }
              this.texture = renderer.createTextureFromSource(null, width, height, this.minFilter);
              this.framebuffer = renderer.createFramebuffer(width, height, this.texture, false);
              this.width = width;
              this.height = height;
            }
            return this;
          },
          bind: function(adjustViewport, width, height) {
            if (adjustViewport === void 0) {
              adjustViewport = false;
            }
            if (adjustViewport) {
              this.renderer.flush();
            }
            if (width && height) {
              this.resize(width, height);
            }
            this.renderer.pushFramebuffer(this.framebuffer, false, false, false);
            if (adjustViewport) {
              this.adjustViewport();
            }
            if (this.autoClear) {
              var gl2 = this.renderer.gl;
              gl2.clearColor(0, 0, 0, 0);
              gl2.clear(gl2.COLOR_BUFFER_BIT);
            }
          },
          adjustViewport: function() {
            var gl2 = this.renderer.gl;
            gl2.viewport(0, 0, this.width, this.height);
            gl2.disable(gl2.SCISSOR_TEST);
          },
          clear: function() {
            var renderer = this.renderer;
            var gl2 = renderer.gl;
            renderer.pushFramebuffer(this.framebuffer);
            gl2.disable(gl2.SCISSOR_TEST);
            gl2.clearColor(0, 0, 0, 0);
            gl2.clear(gl2.COLOR_BUFFER_BIT);
            renderer.popFramebuffer();
            renderer.resetScissor();
          },
          unbind: function(flush) {
            if (flush === void 0) {
              flush = false;
            }
            var renderer = this.renderer;
            if (flush) {
              renderer.flush();
            }
            return renderer.popFramebuffer();
          },
          destroy: function() {
            var renderer = this.renderer;
            renderer.deleteFramebuffer(this.framebuffer);
            renderer.deleteTexture(this.texture);
            renderer.off(Events.RESIZE, this.resize, this);
            this.renderer = null;
            this.framebuffer = null;
            this.texture = null;
          }
        });
        module2.exports = RenderTarget;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AddToDOM = function(element, parent) {
          var target;
          if (parent) {
            if (typeof parent === "string") {
              target = document.getElementById(parent);
            } else if (typeof parent === "object" && parent.nodeType === 1) {
              target = parent;
            }
          } else if (element.parentElement || parent === null) {
            return element;
          }
          if (!target) {
            target = document.body;
          }
          target.appendChild(element);
          return element;
        };
        module2.exports = AddToDOM;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var KeyCodes = {
          BACKSPACE: 8,
          TAB: 9,
          ENTER: 13,
          SHIFT: 16,
          CTRL: 17,
          ALT: 18,
          PAUSE: 19,
          CAPS_LOCK: 20,
          ESC: 27,
          SPACE: 32,
          PAGE_UP: 33,
          PAGE_DOWN: 34,
          END: 35,
          HOME: 36,
          LEFT: 37,
          UP: 38,
          RIGHT: 39,
          DOWN: 40,
          PRINT_SCREEN: 42,
          INSERT: 45,
          DELETE: 46,
          ZERO: 48,
          ONE: 49,
          TWO: 50,
          THREE: 51,
          FOUR: 52,
          FIVE: 53,
          SIX: 54,
          SEVEN: 55,
          EIGHT: 56,
          NINE: 57,
          NUMPAD_ZERO: 96,
          NUMPAD_ONE: 97,
          NUMPAD_TWO: 98,
          NUMPAD_THREE: 99,
          NUMPAD_FOUR: 100,
          NUMPAD_FIVE: 101,
          NUMPAD_SIX: 102,
          NUMPAD_SEVEN: 103,
          NUMPAD_EIGHT: 104,
          NUMPAD_NINE: 105,
          NUMPAD_ADD: 107,
          NUMPAD_SUBTRACT: 109,
          A: 65,
          B: 66,
          C: 67,
          D: 68,
          E: 69,
          F: 70,
          G: 71,
          H: 72,
          I: 73,
          J: 74,
          K: 75,
          L: 76,
          M: 77,
          N: 78,
          O: 79,
          P: 80,
          Q: 81,
          R: 82,
          S: 83,
          T: 84,
          U: 85,
          V: 86,
          W: 87,
          X: 88,
          Y: 89,
          Z: 90,
          F1: 112,
          F2: 113,
          F3: 114,
          F4: 115,
          F5: 116,
          F6: 117,
          F7: 118,
          F8: 119,
          F9: 120,
          F10: 121,
          F11: 122,
          F12: 123,
          SEMICOLON: 186,
          PLUS: 187,
          COMMA: 188,
          MINUS: 189,
          PERIOD: 190,
          FORWARD_SLASH: 191,
          BACK_SLASH: 220,
          QUOTES: 222,
          BACKTICK: 192,
          OPEN_BRACKET: 219,
          CLOSED_BRACKET: 221,
          SEMICOLON_FIREFOX: 59,
          COLON: 58,
          COMMA_FIREFOX_WINDOWS: 60,
          COMMA_FIREFOX: 62,
          BRACKET_RIGHT_FIREFOX: 174,
          BRACKET_LEFT_FIREFOX: 175
        };
        module2.exports = KeyCodes;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = {
          PENDING: 0,
          INIT: 1,
          START: 2,
          LOADING: 3,
          CREATING: 4,
          RUNNING: 5,
          PAUSED: 6,
          SLEEPING: 7,
          SHUTDOWN: 8,
          DESTROYED: 9
        };
        module2.exports = CONST;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Clone = __webpack_require__(77);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(70);
        var GameEvents = __webpack_require__(22);
        var NOOP = __webpack_require__(1);
        var GetAll = __webpack_require__(207);
        var GetFirst = __webpack_require__(428);
        var BaseSoundManager = new Class({
          Extends: EventEmitter,
          initialize: function BaseSoundManager2(game) {
            EventEmitter.call(this);
            this.game = game;
            this.jsonCache = game.cache.json;
            this.sounds = [];
            this.mute = false;
            this.volume = 1;
            this.pauseOnBlur = true;
            this._rate = 1;
            this._detune = 0;
            this.locked = this.locked || false;
            this.unlocked = false;
            game.events.on(GameEvents.BLUR, this.onGameBlur, this);
            game.events.on(GameEvents.FOCUS, this.onGameFocus, this);
            game.events.on(GameEvents.PRE_STEP, this.update, this);
            game.events.once(GameEvents.DESTROY, this.destroy, this);
          },
          add: NOOP,
          addAudioSprite: function(key, config) {
            if (config === void 0) {
              config = {};
            }
            var sound = this.add(key, config);
            sound.spritemap = this.jsonCache.get(key).spritemap;
            for (var markerName in sound.spritemap) {
              if (!sound.spritemap.hasOwnProperty(markerName)) {
                continue;
              }
              var markerConfig = Clone(config);
              var marker = sound.spritemap[markerName];
              markerConfig.loop = marker.hasOwnProperty("loop") ? marker.loop : false;
              sound.addMarker({
                name: markerName,
                start: marker.start,
                duration: marker.end - marker.start,
                config: markerConfig
              });
            }
            return sound;
          },
          get: function(key) {
            return GetFirst(this.sounds, "key", key);
          },
          getAll: function(key) {
            return GetAll(this.sounds, "key", key);
          },
          play: function(key, extra) {
            var sound = this.add(key);
            sound.once(Events.COMPLETE, sound.destroy, sound);
            if (extra) {
              if (extra.name) {
                sound.addMarker(extra);
                return sound.play(extra.name);
              } else {
                return sound.play(extra);
              }
            } else {
              return sound.play();
            }
          },
          playAudioSprite: function(key, spriteName, config) {
            var sound = this.addAudioSprite(key);
            sound.once(Events.COMPLETE, sound.destroy, sound);
            return sound.play(spriteName, config);
          },
          remove: function(sound) {
            var index2 = this.sounds.indexOf(sound);
            if (index2 !== -1) {
              sound.destroy();
              this.sounds.splice(index2, 1);
              return true;
            }
            return false;
          },
          removeAll: function() {
            this.sounds.forEach(function(sound) {
              sound.destroy();
            });
            this.sounds.length = 0;
          },
          removeByKey: function(key) {
            var removed = 0;
            for (var i2 = this.sounds.length - 1; i2 >= 0; i2--) {
              var sound = this.sounds[i2];
              if (sound.key === key) {
                sound.destroy();
                this.sounds.splice(i2, 1);
                removed++;
              }
            }
            return removed;
          },
          pauseAll: function() {
            this.forEachActiveSound(function(sound) {
              sound.pause();
            });
            this.emit(Events.PAUSE_ALL, this);
          },
          resumeAll: function() {
            this.forEachActiveSound(function(sound) {
              sound.resume();
            });
            this.emit(Events.RESUME_ALL, this);
          },
          stopAll: function() {
            this.forEachActiveSound(function(sound) {
              sound.stop();
            });
            this.emit(Events.STOP_ALL, this);
          },
          stopByKey: function(key) {
            var stopped = 0;
            this.getAll(key).forEach(function(sound) {
              if (sound.stop()) {
                stopped++;
              }
            });
            return stopped;
          },
          unlock: NOOP,
          onBlur: NOOP,
          onFocus: NOOP,
          onGameBlur: function() {
            if (this.pauseOnBlur) {
              this.onBlur();
            }
          },
          onGameFocus: function() {
            if (this.pauseOnBlur) {
              this.onFocus();
            }
          },
          update: function(time, delta) {
            if (this.unlocked) {
              this.unlocked = false;
              this.locked = false;
              this.emit(Events.UNLOCKED, this);
            }
            for (var i2 = this.sounds.length - 1; i2 >= 0; i2--) {
              if (this.sounds[i2].pendingRemove) {
                this.sounds.splice(i2, 1);
              }
            }
            this.sounds.forEach(function(sound) {
              sound.update(time, delta);
            });
          },
          destroy: function() {
            this.game.events.off(GameEvents.BLUR, this.onGameBlur, this);
            this.game.events.off(GameEvents.FOCUS, this.onGameFocus, this);
            this.game.events.off(GameEvents.PRE_STEP, this.update, this);
            this.removeAllListeners();
            this.removeAll();
            this.sounds.length = 0;
            this.sounds = null;
            this.game = null;
          },
          forEachActiveSound: function(callback, scope) {
            var _this = this;
            this.sounds.forEach(function(sound, index2) {
              if (sound && !sound.pendingRemove) {
                callback.call(scope || _this, sound, index2, _this.sounds);
              }
            });
          },
          setRate: function(value) {
            this.rate = value;
            return this;
          },
          rate: {
            get: function() {
              return this._rate;
            },
            set: function(value) {
              this._rate = value;
              this.forEachActiveSound(function(sound) {
                sound.calculateRate();
              });
              this.emit(Events.GLOBAL_RATE, this, value);
            }
          },
          setDetune: function(value) {
            this.detune = value;
            return this;
          },
          detune: {
            get: function() {
              return this._detune;
            },
            set: function(value) {
              this._detune = value;
              this.forEachActiveSound(function(sound) {
                sound.calculateRate();
              });
              this.emit(Events.GLOBAL_DETUNE, this, value);
            }
          }
        });
        module2.exports = BaseSoundManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(70);
        var Extend = __webpack_require__(17);
        var NOOP = __webpack_require__(1);
        var BaseSound = new Class({
          Extends: EventEmitter,
          initialize: function BaseSound2(manager, key, config) {
            EventEmitter.call(this);
            this.manager = manager;
            this.key = key;
            this.isPlaying = false;
            this.isPaused = false;
            this.totalRate = 1;
            this.duration = this.duration || 0;
            this.totalDuration = this.totalDuration || 0;
            this.config = {
              mute: false,
              volume: 1,
              rate: 1,
              detune: 0,
              seek: 0,
              loop: false,
              delay: 0,
              pan: 0
            };
            this.currentConfig = this.config;
            this.config = Extend(this.config, config);
            this.markers = {};
            this.currentMarker = null;
            this.pendingRemove = false;
          },
          addMarker: function(marker) {
            if (!marker || !marker.name || typeof marker.name !== "string") {
              return false;
            }
            if (this.markers[marker.name]) {
              console.error("addMarker " + marker.name + " already exists in Sound");
              return false;
            }
            marker = Extend(true, {
              name: "",
              start: 0,
              duration: this.totalDuration - (marker.start || 0),
              config: {
                mute: false,
                volume: 1,
                rate: 1,
                detune: 0,
                seek: 0,
                loop: false,
                delay: 0,
                pan: 0
              }
            }, marker);
            this.markers[marker.name] = marker;
            return true;
          },
          updateMarker: function(marker) {
            if (!marker || !marker.name || typeof marker.name !== "string") {
              return false;
            }
            if (!this.markers[marker.name]) {
              console.warn("Audio Marker: " + marker.name + " missing in Sound: " + this.key);
              return false;
            }
            this.markers[marker.name] = Extend(true, this.markers[marker.name], marker);
            return true;
          },
          removeMarker: function(markerName) {
            var marker = this.markers[markerName];
            if (!marker) {
              return null;
            }
            this.markers[markerName] = null;
            return marker;
          },
          play: function(markerName, config) {
            if (markerName === void 0) {
              markerName = "";
            }
            if (typeof markerName === "object") {
              config = markerName;
              markerName = "";
            }
            if (typeof markerName !== "string") {
              return false;
            }
            if (!markerName) {
              this.currentMarker = null;
              this.currentConfig = this.config;
              this.duration = this.totalDuration;
            } else {
              if (!this.markers[markerName]) {
                console.warn("Marker: " + markerName + " missing in Sound: " + this.key);
                return false;
              }
              this.currentMarker = this.markers[markerName];
              this.currentConfig = this.currentMarker.config;
              this.duration = this.currentMarker.duration;
            }
            this.resetConfig();
            this.currentConfig = Extend(this.currentConfig, config);
            this.isPlaying = true;
            this.isPaused = false;
            return true;
          },
          pause: function() {
            if (this.isPaused || !this.isPlaying) {
              return false;
            }
            this.isPlaying = false;
            this.isPaused = true;
            return true;
          },
          resume: function() {
            if (!this.isPaused || this.isPlaying) {
              return false;
            }
            this.isPlaying = true;
            this.isPaused = false;
            return true;
          },
          stop: function() {
            if (!this.isPaused && !this.isPlaying) {
              return false;
            }
            this.isPlaying = false;
            this.isPaused = false;
            this.resetConfig();
            return true;
          },
          applyConfig: function() {
            this.mute = this.currentConfig.mute;
            this.volume = this.currentConfig.volume;
            this.rate = this.currentConfig.rate;
            this.detune = this.currentConfig.detune;
            this.loop = this.currentConfig.loop;
            this.pan = this.currentConfig.pan;
          },
          resetConfig: function() {
            this.currentConfig.seek = 0;
            this.currentConfig.delay = 0;
          },
          update: NOOP,
          calculateRate: function() {
            var cent = 1.0005777895065548;
            var totalDetune = this.currentConfig.detune + this.manager.detune;
            var detuneRate = Math.pow(cent, totalDetune);
            this.totalRate = this.currentConfig.rate * this.manager.rate * detuneRate;
          },
          destroy: function() {
            if (this.pendingRemove) {
              return;
            }
            this.emit(Events.DESTROY, this);
            this.pendingRemove = true;
            this.manager = null;
            this.key = "";
            this.removeAllListeners();
            this.isPlaying = false;
            this.isPaused = false;
            this.config = null;
            this.currentConfig = null;
            this.markers = null;
            this.currentMarker = null;
          }
        });
        module2.exports = BaseSound;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CheckMatrix = __webpack_require__(209);
        var TransposeMatrix = __webpack_require__(435);
        var RotateMatrix = function(matrix, direction) {
          if (direction === void 0) {
            direction = 90;
          }
          if (!CheckMatrix(matrix)) {
            return null;
          }
          if (typeof direction !== "string") {
            direction = (direction % 360 + 360) % 360;
          }
          if (direction === 90 || direction === -270 || direction === "rotateLeft") {
            matrix = TransposeMatrix(matrix);
            matrix.reverse();
          } else if (direction === -90 || direction === 270 || direction === "rotateRight") {
            matrix.reverse();
            matrix = TransposeMatrix(matrix);
          } else if (Math.abs(direction) === 180 || direction === "rotate180") {
            for (var i2 = 0; i2 < matrix.length; i2++) {
              matrix[i2].reverse();
            }
            matrix.reverse();
          }
          return matrix;
        };
        module2.exports = RotateMatrix;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Clamp = __webpack_require__(18);
        var Components = __webpack_require__(11);
        var GameObject = __webpack_require__(15);
        var GetBitmapTextSize = __webpack_require__(1043);
        var ParseFromAtlas = __webpack_require__(1044);
        var ParseXMLBitmapFont = __webpack_require__(212);
        var Rectangle = __webpack_require__(10);
        var Render = __webpack_require__(1045);
        var BitmapText = new Class({
          Extends: GameObject,
          Mixins: [
            Components.Alpha,
            Components.BlendMode,
            Components.Depth,
            Components.Mask,
            Components.Origin,
            Components.Pipeline,
            Components.ScrollFactor,
            Components.Texture,
            Components.Tint,
            Components.Transform,
            Components.Visible,
            Render
          ],
          initialize: function BitmapText2(scene, x2, y2, font, text, size, align) {
            if (text === void 0) {
              text = "";
            }
            if (align === void 0) {
              align = 0;
            }
            GameObject.call(this, scene, "BitmapText");
            this.font = font;
            var entry = this.scene.sys.cache.bitmapFont.get(font);
            if (!entry) {
              console.warn("Invalid BitmapText key: " + font);
            }
            this.fontData = entry.data;
            this._text = "";
            this._fontSize = size || this.fontData.size;
            this._letterSpacing = 0;
            this._align = align;
            this._bounds = GetBitmapTextSize();
            this._dirty = true;
            this._maxWidth = 0;
            this.wordWrapCharCode = 32;
            this.charColors = [];
            this.dropShadowX = 0;
            this.dropShadowY = 0;
            this.dropShadowColor = 0;
            this.dropShadowAlpha = 0.5;
            this.fromAtlas = entry.fromAtlas;
            this.setTexture(entry.texture, entry.frame);
            this.setPosition(x2, y2);
            this.setOrigin(0, 0);
            this.initPipeline();
            this.setText(text);
          },
          setLeftAlign: function() {
            this._align = BitmapText.ALIGN_LEFT;
            this._dirty = true;
            return this;
          },
          setCenterAlign: function() {
            this._align = BitmapText.ALIGN_CENTER;
            this._dirty = true;
            return this;
          },
          setRightAlign: function() {
            this._align = BitmapText.ALIGN_RIGHT;
            this._dirty = true;
            return this;
          },
          setFontSize: function(size) {
            this._fontSize = size;
            this._dirty = true;
            return this;
          },
          setLetterSpacing: function(spacing) {
            if (spacing === void 0) {
              spacing = 0;
            }
            this._letterSpacing = spacing;
            this._dirty = true;
            return this;
          },
          setText: function(value) {
            if (!value && value !== 0) {
              value = "";
            }
            if (Array.isArray(value)) {
              value = value.join("\n");
            }
            if (value !== this.text) {
              this._text = value.toString();
              this._dirty = true;
              this.updateDisplayOrigin();
            }
            return this;
          },
          setDropShadow: function(x2, y2, color, alpha) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (color === void 0) {
              color = 0;
            }
            if (alpha === void 0) {
              alpha = 0.5;
            }
            this.dropShadowX = x2;
            this.dropShadowY = y2;
            this.dropShadowColor = color;
            this.dropShadowAlpha = alpha;
            return this;
          },
          setCharacterTint: function(start, length, tintFill, topLeft, topRight, bottomLeft, bottomRight) {
            if (start === void 0) {
              start = 0;
            }
            if (length === void 0) {
              length = 1;
            }
            if (tintFill === void 0) {
              tintFill = false;
            }
            if (topLeft === void 0) {
              topLeft = -1;
            }
            if (topRight === void 0) {
              topRight = topLeft;
              bottomLeft = topLeft;
              bottomRight = topLeft;
            }
            var len = this.text.length;
            if (length === -1) {
              length = len;
            }
            if (start < 0) {
              start = len + start;
            }
            start = Clamp(start, 0, len - 1);
            var end = Clamp(start + length, start, len);
            var charColors = this.charColors;
            for (var i2 = start; i2 < end; i2++) {
              var color = charColors[i2];
              if (topLeft === -1) {
                charColors[i2] = null;
              } else {
                var tintEffect = tintFill ? 1 : 0;
                if (color) {
                  color.tintEffect = tintEffect;
                  color.tintTL = topLeft;
                  color.tintTR = topRight;
                  color.tintBL = bottomLeft;
                  color.tintBR = bottomRight;
                } else {
                  charColors[i2] = {
                    tintEffect,
                    tintTL: topLeft,
                    tintTR: topRight,
                    tintBL: bottomLeft,
                    tintBR: bottomRight
                  };
                }
              }
            }
            return this;
          },
          setWordTint: function(word, count, tintFill, topLeft, topRight, bottomLeft, bottomRight) {
            if (count === void 0) {
              count = 1;
            }
            var bounds = this.getTextBounds();
            var words = bounds.words;
            var wordIsNumber = typeof word === "number";
            var total = 0;
            for (var i2 = 0; i2 < words.length; i2++) {
              var lineword = words[i2];
              if (wordIsNumber && i2 === word || !wordIsNumber && lineword.word === word) {
                this.setCharacterTint(lineword.i, lineword.word.length, tintFill, topLeft, topRight, bottomLeft, bottomRight);
                total++;
                if (total === count) {
                  return this;
                }
              }
            }
            return this;
          },
          getTextBounds: function(round) {
            var bounds = this._bounds;
            if (this._dirty || round || this.scaleX !== bounds.scaleX || this.scaleY !== bounds.scaleY) {
              GetBitmapTextSize(this, round, true, bounds);
              this._dirty = false;
            }
            return bounds;
          },
          getCharacterAt: function(x2, y2, camera) {
            var point = this.getLocalPoint(x2, y2, null, camera);
            var bounds = this.getTextBounds();
            var chars = bounds.characters;
            var tempRect = new Rectangle();
            for (var i2 = 0; i2 < chars.length; i2++) {
              var char = chars[i2];
              tempRect.setTo(char.x, char.t, char.r - char.x, char.b);
              if (tempRect.contains(point.x, point.y)) {
                return char;
              }
            }
            return null;
          },
          updateDisplayOrigin: function() {
            this._dirty = true;
            this.getTextBounds(false);
            return this;
          },
          setFont: function(key, size, align) {
            if (size === void 0) {
              size = this._fontSize;
            }
            if (align === void 0) {
              align = this._align;
            }
            if (key !== this.font) {
              var entry = this.scene.sys.cache.bitmapFont.get(key);
              if (entry) {
                this.font = key;
                this.fontData = entry.data;
                this._fontSize = size;
                this._align = align;
                this.fromAtlas = entry.fromAtlas === true;
                this.setTexture(entry.texture, entry.frame);
                GetBitmapTextSize(this, false, true, this._bounds);
              }
            }
            return this;
          },
          setMaxWidth: function(value, wordWrapCharCode) {
            this._maxWidth = value;
            this._dirty = true;
            if (wordWrapCharCode !== void 0) {
              this.wordWrapCharCode = wordWrapCharCode;
            }
            return this;
          },
          align: {
            set: function(value) {
              this._align = value;
              this._dirty = true;
            },
            get: function() {
              return this._align;
            }
          },
          text: {
            set: function(value) {
              this.setText(value);
            },
            get: function() {
              return this._text;
            }
          },
          fontSize: {
            set: function(value) {
              this._fontSize = value;
              this._dirty = true;
            },
            get: function() {
              return this._fontSize;
            }
          },
          letterSpacing: {
            set: function(value) {
              this._letterSpacing = value;
              this._dirty = true;
            },
            get: function() {
              return this._letterSpacing;
            }
          },
          maxWidth: {
            set: function(value) {
              this._maxWidth = value;
              this._dirty = true;
            },
            get: function() {
              return this._maxWidth;
            }
          },
          width: {
            get: function() {
              this.getTextBounds(false);
              return this._bounds.global.width;
            }
          },
          height: {
            get: function() {
              this.getTextBounds(false);
              return this._bounds.global.height;
            }
          },
          toJSON: function() {
            var out = Components.ToJSON(this);
            var data = {
              font: this.font,
              text: this.text,
              fontSize: this.fontSize,
              letterSpacing: this.letterSpacing,
              align: this.align
            };
            out.data = data;
            return out;
          },
          preDestroy: function() {
            this.charColors.length = 0;
            this._bounds = null;
            this.fontData = null;
          }
        });
        BitmapText.ALIGN_LEFT = 0;
        BitmapText.ALIGN_CENTER = 1;
        BitmapText.ALIGN_RIGHT = 2;
        BitmapText.ParseFromAtlas = ParseFromAtlas;
        BitmapText.ParseXMLBitmapFont = ParseXMLBitmapFont;
        module2.exports = BitmapText;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Set2 = new Class({
          initialize: function Set3(elements) {
            this.entries = [];
            if (Array.isArray(elements)) {
              for (var i2 = 0; i2 < elements.length; i2++) {
                this.set(elements[i2]);
              }
            }
          },
          set: function(value) {
            if (this.entries.indexOf(value) === -1) {
              this.entries.push(value);
            }
            return this;
          },
          get: function(property, value) {
            for (var i2 = 0; i2 < this.entries.length; i2++) {
              var entry = this.entries[i2];
              if (entry[property] === value) {
                return entry;
              }
            }
          },
          getArray: function() {
            return this.entries.slice(0);
          },
          delete: function(value) {
            var index2 = this.entries.indexOf(value);
            if (index2 > -1) {
              this.entries.splice(index2, 1);
            }
            return this;
          },
          dump: function() {
            console.group("Set");
            for (var i2 = 0; i2 < this.entries.length; i2++) {
              var entry = this.entries[i2];
              console.log(entry);
            }
            console.groupEnd();
          },
          each: function(callback, callbackScope) {
            var i2;
            var temp = this.entries.slice();
            var len = temp.length;
            if (callbackScope) {
              for (i2 = 0; i2 < len; i2++) {
                if (callback.call(callbackScope, temp[i2], i2) === false) {
                  break;
                }
              }
            } else {
              for (i2 = 0; i2 < len; i2++) {
                if (callback(temp[i2], i2) === false) {
                  break;
                }
              }
            }
            return this;
          },
          iterate: function(callback, callbackScope) {
            var i2;
            var len = this.entries.length;
            if (callbackScope) {
              for (i2 = 0; i2 < len; i2++) {
                if (callback.call(callbackScope, this.entries[i2], i2) === false) {
                  break;
                }
              }
            } else {
              for (i2 = 0; i2 < len; i2++) {
                if (callback(this.entries[i2], i2) === false) {
                  break;
                }
              }
            }
            return this;
          },
          iterateLocal: function(callbackKey) {
            var i2;
            var args = [];
            for (i2 = 1; i2 < arguments.length; i2++) {
              args.push(arguments[i2]);
            }
            var len = this.entries.length;
            for (i2 = 0; i2 < len; i2++) {
              var entry = this.entries[i2];
              entry[callbackKey].apply(entry, args);
            }
            return this;
          },
          clear: function() {
            this.entries.length = 0;
            return this;
          },
          contains: function(value) {
            return this.entries.indexOf(value) > -1;
          },
          union: function(set) {
            var newSet = new Set2();
            set.entries.forEach(function(value) {
              newSet.set(value);
            });
            this.entries.forEach(function(value) {
              newSet.set(value);
            });
            return newSet;
          },
          intersect: function(set) {
            var newSet = new Set2();
            this.entries.forEach(function(value) {
              if (set.contains(value)) {
                newSet.set(value);
              }
            });
            return newSet;
          },
          difference: function(set) {
            var newSet = new Set2();
            this.entries.forEach(function(value) {
              if (!set.contains(value)) {
                newSet.set(value);
              }
            });
            return newSet;
          },
          size: {
            get: function() {
              return this.entries.length;
            },
            set: function(value) {
              if (value < this.entries.length) {
                return this.entries.length = value;
              } else {
                return this.entries.length;
              }
            }
          }
        });
        module2.exports = Set2;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var GameObject = __webpack_require__(15);
        var IntegerToColor = __webpack_require__(189);
        var PIPELINES_CONST = __webpack_require__(92);
        var Render = __webpack_require__(1182);
        var PointLight = new Class({
          Extends: GameObject,
          Mixins: [
            Components.AlphaSingle,
            Components.BlendMode,
            Components.Depth,
            Components.GetBounds,
            Components.Mask,
            Components.Pipeline,
            Components.ScrollFactor,
            Components.Transform,
            Components.Visible,
            Render
          ],
          initialize: function PointLight2(scene, x2, y2, color, radius, intensity, attenuation) {
            if (color === void 0) {
              color = 16777215;
            }
            if (radius === void 0) {
              radius = 128;
            }
            if (intensity === void 0) {
              intensity = 1;
            }
            if (attenuation === void 0) {
              attenuation = 0.1;
            }
            GameObject.call(this, scene, "PointLight");
            this.initPipeline(PIPELINES_CONST.POINTLIGHT_PIPELINE);
            this.setPosition(x2, y2);
            this.color = IntegerToColor(color);
            this.intensity = intensity;
            this.attenuation = attenuation;
            this.width = radius * 2;
            this.height = radius * 2;
            this._radius = radius;
          },
          radius: {
            get: function() {
              return this._radius;
            },
            set: function(value) {
              this._radius = value;
              this.width = value * 2;
              this.height = value * 2;
            }
          },
          originX: {
            get: function() {
              return 0.5;
            }
          },
          originY: {
            get: function() {
              return 0.5;
            }
          },
          displayOriginX: {
            get: function() {
              return this._radius;
            }
          },
          displayOriginY: {
            get: function() {
              return this._radius;
            }
          }
        });
        module2.exports = PointLight;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CircleToRectangle = function(circle, rect) {
          var halfWidth = rect.width / 2;
          var halfHeight = rect.height / 2;
          var cx = Math.abs(circle.x - rect.x - halfWidth);
          var cy = Math.abs(circle.y - rect.y - halfHeight);
          var xDist = halfWidth + circle.radius;
          var yDist = halfHeight + circle.radius;
          if (cx > xDist || cy > yDist) {
            return false;
          } else if (cx <= halfWidth || cy <= halfHeight) {
            return true;
          } else {
            var xCornerDist = cx - halfWidth;
            var yCornerDist = cy - halfHeight;
            var xCornerDistSq = xCornerDist * xCornerDist;
            var yCornerDistSq = yCornerDist * yCornerDist;
            var maxCornerDistSq = circle.radius * circle.radius;
            return xCornerDistSq + yCornerDistSq <= maxCornerDistSq;
          }
        };
        module2.exports = CircleToRectangle;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RectangleToRectangle = function(rectA, rectB) {
          if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0) {
            return false;
          }
          return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
        };
        module2.exports = RectangleToRectangle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetValue = __webpack_require__(6);
        var inputPlugins = {};
        var InputPluginCache = {};
        InputPluginCache.register = function(key, plugin, mapping, settingsKey, configKey) {
          inputPlugins[key] = { plugin, mapping, settingsKey, configKey };
        };
        InputPluginCache.getPlugin = function(key) {
          return inputPlugins[key];
        };
        InputPluginCache.install = function(target) {
          var sys = target.scene.sys;
          var settings = sys.settings.input;
          var config = sys.game.config;
          for (var key in inputPlugins) {
            var source = inputPlugins[key].plugin;
            var mapping = inputPlugins[key].mapping;
            var settingsKey = inputPlugins[key].settingsKey;
            var configKey = inputPlugins[key].configKey;
            if (GetValue(settings, settingsKey, config[configKey])) {
              target[mapping] = new source(target);
            }
          }
        };
        InputPluginCache.remove = function(key) {
          if (inputPlugins.hasOwnProperty(key)) {
            delete inputPlugins[key];
          }
        };
        module2.exports = InputPluginCache;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          ANY_KEY_DOWN: __webpack_require__(1323),
          ANY_KEY_UP: __webpack_require__(1324),
          COMBO_MATCH: __webpack_require__(1325),
          DOWN: __webpack_require__(1326),
          KEY_DOWN: __webpack_require__(1327),
          KEY_UP: __webpack_require__(1328),
          UP: __webpack_require__(1329)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetURL = function(file, baseURL) {
          if (!file.url) {
            return false;
          }
          if (file.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/)) {
            return file.url;
          } else {
            return baseURL + file.url;
          }
        };
        module2.exports = GetURL;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var XHRSettings = function(responseType, async, user, password, timeout, withCredentials) {
          if (responseType === void 0) {
            responseType = "";
          }
          if (async === void 0) {
            async = true;
          }
          if (user === void 0) {
            user = "";
          }
          if (password === void 0) {
            password = "";
          }
          if (timeout === void 0) {
            timeout = 0;
          }
          if (withCredentials === void 0) {
            withCredentials = false;
          }
          return {
            responseType,
            async,
            user,
            password,
            timeout,
            headers: void 0,
            header: void 0,
            headerValue: void 0,
            requestedWith: false,
            overrideMimeType: void 0,
            withCredentials
          };
        };
        module2.exports = XHRSettings;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(243);
        var Sprite = __webpack_require__(73);
        var ArcadeSprite = new Class({
          Extends: Sprite,
          Mixins: [
            Components.Acceleration,
            Components.Angular,
            Components.Bounce,
            Components.Debug,
            Components.Drag,
            Components.Enable,
            Components.Friction,
            Components.Gravity,
            Components.Immovable,
            Components.Mass,
            Components.Pushable,
            Components.Size,
            Components.Velocity
          ],
          initialize: function ArcadeSprite2(scene, x2, y2, texture, frame) {
            Sprite.call(this, scene, x2, y2, texture, frame);
            this.body = null;
          }
        });
        module2.exports = ArcadeSprite;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var IsInLayerBounds = __webpack_require__(119);
        var GetTileAt = function(tileX, tileY, nonNull, layer) {
          if (nonNull === void 0) {
            nonNull = false;
          }
          if (IsInLayerBounds(tileX, tileY, layer)) {
            var tile = layer.data[tileY][tileX] || null;
            if (!tile) {
              return null;
            } else if (tile.index === -1) {
              return nonNull ? tile : null;
            } else {
              return tile;
            }
          } else {
            return null;
          }
        };
        module2.exports = GetTileAt;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RunCull = function(layer, bounds, renderOrder, outputArray) {
          var mapData = layer.data;
          var mapWidth = layer.width;
          var mapHeight = layer.height;
          var tilemapLayer = layer.tilemapLayer;
          var drawLeft = Math.max(0, bounds.left);
          var drawRight = Math.min(mapWidth, bounds.right);
          var drawTop = Math.max(0, bounds.top);
          var drawBottom = Math.min(mapHeight, bounds.bottom);
          var x2;
          var y2;
          var tile;
          if (renderOrder === 0) {
            for (y2 = drawTop; y2 < drawBottom; y2++) {
              for (x2 = drawLeft; mapData[y2] && x2 < drawRight; x2++) {
                tile = mapData[y2][x2];
                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                  continue;
                }
                outputArray.push(tile);
              }
            }
          } else if (renderOrder === 1) {
            for (y2 = drawTop; y2 < drawBottom; y2++) {
              for (x2 = drawRight; mapData[y2] && x2 >= drawLeft; x2--) {
                tile = mapData[y2][x2];
                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                  continue;
                }
                outputArray.push(tile);
              }
            }
          } else if (renderOrder === 2) {
            for (y2 = drawBottom; y2 >= drawTop; y2--) {
              for (x2 = drawLeft; mapData[y2] && x2 < drawRight; x2++) {
                tile = mapData[y2][x2];
                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                  continue;
                }
                outputArray.push(tile);
              }
            }
          } else if (renderOrder === 3) {
            for (y2 = drawBottom; y2 >= drawTop; y2--) {
              for (x2 = drawRight; mapData[y2] && x2 >= drawLeft; x2--) {
                tile = mapData[y2][x2];
                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                  continue;
                }
                outputArray.push(tile);
              }
            }
          }
          tilemapLayer.tilesDrawn = outputArray.length;
          tilemapLayer.tilesTotal = mapWidth * mapHeight;
          return outputArray;
        };
        module2.exports = RunCull;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetLayerCollisionIndex = function(tileIndex, collides, layer) {
          var loc = layer.collideIndexes.indexOf(tileIndex);
          if (collides && loc === -1) {
            layer.collideIndexes.push(tileIndex);
          } else if (!collides && loc !== -1) {
            layer.collideIndexes.splice(loc, 1);
          }
        };
        module2.exports = SetLayerCollisionIndex;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Seth Berrier <berriers@uwstout.edu>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetFastValue = __webpack_require__(2);
        var CreateGroupLayer = function(json, groupl, parentstate) {
          if (!groupl) {
            return {
              i: 0,
              layers: json.layers,
              name: "",
              opacity: 1,
              visible: true,
              x: 0,
              y: 0
            };
          }
          var layerX = groupl.x + GetFastValue(groupl, "startx", 0) * json.tilewidth + GetFastValue(groupl, "offsetx", 0);
          var layerY = groupl.y + GetFastValue(groupl, "starty", 0) * json.tileheight + GetFastValue(groupl, "offsety", 0);
          return {
            i: 0,
            layers: groupl.layers,
            name: parentstate.name + groupl.name + "/",
            opacity: parentstate.opacity * groupl.opacity,
            visible: parentstate.visible && groupl.visible,
            x: parentstate.x + layerX,
            y: parentstate.y + layerY
          };
        };
        module2.exports = CreateGroupLayer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetNewValue = function(source, key, defaultValue) {
          var valueCallback;
          if (source.hasOwnProperty(key)) {
            var t2 = typeof source[key];
            if (t2 === "function") {
              valueCallback = function(target, targetKey, value, targetIndex, totalTargets, tween) {
                return source[key](target, targetKey, value, targetIndex, totalTargets, tween);
              };
            } else {
              valueCallback = function() {
                return source[key];
              };
            }
          } else if (typeof defaultValue === "function") {
            valueCallback = defaultValue;
          } else {
            valueCallback = function() {
              return defaultValue;
            };
          }
          return valueCallback;
        };
        module2.exports = GetNewValue;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Defaults = __webpack_require__(265);
        var GetAdvancedValue = __webpack_require__(13);
        var GetBoolean = __webpack_require__(99);
        var GetEaseFunction = __webpack_require__(80);
        var GetNewValue = __webpack_require__(162);
        var GetProps = __webpack_require__(583);
        var GetTargets = __webpack_require__(263);
        var GetValue = __webpack_require__(6);
        var GetValueOp = __webpack_require__(264);
        var Tween = __webpack_require__(266);
        var TweenData = __webpack_require__(268);
        var TweenBuilder = function(parent, config, defaults) {
          if (defaults === void 0) {
            defaults = Defaults;
          }
          var targets = defaults.targets ? defaults.targets : GetTargets(config);
          var props = GetProps(config);
          var delay = GetNewValue(config, "delay", defaults.delay);
          var duration = GetNewValue(config, "duration", defaults.duration);
          var easeParams = GetValue(config, "easeParams", defaults.easeParams);
          var ease = GetEaseFunction(GetValue(config, "ease", defaults.ease), easeParams);
          var hold = GetNewValue(config, "hold", defaults.hold);
          var repeat = GetNewValue(config, "repeat", defaults.repeat);
          var repeatDelay = GetNewValue(config, "repeatDelay", defaults.repeatDelay);
          var yoyo = GetBoolean(config, "yoyo", defaults.yoyo);
          var flipX = GetBoolean(config, "flipX", defaults.flipX);
          var flipY = GetBoolean(config, "flipY", defaults.flipY);
          var data = [];
          for (var p2 = 0; p2 < props.length; p2++) {
            var key = props[p2].key;
            var value = props[p2].value;
            for (var t2 = 0; t2 < targets.length; t2++) {
              var ops = GetValueOp(key, value);
              var tweenData = TweenData(targets[t2], t2, key, ops.getEnd, ops.getStart, ops.getActive, GetEaseFunction(GetValue(value, "ease", ease), GetValue(value, "easeParams", easeParams)), GetNewValue(value, "delay", delay), GetNewValue(value, "duration", duration), GetBoolean(value, "yoyo", yoyo), GetNewValue(value, "hold", hold), GetNewValue(value, "repeat", repeat), GetNewValue(value, "repeatDelay", repeatDelay), GetBoolean(value, "flipX", flipX), GetBoolean(value, "flipY", flipY));
              data.push(tweenData);
            }
          }
          var tween = new Tween(parent, data, targets);
          tween.offset = GetAdvancedValue(config, "offset", null);
          tween.completeDelay = GetAdvancedValue(config, "completeDelay", 0);
          tween.loop = Math.round(GetAdvancedValue(config, "loop", 0));
          tween.loopDelay = Math.round(GetAdvancedValue(config, "loopDelay", 0));
          tween.paused = GetBoolean(config, "paused", false);
          tween.useFrames = GetBoolean(config, "useFrames", false);
          var scope = GetValue(config, "callbackScope", tween);
          var tweenArray = [tween, null];
          var callbacks = Tween.TYPES;
          for (var i2 = 0; i2 < callbacks.length; i2++) {
            var type = callbacks[i2];
            var callback = GetValue(config, type, false);
            if (callback) {
              var callbackScope = GetValue(config, type + "Scope", scope);
              var callbackParams = GetValue(config, type + "Params", []);
              tween.setCallback(type, callback, tweenArray.concat(callbackParams), callbackScope);
            }
          }
          return tween;
        };
        module2.exports = TweenBuilder;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CustomMap = __webpack_require__(102);
        var GetFastValue = __webpack_require__(2);
        var Events = __webpack_require__(132);
        var Animation = __webpack_require__(185);
        var AnimationState = new Class({
          initialize: function AnimationState2(parent) {
            this.parent = parent;
            this.animationManager = parent.scene.sys.anims;
            this.animationManager.on(Events.REMOVE_ANIMATION, this.globalRemove, this);
            this.textureManager = this.animationManager.textureManager;
            this.anims = null;
            this.isPlaying = false;
            this.hasStarted = false;
            this.currentAnim = null;
            this.currentFrame = null;
            this.nextAnim = null;
            this.nextAnimsQueue = [];
            this.timeScale = 1;
            this.frameRate = 0;
            this.duration = 0;
            this.msPerFrame = 0;
            this.skipMissedFrames = true;
            this.delay = 0;
            this.repeat = 0;
            this.repeatDelay = 0;
            this.yoyo = false;
            this.showOnStart = false;
            this.hideOnComplete = false;
            this.forward = true;
            this.inReverse = false;
            this.accumulator = 0;
            this.nextTick = 0;
            this.delayCounter = 0;
            this.repeatCounter = 0;
            this.pendingRepeat = false;
            this._paused = false;
            this._wasPlaying = false;
            this._pendingStop = 0;
            this._pendingStopValue;
          },
          chain: function(key) {
            var parent = this.parent;
            if (key === void 0) {
              this.nextAnimsQueue.length = 0;
              this.nextAnim = null;
              return parent;
            }
            if (!Array.isArray(key)) {
              key = [key];
            }
            for (var i2 = 0; i2 < key.length; i2++) {
              var anim = key[i2];
              if (this.nextAnim === null) {
                this.nextAnim = anim;
              } else {
                this.nextAnimsQueue.push(anim);
              }
            }
            return this.parent;
          },
          getName: function() {
            return this.currentAnim ? this.currentAnim.key : "";
          },
          getFrameName: function() {
            return this.currentFrame ? this.currentFrame.textureFrame : "";
          },
          load: function(key) {
            if (this.isPlaying) {
              this.stop();
            }
            var manager = this.animationManager;
            var animKey = typeof key === "string" ? key : GetFastValue(key, "key", null);
            var anim = this.exists(animKey) ? this.get(animKey) : manager.get(animKey);
            if (!anim) {
              console.warn("Missing animation: " + animKey);
            } else {
              this.currentAnim = anim;
              var totalFrames = anim.getTotalFrames();
              var frameRate = GetFastValue(key, "frameRate", anim.frameRate);
              var duration = GetFastValue(key, "duration", anim.duration);
              anim.calculateDuration(this, totalFrames, duration, frameRate);
              this.delay = GetFastValue(key, "delay", anim.delay);
              this.repeat = GetFastValue(key, "repeat", anim.repeat);
              this.repeatDelay = GetFastValue(key, "repeatDelay", anim.repeatDelay);
              this.yoyo = GetFastValue(key, "yoyo", anim.yoyo);
              this.showOnStart = GetFastValue(key, "showOnStart", anim.showOnStart);
              this.hideOnComplete = GetFastValue(key, "hideOnComplete", anim.hideOnComplete);
              this.skipMissedFrames = GetFastValue(key, "skipMissedFrames", anim.skipMissedFrames);
              this.timeScale = GetFastValue(key, "timeScale", this.timeScale);
              var startFrame = GetFastValue(key, "startFrame", 0);
              if (startFrame > anim.getTotalFrames()) {
                startFrame = 0;
              }
              var frame = anim.frames[startFrame];
              if (startFrame === 0 && !this.forward) {
                frame = anim.getLastFrame();
              }
              this.currentFrame = frame;
            }
            return this.parent;
          },
          pause: function(atFrame) {
            if (!this._paused) {
              this._paused = true;
              this._wasPlaying = this.isPlaying;
              this.isPlaying = false;
            }
            if (atFrame !== void 0) {
              this.setCurrentFrame(atFrame);
            }
            return this.parent;
          },
          resume: function(fromFrame) {
            if (this._paused) {
              this._paused = false;
              this.isPlaying = this._wasPlaying;
            }
            if (fromFrame !== void 0) {
              this.setCurrentFrame(fromFrame);
            }
            return this.parent;
          },
          playAfterDelay: function(key, delay) {
            if (!this.isPlaying) {
              this.delayCounter = delay;
              this.play(key, true);
            } else {
              var nextAnim = this.nextAnim;
              var queue = this.nextAnimsQueue;
              if (nextAnim) {
                queue.unshift(nextAnim);
              }
              this.nextAnim = key;
              this._pendingStop = 1;
              this._pendingStopValue = delay;
            }
            return this.parent;
          },
          playAfterRepeat: function(key, repeatCount) {
            if (repeatCount === void 0) {
              repeatCount = 1;
            }
            if (!this.isPlaying) {
              this.play(key);
            } else {
              var nextAnim = this.nextAnim;
              var queue = this.nextAnimsQueue;
              if (nextAnim) {
                queue.unshift(nextAnim);
              }
              if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter) {
                repeatCount = this.repeatCounter;
              }
              this.nextAnim = key;
              this._pendingStop = 2;
              this._pendingStopValue = repeatCount;
            }
            return this.parent;
          },
          play: function(key, ignoreIfPlaying) {
            if (ignoreIfPlaying === void 0) {
              ignoreIfPlaying = false;
            }
            var currentAnim = this.currentAnim;
            var parent = this.parent;
            var animKey = typeof key === "string" ? key : key.key;
            if (ignoreIfPlaying && this.isPlaying && currentAnim.key === animKey) {
              return parent;
            }
            if (currentAnim && this.isPlaying) {
              var mix = this.animationManager.getMix(currentAnim.key, key);
              if (mix > 0) {
                return this.playAfterDelay(key, mix);
              }
            }
            this.forward = true;
            this.inReverse = false;
            this._paused = false;
            this._wasPlaying = true;
            return this.startAnimation(key);
          },
          playReverse: function(key, ignoreIfPlaying) {
            if (ignoreIfPlaying === void 0) {
              ignoreIfPlaying = false;
            }
            var animKey = typeof key === "string" ? key : key.key;
            if (ignoreIfPlaying && this.isPlaying && this.currentAnim.key === animKey) {
              return this.parent;
            }
            this.forward = false;
            this.inReverse = true;
            this._paused = false;
            this._wasPlaying = true;
            return this.startAnimation(key);
          },
          startAnimation: function(key) {
            this.load(key);
            var anim = this.currentAnim;
            var gameObject = this.parent;
            if (!anim) {
              return gameObject;
            }
            this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat;
            anim.getFirstTick(this);
            this.isPlaying = true;
            this.pendingRepeat = false;
            this.hasStarted = false;
            this._pendingStop = 0;
            this._pendingStopValue = 0;
            this._paused = false;
            this.delayCounter += this.delay;
            if (this.delayCounter === 0) {
              this.handleStart();
            }
            return gameObject;
          },
          handleStart: function() {
            if (this.showOnStart) {
              this.parent.setVisible(true);
            }
            this.setCurrentFrame(this.currentFrame);
            this.hasStarted = true;
            this.emitEvents(Events.ANIMATION_START);
          },
          handleRepeat: function() {
            this.pendingRepeat = false;
            this.emitEvents(Events.ANIMATION_REPEAT);
          },
          handleStop: function() {
            this._pendingStop = 0;
            this.isPlaying = false;
            this.emitEvents(Events.ANIMATION_STOP);
          },
          handleComplete: function() {
            this._pendingStop = 0;
            this.isPlaying = false;
            if (this.hideOnComplete) {
              this.parent.setVisible(false);
            }
            this.emitEvents(Events.ANIMATION_COMPLETE, Events.ANIMATION_COMPLETE_KEY);
          },
          emitEvents: function(event, keyEvent) {
            var anim = this.currentAnim;
            var frame = this.currentFrame;
            var gameObject = this.parent;
            var frameKey = frame.textureFrame;
            gameObject.emit(event, anim, frame, gameObject, frameKey);
            if (keyEvent) {
              gameObject.emit(keyEvent + anim.key, anim, frame, gameObject, frameKey);
            }
          },
          reverse: function() {
            if (this.isPlaying) {
              this.inReverse = !this.inReverse;
              this.forward = !this.forward;
            }
            return this.parent;
          },
          getProgress: function() {
            var frame = this.currentFrame;
            if (!frame) {
              return 0;
            }
            var p2 = frame.progress;
            if (this.inReverse) {
              p2 *= -1;
            }
            return p2;
          },
          setProgress: function(value) {
            if (!this.forward) {
              value = 1 - value;
            }
            this.setCurrentFrame(this.currentAnim.getFrameByProgress(value));
            return this.parent;
          },
          setRepeat: function(value) {
            this.repeatCounter = value === -1 ? Number.MAX_VALUE : value;
            return this.parent;
          },
          globalRemove: function(key, animation) {
            if (animation === void 0) {
              animation = this.currentAnim;
            }
            if (this.isPlaying && animation.key === this.currentAnim.key) {
              this.stop();
              this.setCurrentFrame(this.currentAnim.frames[0]);
            }
          },
          restart: function(includeDelay, resetRepeats) {
            if (includeDelay === void 0) {
              includeDelay = false;
            }
            if (resetRepeats === void 0) {
              resetRepeats = false;
            }
            var anim = this.currentAnim;
            var gameObject = this.parent;
            if (!anim) {
              return gameObject;
            }
            if (resetRepeats) {
              this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat;
            }
            anim.getFirstTick(this);
            this.emitEvents(Events.ANIMATION_RESTART);
            this.isPlaying = true;
            this.pendingRepeat = false;
            this.hasStarted = !includeDelay;
            this._pendingStop = 0;
            this._pendingStopValue = 0;
            this._paused = false;
            this.setCurrentFrame(anim.frames[0]);
            return this.parent;
          },
          complete: function() {
            this._pendingStop = 0;
            this.isPlaying = false;
            if (this.currentAnim) {
              this.handleComplete();
            }
            if (this.nextAnim) {
              var key = this.nextAnim;
              this.nextAnim = this.nextAnimsQueue.length > 0 ? this.nextAnimsQueue.shift() : null;
              this.play(key);
            }
            return this.parent;
          },
          stop: function() {
            this._pendingStop = 0;
            this.isPlaying = false;
            if (this.currentAnim) {
              this.handleStop();
            }
            if (this.nextAnim) {
              var key = this.nextAnim;
              this.nextAnim = this.nextAnimsQueue.shift();
              this.play(key);
            }
            return this.parent;
          },
          stopAfterDelay: function(delay) {
            this._pendingStop = 1;
            this._pendingStopValue = delay;
            return this.parent;
          },
          stopAfterRepeat: function(repeatCount) {
            if (repeatCount === void 0) {
              repeatCount = 1;
            }
            if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter) {
              repeatCount = this.repeatCounter;
            }
            this._pendingStop = 2;
            this._pendingStopValue = repeatCount;
            return this.parent;
          },
          stopOnFrame: function(frame) {
            this._pendingStop = 3;
            this._pendingStopValue = frame;
            return this.parent;
          },
          getTotalFrames: function() {
            return this.currentAnim ? this.currentAnim.getTotalFrames() : 0;
          },
          update: function(time, delta) {
            var anim = this.currentAnim;
            if (!this.isPlaying || !anim || anim.paused) {
              return;
            }
            this.accumulator += delta * this.timeScale;
            if (this._pendingStop === 1) {
              this._pendingStopValue -= delta;
              if (this._pendingStopValue <= 0) {
                return this.stop();
              }
            }
            if (!this.hasStarted) {
              if (this.accumulator >= this.delayCounter) {
                this.accumulator -= this.delayCounter;
                this.handleStart();
              }
            } else if (this.accumulator >= this.nextTick) {
              if (this.forward) {
                anim.nextFrame(this);
              } else {
                anim.previousFrame(this);
              }
              if (this.isPlaying && this._pendingStop === 0 && this.skipMissedFrames && this.accumulator > this.nextTick) {
                var safetyNet = 0;
                do {
                  if (this.forward) {
                    anim.nextFrame(this);
                  } else {
                    anim.previousFrame(this);
                  }
                  safetyNet++;
                } while (this.isPlaying && this.accumulator > this.nextTick && safetyNet < 60);
              }
            }
          },
          setCurrentFrame: function(animationFrame) {
            var gameObject = this.parent;
            this.currentFrame = animationFrame;
            gameObject.texture = animationFrame.frame.texture;
            gameObject.frame = animationFrame.frame;
            if (gameObject.isCropped) {
              gameObject.frame.updateCropUVs(gameObject._crop, gameObject.flipX, gameObject.flipY);
            }
            if (animationFrame.setAlpha) {
              gameObject.alpha = animationFrame.alpha;
            }
            gameObject.setSizeToFrame();
            if (gameObject._originComponent) {
              if (animationFrame.frame.customPivot) {
                gameObject.setOrigin(animationFrame.frame.pivotX, animationFrame.frame.pivotY);
              } else {
                gameObject.updateDisplayOrigin();
              }
            }
            if (this.isPlaying && this.hasStarted) {
              this.emitEvents(Events.ANIMATION_UPDATE);
              if (this._pendingStop === 3 && this._pendingStopValue === animationFrame) {
                this.stop();
              }
            }
            return gameObject;
          },
          nextFrame: function() {
            if (this.currentAnim) {
              this.currentAnim.nextFrame(this);
            }
            return this.parent;
          },
          previousFrame: function() {
            if (this.currentAnim) {
              this.currentAnim.previousFrame(this);
            }
            return this.parent;
          },
          get: function(key) {
            return this.anims ? this.anims.get(key) : null;
          },
          exists: function(key) {
            return this.anims ? this.anims.has(key) : false;
          },
          create: function(config) {
            var key = config.key;
            var anim = false;
            if (key) {
              anim = this.get(key);
              if (!anim) {
                anim = new Animation(this, key, config);
                if (!this.anims) {
                  this.anims = new CustomMap();
                }
                this.anims.set(key, anim);
              }
            }
            return anim;
          },
          generateFrameNames: function(key, config) {
            return this.animationManager.generateFrameNames(key, config);
          },
          generateFrameNumbers: function(key, config) {
            return this.animationManager.generateFrameNumbers(key, config);
          },
          remove: function(key) {
            var anim = this.get(key);
            if (anim) {
              if (this.currentAnim === anim) {
                this.stop();
              }
              this.anims.delete(key);
            }
            return anim;
          },
          destroy: function() {
            this.animationManager.off(Events.REMOVE_ANIMATION, this.globalRemove, this);
            if (this.anims) {
              this.anims.clear();
            }
            this.animationManager = null;
            this.parent = null;
            this.nextAnim = null;
            this.nextAnimsQueue.length = 0;
            this.currentAnim = null;
            this.currentFrame = null;
          },
          isPaused: {
            get: function() {
              return this._paused;
            }
          }
        });
        module2.exports = AnimationState;
      },
      function(module2, exports2, __webpack_require__) {
        var Sleeping = {};
        module2.exports = Sleeping;
        var Events = __webpack_require__(166);
        (function() {
          Sleeping._motionWakeThreshold = 0.18;
          Sleeping._motionSleepThreshold = 0.08;
          Sleeping._minBias = 0.9;
          Sleeping.update = function(bodies, timeScale) {
            var timeFactor = timeScale * timeScale * timeScale;
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2], motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;
              if (body.force.x !== 0 || body.force.y !== 0) {
                Sleeping.set(body, false);
                continue;
              }
              var minMotion = Math.min(body.motion, motion), maxMotion = Math.max(body.motion, motion);
              body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;
              if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {
                body.sleepCounter += 1;
                if (body.sleepCounter >= body.sleepThreshold)
                  Sleeping.set(body, true);
              } else if (body.sleepCounter > 0) {
                body.sleepCounter -= 1;
              }
            }
          };
          Sleeping.afterCollisions = function(pairs, timeScale) {
            var timeFactor = timeScale * timeScale * timeScale;
            for (var i2 = 0; i2 < pairs.length; i2++) {
              var pair = pairs[i2];
              if (!pair.isActive)
                continue;
              var collision = pair.collision, bodyA = collision.bodyA.parent, bodyB = collision.bodyB.parent;
              if (bodyA.isSleeping && bodyB.isSleeping || bodyA.isStatic || bodyB.isStatic)
                continue;
              if (bodyA.isSleeping || bodyB.isSleeping) {
                var sleepingBody = bodyA.isSleeping && !bodyA.isStatic ? bodyA : bodyB, movingBody = sleepingBody === bodyA ? bodyB : bodyA;
                if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {
                  Sleeping.set(sleepingBody, false);
                }
              }
            }
          };
          Sleeping.set = function(body, isSleeping) {
            var wasSleeping = body.isSleeping;
            if (isSleeping) {
              body.isSleeping = true;
              body.sleepCounter = body.sleepThreshold;
              body.positionImpulse.x = 0;
              body.positionImpulse.y = 0;
              body.positionPrev.x = body.position.x;
              body.positionPrev.y = body.position.y;
              body.anglePrev = body.angle;
              body.speed = 0;
              body.angularSpeed = 0;
              body.motion = 0;
              if (!wasSleeping) {
                Events.trigger(body, "sleepStart");
              }
            } else {
              body.isSleeping = false;
              body.sleepCounter = 0;
              if (wasSleeping) {
                Events.trigger(body, "sleepEnd");
              }
            }
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        var Events = {};
        module2.exports = Events;
        var Common = __webpack_require__(32);
        (function() {
          Events.on = function(object, eventNames, callback) {
            var names = eventNames.split(" "), name;
            for (var i2 = 0; i2 < names.length; i2++) {
              name = names[i2];
              object.events = object.events || {};
              object.events[name] = object.events[name] || [];
              object.events[name].push(callback);
            }
            return callback;
          };
          Events.off = function(object, eventNames, callback) {
            if (!eventNames) {
              object.events = {};
              return;
            }
            if (typeof eventNames === "function") {
              callback = eventNames;
              eventNames = Common.keys(object.events).join(" ");
            }
            var names = eventNames.split(" ");
            for (var i2 = 0; i2 < names.length; i2++) {
              var callbacks = object.events[names[i2]], newCallbacks = [];
              if (callback && callbacks) {
                for (var j = 0; j < callbacks.length; j++) {
                  if (callbacks[j] !== callback)
                    newCallbacks.push(callbacks[j]);
                }
              }
              object.events[names[i2]] = newCallbacks;
            }
          };
          Events.trigger = function(object, eventNames, event) {
            var names, name, callbacks, eventClone;
            var events = object.events;
            if (events && Common.keys(events).length > 0) {
              if (!event)
                event = {};
              names = eventNames.split(" ");
              for (var i2 = 0; i2 < names.length; i2++) {
                name = names[i2];
                callbacks = events[name];
                if (callbacks) {
                  eventClone = Common.clone(event, false);
                  eventClone.name = name;
                  eventClone.source = object;
                  for (var j = 0; j < callbacks.length; j++) {
                    callbacks[j].apply(object, [eventClone]);
                  }
                }
              }
            }
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DeepCopy = __webpack_require__(175);
        var PIPELINE_CONST = __webpack_require__(92);
        var SpliceOne = __webpack_require__(74);
        var Pipeline = {
          defaultPipeline: null,
          pipeline: null,
          hasPostPipeline: false,
          postPipelines: null,
          pipelineData: null,
          initPipeline: function(pipeline) {
            if (pipeline === void 0) {
              pipeline = PIPELINE_CONST.MULTI_PIPELINE;
            }
            var renderer = this.scene.sys.renderer;
            if (!renderer) {
              return false;
            }
            var pipelines = renderer.pipelines;
            this.postPipelines = [];
            this.pipelineData = {};
            if (pipelines) {
              var instance = pipelines.get(pipeline);
              if (instance) {
                this.defaultPipeline = instance;
                this.pipeline = instance;
                return true;
              }
            }
            return false;
          },
          setPipeline: function(pipeline, pipelineData, copyData) {
            var renderer = this.scene.sys.renderer;
            if (!renderer) {
              return this;
            }
            var pipelines = renderer.pipelines;
            if (pipelines) {
              var instance = pipelines.get(pipeline);
              if (instance) {
                this.pipeline = instance;
              }
              if (pipelineData) {
                this.pipelineData = copyData ? DeepCopy(pipelineData) : pipelineData;
              }
            }
            return this;
          },
          setPostPipeline: function(pipelines, pipelineData, copyData) {
            var renderer = this.scene.sys.renderer;
            if (!renderer) {
              return this;
            }
            var pipelineManager = renderer.pipelines;
            if (pipelineManager) {
              if (!Array.isArray(pipelines)) {
                pipelines = [pipelines];
              }
              for (var i2 = 0; i2 < pipelines.length; i2++) {
                var instance = pipelineManager.getPostPipeline(pipelines[i2], this);
                if (instance) {
                  this.postPipelines.push(instance);
                }
              }
              if (pipelineData) {
                this.pipelineData = copyData ? DeepCopy(pipelineData) : pipelineData;
              }
            }
            this.hasPostPipeline = this.postPipelines.length > 0;
            return this;
          },
          setPipelineData: function(key, value) {
            var data = this.pipelineData;
            if (value === void 0) {
              delete data[key];
            } else {
              data[key] = value;
            }
            return this;
          },
          getPostPipeline: function(pipeline) {
            var pipelines = this.postPipelines;
            var results = [];
            for (var i2 = 0; i2 < pipelines.length; i2++) {
              var instance = pipelines[i2];
              if (typeof pipeline === "string" && instance.name === pipeline || instance instanceof pipeline) {
                results.push(instance);
              }
            }
            return results.length === 1 ? results[0] : results;
          },
          resetPipeline: function(resetPostPipelines, resetData) {
            if (resetPostPipelines === void 0) {
              resetPostPipelines = false;
            }
            if (resetData === void 0) {
              resetData = false;
            }
            this.pipeline = this.defaultPipeline;
            if (resetPostPipelines) {
              this.postPipelines = [];
              this.hasPostPipeline = false;
            }
            if (resetData) {
              this.pipelineData = {};
            }
            return this.pipeline !== null;
          },
          resetPostPipeline: function(resetData) {
            if (resetData === void 0) {
              resetData = false;
            }
            var pipelines = this.postPipelines;
            for (var i2 = 0; i2 < pipelines.length; i2++) {
              pipelines[i2].destroy();
            }
            this.postPipelines = [];
            this.hasPostPipeline = false;
            if (resetData) {
              this.pipelineData = {};
            }
          },
          removePostPipeline: function(pipeline) {
            var pipelines = this.postPipelines;
            for (var i2 = pipelines.length - 1; i2 >= 0; i2--) {
              var instance = pipelines[i2];
              if (typeof pipeline === "string" && instance.name === pipeline || typeof pipeline !== "string" && instance instanceof pipeline) {
                instance.destroy();
                SpliceOne(pipelines, i2);
              }
            }
            this.hasPostPipeline = this.postPipelines.length > 0;
            return this;
          },
          getPipelineName: function() {
            return this.pipeline.name;
          }
        };
        module2.exports = Pipeline;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ScaleModes = {
          DEFAULT: 0,
          LINEAR: 0,
          NEAREST: 1
        };
        module2.exports = ScaleModes;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var CircumferencePoint = function(circle, angle, out) {
          if (out === void 0) {
            out = new Point();
          }
          out.x = circle.x + circle.radius * Math.cos(angle);
          out.y = circle.y + circle.radius * Math.sin(angle);
          return out;
        };
        module2.exports = CircumferencePoint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var Random = function(circle, out) {
          if (out === void 0) {
            out = new Point();
          }
          var t2 = 2 * Math.PI * Math.random();
          var u2 = Math.random() + Math.random();
          var r2 = u2 > 1 ? 2 - u2 : u2;
          var x2 = r2 * Math.cos(t2);
          var y2 = r2 * Math.sin(t2);
          out.x = circle.x + x2 * circle.radius;
          out.y = circle.y + y2 * circle.radius;
          return out;
        };
        module2.exports = Random;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Perimeter = __webpack_require__(130);
        var Point = __webpack_require__(4);
        var GetPoint = function(rectangle, position, out) {
          if (out === void 0) {
            out = new Point();
          }
          if (position <= 0 || position >= 1) {
            out.x = rectangle.x;
            out.y = rectangle.y;
            return out;
          }
          var p2 = Perimeter(rectangle) * position;
          if (position > 0.5) {
            p2 -= rectangle.width + rectangle.height;
            if (p2 <= rectangle.width) {
              out.x = rectangle.right - p2;
              out.y = rectangle.bottom;
            } else {
              out.x = rectangle.x;
              out.y = rectangle.bottom - (p2 - rectangle.width);
            }
          } else if (p2 <= rectangle.width) {
            out.x = rectangle.x + p2;
            out.y = rectangle.y;
          } else {
            out.x = rectangle.right;
            out.y = rectangle.y + (p2 - rectangle.width);
          }
          return out;
        };
        module2.exports = GetPoint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Length = __webpack_require__(67);
        var Point = __webpack_require__(4);
        var GetPoints = function(line, quantity, stepRate, out) {
          if (out === void 0) {
            out = [];
          }
          if (!quantity && stepRate > 0) {
            quantity = Length(line) / stepRate;
          }
          var x1 = line.x1;
          var y1 = line.y1;
          var x2 = line.x2;
          var y2 = line.y2;
          for (var i2 = 0; i2 < quantity; i2++) {
            var position = i2 / quantity;
            var x3 = x1 + (x2 - x1) * position;
            var y3 = y1 + (y2 - y1) * position;
            out.push(new Point(x3, y3));
          }
          return out;
        };
        module2.exports = GetPoints;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var Random = function(line, out) {
          if (out === void 0) {
            out = new Point();
          }
          var t2 = Math.random();
          out.x = line.x1 + t2 * (line.x2 - line.x1);
          out.y = line.y1 + t2 * (line.y2 - line.y1);
          return out;
        };
        module2.exports = Random;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var Random = function(rect, out) {
          if (out === void 0) {
            out = new Point();
          }
          out.x = rect.x + Math.random() * rect.width;
          out.y = rect.y + Math.random() * rect.height;
          return out;
        };
        module2.exports = Random;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DeepCopy = function(inObject) {
          var outObject;
          var value;
          var key;
          if (typeof inObject !== "object" || inObject === null) {
            return inObject;
          }
          outObject = Array.isArray(inObject) ? [] : {};
          for (key in inObject) {
            value = inObject[key];
            outObject[key] = DeepCopy(value);
          }
          return outObject;
        };
        module2.exports = DeepCopy;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ToJSON = function(gameObject) {
          var out = {
            name: gameObject.name,
            type: gameObject.type,
            x: gameObject.x,
            y: gameObject.y,
            depth: gameObject.depth,
            scale: {
              x: gameObject.scaleX,
              y: gameObject.scaleY
            },
            origin: {
              x: gameObject.originX,
              y: gameObject.originY
            },
            flipX: gameObject.flipX,
            flipY: gameObject.flipY,
            rotation: gameObject.rotation,
            alpha: gameObject.alpha,
            visible: gameObject.visible,
            blendMode: gameObject.blendMode,
            textureKey: "",
            frameKey: "",
            data: {}
          };
          if (gameObject.texture) {
            out.textureKey = gameObject.texture.key;
            out.frameKey = gameObject.frame.name;
          }
          return out;
        };
        module2.exports = ToJSON;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector2 = __webpack_require__(3);
        var TransformXY = function(x2, y2, positionX, positionY, rotation, scaleX, scaleY, output) {
          if (output === void 0) {
            output = new Vector2();
          }
          var radianSin = Math.sin(rotation);
          var radianCos = Math.cos(rotation);
          var a = radianCos * scaleX;
          var b2 = radianSin * scaleX;
          var c = -radianSin * scaleY;
          var d = radianCos * scaleY;
          var id2 = 1 / (a * d + c * -b2);
          output.x = d * id2 * x2 + -c * id2 * y2 + (positionY * c - positionX * d) * id2;
          output.y = a * id2 * y2 + -b2 * id2 * x2 + (-positionY * a + positionX * b2) * id2;
          return output;
        };
        module2.exports = TransformXY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateLeft = function(array, total) {
          if (total === void 0) {
            total = 1;
          }
          var element = null;
          for (var i2 = 0; i2 < total; i2++) {
            element = array.shift();
            array.push(element);
          }
          return element;
        };
        module2.exports = RotateLeft;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateRight = function(array, total) {
          if (total === void 0) {
            total = 1;
          }
          var element = null;
          for (var i2 = 0; i2 < total; i2++) {
            element = array.pop();
            array.unshift(element);
          }
          return element;
        };
        module2.exports = RotateRight;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var Random = function(ellipse, out) {
          if (out === void 0) {
            out = new Point();
          }
          var p2 = Math.random() * Math.PI * 2;
          var s = Math.sqrt(Math.random());
          out.x = ellipse.x + s * Math.cos(p2) * ellipse.width / 2;
          out.y = ellipse.y + s * Math.sin(p2) * ellipse.height / 2;
          return out;
        };
        module2.exports = Random;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var Random = function(triangle, out) {
          if (out === void 0) {
            out = new Point();
          }
          var ux = triangle.x2 - triangle.x1;
          var uy = triangle.y2 - triangle.y1;
          var vx = triangle.x3 - triangle.x1;
          var vy = triangle.y3 - triangle.y1;
          var r2 = Math.random();
          var s = Math.random();
          if (r2 + s >= 1) {
            r2 = 1 - r2;
            s = 1 - s;
          }
          out.x = triangle.x1 + (ux * r2 + vx * s);
          out.y = triangle.y1 + (uy * r2 + vy * s);
          return out;
        };
        module2.exports = Random;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateAroundDistance = function(point, x2, y2, angle, distance) {
          var t2 = angle + Math.atan2(point.y - y2, point.x - x2);
          point.x = x2 + distance * Math.cos(t2);
          point.y = y2 + distance * Math.sin(t2);
          return point;
        };
        module2.exports = RotateAroundDistance;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SmootherStep = function(x2, min, max) {
          x2 = Math.max(0, Math.min(1, (x2 - min) / (max - min)));
          return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
        };
        module2.exports = SmootherStep;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SmoothStep = function(x2, min, max) {
          if (x2 <= min) {
            return 0;
          }
          if (x2 >= max) {
            return 1;
          }
          x2 = (x2 - min) / (max - min);
          return x2 * x2 * (3 - 2 * x2);
        };
        module2.exports = SmoothStep;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clamp = __webpack_require__(18);
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(132);
        var FindClosestInSorted = __webpack_require__(318);
        var Frame = __webpack_require__(319);
        var GetValue = __webpack_require__(6);
        var SortByDigits = __webpack_require__(320);
        var Animation = new Class({
          initialize: function Animation2(manager, key, config) {
            this.manager = manager;
            this.key = key;
            this.type = "frame";
            this.frames = this.getFrames(manager.textureManager, GetValue(config, "frames", []), GetValue(config, "defaultTextureKey", null), GetValue(config, "sortFrames", true));
            this.frameRate = GetValue(config, "frameRate", null);
            this.duration = GetValue(config, "duration", null);
            this.msPerFrame;
            this.skipMissedFrames = GetValue(config, "skipMissedFrames", true);
            this.delay = GetValue(config, "delay", 0);
            this.repeat = GetValue(config, "repeat", 0);
            this.repeatDelay = GetValue(config, "repeatDelay", 0);
            this.yoyo = GetValue(config, "yoyo", false);
            this.showOnStart = GetValue(config, "showOnStart", false);
            this.hideOnComplete = GetValue(config, "hideOnComplete", false);
            this.paused = false;
            this.calculateDuration(this, this.getTotalFrames(), this.duration, this.frameRate);
            if (this.manager.on) {
              this.manager.on(Events.PAUSE_ALL, this.pause, this);
              this.manager.on(Events.RESUME_ALL, this.resume, this);
            }
          },
          getTotalFrames: function() {
            return this.frames.length;
          },
          calculateDuration: function(target, totalFrames, duration, frameRate) {
            if (duration === null && frameRate === null) {
              target.frameRate = 24;
              target.duration = 24 / totalFrames * 1e3;
            } else if (duration && frameRate === null) {
              target.duration = duration;
              target.frameRate = totalFrames / (duration / 1e3);
            } else {
              target.frameRate = frameRate;
              target.duration = totalFrames / frameRate * 1e3;
            }
            target.msPerFrame = 1e3 / target.frameRate;
          },
          addFrame: function(config) {
            return this.addFrameAt(this.frames.length, config);
          },
          addFrameAt: function(index2, config) {
            var newFrames = this.getFrames(this.manager.textureManager, config);
            if (newFrames.length > 0) {
              if (index2 === 0) {
                this.frames = newFrames.concat(this.frames);
              } else if (index2 === this.frames.length) {
                this.frames = this.frames.concat(newFrames);
              } else {
                var pre = this.frames.slice(0, index2);
                var post = this.frames.slice(index2);
                this.frames = pre.concat(newFrames, post);
              }
              this.updateFrameSequence();
            }
            return this;
          },
          checkFrame: function(index2) {
            return index2 >= 0 && index2 < this.frames.length;
          },
          getFirstTick: function(state) {
            state.accumulator = 0;
            state.nextTick = state.msPerFrame + state.currentFrame.duration;
          },
          getFrameAt: function(index2) {
            return this.frames[index2];
          },
          getFrames: function(textureManager, frames, defaultTextureKey, sortFrames) {
            if (sortFrames === void 0) {
              sortFrames = true;
            }
            var out = [];
            var prev;
            var animationFrame;
            var index2 = 1;
            var i2;
            var textureKey;
            if (typeof frames === "string") {
              textureKey = frames;
              var texture = textureManager.get(textureKey);
              var frameKeys = texture.getFrameNames();
              if (sortFrames) {
                SortByDigits(frameKeys);
              }
              frames = [];
              frameKeys.forEach(function(value) {
                frames.push({ key: textureKey, frame: value });
              });
            }
            if (!Array.isArray(frames) || frames.length === 0) {
              return out;
            }
            for (i2 = 0; i2 < frames.length; i2++) {
              var item = frames[i2];
              var key = GetValue(item, "key", defaultTextureKey);
              if (!key) {
                continue;
              }
              var frame = GetValue(item, "frame", 0);
              var textureFrame = textureManager.getFrame(key, frame);
              animationFrame = new Frame(key, frame, index2, textureFrame);
              animationFrame.duration = GetValue(item, "duration", 0);
              animationFrame.isFirst = !prev;
              if (prev) {
                prev.nextFrame = animationFrame;
                animationFrame.prevFrame = prev;
              }
              out.push(animationFrame);
              prev = animationFrame;
              index2++;
            }
            if (out.length > 0) {
              animationFrame.isLast = true;
              animationFrame.nextFrame = out[0];
              out[0].prevFrame = animationFrame;
              var slice = 1 / (out.length - 1);
              for (i2 = 0; i2 < out.length; i2++) {
                out[i2].progress = i2 * slice;
              }
            }
            return out;
          },
          getNextTick: function(state) {
            state.accumulator -= state.nextTick;
            state.nextTick = state.msPerFrame + state.currentFrame.duration;
          },
          getFrameByProgress: function(value) {
            value = Clamp(value, 0, 1);
            return FindClosestInSorted(value, this.frames, "progress");
          },
          nextFrame: function(state) {
            var frame = state.currentFrame;
            if (frame.isLast) {
              if (state.yoyo) {
                this.handleYoyoFrame(state, false);
              } else if (state.repeatCounter > 0) {
                if (state.inReverse && state.forward) {
                  state.forward = false;
                } else {
                  this.repeatAnimation(state);
                }
              } else {
                state.complete();
              }
            } else {
              this.updateAndGetNextTick(state, frame.nextFrame);
            }
          },
          handleYoyoFrame: function(state, isReverse) {
            if (!isReverse) {
              isReverse = false;
            }
            if (state.inReverse === !isReverse && state.repeatCounter > 0) {
              if (state.repeatDelay === 0 || state.pendingRepeat) {
                state.forward = isReverse;
              }
              this.repeatAnimation(state);
              return;
            }
            if (state.inReverse !== isReverse && state.repeatCounter === 0) {
              state.complete();
              return;
            }
            state.forward = isReverse;
            var frame = isReverse ? state.currentFrame.nextFrame : state.currentFrame.prevFrame;
            this.updateAndGetNextTick(state, frame);
          },
          getLastFrame: function() {
            return this.frames[this.frames.length - 1];
          },
          previousFrame: function(state) {
            var frame = state.currentFrame;
            if (frame.isFirst) {
              if (state.yoyo) {
                this.handleYoyoFrame(state, true);
              } else if (state.repeatCounter > 0) {
                if (state.inReverse && !state.forward) {
                  this.repeatAnimation(state);
                } else {
                  state.forward = true;
                  this.repeatAnimation(state);
                }
              } else {
                state.complete();
              }
            } else {
              this.updateAndGetNextTick(state, frame.prevFrame);
            }
          },
          updateAndGetNextTick: function(state, frame) {
            state.setCurrentFrame(frame);
            this.getNextTick(state);
          },
          removeFrame: function(frame) {
            var index2 = this.frames.indexOf(frame);
            if (index2 !== -1) {
              this.removeFrameAt(index2);
            }
            return this;
          },
          removeFrameAt: function(index2) {
            this.frames.splice(index2, 1);
            this.updateFrameSequence();
            return this;
          },
          repeatAnimation: function(state) {
            if (state._pendingStop === 2) {
              if (state._pendingStopValue === 0) {
                return state.stop();
              } else {
                state._pendingStopValue--;
              }
            }
            if (state.repeatDelay > 0 && !state.pendingRepeat) {
              state.pendingRepeat = true;
              state.accumulator -= state.nextTick;
              state.nextTick += state.repeatDelay;
            } else {
              state.repeatCounter--;
              if (state.forward) {
                state.setCurrentFrame(state.currentFrame.nextFrame);
              } else {
                state.setCurrentFrame(state.currentFrame.prevFrame);
              }
              if (state.isPlaying) {
                this.getNextTick(state);
                state.handleRepeat();
              }
            }
          },
          toJSON: function() {
            var output = {
              key: this.key,
              type: this.type,
              frames: [],
              frameRate: this.frameRate,
              duration: this.duration,
              skipMissedFrames: this.skipMissedFrames,
              delay: this.delay,
              repeat: this.repeat,
              repeatDelay: this.repeatDelay,
              yoyo: this.yoyo,
              showOnStart: this.showOnStart,
              hideOnComplete: this.hideOnComplete
            };
            this.frames.forEach(function(frame) {
              output.frames.push(frame.toJSON());
            });
            return output;
          },
          updateFrameSequence: function() {
            var len = this.frames.length;
            var slice = 1 / (len - 1);
            var frame;
            for (var i2 = 0; i2 < len; i2++) {
              frame = this.frames[i2];
              frame.index = i2 + 1;
              frame.isFirst = false;
              frame.isLast = false;
              frame.progress = i2 * slice;
              if (i2 === 0) {
                frame.isFirst = true;
                if (len === 1) {
                  frame.isLast = true;
                  frame.nextFrame = frame;
                  frame.prevFrame = frame;
                } else {
                  frame.isLast = false;
                  frame.prevFrame = this.frames[len - 1];
                  frame.nextFrame = this.frames[i2 + 1];
                }
              } else if (i2 === len - 1 && len > 1) {
                frame.isLast = true;
                frame.prevFrame = this.frames[len - 2];
                frame.nextFrame = this.frames[0];
              } else if (len > 1) {
                frame.prevFrame = this.frames[i2 - 1];
                frame.nextFrame = this.frames[i2 + 1];
              }
            }
            return this;
          },
          pause: function() {
            this.paused = true;
            return this;
          },
          resume: function() {
            this.paused = false;
            return this;
          },
          destroy: function() {
            if (this.manager.off) {
              this.manager.off(Events.PAUSE_ALL, this.pause, this);
              this.manager.off(Events.RESUME_ALL, this.resume, this);
            }
            this.manager.remove(this.key);
            for (var i2 = 0; i2 < this.frames.length; i2++) {
              this.frames[i2].destroy();
            }
            this.frames = [];
            this.manager = null;
          }
        });
        module2.exports = Animation;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Pad = function(str, len, pad, dir) {
          if (len === void 0) {
            len = 0;
          }
          if (pad === void 0) {
            pad = " ";
          }
          if (dir === void 0) {
            dir = 3;
          }
          str = str.toString();
          var padlen = 0;
          if (len + 1 >= str.length) {
            switch (dir) {
              case 1:
                str = new Array(len + 1 - str.length).join(pad) + str;
                break;
              case 3:
                var right = Math.ceil((padlen = len - str.length) / 2);
                var left = padlen - right;
                str = new Array(left + 1).join(pad) + str + new Array(right + 1).join(pad);
                break;
              default:
                str = str + new Array(len + 1 - str.length).join(pad);
                break;
            }
          }
          return str;
        };
        module2.exports = Pad;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var HexStringToColor = __webpack_require__(327);
        var IntegerToColor = __webpack_require__(189);
        var ObjectToColor = __webpack_require__(331);
        var RGBStringToColor = __webpack_require__(332);
        var ValueToColor = function(input) {
          var t2 = typeof input;
          switch (t2) {
            case "string":
              if (input.substr(0, 3).toLowerCase() === "rgb") {
                return RGBStringToColor(input);
              } else {
                return HexStringToColor(input);
              }
            case "number":
              return IntegerToColor(input);
            case "object":
              return ObjectToColor(input);
          }
        };
        module2.exports = ValueToColor;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetColor = __webpack_require__(103);
        function ConvertValue(n2, h2, s, v2) {
          var k2 = (n2 + h2 * 6) % 6;
          var min = Math.min(k2, 4 - k2, 1);
          return Math.round(255 * (v2 - v2 * s * Math.max(0, min)));
        }
        var HSVToRGB = function(h2, s, v2, out) {
          if (s === void 0) {
            s = 1;
          }
          if (v2 === void 0) {
            v2 = 1;
          }
          var r2 = ConvertValue(5, h2, s, v2);
          var g2 = ConvertValue(3, h2, s, v2);
          var b2 = ConvertValue(1, h2, s, v2);
          if (!out) {
            return { r: r2, g: g2, b: b2, color: GetColor(r2, g2, b2) };
          } else if (out.setTo) {
            return out.setTo(r2, g2, b2, out.alpha, false);
          } else {
            out.r = r2;
            out.g = g2;
            out.b = b2;
            out.color = GetColor(r2, g2, b2);
            return out;
          }
        };
        module2.exports = HSVToRGB;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Color = __webpack_require__(38);
        var IntegerToRGB = __webpack_require__(330);
        var IntegerToColor = function(input) {
          var rgb = IntegerToRGB(input);
          return new Color(rgb.r, rgb.g, rgb.b, rgb.a);
        };
        module2.exports = IntegerToColor;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CenterOn = function(rect, x2, y2) {
          rect.x = x2 - rect.width / 2;
          rect.y = y2 - rect.height / 2;
          return rect;
        };
        module2.exports = CenterOn;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var OS = __webpack_require__(105);
        var Browser = __webpack_require__(136);
        var CanvasPool = __webpack_require__(31);
        var Features = {
          canvas: false,
          canvasBitBltShift: null,
          file: false,
          fileSystem: false,
          getUserMedia: true,
          littleEndian: false,
          localStorage: false,
          pointerLock: false,
          support32bit: false,
          vibration: false,
          webGL: false,
          worker: false
        };
        function checkIsLittleEndian() {
          var a = new ArrayBuffer(4);
          var b2 = new Uint8Array(a);
          var c = new Uint32Array(a);
          b2[0] = 161;
          b2[1] = 178;
          b2[2] = 195;
          b2[3] = 212;
          if (c[0] === 3569595041) {
            return true;
          }
          if (c[0] === 2712847316) {
            return false;
          } else {
            return null;
          }
        }
        function init() {
          if (typeof importScripts === "function") {
            return Features;
          }
          Features.canvas = !!window["CanvasRenderingContext2D"];
          try {
            Features.localStorage = !!localStorage.getItem;
          } catch (error) {
            Features.localStorage = false;
          }
          Features.file = !!window["File"] && !!window["FileReader"] && !!window["FileList"] && !!window["Blob"];
          Features.fileSystem = !!window["requestFileSystem"];
          var isUint8 = false;
          var testWebGL = function() {
            if (window["WebGLRenderingContext"]) {
              try {
                var canvas = CanvasPool.createWebGL(this);
                var ctx = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
                var canvas2D = CanvasPool.create2D(this);
                var ctx2D = canvas2D.getContext("2d");
                var image = ctx2D.createImageData(1, 1);
                isUint8 = image.data instanceof Uint8ClampedArray;
                CanvasPool.remove(canvas);
                CanvasPool.remove(canvas2D);
                return !!ctx;
              } catch (e) {
                return false;
              }
            }
            return false;
          };
          Features.webGL = testWebGL();
          Features.worker = !!window["Worker"];
          Features.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
          navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;
          window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
          Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL;
          if (Browser.firefox && Browser.firefoxVersion < 21) {
            Features.getUserMedia = false;
          }
          if (!OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome)) {
            Features.canvasBitBltShift = true;
          }
          if (Browser.safari || Browser.mobileSafari) {
            Features.canvasBitBltShift = false;
          }
          navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
          if (navigator.vibrate) {
            Features.vibration = true;
          }
          if (typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint32Array !== "undefined") {
            Features.littleEndian = checkIsLittleEndian();
          }
          Features.support32bit = typeof ArrayBuffer !== "undefined" && typeof Uint8ClampedArray !== "undefined" && typeof Int32Array !== "undefined" && Features.littleEndian !== null && isUint8;
          return Features;
        }
        module2.exports = init();
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var prefix = "";
        var Smoothing = function() {
          var getPrefix = function(context) {
            var vendors = ["i", "webkitI", "msI", "mozI", "oI"];
            for (var i2 = 0; i2 < vendors.length; i2++) {
              var s = vendors[i2] + "mageSmoothingEnabled";
              if (s in context) {
                return s;
              }
            }
            return null;
          };
          var enable = function(context) {
            if (prefix === "") {
              prefix = getPrefix(context);
            }
            if (prefix) {
              context[prefix] = true;
            }
            return context;
          };
          var disable = function(context) {
            if (prefix === "") {
              prefix = getPrefix(context);
            }
            if (prefix) {
              context[prefix] = false;
            }
            return context;
          };
          var isEnabled = function(context) {
            return prefix !== null ? context[prefix] : null;
          };
          return {
            disable,
            enable,
            getPrefix,
            isEnabled
          };
        };
        module2.exports = Smoothing();
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(14);
        var Extend = __webpack_require__(17);
        var PhaserMath = {
          Angle: __webpack_require__(812),
          Distance: __webpack_require__(821),
          Easing: __webpack_require__(826),
          Fuzzy: __webpack_require__(827),
          Interpolation: __webpack_require__(830),
          Pow2: __webpack_require__(835),
          Snap: __webpack_require__(837),
          RandomDataGenerator: __webpack_require__(839),
          Average: __webpack_require__(840),
          Bernstein: __webpack_require__(356),
          Between: __webpack_require__(195),
          CatmullRom: __webpack_require__(194),
          CeilTo: __webpack_require__(841),
          Clamp: __webpack_require__(18),
          DegToRad: __webpack_require__(36),
          Difference: __webpack_require__(842),
          Euler: __webpack_require__(843),
          Factorial: __webpack_require__(357),
          FloatBetween: __webpack_require__(137),
          FloorTo: __webpack_require__(844),
          FromPercent: __webpack_require__(98),
          GetSpeed: __webpack_require__(845),
          IsEven: __webpack_require__(846),
          IsEvenStrict: __webpack_require__(847),
          Linear: __webpack_require__(135),
          MaxAdd: __webpack_require__(848),
          Median: __webpack_require__(849),
          MinSub: __webpack_require__(850),
          Percent: __webpack_require__(851),
          RadToDeg: __webpack_require__(196),
          RandomXY: __webpack_require__(852),
          RandomXYZ: __webpack_require__(853),
          RandomXYZW: __webpack_require__(854),
          Rotate: __webpack_require__(362),
          RotateAround: __webpack_require__(308),
          RotateAroundDistance: __webpack_require__(182),
          RotateTo: __webpack_require__(855),
          RoundAwayFromZero: __webpack_require__(363),
          RoundTo: __webpack_require__(856),
          SinCosTableGenerator: __webpack_require__(857),
          SmootherStep: __webpack_require__(183),
          SmoothStep: __webpack_require__(184),
          ToXY: __webpack_require__(858),
          TransformXY: __webpack_require__(177),
          Within: __webpack_require__(859),
          Wrap: __webpack_require__(68),
          Vector2: __webpack_require__(3),
          Vector3: __webpack_require__(39),
          Vector4: __webpack_require__(140),
          Matrix3: __webpack_require__(364),
          Matrix4: __webpack_require__(69),
          Quaternion: __webpack_require__(365),
          RotateVec3: __webpack_require__(860)
        };
        PhaserMath = Extend(false, PhaserMath, CONST);
        module2.exports = PhaserMath;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CatmullRom = function(t2, p0, p1, p2, p3) {
          var v0 = (p2 - p0) * 0.5;
          var v1 = (p3 - p1) * 0.5;
          var t22 = t2 * t2;
          var t3 = t2 * t22;
          return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
        };
        module2.exports = CatmullRom;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Between = function(min, max) {
          return Math.floor(Math.random() * (max - min + 1) + min);
        };
        module2.exports = Between;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(14);
        var RadToDeg = function(radians) {
          return radians * CONST.RAD_TO_DEG;
        };
        module2.exports = RadToDeg;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DefaultPlugins = {
          Global: [
            "game",
            "anims",
            "cache",
            "plugins",
            "registry",
            "scale",
            "sound",
            "textures",
            "renderer"
          ],
          CoreScene: [
            "EventEmitter",
            "CameraManager",
            "GameObjectCreator",
            "GameObjectFactory",
            "ScenePlugin",
            "DisplayList",
            "UpdateList"
          ],
          DefaultScene: [
            "Clock",
            "DataManagerPlugin",
            "InputPlugin",
            "Loader",
            "TweenManager",
            "LightsPlugin"
          ]
        };
        module2.exports = DefaultPlugins;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var ColorMatrix = new Class({
          initialize: function ColorMatrix2() {
            this._matrix = [
              1,
              0,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              1,
              0
            ];
            this.alpha = 1;
            this._dirty = true;
            this._data;
          },
          set: function(value) {
            this._matrix = value;
            this._dirty = true;
            return this;
          },
          reset: function() {
            var m2 = this._matrix;
            m2[0] = 1;
            m2[1] = 0;
            m2[2] = 0;
            m2[3] = 0;
            m2[4] = 0;
            m2[5] = 0;
            m2[6] = 1;
            m2[7] = 0;
            m2[8] = 0;
            m2[9] = 0;
            m2[10] = 0;
            m2[11] = 0;
            m2[12] = 1;
            m2[13] = 0;
            m2[14] = 0;
            m2[15] = 0;
            m2[16] = 0;
            m2[17] = 0;
            m2[18] = 1;
            m2[19] = 0;
            this._dirty = true;
            return this;
          },
          getData: function() {
            if (this._dirty) {
              var f32 = new Float32Array(this._matrix);
              f32[4] /= 255;
              f32[9] /= 255;
              f32[14] /= 255;
              f32[19] /= 255;
              this._data = f32;
              this._dirty = false;
            }
            return this._data;
          },
          brightness: function(value, multiply) {
            if (value === void 0) {
              value = 0;
            }
            if (multiply === void 0) {
              multiply = false;
            }
            var b2 = value;
            return this.multiply([
              b2,
              0,
              0,
              0,
              0,
              0,
              b2,
              0,
              0,
              0,
              0,
              0,
              b2,
              0,
              0,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          saturate: function(value, multiply) {
            if (value === void 0) {
              value = 0;
            }
            if (multiply === void 0) {
              multiply = false;
            }
            var x2 = value * 2 / 3 + 1;
            var y2 = (x2 - 1) * -0.5;
            return this.multiply([
              x2,
              y2,
              y2,
              0,
              0,
              y2,
              x2,
              y2,
              0,
              0,
              y2,
              y2,
              x2,
              0,
              0,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          desaturate: function(multiply) {
            if (multiply === void 0) {
              multiply = false;
            }
            return this.saturate(-1, multiply);
          },
          hue: function(rotation, multiply) {
            if (rotation === void 0) {
              rotation = 0;
            }
            if (multiply === void 0) {
              multiply = false;
            }
            rotation = rotation / 180 * Math.PI;
            var cos = Math.cos(rotation);
            var sin = Math.sin(rotation);
            var lumR = 0.213;
            var lumG = 0.715;
            var lumB = 0.072;
            return this.multiply([
              lumR + cos * (1 - lumR) + sin * -lumR,
              lumG + cos * -lumG + sin * -lumG,
              lumB + cos * -lumB + sin * (1 - lumB),
              0,
              0,
              lumR + cos * -lumR + sin * 0.143,
              lumG + cos * (1 - lumG) + sin * 0.14,
              lumB + cos * -lumB + sin * -0.283,
              0,
              0,
              lumR + cos * -lumR + sin * -(1 - lumR),
              lumG + cos * -lumG + sin * lumG,
              lumB + cos * (1 - lumB) + sin * lumB,
              0,
              0,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          grayscale: function(value, multiply) {
            if (value === void 0) {
              value = 1;
            }
            if (multiply === void 0) {
              multiply = false;
            }
            return this.saturate(-value, multiply);
          },
          blackWhite: function(multiply) {
            if (multiply === void 0) {
              multiply = false;
            }
            return this.multiply([
              0.3,
              0.6,
              0.1,
              0,
              0,
              0.3,
              0.6,
              0.1,
              0,
              0,
              0.3,
              0.6,
              0.1,
              0,
              0,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          contrast: function(value, multiply) {
            if (value === void 0) {
              value = 0;
            }
            if (multiply === void 0) {
              multiply = false;
            }
            var v2 = value + 1;
            var o = -0.5 * (v2 - 1);
            return this.multiply([
              v2,
              0,
              0,
              0,
              o,
              0,
              v2,
              0,
              0,
              o,
              0,
              0,
              v2,
              0,
              o,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          negative: function(multiply) {
            if (multiply === void 0) {
              multiply = false;
            }
            return this.multiply([
              -1,
              0,
              0,
              1,
              0,
              0,
              -1,
              0,
              1,
              0,
              0,
              0,
              -1,
              1,
              0,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          desaturateLuminance: function(multiply) {
            if (multiply === void 0) {
              multiply = false;
            }
            return this.multiply([
              0.2764723,
              0.929708,
              0.0938197,
              0,
              -37.1,
              0.2764723,
              0.929708,
              0.0938197,
              0,
              -37.1,
              0.2764723,
              0.929708,
              0.0938197,
              0,
              -37.1,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          sepia: function(multiply) {
            if (multiply === void 0) {
              multiply = false;
            }
            return this.multiply([
              0.393,
              0.7689999,
              0.18899999,
              0,
              0,
              0.349,
              0.6859999,
              0.16799999,
              0,
              0,
              0.272,
              0.5339999,
              0.13099999,
              0,
              0,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          night: function(intensity, multiply) {
            if (intensity === void 0) {
              intensity = 0.1;
            }
            if (multiply === void 0) {
              multiply = false;
            }
            return this.multiply([
              intensity * -2,
              -intensity,
              0,
              0,
              0,
              -intensity,
              0,
              intensity,
              0,
              0,
              0,
              intensity,
              intensity * 2,
              0,
              0,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          lsd: function(multiply) {
            if (multiply === void 0) {
              multiply = false;
            }
            return this.multiply([
              2,
              -0.4,
              0.5,
              0,
              0,
              -0.5,
              2,
              -0.4,
              0,
              0,
              -0.4,
              -0.5,
              3,
              0,
              0,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          brown: function(multiply) {
            if (multiply === void 0) {
              multiply = false;
            }
            return this.multiply([
              0.5997023498159715,
              0.34553243048391263,
              -0.2708298674538042,
              0,
              47.43192855600873,
              -0.037703249837783157,
              0.8609577587992641,
              0.15059552388459913,
              0,
              -36.96841498319127,
              0.24113635128153335,
              -0.07441037908422492,
              0.44972182064877153,
              0,
              -7.562075277591283,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          vintagePinhole: function(multiply) {
            if (multiply === void 0) {
              multiply = false;
            }
            return this.multiply([
              0.6279345635605994,
              0.3202183420819367,
              -0.03965408211312453,
              0,
              9.651285835294123,
              0.02578397704808868,
              0.6441188644374771,
              0.03259127616149294,
              0,
              7.462829176470591,
              0.0466055556782719,
              -0.0851232987247891,
              0.5241648018700465,
              0,
              5.159190588235296,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          kodachrome: function(multiply) {
            if (multiply === void 0) {
              multiply = false;
            }
            return this.multiply([
              1.1285582396593525,
              -0.3967382283601348,
              -0.03992559172921793,
              0,
              63.72958762196502,
              -0.16404339962244616,
              1.0835251566291304,
              -0.05498805115633132,
              0,
              24.732407896706203,
              -0.16786010706155763,
              -0.5603416277695248,
              1.6014850761964943,
              0,
              35.62982807460946,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          technicolor: function(multiply) {
            if (multiply === void 0) {
              multiply = false;
            }
            return this.multiply([
              1.9125277891456083,
              -0.8545344976951645,
              -0.09155508482755585,
              0,
              11.793603434377337,
              -0.3087833385928097,
              1.7658908555458428,
              -0.10601743074722245,
              0,
              -70.35205161461398,
              -0.231103377548616,
              -0.7501899197440212,
              1.847597816108189,
              0,
              30.950940869491138,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          polaroid: function(multiply) {
            if (multiply === void 0) {
              multiply = false;
            }
            return this.multiply([
              1.438,
              -0.062,
              -0.062,
              0,
              0,
              -0.122,
              1.378,
              -0.122,
              0,
              0,
              -0.016,
              -0.016,
              1.483,
              0,
              0,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          shiftToBGR: function(multiply) {
            if (multiply === void 0) {
              multiply = false;
            }
            return this.multiply([
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              1,
              0
            ], multiply);
          },
          multiply: function(a, multiply) {
            if (!multiply) {
              this.reset();
            }
            var m2 = this._matrix;
            var c = [];
            for (var i2 = 0; i2 < 20; i2++) {
              c[i2] = m2[i2];
            }
            m2[0] = c[0] * a[0] + c[1] * a[5] + c[2] * a[10] + c[3] * a[15];
            m2[1] = c[0] * a[1] + c[1] * a[6] + c[2] * a[11] + c[3] * a[16];
            m2[2] = c[0] * a[2] + c[1] * a[7] + c[2] * a[12] + c[3] * a[17];
            m2[3] = c[0] * a[3] + c[1] * a[8] + c[2] * a[13] + c[3] * a[18];
            m2[4] = c[0] * a[4] + c[1] * a[9] + c[2] * a[14] + c[3] * a[19] + c[4];
            m2[5] = c[5] * a[0] + c[6] * a[5] + c[7] * a[10] + c[8] * a[15];
            m2[6] = c[5] * a[1] + c[6] * a[6] + c[7] * a[11] + c[8] * a[16];
            m2[7] = c[5] * a[2] + c[6] * a[7] + c[7] * a[12] + c[8] * a[17];
            m2[8] = c[5] * a[3] + c[6] * a[8] + c[7] * a[13] + c[8] * a[18];
            m2[9] = c[5] * a[4] + c[6] * a[9] + c[7] * a[14] + c[8] * a[19] + c[9];
            m2[10] = c[10] * a[0] + c[11] * a[5] + c[12] * a[10] + c[13] * a[15];
            m2[11] = c[10] * a[1] + c[11] * a[6] + c[12] * a[11] + c[13] * a[16];
            m2[12] = c[10] * a[2] + c[11] * a[7] + c[12] * a[12] + c[13] * a[17];
            m2[13] = c[10] * a[3] + c[11] * a[8] + c[12] * a[13] + c[13] * a[18];
            m2[14] = c[10] * a[4] + c[11] * a[9] + c[12] * a[14] + c[13] * a[19] + c[14];
            m2[15] = c[15] * a[0] + c[16] * a[5] + c[17] * a[10] + c[18] * a[15];
            m2[16] = c[15] * a[1] + c[16] * a[6] + c[17] * a[11] + c[18] * a[16];
            m2[17] = c[15] * a[2] + c[16] * a[7] + c[17] * a[12] + c[18] * a[17];
            m2[18] = c[15] * a[3] + c[16] * a[8] + c[17] * a[13] + c[18] * a[18];
            m2[19] = c[15] * a[4] + c[16] * a[9] + c[17] * a[14] + c[18] * a[19] + c[19];
            this._dirty = true;
            return this;
          }
        });
        module2.exports = ColorMatrix;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rectangle = __webpack_require__(10);
        var MATH_CONST = __webpack_require__(14);
        var FromPoints = function(points, out) {
          if (out === void 0) {
            out = new Rectangle();
          }
          if (points.length === 0) {
            return out;
          }
          var minX = Number.MAX_VALUE;
          var minY = Number.MAX_VALUE;
          var maxX = MATH_CONST.MIN_SAFE_INTEGER;
          var maxY = MATH_CONST.MIN_SAFE_INTEGER;
          var p2;
          var px;
          var py;
          for (var i2 = 0; i2 < points.length; i2++) {
            p2 = points[i2];
            if (Array.isArray(p2)) {
              px = p2[0];
              py = p2[1];
            } else {
              px = p2.x;
              py = p2.y;
            }
            minX = Math.min(minX, px);
            minY = Math.min(minY, py);
            maxX = Math.max(maxX, px);
            maxY = Math.max(maxY, py);
          }
          out.x = minX;
          out.y = minY;
          out.width = maxX - minX;
          out.height = maxY - minY;
          return out;
        };
        module2.exports = FromPoints;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var NOOP = __webpack_require__(1);
        var RGB = new Class({
          initialize: function RGB2(red, green, blue) {
            this._rgb = [0, 0, 0];
            this.onChangeCallback = NOOP;
            this.dirty = false;
            this.set(red, green, blue);
          },
          set: function(red, green, blue) {
            if (red === void 0) {
              red = 0;
            }
            if (green === void 0) {
              green = 0;
            }
            if (blue === void 0) {
              blue = 0;
            }
            this._rgb = [red, green, blue];
            this.onChange();
            return this;
          },
          equals: function(red, green, blue) {
            var rgb = this._rgb;
            return rgb.r === red && rgb.g === green && rgb.b === blue;
          },
          onChange: function() {
            this.dirty = true;
            var rgb = this._rgb;
            this.onChangeCallback.call(this, rgb[0], rgb[1], rgb[2]);
          },
          r: {
            get: function() {
              return this._rgb[0];
            },
            set: function(value) {
              this._rgb[0] = value;
              this.onChange();
            }
          },
          g: {
            get: function() {
              return this._rgb[1];
            },
            set: function(value) {
              this._rgb[1] = value;
              this.onChange();
            }
          },
          b: {
            get: function() {
              return this._rgb[2];
            },
            set: function(value) {
              this._rgb[2] = value;
              this.onChange();
            }
          },
          destroy: function() {
            this.onChangeCallback = null;
          }
        });
        module2.exports = RGB;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = {
          CENTER: __webpack_require__(403),
          ORIENTATION: __webpack_require__(404),
          SCALE_MODE: __webpack_require__(405),
          ZOOM: __webpack_require__(406)
        };
        module2.exports = CONST;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RemoveFromDOM = function(element) {
          if (element.parentNode) {
            element.parentNode.removeChild(element);
          }
        };
        module2.exports = RemoveFromDOM;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var INPUT_CONST = {
          MOUSE_DOWN: 0,
          MOUSE_MOVE: 1,
          MOUSE_UP: 2,
          TOUCH_START: 3,
          TOUCH_MOVE: 4,
          TOUCH_END: 5,
          POINTER_LOCK_CHANGE: 6,
          TOUCH_CANCEL: 7,
          MOUSE_WHEEL: 8
        };
        module2.exports = INPUT_CONST;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(144);
        var DefaultPlugins = __webpack_require__(197);
        var Events = __webpack_require__(20);
        var GetPhysicsPlugins = __webpack_require__(419);
        var GetScenePlugins = __webpack_require__(420);
        var GLOBAL_CONST = __webpack_require__(33);
        var NOOP = __webpack_require__(1);
        var Settings = __webpack_require__(421);
        var Systems = new Class({
          initialize: function Systems2(scene, config) {
            this.scene = scene;
            this.game;
            this.renderer;
            this.config = config;
            this.settings = Settings.create(config);
            this.canvas;
            this.context;
            this.anims;
            this.cache;
            this.plugins;
            this.registry;
            this.scale;
            this.sound;
            this.textures;
            this.add;
            this.cameras;
            this.displayList;
            this.events;
            this.make;
            this.scenePlugin;
            this.updateList;
            this.sceneUpdate = NOOP;
          },
          init: function(game) {
            this.settings.status = CONST.INIT;
            this.sceneUpdate = NOOP;
            this.game = game;
            this.renderer = game.renderer;
            this.canvas = game.canvas;
            this.context = game.context;
            var pluginManager = game.plugins;
            this.plugins = pluginManager;
            pluginManager.addToScene(this, DefaultPlugins.Global, [DefaultPlugins.CoreScene, GetScenePlugins(this), GetPhysicsPlugins(this)]);
            this.events.emit(Events.BOOT, this);
            this.settings.isBooted = true;
          },
          step: function(time, delta) {
            var events = this.events;
            events.emit(Events.PRE_UPDATE, time, delta);
            events.emit(Events.UPDATE, time, delta);
            this.sceneUpdate.call(this.scene, time, delta);
            events.emit(Events.POST_UPDATE, time, delta);
          },
          render: function(renderer) {
            var displayList = this.displayList;
            displayList.depthSort();
            this.events.emit(Events.PRE_RENDER, renderer);
            this.cameras.render(renderer, displayList);
            this.events.emit(Events.RENDER, renderer);
          },
          queueDepthSort: function() {
            this.displayList.queueDepthSort();
          },
          depthSort: function() {
            this.displayList.depthSort();
          },
          pause: function(data) {
            var events = this.events;
            var settings = this.settings;
            if (this.settings.active) {
              settings.status = CONST.PAUSED;
              settings.active = false;
              events.emit(Events.PAUSE, this, data);
            }
            return this;
          },
          resume: function(data) {
            var events = this.events;
            var settings = this.settings;
            if (!this.settings.active) {
              settings.status = CONST.RUNNING;
              settings.active = true;
              events.emit(Events.RESUME, this, data);
            }
            return this;
          },
          sleep: function(data) {
            var events = this.events;
            var settings = this.settings;
            settings.status = CONST.SLEEPING;
            settings.active = false;
            settings.visible = false;
            events.emit(Events.SLEEP, this, data);
            return this;
          },
          wake: function(data) {
            var events = this.events;
            var settings = this.settings;
            settings.status = CONST.RUNNING;
            settings.active = true;
            settings.visible = true;
            events.emit(Events.WAKE, this, data);
            if (settings.isTransition) {
              events.emit(Events.TRANSITION_WAKE, settings.transitionFrom, settings.transitionDuration);
            }
            return this;
          },
          getData: function() {
            return this.settings.data;
          },
          isSleeping: function() {
            return this.settings.status === CONST.SLEEPING;
          },
          isActive: function() {
            return this.settings.status === CONST.RUNNING;
          },
          isPaused: function() {
            return this.settings.status === CONST.PAUSED;
          },
          isTransitioning: function() {
            return this.settings.isTransition || this.scenePlugin._target !== null;
          },
          isTransitionOut: function() {
            return this.scenePlugin._target !== null && this.scenePlugin._duration > 0;
          },
          isTransitionIn: function() {
            return this.settings.isTransition;
          },
          isVisible: function() {
            return this.settings.visible;
          },
          setVisible: function(value) {
            this.settings.visible = value;
            return this;
          },
          setActive: function(value, data) {
            if (value) {
              return this.resume(data);
            } else {
              return this.pause(data);
            }
          },
          start: function(data) {
            var events = this.events;
            var settings = this.settings;
            if (data) {
              settings.data = data;
            }
            settings.status = CONST.START;
            settings.active = true;
            settings.visible = true;
            events.emit(Events.START, this);
            events.emit(Events.READY, this, data);
          },
          shutdown: function(data) {
            var events = this.events;
            var settings = this.settings;
            events.off(Events.TRANSITION_INIT);
            events.off(Events.TRANSITION_START);
            events.off(Events.TRANSITION_COMPLETE);
            events.off(Events.TRANSITION_OUT);
            settings.status = CONST.SHUTDOWN;
            settings.active = false;
            settings.visible = false;
            if (this.renderer === GLOBAL_CONST.WEBGL) {
              this.renderer.resetTextures(true);
            }
            events.emit(Events.SHUTDOWN, this, data);
          },
          destroy: function() {
            var events = this.events;
            var settings = this.settings;
            settings.status = CONST.DESTROYED;
            settings.active = false;
            settings.visible = false;
            events.emit(Events.DESTROY, this);
            events.removeAllListeners();
            var props = ["scene", "game", "anims", "cache", "plugins", "registry", "sound", "textures", "add", "camera", "displayList", "events", "make", "scenePlugin", "updateList"];
            for (var i2 = 0; i2 < props.length; i2++) {
              this[props[i2]] = null;
            }
          }
        });
        module2.exports = Systems;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var UppercaseFirst = function(str) {
          return str && str[0].toUpperCase() + str.slice(1);
        };
        module2.exports = UppercaseFirst;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(33);
        var Class = __webpack_require__(0);
        var Frame = __webpack_require__(109);
        var TextureSource = __webpack_require__(424);
        var TEXTURE_MISSING_ERROR = "Texture.frame missing: ";
        var Texture = new Class({
          initialize: function Texture2(manager, key, source, width, height) {
            if (!Array.isArray(source)) {
              source = [source];
            }
            this.manager = manager;
            this.key = key;
            this.source = [];
            this.dataSource = [];
            this.frames = {};
            this.customData = {};
            this.firstFrame = "__BASE";
            this.frameTotal = 0;
            for (var i2 = 0; i2 < source.length; i2++) {
              this.source.push(new TextureSource(this, source[i2], width, height));
            }
          },
          add: function(name, sourceIndex, x2, y2, width, height) {
            if (this.has(name)) {
              return null;
            }
            var frame = new Frame(this, name, sourceIndex, x2, y2, width, height);
            this.frames[name] = frame;
            if (this.firstFrame === "__BASE") {
              this.firstFrame = name;
            }
            this.frameTotal++;
            return frame;
          },
          remove: function(name) {
            if (this.has(name)) {
              var frame = this.get(name);
              frame.destroy();
              delete this.frames[name];
              return true;
            }
            return false;
          },
          has: function(name) {
            return this.frames[name];
          },
          get: function(name) {
            if (!name) {
              name = this.firstFrame;
            }
            var frame = this.frames[name];
            if (!frame) {
              console.warn(TEXTURE_MISSING_ERROR + name);
              frame = this.frames[this.firstFrame];
            }
            return frame;
          },
          getTextureSourceIndex: function(source) {
            for (var i2 = 0; i2 < this.source.length; i2++) {
              if (this.source[i2] === source) {
                return i2;
              }
            }
            return -1;
          },
          getFramesFromTextureSource: function(sourceIndex, includeBase) {
            if (includeBase === void 0) {
              includeBase = false;
            }
            var out = [];
            for (var frameName in this.frames) {
              if (frameName === "__BASE" && !includeBase) {
                continue;
              }
              var frame = this.frames[frameName];
              if (frame.sourceIndex === sourceIndex) {
                out.push(frame);
              }
            }
            return out;
          },
          getFrameNames: function(includeBase) {
            if (includeBase === void 0) {
              includeBase = false;
            }
            var out = Object.keys(this.frames);
            if (!includeBase) {
              var idx = out.indexOf("__BASE");
              if (idx !== -1) {
                out.splice(idx, 1);
              }
            }
            return out;
          },
          getSourceImage: function(name) {
            if (name === void 0 || name === null || this.frameTotal === 1) {
              name = "__BASE";
            }
            var frame = this.frames[name];
            if (frame) {
              return frame.source.image;
            } else {
              console.warn(TEXTURE_MISSING_ERROR + name);
              return this.frames["__BASE"].source.image;
            }
          },
          getDataSourceImage: function(name) {
            if (name === void 0 || name === null || this.frameTotal === 1) {
              name = "__BASE";
            }
            var frame = this.frames[name];
            var idx;
            if (!frame) {
              console.warn(TEXTURE_MISSING_ERROR + name);
              idx = this.frames["__BASE"].sourceIndex;
            } else {
              idx = frame.sourceIndex;
            }
            return this.dataSource[idx].image;
          },
          setDataSource: function(data) {
            if (!Array.isArray(data)) {
              data = [data];
            }
            for (var i2 = 0; i2 < data.length; i2++) {
              var source = this.source[i2];
              this.dataSource.push(new TextureSource(this, data[i2], source.width, source.height));
            }
          },
          setFilter: function(filterMode) {
            var i2;
            for (i2 = 0; i2 < this.source.length; i2++) {
              this.source[i2].setFilter(filterMode);
            }
            for (i2 = 0; i2 < this.dataSource.length; i2++) {
              this.dataSource[i2].setFilter(filterMode);
            }
          },
          destroy: function() {
            var i2;
            for (i2 = 0; i2 < this.source.length; i2++) {
              this.source[i2].destroy();
            }
            for (i2 = 0; i2 < this.dataSource.length; i2++) {
              this.dataSource[i2].destroy();
            }
            for (var frameName in this.frames) {
              var frame = this.frames[frameName];
              frame.destroy();
            }
            this.source = [];
            this.dataSource = [];
            this.frames = {};
            this.manager.removeKey(this.key);
            var renderer = this.manager.game.renderer;
            if (renderer && renderer.type === CONST.WEBGL) {
              renderer.resetTextures(true);
            }
            this.manager = null;
          }
        });
        module2.exports = Texture;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SafeRange = __webpack_require__(78);
        var GetAll = function(array, property, value, startIndex, endIndex) {
          if (startIndex === void 0) {
            startIndex = 0;
          }
          if (endIndex === void 0) {
            endIndex = array.length;
          }
          var output = [];
          if (SafeRange(array, startIndex, endIndex)) {
            for (var i2 = startIndex; i2 < endIndex; i2++) {
              var child = array[i2];
              if (!property || property && value === void 0 && child.hasOwnProperty(property) || property && value !== void 0 && child[property] === value) {
                output.push(child);
              }
            }
          }
          return output;
        };
        module2.exports = GetAll;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Matrix: __webpack_require__(1013),
          Add: __webpack_require__(1021),
          AddAt: __webpack_require__(1022),
          BringToTop: __webpack_require__(1023),
          CountAllMatching: __webpack_require__(1024),
          Each: __webpack_require__(1025),
          EachInRange: __webpack_require__(1026),
          FindClosestInSorted: __webpack_require__(318),
          GetAll: __webpack_require__(207),
          GetFirst: __webpack_require__(428),
          GetRandom: __webpack_require__(210),
          MoveDown: __webpack_require__(1027),
          MoveTo: __webpack_require__(1028),
          MoveUp: __webpack_require__(1029),
          MoveAbove: __webpack_require__(1030),
          MoveBelow: __webpack_require__(1031),
          NumberArray: __webpack_require__(322),
          NumberArrayStep: __webpack_require__(1032),
          QuickSelect: __webpack_require__(436),
          Range: __webpack_require__(437),
          Remove: __webpack_require__(93),
          RemoveAt: __webpack_require__(1033),
          RemoveBetween: __webpack_require__(1034),
          RemoveRandomElement: __webpack_require__(1035),
          Replace: __webpack_require__(1036),
          RotateLeft: __webpack_require__(178),
          RotateRight: __webpack_require__(179),
          SafeRange: __webpack_require__(78),
          SendToBack: __webpack_require__(1037),
          SetAll: __webpack_require__(1038),
          Shuffle: __webpack_require__(131),
          SortByDigits: __webpack_require__(320),
          SpliceOne: __webpack_require__(74),
          StableSort: __webpack_require__(79),
          Swap: __webpack_require__(1039)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CheckMatrix = function(matrix) {
          if (!Array.isArray(matrix) || matrix.length < 2 || !Array.isArray(matrix[0])) {
            return false;
          }
          var size = matrix[0].length;
          for (var i2 = 1; i2 < matrix.length; i2++) {
            if (matrix[i2].length !== size) {
              return false;
            }
          }
          return true;
        };
        module2.exports = CheckMatrix;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetRandom = function(array, startIndex, length) {
          if (startIndex === void 0) {
            startIndex = 0;
          }
          if (length === void 0) {
            length = array.length;
          }
          var randomIndex = startIndex + Math.floor(Math.random() * length);
          return array[randomIndex] === void 0 ? null : array[randomIndex];
        };
        module2.exports = GetRandom;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(438);
        var ProcessQueue = new Class({
          Extends: EventEmitter,
          initialize: function ProcessQueue2() {
            EventEmitter.call(this);
            this._pending = [];
            this._active = [];
            this._destroy = [];
            this._toProcess = 0;
            this.checkQueue = false;
          },
          add: function(item) {
            this._pending.push(item);
            this._toProcess++;
            return item;
          },
          remove: function(item) {
            this._destroy.push(item);
            this._toProcess++;
            return item;
          },
          removeAll: function() {
            var list = this._active;
            var destroy = this._destroy;
            var i2 = list.length;
            while (i2--) {
              destroy.push(list[i2]);
              this._toProcess++;
            }
            return this;
          },
          update: function() {
            if (this._toProcess === 0) {
              return this._active;
            }
            var list = this._destroy;
            var active = this._active;
            var i2;
            var item;
            for (i2 = 0; i2 < list.length; i2++) {
              item = list[i2];
              var idx = active.indexOf(item);
              if (idx !== -1) {
                active.splice(idx, 1);
                this.emit(Events.PROCESS_QUEUE_REMOVE, item);
              }
            }
            list.length = 0;
            list = this._pending;
            for (i2 = 0; i2 < list.length; i2++) {
              item = list[i2];
              if (!this.checkQueue || this.checkQueue && active.indexOf(item) === -1) {
                active.push(item);
                this.emit(Events.PROCESS_QUEUE_ADD, item);
              }
            }
            list.length = 0;
            this._toProcess = 0;
            return active;
          },
          getActive: function() {
            return this._active;
          },
          length: {
            get: function() {
              return this._active.length;
            }
          },
          destroy: function() {
            this._toProcess = 0;
            this._pending = [];
            this._active = [];
            this._destroy = [];
          }
        });
        module2.exports = ProcessQueue;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        function getValue(node, attribute) {
          return parseInt(node.getAttribute(attribute), 10);
        }
        var ParseXMLBitmapFont = function(xml, frame, xSpacing, ySpacing, texture) {
          if (xSpacing === void 0) {
            xSpacing = 0;
          }
          if (ySpacing === void 0) {
            ySpacing = 0;
          }
          var textureX = frame.cutX;
          var textureY = frame.cutY;
          var textureWidth = frame.source.width;
          var textureHeight = frame.source.height;
          var sourceIndex = frame.sourceIndex;
          var data = {};
          var info = xml.getElementsByTagName("info")[0];
          var common = xml.getElementsByTagName("common")[0];
          data.font = info.getAttribute("face");
          data.size = getValue(info, "size");
          data.lineHeight = getValue(common, "lineHeight") + ySpacing;
          data.chars = {};
          var letters = xml.getElementsByTagName("char");
          var adjustForTrim = frame !== void 0 && frame.trimmed;
          if (adjustForTrim) {
            var top = frame.height;
            var left = frame.width;
          }
          for (var i2 = 0; i2 < letters.length; i2++) {
            var node = letters[i2];
            var charCode = getValue(node, "id");
            var letter = String.fromCharCode(charCode);
            var gx = getValue(node, "x");
            var gy = getValue(node, "y");
            var gw = getValue(node, "width");
            var gh2 = getValue(node, "height");
            if (adjustForTrim) {
              if (gx < left) {
                left = gx;
              }
              if (gy < top) {
                top = gy;
              }
            }
            if (adjustForTrim && top !== 0 && left !== 0) {
              gx -= frame.x;
              gy -= frame.y;
            }
            var u0 = (textureX + gx) / textureWidth;
            var v0 = (textureY + gy) / textureHeight;
            var u1 = (textureX + gx + gw) / textureWidth;
            var v1 = (textureY + gy + gh2) / textureHeight;
            data.chars[charCode] = {
              x: gx,
              y: gy,
              width: gw,
              height: gh2,
              centerX: Math.floor(gw / 2),
              centerY: Math.floor(gh2 / 2),
              xOffset: getValue(node, "xoffset"),
              yOffset: getValue(node, "yoffset"),
              xAdvance: getValue(node, "xadvance") + xSpacing,
              data: {},
              kerning: {},
              u0,
              v0,
              u1,
              v1
            };
            if (texture && gw !== 0 && gh2 !== 0) {
              var charFrame = texture.add(letter, sourceIndex, gx, gy, gw, gh2);
              if (charFrame) {
                charFrame.setUVs(gw, gh2, u0, v0, u1, v1);
              }
            }
          }
          var kernings = xml.getElementsByTagName("kerning");
          for (i2 = 0; i2 < kernings.length; i2++) {
            var kern = kernings[i2];
            var first = getValue(kern, "first");
            var second = getValue(kern, "second");
            var amount = getValue(kern, "amount");
            data.chars[second].kerning[first] = amount;
          }
          return data;
        };
        module2.exports = ParseXMLBitmapFont;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BlitterRender = __webpack_require__(1049);
        var Bob = __webpack_require__(440);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var Frame = __webpack_require__(109);
        var GameObject = __webpack_require__(15);
        var List = __webpack_require__(110);
        var Blitter = new Class({
          Extends: GameObject,
          Mixins: [
            Components.Alpha,
            Components.BlendMode,
            Components.Depth,
            Components.Mask,
            Components.Pipeline,
            Components.ScrollFactor,
            Components.Size,
            Components.Texture,
            Components.Transform,
            Components.Visible,
            BlitterRender
          ],
          initialize: function Blitter2(scene, x2, y2, texture, frame) {
            GameObject.call(this, scene, "Blitter");
            this.setTexture(texture, frame);
            this.setPosition(x2, y2);
            this.initPipeline();
            this.children = new List();
            this.renderList = [];
            this.dirty = false;
          },
          create: function(x2, y2, frame, visible, index2) {
            if (visible === void 0) {
              visible = true;
            }
            if (index2 === void 0) {
              index2 = this.children.length;
            }
            if (frame === void 0) {
              frame = this.frame;
            } else if (!(frame instanceof Frame)) {
              frame = this.texture.get(frame);
            }
            var bob = new Bob(this, x2, y2, frame, visible);
            this.children.addAt(bob, index2, false);
            this.dirty = true;
            return bob;
          },
          createFromCallback: function(callback, quantity, frame, visible) {
            var bobs = this.createMultiple(quantity, frame, visible);
            for (var i2 = 0; i2 < bobs.length; i2++) {
              var bob = bobs[i2];
              callback.call(this, bob, i2);
            }
            return bobs;
          },
          createMultiple: function(quantity, frame, visible) {
            if (frame === void 0) {
              frame = this.frame.name;
            }
            if (visible === void 0) {
              visible = true;
            }
            if (!Array.isArray(frame)) {
              frame = [frame];
            }
            var bobs = [];
            var _this = this;
            frame.forEach(function(singleFrame) {
              for (var i2 = 0; i2 < quantity; i2++) {
                bobs.push(_this.create(0, 0, singleFrame, visible));
              }
            });
            return bobs;
          },
          childCanRender: function(child) {
            return child.visible && child.alpha > 0;
          },
          getRenderList: function() {
            if (this.dirty) {
              this.renderList = this.children.list.filter(this.childCanRender, this);
              this.dirty = false;
            }
            return this.renderList;
          },
          clear: function() {
            this.children.removeAll();
            this.dirty = true;
          },
          preDestroy: function() {
            this.children.destroy();
            this.renderList = [];
          }
        });
        module2.exports = Blitter;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Felipe Alfonso <@bitnenfer>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ArrayUtils = __webpack_require__(208);
        var BlendModes = __webpack_require__(35);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var Events = __webpack_require__(75);
        var GameObject = __webpack_require__(15);
        var Rectangle = __webpack_require__(10);
        var Render = __webpack_require__(1052);
        var Union = __webpack_require__(441);
        var Vector2 = __webpack_require__(3);
        var Container = new Class({
          Extends: GameObject,
          Mixins: [
            Components.AlphaSingle,
            Components.BlendMode,
            Components.ComputedSize,
            Components.Depth,
            Components.Mask,
            Components.Pipeline,
            Components.Transform,
            Components.Visible,
            Render
          ],
          initialize: function Container2(scene, x2, y2, children) {
            GameObject.call(this, scene, "Container");
            this.list = [];
            this.exclusive = true;
            this.maxSize = -1;
            this.position = 0;
            this.localTransform = new Components.TransformMatrix();
            this.tempTransformMatrix = new Components.TransformMatrix();
            this._sortKey = "";
            this._sysEvents = scene.sys.events;
            this.scrollFactorX = 1;
            this.scrollFactorY = 1;
            this.initPipeline();
            this.setPosition(x2, y2);
            this.clearAlpha();
            this.setBlendMode(BlendModes.SKIP_CHECK);
            if (children) {
              this.add(children);
            }
          },
          originX: {
            get: function() {
              return 0.5;
            }
          },
          originY: {
            get: function() {
              return 0.5;
            }
          },
          displayOriginX: {
            get: function() {
              return this.width * 0.5;
            }
          },
          displayOriginY: {
            get: function() {
              return this.height * 0.5;
            }
          },
          setExclusive: function(value) {
            if (value === void 0) {
              value = true;
            }
            this.exclusive = value;
            return this;
          },
          getBounds: function(output) {
            if (output === void 0) {
              output = new Rectangle();
            }
            output.setTo(this.x, this.y, 0, 0);
            if (this.parentContainer) {
              var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
              var transformedPosition = parentMatrix.transformPoint(this.x, this.y);
              output.setTo(transformedPosition.x, transformedPosition.y, 0, 0);
            }
            if (this.list.length > 0) {
              var children = this.list;
              var tempRect = new Rectangle();
              var hasSetFirst = false;
              output.setEmpty();
              for (var i2 = 0; i2 < children.length; i2++) {
                var entry = children[i2];
                if (entry.getBounds) {
                  entry.getBounds(tempRect);
                  if (!hasSetFirst) {
                    output.setTo(tempRect.x, tempRect.y, tempRect.width, tempRect.height);
                    hasSetFirst = true;
                  } else {
                    Union(tempRect, output, output);
                  }
                }
              }
            }
            return output;
          },
          addHandler: function(gameObject) {
            gameObject.once(Events.DESTROY, this.remove, this);
            if (this.exclusive) {
              if (gameObject.parentContainer) {
                gameObject.parentContainer.remove(gameObject);
              }
              gameObject.removeFromDisplayList();
              gameObject.parentContainer = this;
            }
          },
          removeHandler: function(gameObject) {
            gameObject.off(Events.DESTROY, this.remove);
            if (this.exclusive) {
              gameObject.parentContainer = null;
              gameObject.addToDisplayList();
            }
          },
          pointToContainer: function(source, output) {
            if (output === void 0) {
              output = new Vector2();
            }
            if (this.parentContainer) {
              this.parentContainer.pointToContainer(source, output);
            } else {
              output = new Vector2(source.x, source.y);
            }
            var tempMatrix = this.tempTransformMatrix;
            tempMatrix.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY);
            tempMatrix.invert();
            tempMatrix.transformPoint(source.x, source.y, output);
            return output;
          },
          getBoundsTransformMatrix: function() {
            return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform);
          },
          add: function(child) {
            ArrayUtils.Add(this.list, child, this.maxSize, this.addHandler, this);
            return this;
          },
          addAt: function(child, index2) {
            ArrayUtils.AddAt(this.list, child, index2, this.maxSize, this.addHandler, this);
            return this;
          },
          getAt: function(index2) {
            return this.list[index2];
          },
          getIndex: function(child) {
            return this.list.indexOf(child);
          },
          sort: function(property, handler) {
            if (!property) {
              return this;
            }
            if (handler === void 0) {
              handler = function(childA, childB) {
                return childA[property] - childB[property];
              };
            }
            ArrayUtils.StableSort(this.list, handler);
            return this;
          },
          getByName: function(name) {
            return ArrayUtils.GetFirst(this.list, "name", name);
          },
          getRandom: function(startIndex, length) {
            return ArrayUtils.GetRandom(this.list, startIndex, length);
          },
          getFirst: function(property, value, startIndex, endIndex) {
            return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
          },
          getAll: function(property, value, startIndex, endIndex) {
            return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
          },
          count: function(property, value, startIndex, endIndex) {
            return ArrayUtils.CountAllMatching(this.list, property, value, startIndex, endIndex);
          },
          swap: function(child1, child2) {
            ArrayUtils.Swap(this.list, child1, child2);
            return this;
          },
          moveTo: function(child, index2) {
            ArrayUtils.MoveTo(this.list, child, index2);
            return this;
          },
          moveAbove: function(child1, child2) {
            ArrayUtils.MoveAbove(this.list, child1, child2);
            return this;
          },
          moveBelow: function(child1, child2) {
            ArrayUtils.MoveBelow(this.list, child1, child2);
            return this;
          },
          remove: function(child, destroyChild) {
            var removed = ArrayUtils.Remove(this.list, child, this.removeHandler, this);
            if (destroyChild && removed) {
              if (!Array.isArray(removed)) {
                removed = [removed];
              }
              for (var i2 = 0; i2 < removed.length; i2++) {
                removed[i2].destroy();
              }
            }
            return this;
          },
          removeAt: function(index2, destroyChild) {
            var removed = ArrayUtils.RemoveAt(this.list, index2, this.removeHandler, this);
            if (destroyChild && removed) {
              removed.destroy();
            }
            return this;
          },
          removeBetween: function(startIndex, endIndex, destroyChild) {
            var removed = ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeHandler, this);
            if (destroyChild) {
              for (var i2 = 0; i2 < removed.length; i2++) {
                removed[i2].destroy();
              }
            }
            return this;
          },
          removeAll: function(destroyChild) {
            var removed = ArrayUtils.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this);
            if (destroyChild) {
              for (var i2 = 0; i2 < removed.length; i2++) {
                removed[i2].destroy();
              }
            }
            return this;
          },
          bringToTop: function(child) {
            ArrayUtils.BringToTop(this.list, child);
            return this;
          },
          sendToBack: function(child) {
            ArrayUtils.SendToBack(this.list, child);
            return this;
          },
          moveUp: function(child) {
            ArrayUtils.MoveUp(this.list, child);
            return this;
          },
          moveDown: function(child) {
            ArrayUtils.MoveDown(this.list, child);
            return this;
          },
          reverse: function() {
            this.list.reverse();
            return this;
          },
          shuffle: function() {
            ArrayUtils.Shuffle(this.list);
            return this;
          },
          replace: function(oldChild, newChild, destroyChild) {
            var moved = ArrayUtils.Replace(this.list, oldChild, newChild);
            if (moved) {
              this.addHandler(newChild);
              this.removeHandler(oldChild);
              if (destroyChild) {
                oldChild.destroy();
              }
            }
            return this;
          },
          exists: function(child) {
            return this.list.indexOf(child) > -1;
          },
          setAll: function(property, value, startIndex, endIndex) {
            ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);
            return this;
          },
          each: function(callback, context) {
            var args = [null];
            var i2;
            var temp = this.list.slice();
            var len = temp.length;
            for (i2 = 2; i2 < arguments.length; i2++) {
              args.push(arguments[i2]);
            }
            for (i2 = 0; i2 < len; i2++) {
              args[0] = temp[i2];
              callback.apply(context, args);
            }
            return this;
          },
          iterate: function(callback, context) {
            var args = [null];
            var i2;
            for (i2 = 2; i2 < arguments.length; i2++) {
              args.push(arguments[i2]);
            }
            for (i2 = 0; i2 < this.list.length; i2++) {
              args[0] = this.list[i2];
              callback.apply(context, args);
            }
            return this;
          },
          setScrollFactor: function(x2, y2, updateChildren) {
            if (y2 === void 0) {
              y2 = x2;
            }
            if (updateChildren === void 0) {
              updateChildren = false;
            }
            this.scrollFactorX = x2;
            this.scrollFactorY = y2;
            if (updateChildren) {
              ArrayUtils.SetAll(this.list, "scrollFactorX", x2);
              ArrayUtils.SetAll(this.list, "scrollFactorY", y2);
            }
            return this;
          },
          length: {
            get: function() {
              return this.list.length;
            }
          },
          first: {
            get: function() {
              this.position = 0;
              if (this.list.length > 0) {
                return this.list[0];
              } else {
                return null;
              }
            }
          },
          last: {
            get: function() {
              if (this.list.length > 0) {
                this.position = this.list.length - 1;
                return this.list[this.position];
              } else {
                return null;
              }
            }
          },
          next: {
            get: function() {
              if (this.position < this.list.length) {
                this.position++;
                return this.list[this.position];
              } else {
                return null;
              }
            }
          },
          previous: {
            get: function() {
              if (this.position > 0) {
                this.position--;
                return this.list[this.position];
              } else {
                return null;
              }
            }
          },
          preDestroy: function() {
            this.removeAll(!!this.exclusive);
            this.localTransform.destroy();
            this.tempTransformMatrix.destroy();
            this.list = [];
          }
        });
        module2.exports = Container;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BitmapText = __webpack_require__(148);
        var Class = __webpack_require__(0);
        var Render = __webpack_require__(1057);
        var DynamicBitmapText = new Class({
          Extends: BitmapText,
          Mixins: [
            Render
          ],
          initialize: function DynamicBitmapText2(scene, x2, y2, font, text, size, align) {
            BitmapText.call(this, scene, x2, y2, font, text, size, align);
            this.type = "DynamicBitmapText";
            this.scrollX = 0;
            this.scrollY = 0;
            this.cropWidth = 0;
            this.cropHeight = 0;
            this.displayCallback;
            this.callbackData = {
              parent: this,
              color: 0,
              tint: {
                topLeft: 0,
                topRight: 0,
                bottomLeft: 0,
                bottomRight: 0
              },
              index: 0,
              charCode: 0,
              x: 0,
              y: 0,
              scale: 0,
              rotation: 0,
              data: 0
            };
          },
          setSize: function(width, height) {
            this.cropWidth = width;
            this.cropHeight = height;
            return this;
          },
          setDisplayCallback: function(callback) {
            this.displayCallback = callback;
            return this;
          },
          setScrollX: function(value) {
            this.scrollX = value;
            return this;
          },
          setScrollY: function(value) {
            this.scrollY = value;
            return this;
          }
        });
        module2.exports = DynamicBitmapText;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BaseCamera = __webpack_require__(133);
        var Class = __webpack_require__(0);
        var Commands = __webpack_require__(217);
        var ComponentsAlpha = __webpack_require__(303);
        var ComponentsBlendMode = __webpack_require__(304);
        var ComponentsDepth = __webpack_require__(305);
        var ComponentsMask = __webpack_require__(309);
        var ComponentsPipeline = __webpack_require__(167);
        var ComponentsScrollFactor = __webpack_require__(312);
        var ComponentsTransform = __webpack_require__(313);
        var ComponentsVisible = __webpack_require__(314);
        var Ellipse = __webpack_require__(111);
        var GameObject = __webpack_require__(15);
        var GetFastValue = __webpack_require__(2);
        var GetValue = __webpack_require__(6);
        var MATH_CONST = __webpack_require__(14);
        var Render = __webpack_require__(1063);
        var Graphics = new Class({
          Extends: GameObject,
          Mixins: [
            ComponentsAlpha,
            ComponentsBlendMode,
            ComponentsDepth,
            ComponentsMask,
            ComponentsPipeline,
            ComponentsTransform,
            ComponentsVisible,
            ComponentsScrollFactor,
            Render
          ],
          initialize: function Graphics2(scene, options) {
            var x2 = GetValue(options, "x", 0);
            var y2 = GetValue(options, "y", 0);
            GameObject.call(this, scene, "Graphics");
            this.setPosition(x2, y2);
            this.initPipeline();
            this.displayOriginX = 0;
            this.displayOriginY = 0;
            this.commandBuffer = [];
            this.defaultFillColor = -1;
            this.defaultFillAlpha = 1;
            this.defaultStrokeWidth = 1;
            this.defaultStrokeColor = -1;
            this.defaultStrokeAlpha = 1;
            this._lineWidth = 1;
            this.setDefaultStyles(options);
          },
          setDefaultStyles: function(options) {
            if (GetValue(options, "lineStyle", null)) {
              this.defaultStrokeWidth = GetValue(options, "lineStyle.width", 1);
              this.defaultStrokeColor = GetValue(options, "lineStyle.color", 16777215);
              this.defaultStrokeAlpha = GetValue(options, "lineStyle.alpha", 1);
              this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
            }
            if (GetValue(options, "fillStyle", null)) {
              this.defaultFillColor = GetValue(options, "fillStyle.color", 16777215);
              this.defaultFillAlpha = GetValue(options, "fillStyle.alpha", 1);
              this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
            }
            return this;
          },
          lineStyle: function(lineWidth, color, alpha) {
            if (alpha === void 0) {
              alpha = 1;
            }
            this.commandBuffer.push(Commands.LINE_STYLE, lineWidth, color, alpha);
            this._lineWidth = lineWidth;
            return this;
          },
          fillStyle: function(color, alpha) {
            if (alpha === void 0) {
              alpha = 1;
            }
            this.commandBuffer.push(Commands.FILL_STYLE, color, alpha);
            return this;
          },
          fillGradientStyle: function(topLeft, topRight, bottomLeft, bottomRight, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight) {
            if (alphaTopLeft === void 0) {
              alphaTopLeft = 1;
            }
            if (alphaTopRight === void 0) {
              alphaTopRight = alphaTopLeft;
            }
            if (alphaBottomLeft === void 0) {
              alphaBottomLeft = alphaTopLeft;
            }
            if (alphaBottomRight === void 0) {
              alphaBottomRight = alphaTopLeft;
            }
            this.commandBuffer.push(Commands.GRADIENT_FILL_STYLE, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight, topLeft, topRight, bottomLeft, bottomRight);
            return this;
          },
          lineGradientStyle: function(lineWidth, topLeft, topRight, bottomLeft, bottomRight, alpha) {
            if (alpha === void 0) {
              alpha = 1;
            }
            this.commandBuffer.push(Commands.GRADIENT_LINE_STYLE, lineWidth, alpha, topLeft, topRight, bottomLeft, bottomRight);
            return this;
          },
          beginPath: function() {
            this.commandBuffer.push(Commands.BEGIN_PATH);
            return this;
          },
          closePath: function() {
            this.commandBuffer.push(Commands.CLOSE_PATH);
            return this;
          },
          fillPath: function() {
            this.commandBuffer.push(Commands.FILL_PATH);
            return this;
          },
          fill: function() {
            this.commandBuffer.push(Commands.FILL_PATH);
            return this;
          },
          strokePath: function() {
            this.commandBuffer.push(Commands.STROKE_PATH);
            return this;
          },
          stroke: function() {
            this.commandBuffer.push(Commands.STROKE_PATH);
            return this;
          },
          fillCircleShape: function(circle) {
            return this.fillCircle(circle.x, circle.y, circle.radius);
          },
          strokeCircleShape: function(circle) {
            return this.strokeCircle(circle.x, circle.y, circle.radius);
          },
          fillCircle: function(x2, y2, radius) {
            this.beginPath();
            this.arc(x2, y2, radius, 0, MATH_CONST.PI2);
            this.fillPath();
            return this;
          },
          strokeCircle: function(x2, y2, radius) {
            this.beginPath();
            this.arc(x2, y2, radius, 0, MATH_CONST.PI2);
            this.strokePath();
            return this;
          },
          fillRectShape: function(rect) {
            return this.fillRect(rect.x, rect.y, rect.width, rect.height);
          },
          strokeRectShape: function(rect) {
            return this.strokeRect(rect.x, rect.y, rect.width, rect.height);
          },
          fillRect: function(x2, y2, width, height) {
            this.commandBuffer.push(Commands.FILL_RECT, x2, y2, width, height);
            return this;
          },
          strokeRect: function(x2, y2, width, height) {
            var lineWidthHalf = this._lineWidth / 2;
            var minx = x2 - lineWidthHalf;
            var maxx = x2 + lineWidthHalf;
            this.beginPath();
            this.moveTo(x2, y2);
            this.lineTo(x2, y2 + height);
            this.strokePath();
            this.beginPath();
            this.moveTo(x2 + width, y2);
            this.lineTo(x2 + width, y2 + height);
            this.strokePath();
            this.beginPath();
            this.moveTo(minx, y2);
            this.lineTo(maxx + width, y2);
            this.strokePath();
            this.beginPath();
            this.moveTo(minx, y2 + height);
            this.lineTo(maxx + width, y2 + height);
            this.strokePath();
            return this;
          },
          fillRoundedRect: function(x2, y2, width, height, radius) {
            if (radius === void 0) {
              radius = 20;
            }
            var tl2 = radius;
            var tr = radius;
            var bl2 = radius;
            var br = radius;
            if (typeof radius !== "number") {
              tl2 = GetFastValue(radius, "tl", 20);
              tr = GetFastValue(radius, "tr", 20);
              bl2 = GetFastValue(radius, "bl", 20);
              br = GetFastValue(radius, "br", 20);
            }
            this.beginPath();
            this.moveTo(x2 + tl2, y2);
            this.lineTo(x2 + width - tr, y2);
            this.arc(x2 + width - tr, y2 + tr, tr, -MATH_CONST.TAU, 0);
            this.lineTo(x2 + width, y2 + height - br);
            this.arc(x2 + width - br, y2 + height - br, br, 0, MATH_CONST.TAU);
            this.lineTo(x2 + bl2, y2 + height);
            this.arc(x2 + bl2, y2 + height - bl2, bl2, MATH_CONST.TAU, Math.PI);
            this.lineTo(x2, y2 + tl2);
            this.arc(x2 + tl2, y2 + tl2, tl2, -Math.PI, -MATH_CONST.TAU);
            this.fillPath();
            return this;
          },
          strokeRoundedRect: function(x2, y2, width, height, radius) {
            if (radius === void 0) {
              radius = 20;
            }
            var tl2 = radius;
            var tr = radius;
            var bl2 = radius;
            var br = radius;
            if (typeof radius !== "number") {
              tl2 = GetFastValue(radius, "tl", 20);
              tr = GetFastValue(radius, "tr", 20);
              bl2 = GetFastValue(radius, "bl", 20);
              br = GetFastValue(radius, "br", 20);
            }
            this.beginPath();
            this.moveTo(x2 + tl2, y2);
            this.lineTo(x2 + width - tr, y2);
            this.moveTo(x2 + width - tr, y2);
            this.arc(x2 + width - tr, y2 + tr, tr, -MATH_CONST.TAU, 0);
            this.lineTo(x2 + width, y2 + height - br);
            this.moveTo(x2 + width, y2 + height - br);
            this.arc(x2 + width - br, y2 + height - br, br, 0, MATH_CONST.TAU);
            this.lineTo(x2 + bl2, y2 + height);
            this.moveTo(x2 + bl2, y2 + height);
            this.arc(x2 + bl2, y2 + height - bl2, bl2, MATH_CONST.TAU, Math.PI);
            this.lineTo(x2, y2 + tl2);
            this.moveTo(x2, y2 + tl2);
            this.arc(x2 + tl2, y2 + tl2, tl2, -Math.PI, -MATH_CONST.TAU);
            this.strokePath();
            return this;
          },
          fillPointShape: function(point, size) {
            return this.fillPoint(point.x, point.y, size);
          },
          fillPoint: function(x2, y2, size) {
            if (!size || size < 1) {
              size = 1;
            } else {
              x2 -= size / 2;
              y2 -= size / 2;
            }
            this.commandBuffer.push(Commands.FILL_RECT, x2, y2, size, size);
            return this;
          },
          fillTriangleShape: function(triangle) {
            return this.fillTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
          },
          strokeTriangleShape: function(triangle) {
            return this.strokeTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
          },
          fillTriangle: function(x0, y0, x1, y1, x2, y2) {
            this.commandBuffer.push(Commands.FILL_TRIANGLE, x0, y0, x1, y1, x2, y2);
            return this;
          },
          strokeTriangle: function(x0, y0, x1, y1, x2, y2) {
            this.commandBuffer.push(Commands.STROKE_TRIANGLE, x0, y0, x1, y1, x2, y2);
            return this;
          },
          strokeLineShape: function(line) {
            return this.lineBetween(line.x1, line.y1, line.x2, line.y2);
          },
          lineBetween: function(x1, y1, x2, y2) {
            this.beginPath();
            this.moveTo(x1, y1);
            this.lineTo(x2, y2);
            this.strokePath();
            return this;
          },
          lineTo: function(x2, y2) {
            this.commandBuffer.push(Commands.LINE_TO, x2, y2);
            return this;
          },
          moveTo: function(x2, y2) {
            this.commandBuffer.push(Commands.MOVE_TO, x2, y2);
            return this;
          },
          strokePoints: function(points, closeShape, closePath, endIndex) {
            if (closeShape === void 0) {
              closeShape = false;
            }
            if (closePath === void 0) {
              closePath = false;
            }
            if (endIndex === void 0) {
              endIndex = points.length;
            }
            this.beginPath();
            this.moveTo(points[0].x, points[0].y);
            for (var i2 = 1; i2 < endIndex; i2++) {
              this.lineTo(points[i2].x, points[i2].y);
            }
            if (closeShape) {
              this.lineTo(points[0].x, points[0].y);
            }
            if (closePath) {
              this.closePath();
            }
            this.strokePath();
            return this;
          },
          fillPoints: function(points, closeShape, closePath, endIndex) {
            if (closeShape === void 0) {
              closeShape = false;
            }
            if (closePath === void 0) {
              closePath = false;
            }
            if (endIndex === void 0) {
              endIndex = points.length;
            }
            this.beginPath();
            this.moveTo(points[0].x, points[0].y);
            for (var i2 = 1; i2 < endIndex; i2++) {
              this.lineTo(points[i2].x, points[i2].y);
            }
            if (closeShape) {
              this.lineTo(points[0].x, points[0].y);
            }
            if (closePath) {
              this.closePath();
            }
            this.fillPath();
            return this;
          },
          strokeEllipseShape: function(ellipse, smoothness) {
            if (smoothness === void 0) {
              smoothness = 32;
            }
            var points = ellipse.getPoints(smoothness);
            return this.strokePoints(points, true);
          },
          strokeEllipse: function(x2, y2, width, height, smoothness) {
            if (smoothness === void 0) {
              smoothness = 32;
            }
            var ellipse = new Ellipse(x2, y2, width, height);
            var points = ellipse.getPoints(smoothness);
            return this.strokePoints(points, true);
          },
          fillEllipseShape: function(ellipse, smoothness) {
            if (smoothness === void 0) {
              smoothness = 32;
            }
            var points = ellipse.getPoints(smoothness);
            return this.fillPoints(points, true);
          },
          fillEllipse: function(x2, y2, width, height, smoothness) {
            if (smoothness === void 0) {
              smoothness = 32;
            }
            var ellipse = new Ellipse(x2, y2, width, height);
            var points = ellipse.getPoints(smoothness);
            return this.fillPoints(points, true);
          },
          arc: function(x2, y2, radius, startAngle, endAngle, anticlockwise, overshoot) {
            if (anticlockwise === void 0) {
              anticlockwise = false;
            }
            if (overshoot === void 0) {
              overshoot = 0;
            }
            this.commandBuffer.push(Commands.ARC, x2, y2, radius, startAngle, endAngle, anticlockwise, overshoot);
            return this;
          },
          slice: function(x2, y2, radius, startAngle, endAngle, anticlockwise, overshoot) {
            if (anticlockwise === void 0) {
              anticlockwise = false;
            }
            if (overshoot === void 0) {
              overshoot = 0;
            }
            this.commandBuffer.push(Commands.BEGIN_PATH);
            this.commandBuffer.push(Commands.MOVE_TO, x2, y2);
            this.commandBuffer.push(Commands.ARC, x2, y2, radius, startAngle, endAngle, anticlockwise, overshoot);
            this.commandBuffer.push(Commands.CLOSE_PATH);
            return this;
          },
          save: function() {
            this.commandBuffer.push(Commands.SAVE);
            return this;
          },
          restore: function() {
            this.commandBuffer.push(Commands.RESTORE);
            return this;
          },
          translateCanvas: function(x2, y2) {
            this.commandBuffer.push(Commands.TRANSLATE, x2, y2);
            return this;
          },
          scaleCanvas: function(x2, y2) {
            this.commandBuffer.push(Commands.SCALE, x2, y2);
            return this;
          },
          rotateCanvas: function(radians) {
            this.commandBuffer.push(Commands.ROTATE, radians);
            return this;
          },
          clear: function() {
            this.commandBuffer.length = 0;
            if (this.defaultFillColor > -1) {
              this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
            }
            if (this.defaultStrokeColor > -1) {
              this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
            }
            return this;
          },
          generateTexture: function(key, width, height) {
            var sys = this.scene.sys;
            var renderer = sys.game.renderer;
            if (width === void 0) {
              width = sys.scale.width;
            }
            if (height === void 0) {
              height = sys.scale.height;
            }
            Graphics.TargetCamera.setScene(this.scene);
            Graphics.TargetCamera.setViewport(0, 0, width, height);
            Graphics.TargetCamera.scrollX = this.x;
            Graphics.TargetCamera.scrollY = this.y;
            var texture;
            var ctx;
            if (typeof key === "string") {
              if (sys.textures.exists(key)) {
                texture = sys.textures.get(key);
                var src = texture.getSourceImage();
                if (src instanceof HTMLCanvasElement) {
                  ctx = src.getContext("2d");
                }
              } else {
                texture = sys.textures.createCanvas(key, width, height);
                ctx = texture.getSourceImage().getContext("2d");
              }
            } else if (key instanceof HTMLCanvasElement) {
              ctx = key.getContext("2d");
            }
            if (ctx) {
              this.renderCanvas(renderer, this, Graphics.TargetCamera, null, ctx, false);
              if (texture) {
                texture.refresh();
              }
            }
            return this;
          },
          preDestroy: function() {
            this.commandBuffer = [];
          }
        });
        Graphics.TargetCamera = new BaseCamera();
        module2.exports = Graphics;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          ARC: 0,
          BEGIN_PATH: 1,
          CLOSE_PATH: 2,
          FILL_RECT: 3,
          LINE_TO: 4,
          MOVE_TO: 5,
          LINE_STYLE: 6,
          FILL_STYLE: 7,
          FILL_PATH: 8,
          STROKE_PATH: 9,
          FILL_TRIANGLE: 10,
          STROKE_TRIANGLE: 11,
          SAVE: 14,
          RESTORE: 15,
          TRANSLATE: 16,
          SCALE: 17,
          ROTATE: 18,
          GRADIENT_FILL_STYLE: 21,
          GRADIENT_LINE_STYLE: 22
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var CircumferencePoint = function(ellipse, angle, out) {
          if (out === void 0) {
            out = new Point();
          }
          var halfWidth = ellipse.width / 2;
          var halfHeight = ellipse.height / 2;
          out.x = ellipse.x + halfWidth * Math.cos(angle);
          out.y = ellipse.y + halfHeight * Math.sin(angle);
          return out;
        };
        module2.exports = CircumferencePoint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BlendModes = __webpack_require__(35);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var ComponentsToJSON = __webpack_require__(176);
        var DataManager = __webpack_require__(101);
        var EventEmitter = __webpack_require__(9);
        var GameObjectEvents = __webpack_require__(75);
        var List = __webpack_require__(110);
        var Render = __webpack_require__(1071);
        var SceneEvents = __webpack_require__(20);
        var StableSort = __webpack_require__(79);
        var Layer = new Class({
          Extends: List,
          Mixins: [
            Components.AlphaSingle,
            Components.BlendMode,
            Components.Depth,
            Components.Mask,
            Components.Pipeline,
            Components.Visible,
            EventEmitter,
            Render
          ],
          initialize: function Layer2(scene, children) {
            List.call(this, scene);
            EventEmitter.call(this);
            this.scene = scene;
            this.displayList = null;
            this.type = "Layer";
            this.state = 0;
            this.parentContainer = null;
            this.name = "";
            this.active = true;
            this.tabIndex = -1;
            this.data = null;
            this.renderFlags = 15;
            this.cameraFilter = 0;
            this.input = null;
            this.body = null;
            this.ignoreDestroy = false;
            this.systems = scene.sys;
            this.events = scene.sys.events;
            this.sortChildrenFlag = false;
            this.addCallback = this.addChildCallback;
            this.removeCallback = this.removeChildCallback;
            this.initPipeline();
            this.clearAlpha();
            this.setBlendMode(BlendModes.SKIP_CHECK);
            if (children) {
              this.add(children);
            }
            scene.sys.queueDepthSort();
          },
          setActive: function(value) {
            this.active = value;
            return this;
          },
          setName: function(value) {
            this.name = value;
            return this;
          },
          setState: function(value) {
            this.state = value;
            return this;
          },
          setDataEnabled: function() {
            if (!this.data) {
              this.data = new DataManager(this);
            }
            return this;
          },
          setData: function(key, value) {
            if (!this.data) {
              this.data = new DataManager(this);
            }
            this.data.set(key, value);
            return this;
          },
          incData: function(key, value) {
            if (!this.data) {
              this.data = new DataManager(this);
            }
            this.data.inc(key, value);
            return this;
          },
          toggleData: function(key) {
            if (!this.data) {
              this.data = new DataManager(this);
            }
            this.data.toggle(key);
            return this;
          },
          getData: function(key) {
            if (!this.data) {
              this.data = new DataManager(this);
            }
            return this.data.get(key);
          },
          setInteractive: function() {
            return this;
          },
          disableInteractive: function() {
            return this;
          },
          removeInteractive: function() {
            return this;
          },
          addedToScene: function() {
          },
          removedFromScene: function() {
          },
          update: function() {
          },
          toJSON: function() {
            return ComponentsToJSON(this);
          },
          willRender: function(camera) {
            return !(this.renderFlags !== 15 || this.list.length === 0 || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
          },
          getIndexList: function() {
            var child = this;
            var parent = this.parentContainer;
            var indexes = [];
            while (parent) {
              indexes.unshift(parent.getIndex(child));
              child = parent;
              if (!parent.parentContainer) {
                break;
              } else {
                parent = parent.parentContainer;
              }
            }
            indexes.unshift(this.displayList.getIndex(child));
            return indexes;
          },
          addChildCallback: function(gameObject) {
            if (gameObject.displayList && gameObject.displayList !== this) {
              gameObject.removeFromDisplayList();
            }
            if (!gameObject.displayList) {
              this.queueDepthSort();
              gameObject.displayList = this;
              gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);
              this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);
            }
          },
          removeChildCallback: function(gameObject) {
            this.queueDepthSort();
            gameObject.displayList = null;
            gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
            this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
          },
          queueDepthSort: function() {
            this.sortChildrenFlag = true;
          },
          depthSort: function() {
            if (this.sortChildrenFlag) {
              StableSort(this.list, this.sortByDepth);
              this.sortChildrenFlag = false;
            }
          },
          sortByDepth: function(childA, childB) {
            return childA._depth - childB._depth;
          },
          getChildren: function() {
            return this.list;
          },
          destroy: function() {
            if (!this.scene || this.ignoreDestroy) {
              return;
            }
            this.emit(GameObjectEvents.DESTROY, this);
            var i2 = this.list.length;
            while (i2--) {
              this.list[i2].destroy();
            }
            this.removeAllListeners();
            this.resetPostPipeline(true);
            if (this.displayList) {
              this.displayList.remove(this, true);
              this.displayList.queueDepthSort();
            }
            if (this.data) {
              this.data.destroy();
              this.data = void 0;
            }
            this.active = false;
            this.visible = false;
            this.list = void 0;
            this.scene = void 0;
            this.displayList = void 0;
            this.systems = void 0;
            this.events = void 0;
          }
        });
        module2.exports = Layer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var GameObject = __webpack_require__(15);
        var GravityWell = __webpack_require__(450);
        var List = __webpack_require__(110);
        var ParticleEmitter = __webpack_require__(452);
        var Render = __webpack_require__(1075);
        var ParticleEmitterManager = new Class({
          Extends: GameObject,
          Mixins: [
            Components.Depth,
            Components.Mask,
            Components.Pipeline,
            Components.Transform,
            Components.Visible,
            Render
          ],
          initialize: function ParticleEmitterManager2(scene, texture, frame, emitters) {
            GameObject.call(this, scene, "ParticleEmitterManager");
            this.blendMode = -1;
            this.timeScale = 1;
            this.texture = null;
            this.frame = null;
            this.frameNames = [];
            if (frame !== null && (typeof frame === "object" || Array.isArray(frame))) {
              emitters = frame;
              frame = null;
            }
            this.setTexture(texture, frame);
            this.initPipeline();
            this.emitters = new List(this);
            this.wells = new List(this);
            if (emitters) {
              if (!Array.isArray(emitters)) {
                emitters = [emitters];
              }
              for (var i2 = 0; i2 < emitters.length; i2++) {
                this.createEmitter(emitters[i2]);
              }
            }
          },
          addedToScene: function() {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function() {
            this.scene.sys.updateList.remove(this);
          },
          setTexture: function(key, frame) {
            this.texture = this.scene.sys.textures.get(key);
            return this.setFrame(frame);
          },
          setFrame: function(frame) {
            this.frame = this.texture.get(frame);
            var frames = this.texture.getFramesFromTextureSource(this.frame.sourceIndex);
            var names = [];
            frames.forEach(function(sourceFrame) {
              names.push(sourceFrame.name);
            });
            this.frameNames = names;
            this.defaultFrame = this.frame;
            return this;
          },
          setEmitterFrames: function(frames, emitter) {
            if (!Array.isArray(frames)) {
              frames = [frames];
            }
            var out = emitter.frames;
            out.length = 0;
            for (var i2 = 0; i2 < frames.length; i2++) {
              var frame = frames[i2];
              if (this.frameNames.indexOf(frame) !== -1) {
                out.push(this.texture.get(frame));
              }
            }
            if (out.length > 0) {
              emitter.defaultFrame = out[0];
            } else {
              emitter.defaultFrame = this.defaultFrame;
            }
            return this;
          },
          addEmitter: function(emitter) {
            return this.emitters.add(emitter);
          },
          createEmitter: function(config) {
            return this.addEmitter(new ParticleEmitter(this, config));
          },
          removeEmitter: function(emitter) {
            return this.emitters.remove(emitter, true);
          },
          addGravityWell: function(well) {
            return this.wells.add(well);
          },
          createGravityWell: function(config) {
            return this.addGravityWell(new GravityWell(config));
          },
          emitParticle: function(count, x2, y2) {
            var emitters = this.emitters.list;
            for (var i2 = 0; i2 < emitters.length; i2++) {
              var emitter = emitters[i2];
              if (emitter.active) {
                emitter.emitParticle(count, x2, y2);
              }
            }
            return this;
          },
          emitParticleAt: function(x2, y2, count) {
            return this.emitParticle(count, x2, y2);
          },
          pause: function() {
            this.active = false;
            return this;
          },
          resume: function() {
            this.active = true;
            return this;
          },
          getProcessors: function() {
            return this.wells.getAll("active", true);
          },
          preUpdate: function(time, delta) {
            delta *= this.timeScale;
            var emitters = this.emitters.list;
            for (var i2 = 0; i2 < emitters.length; i2++) {
              var emitter = emitters[i2];
              if (emitter.active) {
                emitter.preUpdate(time, delta);
              }
            }
          },
          setAlpha: function() {
          },
          setScrollFactor: function() {
          },
          setBlendMode: function() {
          }
        });
        module2.exports = ParticleEmitterManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BlendModes = __webpack_require__(35);
        var Camera = __webpack_require__(133);
        var CanvasPool = __webpack_require__(31);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var CONST = __webpack_require__(33);
        var Frame = __webpack_require__(109);
        var GameObject = __webpack_require__(15);
        var NOOP = __webpack_require__(1);
        var PIPELINE_CONST = __webpack_require__(92);
        var Render = __webpack_require__(1079);
        var RenderTarget = __webpack_require__(141);
        var Utils = __webpack_require__(12);
        var UUID2 = __webpack_require__(222);
        var RenderTexture = new Class({
          Extends: GameObject,
          Mixins: [
            Components.Alpha,
            Components.BlendMode,
            Components.ComputedSize,
            Components.Crop,
            Components.Depth,
            Components.Flip,
            Components.GetBounds,
            Components.Mask,
            Components.Origin,
            Components.Pipeline,
            Components.ScrollFactor,
            Components.Tint,
            Components.Transform,
            Components.Visible,
            Render
          ],
          initialize: function RenderTexture2(scene, x2, y2, width, height, key, frame) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = 32;
            }
            if (height === void 0) {
              height = 32;
            }
            GameObject.call(this, scene, "RenderTexture");
            this.renderer = scene.sys.renderer;
            this.textureManager = scene.sys.textures;
            this.globalTint = 16777215;
            this.globalAlpha = 1;
            this.canvas = null;
            this.dirty = false;
            this._crop = this.resetCropObject();
            this.texture = null;
            this.frame = null;
            this._saved = false;
            if (key === void 0) {
              this.canvas = CanvasPool.create2D(this, width, height);
              this.texture = scene.sys.textures.addCanvas(UUID2(), this.canvas);
              this.frame = this.texture.get();
            } else {
              this.texture = scene.sys.textures.get(key);
              this.frame = this.texture.get(frame);
              this.canvas = this.frame.source.image;
              this._saved = true;
              this.dirty = true;
              this.width = this.frame.cutWidth;
              this.height = this.frame.cutHeight;
            }
            this.context = this.canvas.getContext("2d");
            this._eraseMode = false;
            this.camera = new Camera(0, 0, width, height);
            this.renderTarget = null;
            var renderer = this.renderer;
            if (!renderer) {
              this.drawGameObject = NOOP;
            } else if (renderer.type === CONST.WEBGL) {
              this.drawGameObject = this.batchGameObjectWebGL;
              this.renderTarget = new RenderTarget(renderer, width, height, 1, 0, false);
            } else if (renderer.type === CONST.CANVAS) {
              this.drawGameObject = this.batchGameObjectCanvas;
            }
            this.camera.setScene(scene);
            this.setPosition(x2, y2);
            if (key === void 0) {
              this.setSize(width, height);
            }
            this.setOrigin(0, 0);
            this.initPipeline(PIPELINE_CONST.SINGLE_PIPELINE);
          },
          setSize: function(width, height) {
            return this.resize(width, height);
          },
          resize: function(width, height) {
            if (height === void 0) {
              height = width;
            }
            var frame = this.frame;
            if (width !== this.width || height !== this.height) {
              if (frame.name === "__BASE") {
                this.canvas.width = width;
                this.canvas.height = height;
                this.texture.width = width;
                this.texture.height = height;
                var renderTarget = this.renderTarget;
                if (renderTarget) {
                  renderTarget.resize(width, height);
                  frame.glTexture = renderTarget.texture;
                  frame.source.isRenderTexture = true;
                  frame.source.isGLTexture = true;
                  frame.source.glTexture = renderTarget.texture;
                }
                this.camera.setSize(width, height);
                frame.source.width = width;
                frame.source.height = height;
                frame.setSize(width, height);
                this.width = width;
                this.height = height;
              }
            } else {
              var baseFrame = this.texture.getSourceImage();
              if (frame.cutX + width > baseFrame.width) {
                width = baseFrame.width - frame.cutX;
              }
              if (frame.cutY + height > baseFrame.height) {
                height = baseFrame.height - frame.cutY;
              }
              frame.setSize(width, height, frame.cutX, frame.cutY);
            }
            this.updateDisplayOrigin();
            var input = this.input;
            if (input && !input.customHitArea) {
              input.hitArea.width = width;
              input.hitArea.height = height;
            }
            return this;
          },
          setGlobalTint: function(tint) {
            this.globalTint = tint;
            return this;
          },
          setGlobalAlpha: function(alpha) {
            this.globalAlpha = alpha;
            return this;
          },
          saveTexture: function(key) {
            this.textureManager.renameTexture(this.texture.key, key);
            this._saved = true;
            return this.texture;
          },
          fill: function(rgb, alpha, x2, y2, width, height) {
            var frame = this.frame;
            var camera = this.camera;
            var renderer = this.renderer;
            if (alpha === void 0) {
              alpha = 1;
            }
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = frame.cutWidth;
            }
            if (height === void 0) {
              height = frame.cutHeight;
            }
            var r2 = (rgb >> 16 & 255) / 255;
            var g2 = (rgb >> 8 & 255) / 255;
            var b2 = (rgb & 255) / 255;
            var renderTarget = this.renderTarget;
            camera.preRender();
            if (renderTarget) {
              renderTarget.bind(true);
              var pipeline = this.pipeline;
              pipeline.manager.set(pipeline);
              var tw = renderTarget.width;
              var th2 = renderTarget.height;
              var rw = renderer.width;
              var rh2 = renderer.height;
              var sx = rw / tw;
              var sy = rh2 / th2;
              pipeline.drawFillRect(x2 * sx, y2 * sy, width * sx, height * sy, Utils.getTintFromFloats(b2, g2, r2, 1), alpha);
              renderTarget.unbind(true);
            } else {
              var ctx = this.context;
              renderer.setContext(ctx);
              ctx.fillStyle = "rgba(" + r2 + "," + g2 + "," + b2 + "," + alpha + ")";
              ctx.fillRect(x2 + frame.cutX, y2 + frame.cutY, width, height);
              renderer.setContext();
            }
            this.dirty = true;
            return this;
          },
          clear: function() {
            if (this.dirty) {
              var renderTarget = this.renderTarget;
              if (renderTarget) {
                renderTarget.clear();
              } else {
                var ctx = this.context;
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight);
                ctx.restore();
              }
              this.dirty = false;
            }
            return this;
          },
          erase: function(entries, x2, y2) {
            this._eraseMode = true;
            this.draw(entries, x2, y2, 1, 16777215);
            this._eraseMode = false;
            return this;
          },
          draw: function(entries, x2, y2, alpha, tint) {
            this.beginDraw();
            this.batchDraw(entries, x2, y2, alpha, tint);
            this.endDraw();
            return this;
          },
          drawFrame: function(key, frame, x2, y2, alpha, tint) {
            this.beginDraw();
            this.batchDrawFrame(key, frame, x2, y2, alpha, tint);
            this.endDraw();
            return this;
          },
          beginDraw: function() {
            var camera = this.camera;
            var renderer = this.renderer;
            var renderTarget = this.renderTarget;
            camera.preRender();
            if (renderTarget) {
              renderer.beginCapture(renderTarget.width, renderTarget.height);
            } else {
              renderer.setContext(this.context);
            }
            return this;
          },
          batchDraw: function(entries, x2, y2, alpha, tint) {
            if (alpha === void 0) {
              alpha = this.globalAlpha;
            }
            if (tint === void 0) {
              tint = (this.globalTint >> 16) + (this.globalTint & 65280) + ((this.globalTint & 255) << 16);
            } else {
              tint = (tint >> 16) + (tint & 65280) + ((tint & 255) << 16);
            }
            if (!Array.isArray(entries)) {
              entries = [entries];
            }
            this.batchList(entries, x2, y2, alpha, tint);
            return this;
          },
          batchDrawFrame: function(key, frame, x2, y2, alpha, tint) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (alpha === void 0) {
              alpha = this.globalAlpha;
            }
            if (tint === void 0) {
              tint = (this.globalTint >> 16) + (this.globalTint & 65280) + ((this.globalTint & 255) << 16);
            } else {
              tint = (tint >> 16) + (tint & 65280) + ((tint & 255) << 16);
            }
            var textureFrame = this.textureManager.getFrame(key, frame);
            if (textureFrame) {
              if (this.renderTarget) {
                this.pipeline.batchTextureFrame(textureFrame, x2, y2, tint, alpha, this.camera.matrix, null);
              } else {
                this.batchTextureFrame(textureFrame, x2 + this.frame.cutX, y2 + this.frame.cutY, alpha, tint);
              }
            }
            return this;
          },
          endDraw: function(erase) {
            if (erase === void 0) {
              erase = this._eraseMode;
            }
            var renderer = this.renderer;
            var renderTarget = this.renderTarget;
            if (renderTarget) {
              var canvasTarget = renderer.endCapture();
              var util = renderer.pipelines.setUtility();
              util.blitFrame(canvasTarget, renderTarget, 1, false, false, erase);
              renderer.resetScissor();
              renderer.resetViewport();
            } else {
              renderer.setContext();
            }
            this.dirty = true;
            return this;
          },
          batchList: function(children, x2, y2, alpha, tint) {
            for (var i2 = 0; i2 < children.length; i2++) {
              var entry = children[i2];
              if (!entry || entry === this) {
                continue;
              }
              if (entry.renderWebGL || entry.renderCanvas) {
                this.drawGameObject(entry, x2, y2);
              } else if (entry.isParent || entry.list) {
                this.batchGroup(entry.getChildren(), x2, y2);
              } else if (typeof entry === "string") {
                this.batchTextureFrameKey(entry, null, x2, y2, alpha, tint);
              } else if (entry instanceof Frame) {
                this.batchTextureFrame(entry, x2, y2, alpha, tint);
              } else if (Array.isArray(entry)) {
                this.batchList(entry, x2, y2, alpha, tint);
              }
            }
          },
          batchGroup: function(children, x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            x2 += this.frame.cutX;
            y2 += this.frame.cutY;
            for (var i2 = 0; i2 < children.length; i2++) {
              var entry = children[i2];
              if (entry.willRender(this.camera)) {
                var tx = entry.x + x2;
                var ty = entry.y + y2;
                this.drawGameObject(entry, tx, ty);
              }
            }
          },
          batchGameObjectWebGL: function(gameObject, x2, y2) {
            if (x2 === void 0) {
              x2 = gameObject.x;
            }
            if (y2 === void 0) {
              y2 = gameObject.y;
            }
            var prevX = gameObject.x;
            var prevY = gameObject.y;
            gameObject.setPosition(x2 + this.frame.cutX, y2 + this.frame.cutY);
            if (gameObject.renderDirect) {
              gameObject.renderDirect(this.renderer, gameObject, this.camera);
            } else {
              gameObject.renderWebGL(this.renderer, gameObject, this.camera);
            }
            gameObject.setPosition(prevX, prevY);
          },
          batchGameObjectCanvas: function(gameObject, x2, y2) {
            if (x2 === void 0) {
              x2 = gameObject.x;
            }
            if (y2 === void 0) {
              y2 = gameObject.y;
            }
            var prevX = gameObject.x;
            var prevY = gameObject.y;
            if (this._eraseMode) {
              var blendMode = gameObject.blendMode;
              gameObject.blendMode = BlendModes.ERASE;
            }
            gameObject.setPosition(x2 + this.frame.cutX, y2 + this.frame.cutY);
            gameObject.renderCanvas(this.renderer, gameObject, this.camera, null);
            gameObject.setPosition(prevX, prevY);
            if (this._eraseMode) {
              gameObject.blendMode = blendMode;
            }
          },
          batchTextureFrameKey: function(key, frame, x2, y2, alpha, tint) {
            var textureFrame = this.textureManager.getFrame(key, frame);
            if (textureFrame) {
              this.batchTextureFrame(textureFrame, x2, y2, alpha, tint);
            }
          },
          batchTextureFrame: function(textureFrame, x2, y2, alpha, tint) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            x2 += this.frame.cutX;
            y2 += this.frame.cutY;
            var renderTarget = this.renderTarget;
            if (renderTarget) {
              this.pipeline.batchTextureFrame(textureFrame, x2, y2, tint, alpha, this.camera.matrix, null);
            } else {
              var ctx = this.context;
              var cd2 = textureFrame.canvasData;
              var source = textureFrame.source.image;
              var matrix = this.camera.matrix;
              ctx.save();
              ctx.globalCompositeOperation = this._eraseMode ? "destination-out" : "source-over";
              ctx.globalAlpha = alpha;
              matrix.setToContext(ctx);
              ctx.drawImage(source, cd2.x, cd2.y, cd2.width, cd2.height, x2, y2, cd2.width, cd2.height);
              ctx.restore();
            }
          },
          snapshotArea: function(x2, y2, width, height, callback, type, encoderOptions) {
            if (this.renderTarget) {
              this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, x2, y2, width, height, type, encoderOptions);
            } else {
              this.renderer.snapshotCanvas(this.canvas, callback, false, x2, y2, width, height, type, encoderOptions);
            }
            return this;
          },
          snapshot: function(callback, type, encoderOptions) {
            if (this.renderTarget) {
              this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, 0, 0, this.width, this.height, type, encoderOptions);
            } else {
              this.renderer.snapshotCanvas(this.canvas, callback, false, 0, 0, this.width, this.height, type, encoderOptions);
            }
            return this;
          },
          snapshotPixel: function(x2, y2, callback) {
            if (this.renderTarget) {
              this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, true, x2, y2);
            } else {
              this.renderer.snapshotCanvas(this.canvas, callback, true, x2, y2);
            }
            return this;
          },
          preDestroy: function() {
            if (!this._saved) {
              CanvasPool.remove(this.canvas);
              if (this.renderTarget) {
                this.renderTarget.destroy();
              }
              this.texture.destroy();
              this.camera.destroy();
              this.canvas = null;
              this.context = null;
              this.texture = null;
            }
          }
        });
        module2.exports = RenderTexture;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var UUID2 = function() {
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
            var r2 = Math.random() * 16 | 0;
            var v2 = c === "x" ? r2 : r2 & 3 | 8;
            return v2.toString(16);
          });
        };
        module2.exports = UUID2;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AnimationState = __webpack_require__(164);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var GameObject = __webpack_require__(15);
        var PIPELINE_CONST = __webpack_require__(92);
        var RopeRender = __webpack_require__(1085);
        var Vector2 = __webpack_require__(3);
        var Rope = new Class({
          Extends: GameObject,
          Mixins: [
            Components.AlphaSingle,
            Components.BlendMode,
            Components.Depth,
            Components.Flip,
            Components.Mask,
            Components.Pipeline,
            Components.Size,
            Components.Texture,
            Components.Transform,
            Components.Visible,
            Components.ScrollFactor,
            RopeRender
          ],
          initialize: function Rope2(scene, x2, y2, texture, frame, points, horizontal, colors, alphas) {
            if (texture === void 0) {
              texture = "__DEFAULT";
            }
            if (points === void 0) {
              points = 2;
            }
            if (horizontal === void 0) {
              horizontal = true;
            }
            GameObject.call(this, scene, "Rope");
            this.anims = new AnimationState(this);
            this.points = points;
            this.vertices;
            this.uv;
            this.colors;
            this.alphas;
            this.tintFill = texture === "__DEFAULT" ? true : false;
            this.dirty = false;
            this.horizontal = horizontal;
            this._flipX = false;
            this._flipY = false;
            this._perp = new Vector2();
            this.debugCallback = null;
            this.debugGraphic = null;
            this.setTexture(texture, frame);
            this.setPosition(x2, y2);
            this.setSizeToFrame();
            this.initPipeline(PIPELINE_CONST.ROPE_PIPELINE);
            if (Array.isArray(points)) {
              this.resizeArrays(points.length);
            }
            this.setPoints(points, colors, alphas);
            this.updateVertices();
          },
          addedToScene: function() {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function() {
            this.scene.sys.updateList.remove(this);
          },
          preUpdate: function(time, delta) {
            var prevFrame = this.anims.currentFrame;
            this.anims.update(time, delta);
            if (this.anims.currentFrame !== prevFrame) {
              this.updateUVs();
              this.updateVertices();
            }
          },
          play: function(key, ignoreIfPlaying, startFrame) {
            this.anims.play(key, ignoreIfPlaying, startFrame);
            return this;
          },
          setDirty: function() {
            this.dirty = true;
            return this;
          },
          setHorizontal: function(points, colors, alphas) {
            if (points === void 0) {
              points = this.points.length;
            }
            if (this.horizontal) {
              return this;
            }
            this.horizontal = true;
            return this.setPoints(points, colors, alphas);
          },
          setVertical: function(points, colors, alphas) {
            if (points === void 0) {
              points = this.points.length;
            }
            if (!this.horizontal) {
              return this;
            }
            this.horizontal = false;
            return this.setPoints(points, colors, alphas);
          },
          setTintFill: function(value) {
            if (value === void 0) {
              value = false;
            }
            this.tintFill = value;
            return this;
          },
          setAlphas: function(alphas, bottomAlpha) {
            var total = this.points.length;
            if (total < 1) {
              return this;
            }
            var currentAlphas = this.alphas;
            if (alphas === void 0) {
              alphas = [1];
            } else if (!Array.isArray(alphas) && bottomAlpha === void 0) {
              alphas = [alphas];
            }
            var i2;
            var index2 = 0;
            if (bottomAlpha !== void 0) {
              for (i2 = 0; i2 < total; i2++) {
                index2 = i2 * 2;
                currentAlphas[index2] = alphas;
                currentAlphas[index2 + 1] = bottomAlpha;
              }
            } else if (alphas.length === total) {
              for (i2 = 0; i2 < total; i2++) {
                index2 = i2 * 2;
                currentAlphas[index2] = alphas[i2];
                currentAlphas[index2 + 1] = alphas[i2];
              }
            } else {
              var prevAlpha = alphas[0];
              for (i2 = 0; i2 < total; i2++) {
                index2 = i2 * 2;
                if (alphas.length > index2) {
                  prevAlpha = alphas[index2];
                }
                currentAlphas[index2] = prevAlpha;
                if (alphas.length > index2 + 1) {
                  prevAlpha = alphas[index2 + 1];
                }
                currentAlphas[index2 + 1] = prevAlpha;
              }
            }
            return this;
          },
          setColors: function(colors) {
            var total = this.points.length;
            if (total < 1) {
              return this;
            }
            var currentColors = this.colors;
            if (colors === void 0) {
              colors = [16777215];
            } else if (!Array.isArray(colors)) {
              colors = [colors];
            }
            var i2;
            var index2 = 0;
            if (colors.length === total) {
              for (i2 = 0; i2 < total; i2++) {
                index2 = i2 * 2;
                currentColors[index2] = colors[i2];
                currentColors[index2 + 1] = colors[i2];
              }
            } else {
              var prevColor = colors[0];
              for (i2 = 0; i2 < total; i2++) {
                index2 = i2 * 2;
                if (colors.length > index2) {
                  prevColor = colors[index2];
                }
                currentColors[index2] = prevColor;
                if (colors.length > index2 + 1) {
                  prevColor = colors[index2 + 1];
                }
                currentColors[index2 + 1] = prevColor;
              }
            }
            return this;
          },
          setPoints: function(points, colors, alphas) {
            if (points === void 0) {
              points = 2;
            }
            if (typeof points === "number") {
              var segments = points;
              if (segments < 2) {
                segments = 2;
              }
              points = [];
              var s;
              var frameSegment;
              var offset;
              if (this.horizontal) {
                offset = -this.frame.halfWidth;
                frameSegment = this.frame.width / (segments - 1);
                for (s = 0; s < segments; s++) {
                  points.push({ x: offset + s * frameSegment, y: 0 });
                }
              } else {
                offset = -this.frame.halfHeight;
                frameSegment = this.frame.height / (segments - 1);
                for (s = 0; s < segments; s++) {
                  points.push({ x: 0, y: offset + s * frameSegment });
                }
              }
            }
            var total = points.length;
            var currentTotal = this.points.length;
            if (total < 1) {
              console.warn("Rope: Not enough points given");
              return this;
            } else if (total === 1) {
              points.unshift({ x: 0, y: 0 });
              total++;
            }
            if (currentTotal !== total) {
              this.resizeArrays(total);
            }
            this.points = points;
            this.updateUVs();
            if (colors !== void 0 && colors !== null) {
              this.setColors(colors);
            }
            if (alphas !== void 0 && alphas !== null) {
              this.setAlphas(alphas);
            }
            return this;
          },
          updateUVs: function() {
            var currentUVs = this.uv;
            var total = this.points.length;
            var u0 = this.frame.u0;
            var v0 = this.frame.v0;
            var u1 = this.frame.u1;
            var v1 = this.frame.v1;
            var partH = (u1 - u0) / (total - 1);
            var partV = (v1 - v0) / (total - 1);
            for (var i2 = 0; i2 < total; i2++) {
              var index2 = i2 * 4;
              var uv0;
              var uv1;
              var uv2;
              var uv3;
              if (this.horizontal) {
                if (this._flipX) {
                  uv0 = u1 - i2 * partH;
                  uv2 = u1 - i2 * partH;
                } else {
                  uv0 = u0 + i2 * partH;
                  uv2 = u0 + i2 * partH;
                }
                if (this._flipY) {
                  uv1 = v1;
                  uv3 = v0;
                } else {
                  uv1 = v0;
                  uv3 = v1;
                }
              } else {
                if (this._flipX) {
                  uv0 = u0;
                  uv2 = u1;
                } else {
                  uv0 = u1;
                  uv2 = u0;
                }
                if (this._flipY) {
                  uv1 = v1 - i2 * partV;
                  uv3 = v1 - i2 * partV;
                } else {
                  uv1 = v0 + i2 * partV;
                  uv3 = v0 + i2 * partV;
                }
              }
              currentUVs[index2 + 0] = uv0;
              currentUVs[index2 + 1] = uv1;
              currentUVs[index2 + 2] = uv2;
              currentUVs[index2 + 3] = uv3;
            }
            return this;
          },
          resizeArrays: function(newSize) {
            var colors = this.colors;
            var alphas = this.alphas;
            this.vertices = new Float32Array(newSize * 4);
            this.uv = new Float32Array(newSize * 4);
            colors = new Uint32Array(newSize * 2);
            alphas = new Float32Array(newSize * 2);
            for (var i2 = 0; i2 < newSize * 2; i2++) {
              colors[i2] = 16777215;
              alphas[i2] = 1;
            }
            this.colors = colors;
            this.alphas = alphas;
            this.dirty = true;
            return this;
          },
          updateVertices: function() {
            var perp = this._perp;
            var points = this.points;
            var vertices = this.vertices;
            var total = points.length;
            this.dirty = false;
            if (total < 1) {
              return;
            }
            var nextPoint;
            var lastPoint = points[0];
            var frameSize = this.horizontal ? this.frame.halfHeight : this.frame.halfWidth;
            for (var i2 = 0; i2 < total; i2++) {
              var point = points[i2];
              var index2 = i2 * 4;
              if (i2 < total - 1) {
                nextPoint = points[i2 + 1];
              } else {
                nextPoint = point;
              }
              perp.x = nextPoint.y - lastPoint.y;
              perp.y = -(nextPoint.x - lastPoint.x);
              var perpLength = perp.length();
              perp.x /= perpLength;
              perp.y /= perpLength;
              perp.x *= frameSize;
              perp.y *= frameSize;
              vertices[index2] = point.x + perp.x;
              vertices[index2 + 1] = point.y + perp.y;
              vertices[index2 + 2] = point.x - perp.x;
              vertices[index2 + 3] = point.y - perp.y;
              lastPoint = point;
            }
            return this;
          },
          setDebug: function(graphic, callback) {
            this.debugGraphic = graphic;
            if (!graphic && !callback) {
              this.debugCallback = null;
            } else if (!callback) {
              this.debugCallback = this.renderDebugVerts;
            } else {
              this.debugCallback = callback;
            }
            return this;
          },
          renderDebugVerts: function(src, meshLength, verts) {
            var graphic = src.debugGraphic;
            var px0 = verts[0];
            var py0 = verts[1];
            var px1 = verts[2];
            var py1 = verts[3];
            graphic.lineBetween(px0, py0, px1, py1);
            for (var i2 = 4; i2 < meshLength; i2 += 4) {
              var x0 = verts[i2 + 0];
              var y0 = verts[i2 + 1];
              var x1 = verts[i2 + 2];
              var y1 = verts[i2 + 3];
              graphic.lineBetween(px0, py0, x0, y0);
              graphic.lineBetween(px1, py1, x1, y1);
              graphic.lineBetween(px1, py1, x0, y0);
              graphic.lineBetween(x0, y0, x1, y1);
              px0 = x0;
              py0 = y0;
              px1 = x1;
              py1 = y1;
            }
          },
          preDestroy: function() {
            this.anims.destroy();
            this.anims = void 0;
            this.points = null;
            this.vertices = null;
            this.uv = null;
            this.colors = null;
            this.alphas = null;
            this.debugCallback = null;
            this.debugGraphic = null;
          },
          flipX: {
            get: function() {
              return this._flipX;
            },
            set: function(value) {
              this._flipX = value;
              return this.updateUVs();
            }
          },
          flipY: {
            get: function() {
              return this._flipY;
            },
            set: function(value) {
              this._flipY = value;
              return this.updateUVs();
            }
          }
        });
        module2.exports = Rope;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AddToDOM = __webpack_require__(142);
        var CanvasPool = __webpack_require__(31);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var GameEvents = __webpack_require__(22);
        var GameObject = __webpack_require__(15);
        var GetTextSize = __webpack_require__(458);
        var GetValue = __webpack_require__(6);
        var RemoveFromDOM = __webpack_require__(202);
        var TextRender = __webpack_require__(1088);
        var TextStyle = __webpack_require__(459);
        var Text = new Class({
          Extends: GameObject,
          Mixins: [
            Components.Alpha,
            Components.BlendMode,
            Components.ComputedSize,
            Components.Crop,
            Components.Depth,
            Components.Flip,
            Components.GetBounds,
            Components.Mask,
            Components.Origin,
            Components.Pipeline,
            Components.ScrollFactor,
            Components.Tint,
            Components.Transform,
            Components.Visible,
            TextRender
          ],
          initialize: function Text2(scene, x2, y2, text, style) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            GameObject.call(this, scene, "Text");
            this.renderer = scene.sys.renderer;
            this.setPosition(x2, y2);
            this.setOrigin(0, 0);
            this.initPipeline();
            this.canvas = CanvasPool.create(this);
            this.context = this.canvas.getContext("2d");
            this.style = new TextStyle(this, style);
            this.autoRound = true;
            this.splitRegExp = /(?:\r\n|\r|\n)/;
            this._text = void 0;
            this.padding = { left: 0, right: 0, top: 0, bottom: 0 };
            this.width = 1;
            this.height = 1;
            this.lineSpacing = 0;
            this.dirty = false;
            if (this.style.resolution === 0) {
              this.style.resolution = 1;
            }
            this._crop = this.resetCropObject();
            this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);
            this.frame = this.texture.get();
            this.frame.source.resolution = this.style.resolution;
            if (this.renderer && this.renderer.gl) {
              this.renderer.deleteTexture(this.frame.source.glTexture);
              this.frame.source.glTexture = null;
            }
            this.initRTL();
            this.setText(text);
            if (style && style.padding) {
              this.setPadding(style.padding);
            }
            if (style && style.lineSpacing) {
              this.setLineSpacing(style.lineSpacing);
            }
            scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function() {
              this.dirty = true;
            }, this);
          },
          initRTL: function() {
            if (!this.style.rtl) {
              return;
            }
            this.canvas.dir = "rtl";
            this.context.direction = "rtl";
            this.canvas.style.display = "none";
            AddToDOM(this.canvas, this.scene.sys.canvas);
            this.originX = 1;
          },
          runWordWrap: function(text) {
            var style = this.style;
            if (style.wordWrapCallback) {
              var wrappedLines = style.wordWrapCallback.call(style.wordWrapCallbackScope, text, this);
              if (Array.isArray(wrappedLines)) {
                wrappedLines = wrappedLines.join("\n");
              }
              return wrappedLines;
            } else if (style.wordWrapWidth) {
              if (style.wordWrapUseAdvanced) {
                return this.advancedWordWrap(text, this.context, this.style.wordWrapWidth);
              } else {
                return this.basicWordWrap(text, this.context, this.style.wordWrapWidth);
              }
            } else {
              return text;
            }
          },
          advancedWordWrap: function(text, context, wordWrapWidth) {
            var output = "";
            var lines = text.replace(/ +/gi, " ").split(this.splitRegExp);
            var linesCount = lines.length;
            for (var i2 = 0; i2 < linesCount; i2++) {
              var line = lines[i2];
              var out = "";
              line = line.replace(/^ *|\s*$/gi, "");
              var lineWidth = context.measureText(line).width;
              if (lineWidth < wordWrapWidth) {
                output += line + "\n";
                continue;
              }
              var currentLineWidth = wordWrapWidth;
              var words = line.split(" ");
              for (var j = 0; j < words.length; j++) {
                var word = words[j];
                var wordWithSpace = word + " ";
                var wordWidth = context.measureText(wordWithSpace).width;
                if (wordWidth > currentLineWidth) {
                  if (j === 0) {
                    var newWord = wordWithSpace;
                    while (newWord.length) {
                      newWord = newWord.slice(0, -1);
                      wordWidth = context.measureText(newWord).width;
                      if (wordWidth <= currentLineWidth) {
                        break;
                      }
                    }
                    if (!newWord.length) {
                      throw new Error("This text's wordWrapWidth setting is less than a single character!");
                    }
                    var secondPart = word.substr(newWord.length);
                    words[j] = secondPart;
                    out += newWord;
                  }
                  var offset = words[j].length ? j : j + 1;
                  var remainder = words.slice(offset).join(" ").replace(/[ \n]*$/gi, "");
                  lines[i2 + 1] = remainder + " " + (lines[i2 + 1] || "");
                  linesCount = lines.length;
                  break;
                } else {
                  out += wordWithSpace;
                  currentLineWidth -= wordWidth;
                }
              }
              output += out.replace(/[ \n]*$/gi, "") + "\n";
            }
            output = output.replace(/[\s|\n]*$/gi, "");
            return output;
          },
          basicWordWrap: function(text, context, wordWrapWidth) {
            var result = "";
            var lines = text.split(this.splitRegExp);
            var lastLineIndex = lines.length - 1;
            var whiteSpaceWidth = context.measureText(" ").width;
            for (var i2 = 0; i2 <= lastLineIndex; i2++) {
              var spaceLeft = wordWrapWidth;
              var words = lines[i2].split(" ");
              var lastWordIndex = words.length - 1;
              for (var j = 0; j <= lastWordIndex; j++) {
                var word = words[j];
                var wordWidth = context.measureText(word).width;
                var wordWidthWithSpace = wordWidth;
                if (j < lastWordIndex) {
                  wordWidthWithSpace += whiteSpaceWidth;
                }
                if (wordWidthWithSpace > spaceLeft) {
                  if (j > 0) {
                    result += "\n";
                    spaceLeft = wordWrapWidth;
                  }
                }
                result += word;
                if (j < lastWordIndex) {
                  result += " ";
                  spaceLeft -= wordWidthWithSpace;
                } else {
                  spaceLeft -= wordWidth;
                }
              }
              if (i2 < lastLineIndex) {
                result += "\n";
              }
            }
            return result;
          },
          getWrappedText: function(text) {
            if (text === void 0) {
              text = this._text;
            }
            this.style.syncFont(this.canvas, this.context);
            var wrappedLines = this.runWordWrap(text);
            return wrappedLines.split(this.splitRegExp);
          },
          setText: function(value) {
            if (!value && value !== 0) {
              value = "";
            }
            if (Array.isArray(value)) {
              value = value.join("\n");
            }
            if (value !== this._text) {
              this._text = value.toString();
              this.updateText();
            }
            return this;
          },
          setStyle: function(style) {
            return this.style.setStyle(style);
          },
          setFont: function(font) {
            return this.style.setFont(font);
          },
          setFontFamily: function(family) {
            return this.style.setFontFamily(family);
          },
          setFontSize: function(size) {
            return this.style.setFontSize(size);
          },
          setFontStyle: function(style) {
            return this.style.setFontStyle(style);
          },
          setFixedSize: function(width, height) {
            return this.style.setFixedSize(width, height);
          },
          setBackgroundColor: function(color) {
            return this.style.setBackgroundColor(color);
          },
          setFill: function(fillStyle) {
            return this.style.setFill(fillStyle);
          },
          setColor: function(color) {
            return this.style.setColor(color);
          },
          setStroke: function(color, thickness) {
            return this.style.setStroke(color, thickness);
          },
          setShadow: function(x2, y2, color, blur, shadowStroke, shadowFill) {
            return this.style.setShadow(x2, y2, color, blur, shadowStroke, shadowFill);
          },
          setShadowOffset: function(x2, y2) {
            return this.style.setShadowOffset(x2, y2);
          },
          setShadowColor: function(color) {
            return this.style.setShadowColor(color);
          },
          setShadowBlur: function(blur) {
            return this.style.setShadowBlur(blur);
          },
          setShadowStroke: function(enabled) {
            return this.style.setShadowStroke(enabled);
          },
          setShadowFill: function(enabled) {
            return this.style.setShadowFill(enabled);
          },
          setWordWrapWidth: function(width, useAdvancedWrap) {
            return this.style.setWordWrapWidth(width, useAdvancedWrap);
          },
          setWordWrapCallback: function(callback, scope) {
            return this.style.setWordWrapCallback(callback, scope);
          },
          setAlign: function(align) {
            return this.style.setAlign(align);
          },
          setResolution: function(value) {
            return this.style.setResolution(value);
          },
          setLineSpacing: function(value) {
            this.lineSpacing = value;
            return this.updateText();
          },
          setPadding: function(left, top, right, bottom) {
            if (typeof left === "object") {
              var config = left;
              var x2 = GetValue(config, "x", null);
              if (x2 !== null) {
                left = x2;
                right = x2;
              } else {
                left = GetValue(config, "left", 0);
                right = GetValue(config, "right", left);
              }
              var y2 = GetValue(config, "y", null);
              if (y2 !== null) {
                top = y2;
                bottom = y2;
              } else {
                top = GetValue(config, "top", 0);
                bottom = GetValue(config, "bottom", top);
              }
            } else {
              if (left === void 0) {
                left = 0;
              }
              if (top === void 0) {
                top = left;
              }
              if (right === void 0) {
                right = left;
              }
              if (bottom === void 0) {
                bottom = top;
              }
            }
            this.padding.left = left;
            this.padding.top = top;
            this.padding.right = right;
            this.padding.bottom = bottom;
            return this.updateText();
          },
          setMaxLines: function(max) {
            return this.style.setMaxLines(max);
          },
          updateText: function() {
            var canvas = this.canvas;
            var context = this.context;
            var style = this.style;
            var resolution = style.resolution;
            var size = style.metrics;
            style.syncFont(canvas, context);
            var outputText = this._text;
            if (style.wordWrapWidth || style.wordWrapCallback) {
              outputText = this.runWordWrap(this._text);
            }
            var lines = outputText.split(this.splitRegExp);
            var textSize = GetTextSize(this, size, lines);
            var padding = this.padding;
            var textWidth;
            if (style.fixedWidth === 0) {
              this.width = textSize.width + padding.left + padding.right;
              textWidth = textSize.width;
            } else {
              this.width = style.fixedWidth;
              textWidth = this.width - padding.left - padding.right;
              if (textWidth < textSize.width) {
                textWidth = textSize.width;
              }
            }
            if (style.fixedHeight === 0) {
              this.height = textSize.height + padding.top + padding.bottom;
            } else {
              this.height = style.fixedHeight;
            }
            var w2 = this.width;
            var h2 = this.height;
            this.updateDisplayOrigin();
            w2 *= resolution;
            h2 *= resolution;
            w2 = Math.max(w2, 1);
            h2 = Math.max(h2, 1);
            if (canvas.width !== w2 || canvas.height !== h2) {
              canvas.width = w2;
              canvas.height = h2;
              this.frame.setSize(w2, h2);
              style.syncFont(canvas, context);
            } else {
              context.clearRect(0, 0, w2, h2);
            }
            context.save();
            context.scale(resolution, resolution);
            if (style.backgroundColor) {
              context.fillStyle = style.backgroundColor;
              context.fillRect(0, 0, w2, h2);
            }
            style.syncStyle(canvas, context);
            context.textBaseline = "alphabetic";
            context.translate(padding.left, padding.top);
            var linePositionX;
            var linePositionY;
            for (var i2 = 0; i2 < textSize.lines; i2++) {
              linePositionX = style.strokeThickness / 2;
              linePositionY = style.strokeThickness / 2 + i2 * textSize.lineHeight + size.ascent;
              if (i2 > 0) {
                linePositionY += textSize.lineSpacing * i2;
              }
              if (style.rtl) {
                linePositionX = w2 - linePositionX;
              } else if (style.align === "right") {
                linePositionX += textWidth - textSize.lineWidths[i2];
              } else if (style.align === "center") {
                linePositionX += (textWidth - textSize.lineWidths[i2]) / 2;
              } else if (style.align === "justify") {
                var minimumLengthToApplyJustification = 0.85;
                if (textSize.lineWidths[i2] / textSize.width >= minimumLengthToApplyJustification) {
                  var extraSpace = textSize.width - textSize.lineWidths[i2];
                  var spaceSize = context.measureText(" ").width;
                  var trimmedLine = lines[i2].trim();
                  var array = trimmedLine.split(" ");
                  extraSpace += (lines[i2].length - trimmedLine.length) * spaceSize;
                  var extraSpaceCharacters = Math.floor(extraSpace / spaceSize);
                  var idx = 0;
                  while (extraSpaceCharacters > 0) {
                    array[idx] += " ";
                    idx = (idx + 1) % (array.length - 1 || 1);
                    --extraSpaceCharacters;
                  }
                  lines[i2] = array.join(" ");
                }
              }
              if (this.autoRound) {
                linePositionX = Math.round(linePositionX);
                linePositionY = Math.round(linePositionY);
              }
              if (style.strokeThickness) {
                this.style.syncShadow(context, style.shadowStroke);
                context.strokeText(lines[i2], linePositionX, linePositionY);
              }
              if (style.color) {
                this.style.syncShadow(context, style.shadowFill);
                context.fillText(lines[i2], linePositionX, linePositionY);
              }
            }
            context.restore();
            if (this.renderer && this.renderer.gl) {
              this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
              this.frame.glTexture = this.frame.source.glTexture;
            }
            this.dirty = true;
            var input = this.input;
            if (input && !input.customHitArea) {
              input.hitArea.width = this.width;
              input.hitArea.height = this.height;
            }
            return this;
          },
          getTextMetrics: function() {
            return this.style.getTextMetrics();
          },
          text: {
            get: function() {
              return this._text;
            },
            set: function(value) {
              this.setText(value);
            }
          },
          toJSON: function() {
            var out = Components.ToJSON(this);
            var data = {
              autoRound: this.autoRound,
              text: this._text,
              style: this.style.toJSON(),
              padding: {
                left: this.padding.left,
                right: this.padding.right,
                top: this.padding.top,
                bottom: this.padding.bottom
              }
            };
            out.data = data;
            return out;
          },
          preDestroy: function() {
            if (this.style.rtl) {
              RemoveFromDOM(this.canvas);
            }
            CanvasPool.remove(this.canvas);
            this.texture.destroy();
          }
        });
        module2.exports = Text;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CanvasPool = __webpack_require__(31);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var GameEvents = __webpack_require__(22);
        var GameObject = __webpack_require__(15);
        var GetPowerOfTwo = __webpack_require__(361);
        var Smoothing = __webpack_require__(192);
        var TileSpriteRender = __webpack_require__(1091);
        var Vector2 = __webpack_require__(3);
        var _FLAG = 8;
        var TileSprite = new Class({
          Extends: GameObject,
          Mixins: [
            Components.Alpha,
            Components.BlendMode,
            Components.ComputedSize,
            Components.Crop,
            Components.Depth,
            Components.Flip,
            Components.GetBounds,
            Components.Mask,
            Components.Origin,
            Components.Pipeline,
            Components.ScrollFactor,
            Components.Tint,
            Components.Transform,
            Components.Visible,
            TileSpriteRender
          ],
          initialize: function TileSprite2(scene, x2, y2, width, height, textureKey, frameKey) {
            var renderer = scene.sys.renderer;
            GameObject.call(this, scene, "TileSprite");
            var displayTexture = scene.sys.textures.get(textureKey);
            var displayFrame = displayTexture.get(frameKey);
            if (!width || !height) {
              width = displayFrame.width;
              height = displayFrame.height;
            } else {
              width = Math.floor(width);
              height = Math.floor(height);
            }
            this._tilePosition = new Vector2();
            this._tileScale = new Vector2(1, 1);
            this.dirty = false;
            this.renderer = renderer;
            this.canvas = CanvasPool.create(this, width, height);
            this.context = this.canvas.getContext("2d");
            this.displayTexture = displayTexture;
            this.displayFrame = displayFrame;
            this._crop = this.resetCropObject();
            this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);
            this.frame = this.texture.get();
            this.potWidth = GetPowerOfTwo(displayFrame.width);
            this.potHeight = GetPowerOfTwo(displayFrame.height);
            this.fillCanvas = CanvasPool.create2D(this, this.potWidth, this.potHeight);
            this.fillContext = this.fillCanvas.getContext("2d");
            this.fillPattern = null;
            this.setPosition(x2, y2);
            this.setSize(width, height);
            this.setFrame(frameKey);
            this.setOriginFromFrame();
            this.initPipeline();
            scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function(renderer2) {
              if (!renderer2) {
                return;
              }
              var gl2 = renderer2.gl;
              this.dirty = true;
              this.fillPattern = null;
              this.fillPattern = renderer2.createTexture2D(0, gl2.LINEAR, gl2.LINEAR, gl2.REPEAT, gl2.REPEAT, gl2.RGBA, this.fillCanvas, this.potWidth, this.potHeight);
            }, this);
          },
          setTexture: function(key, frame) {
            this.displayTexture = this.scene.sys.textures.get(key);
            return this.setFrame(frame);
          },
          setFrame: function(frame) {
            var newFrame = this.displayTexture.get(frame);
            this.potWidth = GetPowerOfTwo(newFrame.width);
            this.potHeight = GetPowerOfTwo(newFrame.height);
            this.canvas.width = 0;
            if (!newFrame.cutWidth || !newFrame.cutHeight) {
              this.renderFlags &= ~_FLAG;
            } else {
              this.renderFlags |= _FLAG;
            }
            this.displayFrame = newFrame;
            this.dirty = true;
            this.updateTileTexture();
            return this;
          },
          setTilePosition: function(x2, y2) {
            if (x2 !== void 0) {
              this.tilePositionX = x2;
            }
            if (y2 !== void 0) {
              this.tilePositionY = y2;
            }
            return this;
          },
          setTileScale: function(x2, y2) {
            if (x2 === void 0) {
              x2 = this.tileScaleX;
            }
            if (y2 === void 0) {
              y2 = x2;
            }
            this.tileScaleX = x2;
            this.tileScaleY = y2;
            return this;
          },
          updateTileTexture: function() {
            if (!this.dirty || !this.renderer) {
              return;
            }
            var frame = this.displayFrame;
            if (frame.source.isRenderTexture || frame.source.isGLTexture) {
              console.warn("TileSprites can only use Image or Canvas based textures");
              this.dirty = false;
              return;
            }
            var ctx = this.fillContext;
            var canvas = this.fillCanvas;
            var fw = this.potWidth;
            var fh2 = this.potHeight;
            if (!this.renderer || !this.renderer.gl) {
              fw = frame.cutWidth;
              fh2 = frame.cutHeight;
            }
            ctx.clearRect(0, 0, fw, fh2);
            canvas.width = fw;
            canvas.height = fh2;
            ctx.drawImage(frame.source.image, frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight, 0, 0, fw, fh2);
            if (this.renderer && this.renderer.gl) {
              this.fillPattern = this.renderer.canvasToTexture(canvas, this.fillPattern);
            } else {
              this.fillPattern = ctx.createPattern(canvas, "repeat");
            }
            this.updateCanvas();
            this.dirty = false;
          },
          updateCanvas: function() {
            var canvas = this.canvas;
            if (canvas.width !== this.width || canvas.height !== this.height) {
              canvas.width = this.width;
              canvas.height = this.height;
              this.frame.setSize(this.width, this.height);
              this.updateDisplayOrigin();
              this.dirty = true;
            }
            if (!this.dirty || this.renderer && this.renderer.gl) {
              this.dirty = false;
              return;
            }
            var ctx = this.context;
            if (!this.scene.sys.game.config.antialias) {
              Smoothing.disable(ctx);
            }
            var scaleX = this._tileScale.x;
            var scaleY = this._tileScale.y;
            var positionX = this._tilePosition.x;
            var positionY = this._tilePosition.y;
            ctx.clearRect(0, 0, this.width, this.height);
            ctx.save();
            ctx.scale(scaleX, scaleY);
            ctx.translate(-positionX, -positionY);
            ctx.fillStyle = this.fillPattern;
            ctx.fillRect(positionX, positionY, this.width / scaleX, this.height / scaleY);
            ctx.restore();
            this.dirty = false;
          },
          preDestroy: function() {
            if (this.renderer && this.renderer.gl) {
              this.renderer.deleteTexture(this.fillPattern);
            }
            CanvasPool.remove(this.canvas);
            CanvasPool.remove(this.fillCanvas);
            this.fillPattern = null;
            this.fillContext = null;
            this.fillCanvas = null;
            this.displayTexture = null;
            this.displayFrame = null;
            this.texture.destroy();
            this.renderer = null;
          },
          tilePositionX: {
            get: function() {
              return this._tilePosition.x;
            },
            set: function(value) {
              this._tilePosition.x = value;
              this.dirty = true;
            }
          },
          tilePositionY: {
            get: function() {
              return this._tilePosition.y;
            },
            set: function(value) {
              this._tilePosition.y = value;
              this.dirty = true;
            }
          },
          tileScaleX: {
            get: function() {
              return this._tileScale.x;
            },
            set: function(value) {
              this._tileScale.x = value;
              this.dirty = true;
            }
          },
          tileScaleY: {
            get: function() {
              return this._tileScale.y;
            },
            set: function(value) {
              this._tileScale.y = value;
              this.dirty = true;
            }
          }
        });
        module2.exports = TileSprite;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Clamp = __webpack_require__(18);
        var Components = __webpack_require__(11);
        var Events = __webpack_require__(75);
        var GameEvents = __webpack_require__(22);
        var InputEvents = __webpack_require__(51);
        var GameObject = __webpack_require__(15);
        var SoundEvents = __webpack_require__(70);
        var UUID2 = __webpack_require__(222);
        var VideoRender = __webpack_require__(1094);
        var MATH_CONST = __webpack_require__(14);
        var Video = new Class({
          Extends: GameObject,
          Mixins: [
            Components.Alpha,
            Components.BlendMode,
            Components.Depth,
            Components.Flip,
            Components.GetBounds,
            Components.Mask,
            Components.Origin,
            Components.Pipeline,
            Components.ScrollFactor,
            Components.Size,
            Components.TextureCrop,
            Components.Tint,
            Components.Transform,
            Components.Visible,
            VideoRender
          ],
          initialize: function Video2(scene, x2, y2, key) {
            GameObject.call(this, scene, "Video");
            this.video = null;
            this.videoTexture = null;
            this.videoTextureSource = null;
            this.snapshotTexture = null;
            this.flipY = false;
            this._key = UUID2();
            this.touchLocked = true;
            this.playWhenUnlocked = false;
            this.retryLimit = 20;
            this.retry = 0;
            this.retryInterval = 500;
            this._retryID = null;
            this._systemMuted = false;
            this._codeMuted = false;
            this._systemPaused = false;
            this._codePaused = false;
            this._callbacks = {
              play: this.playHandler.bind(this),
              error: this.loadErrorHandler.bind(this),
              end: this.completeHandler.bind(this),
              time: this.timeUpdateHandler.bind(this),
              seeking: this.seekingHandler.bind(this),
              seeked: this.seekedHandler.bind(this)
            };
            this._crop = this.resetCropObject();
            this.markers = {};
            this._markerIn = -1;
            this._markerOut = MATH_CONST.MAX_SAFE_INTEGER;
            this._lastUpdate = 0;
            this._cacheKey = "";
            this._isSeeking = false;
            this.removeVideoElementOnDestroy = false;
            this.setPosition(x2, y2);
            this.initPipeline();
            if (key) {
              this.changeSource(key, false);
            }
            var game = scene.sys.game.events;
            game.on(GameEvents.PAUSE, this.globalPause, this);
            game.on(GameEvents.RESUME, this.globalResume, this);
            var sound = scene.sys.sound;
            if (sound) {
              sound.on(SoundEvents.GLOBAL_MUTE, this.globalMute, this);
            }
          },
          addedToScene: function() {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function() {
            this.scene.sys.updateList.remove(this);
          },
          play: function(loop, markerIn, markerOut) {
            if (this.touchLocked && this.playWhenUnlocked || this.isPlaying()) {
              return this;
            }
            var video = this.video;
            if (!video) {
              console.warn("Video not loaded");
              return this;
            }
            if (loop === void 0) {
              loop = video.loop;
            }
            var sound = this.scene.sys.sound;
            if (sound && sound.mute) {
              this.setMute(true);
            }
            if (!isNaN(markerIn)) {
              this._markerIn = markerIn;
            }
            if (!isNaN(markerOut) && markerOut > markerIn) {
              this._markerOut = markerOut;
            }
            video.loop = loop;
            var callbacks = this._callbacks;
            var playPromise = video.play();
            if (playPromise !== void 0) {
              playPromise.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this));
            } else {
              video.addEventListener("playing", callbacks.play, true);
              if (video.readyState < 2) {
                this.retry = this.retryLimit;
                this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
              }
            }
            video.addEventListener("ended", callbacks.end, true);
            video.addEventListener("timeupdate", callbacks.time, true);
            video.addEventListener("seeking", callbacks.seeking, true);
            video.addEventListener("seeked", callbacks.seeked, true);
            return this;
          },
          changeSource: function(key, autoplay, loop, markerIn, markerOut) {
            if (autoplay === void 0) {
              autoplay = true;
            }
            var currentVideo = this.video;
            if (currentVideo) {
              this.stop();
            }
            var newVideo = this.scene.sys.cache.video.get(key);
            if (newVideo) {
              this.video = newVideo;
              this._cacheKey = key;
              this._codePaused = newVideo.paused;
              this._codeMuted = newVideo.muted;
              if (this.videoTexture) {
                this.scene.sys.textures.remove(this._key);
                this.videoTexture = this.scene.sys.textures.create(this._key, newVideo, newVideo.videoWidth, newVideo.videoHeight);
                this.videoTextureSource = this.videoTexture.source[0];
                this.videoTexture.add("__BASE", 0, 0, 0, newVideo.videoWidth, newVideo.videoHeight);
                this.setTexture(this.videoTexture);
                this.setSizeToFrame();
                this.updateDisplayOrigin();
                this.emit(Events.VIDEO_CREATED, this, newVideo.videoWidth, newVideo.videoHeight);
              } else {
                this.updateTexture();
              }
              newVideo.currentTime = 0;
              this._lastUpdate = 0;
              if (autoplay) {
                this.play(loop, markerIn, markerOut);
              }
            } else {
              this.video = null;
            }
            return this;
          },
          addMarker: function(key, markerIn, markerOut) {
            if (!isNaN(markerIn) && markerIn >= 0 && !isNaN(markerOut)) {
              this.markers[key] = [markerIn, markerOut];
            }
            return this;
          },
          playMarker: function(key, loop) {
            var marker = this.markers[key];
            if (marker) {
              this.play(loop, marker[0], marker[1]);
            }
            return this;
          },
          removeMarker: function(key) {
            delete this.markers[key];
            return this;
          },
          snapshot: function(width, height) {
            if (width === void 0) {
              width = this.width;
            }
            if (height === void 0) {
              height = this.height;
            }
            return this.snapshotArea(0, 0, this.width, this.height, width, height);
          },
          snapshotArea: function(x2, y2, srcWidth, srcHeight, destWidth, destHeight) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (srcWidth === void 0) {
              srcWidth = this.width;
            }
            if (srcHeight === void 0) {
              srcHeight = this.height;
            }
            if (destWidth === void 0) {
              destWidth = srcWidth;
            }
            if (destHeight === void 0) {
              destHeight = srcHeight;
            }
            var video = this.video;
            var snap = this.snapshotTexture;
            if (!snap) {
              snap = this.scene.sys.textures.createCanvas(UUID2(), destWidth, destHeight);
              this.snapshotTexture = snap;
              if (video) {
                snap.context.drawImage(video, x2, y2, srcWidth, srcHeight, 0, 0, destWidth, destHeight);
              }
            } else {
              snap.setSize(destWidth, destHeight);
              if (video) {
                snap.context.drawImage(video, x2, y2, srcWidth, srcHeight, 0, 0, destWidth, destHeight);
              }
            }
            return snap.update();
          },
          saveSnapshotTexture: function(key) {
            if (this.snapshotTexture) {
              this.scene.sys.textures.renameTexture(this.snapshotTexture.key, key);
            } else {
              this.snapshotTexture = this.scene.sys.textures.createCanvas(key, this.width, this.height);
            }
            return this.snapshotTexture;
          },
          loadURL: function(url, loadEvent, noAudio) {
            if (noAudio === void 0) {
              noAudio = false;
            }
            if (this.video) {
              this.stop();
            }
            if (this.videoTexture) {
              this.scene.sys.textures.remove(this._key);
            }
            var video = document.createElement("video");
            video.controls = false;
            if (noAudio) {
              video.muted = true;
              video.defaultMuted = true;
              video.setAttribute("autoplay", "autoplay");
            }
            video.setAttribute("playsinline", "playsinline");
            video.setAttribute("preload", "auto");
            video.addEventListener("error", this._callbacks.error, true);
            video.src = url;
            video.load();
            this.video = video;
            return this;
          },
          loadMediaStream: function(stream, loadEvent, noAudio) {
            if (noAudio === void 0) {
              noAudio = false;
            }
            if (this.video) {
              this.stop();
            }
            if (this.videoTexture) {
              this.scene.sys.textures.remove(this._key);
            }
            var video = document.createElement("video");
            video.controls = false;
            if (noAudio) {
              video.muted = true;
              video.defaultMuted = true;
              video.setAttribute("autoplay", "autoplay");
            }
            video.setAttribute("playsinline", "playsinline");
            video.setAttribute("preload", "auto");
            video.addEventListener("error", this._callbacks.error, true);
            try {
              video.srcObject = stream;
            } catch (error) {
              video.src = window.URL.createObjectURL(stream);
            }
            video.load();
            this.video = video;
            return this;
          },
          playPromiseSuccessHandler: function() {
            this._codePaused = false;
            this.touchLocked = false;
            this.emit(Events.VIDEO_PLAY, this);
            if (this._markerIn > -1) {
              this.video.currentTime = this._markerIn;
            }
          },
          playPromiseErrorHandler: function(error) {
            this.scene.sys.input.once(InputEvents.POINTER_DOWN, this.unlockHandler, this);
            this.touchLocked = true;
            this.playWhenUnlocked = true;
            this.emit(Events.VIDEO_ERROR, this, error);
          },
          playHandler: function() {
            this._codePaused = false;
            this.touchLocked = false;
            this.emit(Events.VIDEO_PLAY, this);
            this.video.removeEventListener("playing", this._callbacks.play, true);
          },
          loadErrorHandler: function(event) {
            this.stop();
            this.emit(Events.VIDEO_ERROR, this, event);
          },
          unlockHandler: function() {
            this.touchLocked = false;
            this.playWhenUnlocked = false;
            this.emit(Events.VIDEO_UNLOCKED, this);
            if (this._markerIn > -1) {
              this.video.currentTime = this._markerIn;
            }
            this.video.play();
            this.emit(Events.VIDEO_PLAY, this);
          },
          completeHandler: function() {
            this.emit(Events.VIDEO_COMPLETE, this);
          },
          timeUpdateHandler: function() {
            if (this.video && this.video.currentTime < this._lastUpdate) {
              this.emit(Events.VIDEO_LOOP, this);
              this._lastUpdate = 0;
            }
          },
          preUpdate: function() {
            var video = this.video;
            if (video) {
              var currentTime = video.currentTime;
              if (currentTime !== this._lastUpdate) {
                this._lastUpdate = currentTime;
                this.updateTexture();
                if (currentTime >= this._markerOut) {
                  if (video.loop) {
                    video.currentTime = this._markerIn;
                    this.updateTexture();
                    this._lastUpdate = currentTime;
                    this.emit(Events.VIDEO_LOOP, this);
                  } else {
                    this.emit(Events.VIDEO_COMPLETE, this);
                    this.stop();
                  }
                }
              }
            }
          },
          checkVideoProgress: function() {
            if (this.video.readyState >= 2) {
              this.updateTexture();
            } else {
              this.retry--;
              if (this.retry > 0) {
                this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
              } else {
                this.emit(Events.VIDEO_TIMEOUT, this);
              }
            }
          },
          updateTexture: function() {
            var video = this.video;
            var width = video.videoWidth;
            var height = video.videoHeight;
            if (!this.videoTexture) {
              this.videoTexture = this.scene.sys.textures.create(this._key, video, width, height);
              this.videoTextureSource = this.videoTexture.source[0];
              this.videoTexture.add("__BASE", 0, 0, 0, width, height);
              this.setTexture(this.videoTexture);
              this.setSizeToFrame();
              this.updateDisplayOrigin();
              this.emit(Events.VIDEO_CREATED, this, width, height);
            } else {
              var textureSource = this.videoTextureSource;
              if (textureSource.source !== video) {
                textureSource.source = video;
                textureSource.width = width;
                textureSource.height = height;
              }
              textureSource.update();
            }
          },
          getVideoKey: function() {
            return this._cacheKey;
          },
          seekTo: function(value) {
            var video = this.video;
            if (video) {
              var duration = video.duration;
              if (duration !== Infinity && !isNaN(duration)) {
                var seekTime = duration * value;
                this.setCurrentTime(seekTime);
              }
            }
            return this;
          },
          getCurrentTime: function() {
            return this.video ? this.video.currentTime : 0;
          },
          setCurrentTime: function(value) {
            var video = this.video;
            if (video) {
              if (typeof value === "string") {
                var op = value[0];
                var num = parseFloat(value.substr(1));
                if (op === "+") {
                  value = video.currentTime + num;
                } else if (op === "-") {
                  value = video.currentTime - num;
                }
              }
              video.currentTime = value;
              this._lastUpdate = value;
            }
            return this;
          },
          isSeeking: function() {
            return this._isSeeking;
          },
          seekingHandler: function() {
            this._isSeeking = true;
            this.emit(Events.VIDEO_SEEKING, this);
          },
          seekedHandler: function() {
            this._isSeeking = false;
            this.emit(Events.VIDEO_SEEKED, this);
            var video = this.video;
            if (video) {
              this.updateTexture();
            }
          },
          getProgress: function() {
            var video = this.video;
            if (video) {
              var now = video.currentTime;
              var duration = video.duration;
              if (duration !== Infinity && !isNaN(duration)) {
                return now / duration;
              }
            }
            return 0;
          },
          getDuration: function() {
            return this.video ? this.video.duration : 0;
          },
          setMute: function(value) {
            if (value === void 0) {
              value = true;
            }
            this._codeMuted = value;
            var video = this.video;
            if (video) {
              video.muted = this._systemMuted ? true : value;
            }
            return this;
          },
          isMuted: function() {
            return this._codeMuted;
          },
          globalMute: function(soundManager, value) {
            this._systemMuted = value;
            var video = this.video;
            if (video) {
              video.muted = this._codeMuted ? true : value;
            }
          },
          globalPause: function() {
            this._systemPaused = true;
            if (this.video) {
              this.video.pause();
            }
          },
          globalResume: function() {
            this._systemPaused = false;
            if (this.video && !this._codePaused) {
              this.video.play();
            }
          },
          setPaused: function(value) {
            if (value === void 0) {
              value = true;
            }
            var video = this.video;
            this._codePaused = value;
            if (video) {
              if (value) {
                if (!video.paused) {
                  video.pause();
                }
              } else if (!value) {
                if (video.paused && !this._systemPaused) {
                  video.play();
                }
              }
            }
            return this;
          },
          getVolume: function() {
            return this.video ? this.video.volume : 1;
          },
          setVolume: function(value) {
            if (value === void 0) {
              value = 1;
            }
            if (this.video) {
              this.video.volume = Clamp(value, 0, 1);
            }
            return this;
          },
          getPlaybackRate: function() {
            return this.video ? this.video.playbackRate : 1;
          },
          setPlaybackRate: function(rate) {
            if (this.video) {
              this.video.playbackRate = rate;
            }
            return this;
          },
          getLoop: function() {
            return this.video ? this.video.loop : false;
          },
          setLoop: function(value) {
            if (value === void 0) {
              value = true;
            }
            if (this.video) {
              this.video.loop = value;
            }
            return this;
          },
          isPlaying: function() {
            return this.video ? !(this.video.paused || this.video.ended) : false;
          },
          isPaused: function() {
            return this.video && this.video.paused || this._codePaused || this._systemPaused;
          },
          saveTexture: function(key, flipY) {
            if (flipY === void 0) {
              flipY = false;
            }
            if (this.videoTexture) {
              this.scene.sys.textures.renameTexture(this._key, key);
            }
            this._key = key;
            this.flipY = flipY;
            if (this.videoTextureSource) {
              this.videoTextureSource.setFlipY(flipY);
            }
            return this.videoTexture;
          },
          stop: function() {
            var video = this.video;
            if (video) {
              var callbacks = this._callbacks;
              for (var callback in callbacks) {
                video.removeEventListener(callback, callbacks[callback], true);
              }
              video.pause();
            }
            if (this._retryID) {
              window.clearTimeout(this._retryID);
            }
            this.emit(Events.VIDEO_STOP, this);
            return this;
          },
          removeVideoElement: function() {
            var video = this.video;
            if (!video) {
              return;
            }
            if (video.parentNode) {
              video.parentNode.removeChild(video);
            }
            while (video.hasChildNodes()) {
              video.removeChild(video.firstChild);
            }
            video.removeAttribute("autoplay");
            video.removeAttribute("src");
            this.video = null;
          },
          preDestroy: function() {
            this.stop();
            if (this.removeVideoElementOnDestroy) {
              this.removeVideoElement();
            }
            var game = this.scene.sys.game.events;
            game.off(GameEvents.PAUSE, this.globalPause, this);
            game.off(GameEvents.RESUME, this.globalResume, this);
            var sound = this.scene.sys.sound;
            if (sound) {
              sound.off(SoundEvents.GLOBAL_MUTE, this.globalMute, this);
            }
            if (this._retryID) {
              window.clearTimeout(this._retryID);
            }
          }
        });
        module2.exports = Video;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Contains = __webpack_require__(228);
        var GetPoints = __webpack_require__(470);
        var GEOM_CONST = __webpack_require__(56);
        var Polygon = new Class({
          initialize: function Polygon2(points) {
            this.type = GEOM_CONST.POLYGON;
            this.area = 0;
            this.points = [];
            if (points) {
              this.setTo(points);
            }
          },
          contains: function(x2, y2) {
            return Contains(this, x2, y2);
          },
          setTo: function(points) {
            this.area = 0;
            this.points = [];
            if (typeof points === "string") {
              points = points.split(" ");
            }
            if (!Array.isArray(points)) {
              return this;
            }
            var p2;
            var y0 = Number.MAX_VALUE;
            for (var i2 = 0; i2 < points.length; i2++) {
              p2 = { x: 0, y: 0 };
              if (typeof points[i2] === "number" || typeof points[i2] === "string") {
                p2.x = parseFloat(points[i2]);
                p2.y = parseFloat(points[i2 + 1]);
                i2++;
              } else if (Array.isArray(points[i2])) {
                p2.x = points[i2][0];
                p2.y = points[i2][1];
              } else {
                p2.x = points[i2].x;
                p2.y = points[i2].y;
              }
              this.points.push(p2);
              if (p2.y < y0) {
                y0 = p2.y;
              }
            }
            this.calculateArea(y0);
            return this;
          },
          calculateArea: function() {
            if (this.points.length < 3) {
              this.area = 0;
              return this.area;
            }
            var sum = 0;
            var p1;
            var p2;
            for (var i2 = 0; i2 < this.points.length - 1; i2++) {
              p1 = this.points[i2];
              p2 = this.points[i2 + 1];
              sum += (p2.x - p1.x) * (p1.y + p2.y);
            }
            p1 = this.points[0];
            p2 = this.points[this.points.length - 1];
            sum += (p1.x - p2.x) * (p2.y + p1.y);
            this.area = -sum * 0.5;
            return this.area;
          },
          getPoints: function(quantity, step, output) {
            return GetPoints(this, quantity, step, output);
          }
        });
        module2.exports = Polygon;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Contains = function(polygon, x2, y2) {
          var inside = false;
          for (var i2 = -1, j = polygon.points.length - 1; ++i2 < polygon.points.length; j = i2) {
            var ix = polygon.points[i2].x;
            var iy = polygon.points[i2].y;
            var jx = polygon.points[j].x;
            var jy = polygon.points[j].y;
            if ((iy <= y2 && y2 < jy || jy <= y2 && y2 < iy) && x2 < (jx - ix) * (y2 - iy) / (jy - iy) + ix) {
              inside = !inside;
            }
          }
          return inside;
        };
        module2.exports = Contains;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var GameObject = __webpack_require__(15);
        var GetFastValue = __webpack_require__(2);
        var Extend = __webpack_require__(17);
        var SetValue = __webpack_require__(478);
        var ShaderRender = __webpack_require__(1176);
        var TransformMatrix = __webpack_require__(25);
        var Shader = new Class({
          Extends: GameObject,
          Mixins: [
            Components.ComputedSize,
            Components.Depth,
            Components.GetBounds,
            Components.Mask,
            Components.Origin,
            Components.ScrollFactor,
            Components.Transform,
            Components.Visible,
            ShaderRender
          ],
          initialize: function Shader2(scene, key, x2, y2, width, height, textures, textureData) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = 128;
            }
            if (height === void 0) {
              height = 128;
            }
            GameObject.call(this, scene, "Shader");
            this.blendMode = -1;
            this.shader;
            var renderer = scene.sys.renderer;
            this.renderer = renderer;
            this.gl = renderer.gl;
            this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2));
            this.vertexBuffer = renderer.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW);
            this.program = null;
            this.bytes = new Uint8Array(this.vertexData);
            this.vertexViewF32 = new Float32Array(this.vertexData);
            this._tempMatrix1 = new TransformMatrix();
            this._tempMatrix2 = new TransformMatrix();
            this._tempMatrix3 = new TransformMatrix();
            this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
            this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
            this.uniforms = {};
            this.pointer = null;
            this._rendererWidth = renderer.width;
            this._rendererHeight = renderer.height;
            this._textureCount = 0;
            this.framebuffer = null;
            this.glTexture = null;
            this.renderToTexture = false;
            this.texture = null;
            this.setPosition(x2, y2);
            this.setSize(width, height);
            this.setOrigin(0.5, 0.5);
            this.setShader(key, textures, textureData);
          },
          willRender: function(camera) {
            if (this.renderToTexture) {
              return true;
            } else {
              return !(GameObject.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
            }
          },
          setRenderToTexture: function(key, flipY) {
            if (flipY === void 0) {
              flipY = false;
            }
            if (!this.renderToTexture) {
              var width = this.width;
              var height = this.height;
              var renderer = this.renderer;
              this.glTexture = renderer.createTextureFromSource(null, width, height, 0);
              this.glTexture.flipY = flipY;
              this.framebuffer = renderer.createFramebuffer(width, height, this.glTexture, false);
              this._rendererWidth = width;
              this._rendererHeight = height;
              this.renderToTexture = true;
              this.projOrtho(0, this.width, this.height, 0);
              if (key) {
                this.texture = this.scene.sys.textures.addGLTexture(key, this.glTexture, width, height);
              }
            }
            if (this.shader) {
              renderer.pipelines.clear();
              this.load();
              this.flush();
              renderer.pipelines.rebind();
            }
            return this;
          },
          setShader: function(key, textures, textureData) {
            if (textures === void 0) {
              textures = [];
            }
            if (typeof key === "string") {
              var cache = this.scene.sys.cache.shader;
              if (!cache.has(key)) {
                console.warn("Shader missing: " + key);
                return this;
              }
              this.shader = cache.get(key);
            } else {
              this.shader = key;
            }
            var gl2 = this.gl;
            var renderer = this.renderer;
            if (this.program) {
              gl2.deleteProgram(this.program);
            }
            var program = renderer.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);
            gl2.uniformMatrix4fv(gl2.getUniformLocation(program, "uViewMatrix"), false, this.viewMatrix);
            gl2.uniformMatrix4fv(gl2.getUniformLocation(program, "uProjectionMatrix"), false, this.projectionMatrix);
            gl2.uniform2f(gl2.getUniformLocation(program, "uResolution"), this.width, this.height);
            this.program = program;
            var d = new Date();
            var defaultUniforms = {
              resolution: { type: "2f", value: { x: this.width, y: this.height } },
              time: { type: "1f", value: 0 },
              mouse: { type: "2f", value: { x: this.width / 2, y: this.height / 2 } },
              date: { type: "4fv", value: [d.getFullYear(), d.getMonth(), d.getDate(), d.getHours() * 60 * 60 + d.getMinutes() * 60 + d.getSeconds()] },
              sampleRate: { type: "1f", value: 44100 },
              iChannel0: { type: "sampler2D", value: null, textureData: { repeat: true } },
              iChannel1: { type: "sampler2D", value: null, textureData: { repeat: true } },
              iChannel2: { type: "sampler2D", value: null, textureData: { repeat: true } },
              iChannel3: { type: "sampler2D", value: null, textureData: { repeat: true } }
            };
            if (this.shader.uniforms) {
              this.uniforms = Extend(true, {}, this.shader.uniforms, defaultUniforms);
            } else {
              this.uniforms = defaultUniforms;
            }
            for (var i2 = 0; i2 < 4; i2++) {
              if (textures[i2]) {
                this.setSampler2D("iChannel" + i2, textures[i2], i2, textureData);
              }
            }
            this.initUniforms();
            this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0);
            return this;
          },
          setPointer: function(pointer) {
            this.pointer = pointer;
            return this;
          },
          projOrtho: function(left, right, bottom, top) {
            var near = -1e3;
            var far = 1e3;
            var leftRight = 1 / (left - right);
            var bottomTop = 1 / (bottom - top);
            var nearFar = 1 / (near - far);
            var pm = this.projectionMatrix;
            pm[0] = -2 * leftRight;
            pm[5] = -2 * bottomTop;
            pm[10] = 2 * nearFar;
            pm[12] = (left + right) * leftRight;
            pm[13] = (top + bottom) * bottomTop;
            pm[14] = (far + near) * nearFar;
            var program = this.program;
            var gl2 = this.gl;
            var renderer = this.renderer;
            renderer.setProgram(program);
            gl2.uniformMatrix4fv(gl2.getUniformLocation(program, "uProjectionMatrix"), false, this.projectionMatrix);
            this._rendererWidth = right;
            this._rendererHeight = bottom;
          },
          initUniforms: function() {
            var gl2 = this.gl;
            var map = this.renderer.glFuncMap;
            var program = this.program;
            this._textureCount = 0;
            for (var key in this.uniforms) {
              var uniform = this.uniforms[key];
              var type = uniform.type;
              var data = map[type];
              uniform.uniformLocation = gl2.getUniformLocation(program, key);
              if (type !== "sampler2D") {
                uniform.glMatrix = data.matrix;
                uniform.glValueLength = data.length;
                uniform.glFunc = data.func;
              }
            }
          },
          setSampler2DBuffer: function(uniformKey, texture, width, height, textureIndex, textureData) {
            if (textureIndex === void 0) {
              textureIndex = 0;
            }
            if (textureData === void 0) {
              textureData = {};
            }
            var uniform = this.uniforms[uniformKey];
            uniform.value = texture;
            textureData.width = width;
            textureData.height = height;
            uniform.textureData = textureData;
            this._textureCount = textureIndex;
            this.initSampler2D(uniform);
            return this;
          },
          setSampler2D: function(uniformKey, textureKey, textureIndex, textureData) {
            if (textureIndex === void 0) {
              textureIndex = 0;
            }
            var textureManager = this.scene.sys.textures;
            if (textureManager.exists(textureKey)) {
              var frame = textureManager.getFrame(textureKey);
              if (frame.glTexture && frame.glTexture.isRenderTexture) {
                return this.setSampler2DBuffer(uniformKey, frame.glTexture, frame.width, frame.height, textureIndex, textureData);
              }
              var uniform = this.uniforms[uniformKey];
              var source = frame.source;
              uniform.textureKey = textureKey;
              uniform.source = source.image;
              uniform.value = frame.glTexture;
              if (source.isGLTexture) {
                if (!textureData) {
                  textureData = {};
                }
                textureData.width = source.width;
                textureData.height = source.height;
              }
              if (textureData) {
                uniform.textureData = textureData;
              }
              this._textureCount = textureIndex;
              this.initSampler2D(uniform);
            }
            return this;
          },
          setUniform: function(key, value) {
            SetValue(this.uniforms, key, value);
            return this;
          },
          getUniform: function(key) {
            return GetFastValue(this.uniforms, key, null);
          },
          setChannel0: function(textureKey, textureData) {
            return this.setSampler2D("iChannel0", textureKey, 0, textureData);
          },
          setChannel1: function(textureKey, textureData) {
            return this.setSampler2D("iChannel1", textureKey, 1, textureData);
          },
          setChannel2: function(textureKey, textureData) {
            return this.setSampler2D("iChannel2", textureKey, 2, textureData);
          },
          setChannel3: function(textureKey, textureData) {
            return this.setSampler2D("iChannel3", textureKey, 3, textureData);
          },
          initSampler2D: function(uniform) {
            if (!uniform.value) {
              return;
            }
            var gl2 = this.gl;
            gl2.activeTexture(gl2.TEXTURE0 + this._textureCount);
            gl2.bindTexture(gl2.TEXTURE_2D, uniform.value);
            var data = uniform.textureData;
            if (data && !uniform.value.isRenderTexture) {
              var magFilter = gl2[GetFastValue(data, "magFilter", "linear").toUpperCase()];
              var minFilter = gl2[GetFastValue(data, "minFilter", "linear").toUpperCase()];
              var wrapS = gl2[GetFastValue(data, "wrapS", "repeat").toUpperCase()];
              var wrapT = gl2[GetFastValue(data, "wrapT", "repeat").toUpperCase()];
              var format = gl2[GetFastValue(data, "format", "rgba").toUpperCase()];
              if (data.repeat) {
                wrapS = gl2.REPEAT;
                wrapT = gl2.REPEAT;
              }
              gl2.pixelStorei(gl2.UNPACK_FLIP_Y_WEBGL, !!data.flipY);
              if (data.width) {
                var width = GetFastValue(data, "width", 512);
                var height = GetFastValue(data, "height", 2);
                var border = GetFastValue(data, "border", 0);
                gl2.texImage2D(gl2.TEXTURE_2D, 0, format, width, height, border, format, gl2.UNSIGNED_BYTE, null);
              } else {
                gl2.texImage2D(gl2.TEXTURE_2D, 0, format, gl2.RGBA, gl2.UNSIGNED_BYTE, uniform.source);
              }
              gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, magFilter);
              gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, minFilter);
              gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, wrapS);
              gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, wrapT);
            }
            this.renderer.setProgram(this.program);
            gl2.uniform1i(uniform.uniformLocation, this._textureCount);
            this._textureCount++;
          },
          syncUniforms: function() {
            var gl2 = this.gl;
            var uniforms = this.uniforms;
            var uniform;
            var length;
            var glFunc;
            var location;
            var value;
            var textureCount = 0;
            for (var key in uniforms) {
              uniform = uniforms[key];
              glFunc = uniform.glFunc;
              length = uniform.glValueLength;
              location = uniform.uniformLocation;
              value = uniform.value;
              if (value === null) {
                continue;
              }
              if (length === 1) {
                if (uniform.glMatrix) {
                  glFunc.call(gl2, location, uniform.transpose, value);
                } else {
                  glFunc.call(gl2, location, value);
                }
              } else if (length === 2) {
                glFunc.call(gl2, location, value.x, value.y);
              } else if (length === 3) {
                glFunc.call(gl2, location, value.x, value.y, value.z);
              } else if (length === 4) {
                glFunc.call(gl2, location, value.x, value.y, value.z, value.w);
              } else if (uniform.type === "sampler2D") {
                gl2.activeTexture(gl2.TEXTURE0 + textureCount);
                gl2.bindTexture(gl2.TEXTURE_2D, value);
                gl2.uniform1i(location, textureCount);
                textureCount++;
              }
            }
          },
          load: function(matrix2D) {
            var gl2 = this.gl;
            var width = this.width;
            var height = this.height;
            var renderer = this.renderer;
            var program = this.program;
            var vm = this.viewMatrix;
            if (!this.renderToTexture) {
              var x2 = -this._displayOriginX;
              var y2 = -this._displayOriginY;
              vm[0] = matrix2D[0];
              vm[1] = matrix2D[1];
              vm[4] = matrix2D[2];
              vm[5] = matrix2D[3];
              vm[8] = matrix2D[4];
              vm[9] = matrix2D[5];
              vm[12] = vm[0] * x2 + vm[4] * y2;
              vm[13] = vm[1] * x2 + vm[5] * y2;
            }
            gl2.useProgram(program);
            gl2.uniformMatrix4fv(gl2.getUniformLocation(program, "uViewMatrix"), false, vm);
            gl2.uniform2f(gl2.getUniformLocation(program, "uResolution"), this.width, this.height);
            var uniforms = this.uniforms;
            var res = uniforms.resolution;
            res.value.x = width;
            res.value.y = height;
            uniforms.time.value = renderer.game.loop.getDuration();
            var pointer = this.pointer;
            if (pointer) {
              var mouse = uniforms.mouse;
              var px = pointer.x / width;
              var py = 1 - pointer.y / height;
              mouse.value.x = px.toFixed(2);
              mouse.value.y = py.toFixed(2);
            }
            this.syncUniforms();
          },
          flush: function() {
            var width = this.width;
            var height = this.height;
            var program = this.program;
            var gl2 = this.gl;
            var vertexBuffer = this.vertexBuffer;
            var renderer = this.renderer;
            var vertexSize = Float32Array.BYTES_PER_ELEMENT * 2;
            if (this.renderToTexture) {
              renderer.setFramebuffer(this.framebuffer);
              gl2.clearColor(0, 0, 0, 0);
              gl2.clear(gl2.COLOR_BUFFER_BIT);
            }
            gl2.bindBuffer(gl2.ARRAY_BUFFER, vertexBuffer);
            var location = gl2.getAttribLocation(program, "inPosition");
            if (location !== -1) {
              gl2.enableVertexAttribArray(location);
              gl2.vertexAttribPointer(location, 2, gl2.FLOAT, false, vertexSize, 0);
            }
            var vf2 = this.vertexViewF32;
            vf2[3] = height;
            vf2[4] = width;
            vf2[5] = height;
            vf2[8] = width;
            vf2[9] = height;
            vf2[10] = width;
            var vertexCount = 6;
            gl2.bufferSubData(gl2.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));
            gl2.drawArrays(gl2.TRIANGLES, 0, vertexCount);
            if (this.renderToTexture) {
              renderer.setFramebuffer(null, false);
            }
          },
          setAlpha: function() {
          },
          setBlendMode: function() {
          },
          preDestroy: function() {
            var gl2 = this.gl;
            gl2.deleteProgram(this.program);
            gl2.deleteBuffer(this.vertexBuffer);
            if (this.renderToTexture) {
              this.renderer.deleteFramebuffer(this.framebuffer);
              this.texture.destroy();
              this.framebuffer = null;
              this.glTexture = null;
              this.texture = null;
            }
          }
        });
        module2.exports = Shader;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var DegToRad = __webpack_require__(36);
        var Face = __webpack_require__(116);
        var GameObject = __webpack_require__(15);
        var GenerateVerts = __webpack_require__(479);
        var GenerateObjVerts = __webpack_require__(480);
        var GetCalcMatrix = __webpack_require__(19);
        var Matrix4 = __webpack_require__(69);
        var MeshRender = __webpack_require__(1179);
        var StableSort = __webpack_require__(79);
        var Vector3 = __webpack_require__(39);
        var Vertex = __webpack_require__(117);
        var Mesh = new Class({
          Extends: GameObject,
          Mixins: [
            Components.AlphaSingle,
            Components.BlendMode,
            Components.Depth,
            Components.Mask,
            Components.Pipeline,
            Components.Size,
            Components.Texture,
            Components.Transform,
            Components.Visible,
            Components.ScrollFactor,
            MeshRender
          ],
          initialize: function Mesh2(scene, x2, y2, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (texture === void 0) {
              texture = "__WHITE";
            }
            GameObject.call(this, scene, "Mesh");
            this.faces = [];
            this.vertices = [];
            this.tintFill = false;
            this.debugCallback = null;
            this.debugGraphic = null;
            this.hideCCW = true;
            this.modelPosition = new Vector3();
            this.modelScale = new Vector3(1, 1, 1);
            this.modelRotation = new Vector3();
            this.dirtyCache = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            this.transformMatrix = new Matrix4();
            this.viewPosition = new Vector3();
            this.viewMatrix = new Matrix4();
            this.projectionMatrix = new Matrix4();
            this.totalRendered = 0;
            this.totalFrame = 0;
            this.ignoreDirtyCache = false;
            var renderer = scene.sys.renderer;
            this.setPosition(x2, y2);
            this.setTexture(texture, frame);
            this.setSize(renderer.width, renderer.height);
            this.initPipeline();
            this.setPerspective(renderer.width, renderer.height);
            if (vertices) {
              this.addVertices(vertices, uvs, indicies, containsZ, normals, colors, alphas);
            }
          },
          addedToScene: function() {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function() {
            this.scene.sys.updateList.remove(this);
          },
          panX: function(v2) {
            this.viewPosition.addScale(Vector3.LEFT, v2);
            this.dirtyCache[10] = 1;
            return this;
          },
          panY: function(v2) {
            this.viewPosition.y += Vector3.DOWN.y * v2;
            this.dirtyCache[10] = 1;
            return this;
          },
          panZ: function(amount) {
            this.viewPosition.z += amount;
            this.dirtyCache[10] = 1;
            return this;
          },
          setPerspective: function(width, height, fov, near, far) {
            if (fov === void 0) {
              fov = 45;
            }
            if (near === void 0) {
              near = 0.01;
            }
            if (far === void 0) {
              far = 1e3;
            }
            this.projectionMatrix.perspective(DegToRad(fov), width / height, near, far);
            this.dirtyCache[10] = 1;
            this.dirtyCache[11] = 0;
            return this;
          },
          setOrtho: function(scaleX, scaleY, near, far) {
            if (scaleX === void 0) {
              scaleX = this.scene.sys.renderer.getAspectRatio();
            }
            if (scaleY === void 0) {
              scaleY = 1;
            }
            if (near === void 0) {
              near = -1e3;
            }
            if (far === void 0) {
              far = 1e3;
            }
            this.projectionMatrix.ortho(-scaleX, scaleX, -scaleY, scaleY, near, far);
            this.dirtyCache[10] = 1;
            this.dirtyCache[11] = 1;
            return this;
          },
          clear: function() {
            this.faces.forEach(function(face) {
              face.destroy();
            });
            this.faces = [];
            this.vertices = [];
            return this;
          },
          addVerticesFromObj: function(key, scale, x2, y2, z2, rotateX, rotateY, rotateZ, zIsUp) {
            var data = this.scene.sys.cache.obj.get(key);
            if (data) {
              GenerateObjVerts(data, this, scale, x2, y2, z2, rotateX, rotateY, rotateZ, zIsUp);
            }
            return this;
          },
          sortByDepth: function(faceA, faceB) {
            return faceA.depth - faceB.depth;
          },
          depthSort: function() {
            StableSort(this.faces, this.sortByDepth);
            return this;
          },
          addVertex: function(x2, y2, z2, u2, v2, color, alpha) {
            var vert = new Vertex(x2, y2, z2, u2, v2, color, alpha);
            this.vertices.push(vert);
            return vert;
          },
          addFace: function(vertex1, vertex2, vertex3) {
            var face = new Face(vertex1, vertex2, vertex3);
            this.faces.push(face);
            this.dirtyCache[9] = -1;
            return face;
          },
          addVertices: function(vertices, uvs, indicies, containsZ, normals, colors, alphas) {
            var result = GenerateVerts(vertices, uvs, indicies, containsZ, normals, colors, alphas);
            if (result) {
              this.faces = this.faces.concat(result.faces);
              this.vertices = this.vertices.concat(result.vertices);
            }
            this.dirtyCache[9] = -1;
            return this;
          },
          getFaceCount: function() {
            return this.faces.length;
          },
          getVertexCount: function() {
            return this.vertices.length;
          },
          getFace: function(index2) {
            return this.faces[index2];
          },
          getFaceAt: function(x2, y2, camera) {
            if (camera === void 0) {
              camera = this.scene.sys.cameras.main;
            }
            var calcMatrix = GetCalcMatrix(this, camera).calc;
            var faces = this.faces;
            var results = [];
            for (var i2 = 0; i2 < faces.length; i2++) {
              var face = faces[i2];
              if (face.contains(x2, y2, calcMatrix)) {
                results.push(face);
              }
            }
            return StableSort(results, this.sortByDepth);
          },
          setDebug: function(graphic, callback) {
            this.debugGraphic = graphic;
            if (!graphic && !callback) {
              this.debugCallback = null;
            } else if (!callback) {
              this.debugCallback = this.renderDebug;
            } else {
              this.debugCallback = callback;
            }
            return this;
          },
          isDirty: function() {
            var position = this.modelPosition;
            var rotation = this.modelRotation;
            var scale = this.modelScale;
            var dirtyCache = this.dirtyCache;
            var px = position.x;
            var py = position.y;
            var pz = position.z;
            var rx = rotation.x;
            var ry = rotation.y;
            var rz = rotation.z;
            var sx = scale.x;
            var sy = scale.y;
            var sz = scale.z;
            var faces = this.getFaceCount();
            var pxCached = dirtyCache[0];
            var pyCached = dirtyCache[1];
            var pzCached = dirtyCache[2];
            var rxCached = dirtyCache[3];
            var ryCached = dirtyCache[4];
            var rzCached = dirtyCache[5];
            var sxCached = dirtyCache[6];
            var syCached = dirtyCache[7];
            var szCached = dirtyCache[8];
            var fCached = dirtyCache[9];
            dirtyCache[0] = px;
            dirtyCache[1] = py;
            dirtyCache[2] = pz;
            dirtyCache[3] = rx;
            dirtyCache[4] = ry;
            dirtyCache[5] = rz;
            dirtyCache[6] = sx;
            dirtyCache[7] = sy;
            dirtyCache[8] = sz;
            dirtyCache[9] = faces;
            return pxCached !== px || pyCached !== py || pzCached !== pz || rxCached !== rx || ryCached !== ry || rzCached !== rz || sxCached !== sx || syCached !== sy || szCached !== sz || fCached !== faces;
          },
          preUpdate: function() {
            this.totalRendered = this.totalFrame;
            this.totalFrame = 0;
            var dirty = this.dirtyCache;
            if (!this.ignoreDirtyCache && !dirty[10] && !this.isDirty()) {
              return;
            }
            var width = this.width;
            var height = this.height;
            var viewMatrix = this.viewMatrix;
            var viewPosition = this.viewPosition;
            if (dirty[10]) {
              viewMatrix.identity();
              viewMatrix.translate(viewPosition);
              viewMatrix.invert();
              dirty[10] = 0;
            }
            var transformMatrix = this.transformMatrix;
            transformMatrix.setWorldMatrix(this.modelRotation, this.modelPosition, this.modelScale, this.viewMatrix, this.projectionMatrix);
            var z2 = viewPosition.z;
            var faces = this.faces;
            for (var i2 = 0; i2 < faces.length; i2++) {
              faces[i2].transformCoordinatesLocal(transformMatrix, width, height, z2);
            }
            this.depthSort();
          },
          renderDebug: function(src, faces) {
            var graphic = src.debugGraphic;
            for (var i2 = 0; i2 < faces.length; i2++) {
              var face = faces[i2];
              var x0 = face.vertex1.tx;
              var y0 = face.vertex1.ty;
              var x1 = face.vertex2.tx;
              var y1 = face.vertex2.ty;
              var x2 = face.vertex3.tx;
              var y2 = face.vertex3.ty;
              graphic.strokeTriangle(x0, y0, x1, y1, x2, y2);
            }
          },
          preDestroy: function() {
            this.clear();
            this.debugCallback = null;
            this.debugGraphic = null;
          }
        });
        module2.exports = Mesh;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DistanceBetween = __webpack_require__(50);
        var CircleToCircle = function(circleA, circleB) {
          return DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= circleA.radius + circleB.radius;
        };
        module2.exports = CircleToCircle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Florian Vazelle
         * @author       Geoffrey Glaive
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var LineToCircle = __webpack_require__(233);
        var GetLineToCircle = function(line, circle, out) {
          if (out === void 0) {
            out = [];
          }
          if (LineToCircle(line, circle)) {
            var lx1 = line.x1;
            var ly1 = line.y1;
            var lx2 = line.x2;
            var ly2 = line.y2;
            var cx = circle.x;
            var cy = circle.y;
            var cr = circle.radius;
            var lDirX = lx2 - lx1;
            var lDirY = ly2 - ly1;
            var oDirX = lx1 - cx;
            var oDirY = ly1 - cy;
            var coefficientA = lDirX * lDirX + lDirY * lDirY;
            var coefficientB = 2 * (lDirX * oDirX + lDirY * oDirY);
            var coefficientC = oDirX * oDirX + oDirY * oDirY - cr * cr;
            var lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
            var x2, y2;
            if (lambda === 0) {
              var root = -coefficientB / (2 * coefficientA);
              x2 = lx1 + root * lDirX;
              y2 = ly1 + root * lDirY;
              if (root >= 0 && root <= 1) {
                out.push(new Point(x2, y2));
              }
            } else if (lambda > 0) {
              var root1 = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);
              x2 = lx1 + root1 * lDirX;
              y2 = ly1 + root1 * lDirY;
              if (root1 >= 0 && root1 <= 1) {
                out.push(new Point(x2, y2));
              }
              var root2 = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);
              x2 = lx1 + root2 * lDirX;
              y2 = ly1 + root2 * lDirY;
              if (root2 >= 0 && root2 <= 1) {
                out.push(new Point(x2, y2));
              }
            }
          }
          return out;
        };
        module2.exports = GetLineToCircle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Contains = __webpack_require__(66);
        var Point = __webpack_require__(4);
        var tmp = new Point();
        var LineToCircle = function(line, circle, nearest) {
          if (nearest === void 0) {
            nearest = tmp;
          }
          if (Contains(circle, line.x1, line.y1)) {
            nearest.x = line.x1;
            nearest.y = line.y1;
            return true;
          }
          if (Contains(circle, line.x2, line.y2)) {
            nearest.x = line.x2;
            nearest.y = line.y2;
            return true;
          }
          var dx = line.x2 - line.x1;
          var dy = line.y2 - line.y1;
          var lcx = circle.x - line.x1;
          var lcy = circle.y - line.y1;
          var dLen2 = dx * dx + dy * dy;
          var px = dx;
          var py = dy;
          if (dLen2 > 0) {
            var dp = (lcx * dx + lcy * dy) / dLen2;
            px *= dp;
            py *= dp;
          }
          nearest.x = line.x1 + px;
          nearest.y = line.y1 + py;
          var pLen2 = px * px + py * py;
          return pLen2 <= dLen2 && px * dx + py * dy >= 0 && Contains(circle, nearest.x, nearest.y);
        };
        module2.exports = LineToCircle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Florian Vazelle
         * @author       Geoffrey Glaive
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var LineToLine = __webpack_require__(96);
        var LineToRectangle = __webpack_require__(488);
        var GetLineToRectangle = function(line, rect, out) {
          if (out === void 0) {
            out = [];
          }
          if (LineToRectangle(line, rect)) {
            var lineA = rect.getLineA();
            var lineB = rect.getLineB();
            var lineC = rect.getLineC();
            var lineD = rect.getLineD();
            var output = [new Point(), new Point(), new Point(), new Point()];
            var result = [
              LineToLine(lineA, line, output[0]),
              LineToLine(lineB, line, output[1]),
              LineToLine(lineC, line, output[2]),
              LineToLine(lineD, line, output[3])
            ];
            for (var i2 = 0; i2 < 4; i2++) {
              if (result[i2]) {
                out.push(output[i2]);
              }
            }
          }
          return out;
        };
        module2.exports = GetLineToRectangle;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ContainsArray = function(triangle, points, returnFirst, out) {
          if (returnFirst === void 0) {
            returnFirst = false;
          }
          if (out === void 0) {
            out = [];
          }
          var v0x = triangle.x3 - triangle.x1;
          var v0y = triangle.y3 - triangle.y1;
          var v1x = triangle.x2 - triangle.x1;
          var v1y = triangle.y2 - triangle.y1;
          var dot00 = v0x * v0x + v0y * v0y;
          var dot01 = v0x * v1x + v0y * v1y;
          var dot11 = v1x * v1x + v1y * v1y;
          var b2 = dot00 * dot11 - dot01 * dot01;
          var inv = b2 === 0 ? 0 : 1 / b2;
          var u2;
          var v2;
          var v2x;
          var v2y;
          var dot02;
          var dot12;
          var x1 = triangle.x1;
          var y1 = triangle.y1;
          for (var i2 = 0; i2 < points.length; i2++) {
            v2x = points[i2].x - x1;
            v2y = points[i2].y - y1;
            dot02 = v0x * v2x + v0y * v2y;
            dot12 = v1x * v2x + v1y * v2y;
            u2 = (dot11 * dot02 - dot01 * dot12) * inv;
            v2 = (dot00 * dot12 - dot01 * dot02) * inv;
            if (u2 >= 0 && v2 >= 0 && u2 + v2 < 1) {
              out.push({ x: points[i2].x, y: points[i2].y });
              if (returnFirst) {
                break;
              }
            }
          }
          return out;
        };
        module2.exports = ContainsArray;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateAroundXY = function(line, x2, y2, angle) {
          var c = Math.cos(angle);
          var s = Math.sin(angle);
          var tx = line.x1 - x2;
          var ty = line.y1 - y2;
          line.x1 = tx * c - ty * s + x2;
          line.y1 = tx * s + ty * c + y2;
          tx = line.x2 - x2;
          ty = line.y2 - y2;
          line.x2 = tx * c - ty * s + x2;
          line.y2 = tx * s + ty * c + y2;
          return line;
        };
        module2.exports = RotateAroundXY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetAspectRatio = function(rect) {
          return rect.height === 0 ? NaN : rect.width / rect.height;
        };
        module2.exports = GetAspectRatio;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateAroundXY = function(triangle, x2, y2, angle) {
          var c = Math.cos(angle);
          var s = Math.sin(angle);
          var tx = triangle.x1 - x2;
          var ty = triangle.y1 - y2;
          triangle.x1 = tx * c - ty * s + x2;
          triangle.y1 = tx * s + ty * c + y2;
          tx = triangle.x2 - x2;
          ty = triangle.y2 - y2;
          triangle.x2 = tx * c - ty * s + x2;
          triangle.y2 = tx * s + ty * c + y2;
          tx = triangle.x3 - x2;
          ty = triangle.y3 - y2;
          triangle.x3 = tx * c - ty * s + x2;
          triangle.y3 = tx * s + ty * c + y2;
          return triangle;
        };
        module2.exports = RotateAroundXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          BUTTON_DOWN: __webpack_require__(1310),
          BUTTON_UP: __webpack_require__(1311),
          CONNECTED: __webpack_require__(1312),
          DISCONNECTED: __webpack_require__(1313),
          GAMEPAD_BUTTON_DOWN: __webpack_require__(1314),
          GAMEPAD_BUTTON_UP: __webpack_require__(1315)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Extend = __webpack_require__(17);
        var XHRSettings = __webpack_require__(156);
        var MergeXHRSettings = function(global2, local) {
          var output = global2 === void 0 ? XHRSettings() : Extend({}, global2);
          if (local) {
            for (var setting in local) {
              if (local[setting] !== void 0) {
                output[setting] = local[setting];
              }
            }
          }
          return output;
        };
        module2.exports = MergeXHRSettings;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var ParseXML = __webpack_require__(408);
        var XMLFile = new Class({
          Extends: File,
          initialize: function XMLFile2(loader, key, url, xhrSettings) {
            var extension = "xml";
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
            }
            var fileConfig = {
              type: "xml",
              cache: loader.cacheManager.xml,
              extension,
              responseType: "text",
              key,
              url,
              xhrSettings
            };
            File.call(this, loader, fileConfig);
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            this.data = ParseXML(this.xhrLoader.responseText);
            if (this.data) {
              this.onProcessComplete();
            } else {
              console.warn("Invalid XMLFile: " + this.key);
              this.onProcessError();
            }
          }
        });
        FileTypesManager.register("xml", function(key, url, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new XMLFile(this, key[i2]));
            }
          } else {
            this.addFile(new XMLFile(this, key, url, xhrSettings));
          }
          return this;
        });
        module2.exports = XMLFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var TextFile = new Class({
          Extends: File,
          initialize: function TextFile2(loader, key, url, xhrSettings) {
            var type = "text";
            var extension = "txt";
            var cache = loader.cacheManager.text;
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
              type = GetFastValue(config, "type", type);
              cache = GetFastValue(config, "cache", cache);
            }
            var fileConfig = {
              type,
              cache,
              extension,
              responseType: "text",
              key,
              url,
              xhrSettings
            };
            File.call(this, loader, fileConfig);
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            this.data = this.xhrLoader.responseText;
            this.onProcessComplete();
          }
        });
        FileTypesManager.register("text", function(key, url, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new TextFile(this, key[i2]));
            }
          } else {
            this.addFile(new TextFile(this, key, url, xhrSettings));
          }
          return this;
        });
        module2.exports = TextFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Acceleration: __webpack_require__(1368),
          Angular: __webpack_require__(1369),
          Bounce: __webpack_require__(1370),
          Debug: __webpack_require__(1371),
          Drag: __webpack_require__(1372),
          Enable: __webpack_require__(1373),
          Friction: __webpack_require__(1374),
          Gravity: __webpack_require__(1375),
          Immovable: __webpack_require__(1376),
          Mass: __webpack_require__(1377),
          OverlapCirc: __webpack_require__(523),
          OverlapRect: __webpack_require__(244),
          Pushable: __webpack_require__(1378),
          Size: __webpack_require__(1379),
          Velocity: __webpack_require__(1380)
        };
      },
      function(module2, exports2) {
        var OverlapRect = function(world, x2, y2, width, height, includeDynamic, includeStatic) {
          if (includeDynamic === void 0) {
            includeDynamic = true;
          }
          if (includeStatic === void 0) {
            includeStatic = false;
          }
          var dynamicBodies = [];
          var staticBodies = [];
          var minMax = world.treeMinMax;
          minMax.minX = x2;
          minMax.minY = y2;
          minMax.maxX = x2 + width;
          minMax.maxY = y2 + height;
          if (includeStatic) {
            staticBodies = world.staticTree.search(minMax);
          }
          if (includeDynamic && world.useTree) {
            dynamicBodies = world.tree.search(minMax);
          } else if (includeDynamic) {
            var bodies = world.bodies;
            var fakeBody = {
              position: {
                x: x2,
                y: y2
              },
              left: x2,
              top: y2,
              right: x2 + width,
              bottom: y2 + height,
              isCircle: false
            };
            var intersects = world.intersects;
            bodies.iterate(function(target) {
              if (intersects(target, fakeBody)) {
                dynamicBodies.push(target);
              }
            });
          }
          return staticBodies.concat(dynamicBodies);
        };
        module2.exports = OverlapRect;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          COLLIDE: __webpack_require__(1381),
          OVERLAP: __webpack_require__(1382),
          PAUSE: __webpack_require__(1383),
          RESUME: __webpack_require__(1384),
          TILE_COLLIDE: __webpack_require__(1385),
          TILE_OVERLAP: __webpack_require__(1386),
          WORLD_BOUNDS: __webpack_require__(1387),
          WORLD_STEP: __webpack_require__(1388)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(62);
        var GetOverlapX = function(body1, body2, overlapOnly, bias) {
          var overlap = 0;
          var maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + bias;
          if (body1._dx === 0 && body2._dx === 0) {
            body1.embedded = true;
            body2.embedded = true;
          } else if (body1._dx > body2._dx) {
            overlap = body1.right - body2.x;
            if (overlap > maxOverlap && !overlapOnly || body1.checkCollision.right === false || body2.checkCollision.left === false) {
              overlap = 0;
            } else {
              body1.touching.none = false;
              body1.touching.right = true;
              body2.touching.none = false;
              body2.touching.left = true;
              if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                body1.blocked.none = false;
                body1.blocked.right = true;
              }
              if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                body2.blocked.none = false;
                body2.blocked.left = true;
              }
            }
          } else if (body1._dx < body2._dx) {
            overlap = body1.x - body2.width - body2.x;
            if (-overlap > maxOverlap && !overlapOnly || body1.checkCollision.left === false || body2.checkCollision.right === false) {
              overlap = 0;
            } else {
              body1.touching.none = false;
              body1.touching.left = true;
              body2.touching.none = false;
              body2.touching.right = true;
              if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                body1.blocked.none = false;
                body1.blocked.left = true;
              }
              if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                body2.blocked.none = false;
                body2.blocked.right = true;
              }
            }
          }
          body1.overlapX = overlap;
          body2.overlapX = overlap;
          return overlap;
        };
        module2.exports = GetOverlapX;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(62);
        var GetOverlapY = function(body1, body2, overlapOnly, bias) {
          var overlap = 0;
          var maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + bias;
          if (body1._dy === 0 && body2._dy === 0) {
            body1.embedded = true;
            body2.embedded = true;
          } else if (body1._dy > body2._dy) {
            overlap = body1.bottom - body2.y;
            if (overlap > maxOverlap && !overlapOnly || body1.checkCollision.down === false || body2.checkCollision.up === false) {
              overlap = 0;
            } else {
              body1.touching.none = false;
              body1.touching.down = true;
              body2.touching.none = false;
              body2.touching.up = true;
              if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                body1.blocked.none = false;
                body1.blocked.down = true;
              }
              if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                body2.blocked.none = false;
                body2.blocked.up = true;
              }
            }
          } else if (body1._dy < body2._dy) {
            overlap = body1.y - body2.bottom;
            if (-overlap > maxOverlap && !overlapOnly || body1.checkCollision.up === false || body2.checkCollision.down === false) {
              overlap = 0;
            } else {
              body1.touching.none = false;
              body1.touching.up = true;
              body2.touching.none = false;
              body2.touching.down = true;
              if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                body1.blocked.none = false;
                body1.blocked.up = true;
              }
              if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                body2.blocked.none = false;
                body2.blocked.down = true;
              }
            }
          }
          body1.overlapY = overlap;
          body2.overlapY = overlap;
          return overlap;
        };
        module2.exports = GetOverlapY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TileIntersectsBody = function(tileWorldRect, body) {
          return !(body.right <= tileWorldRect.left || body.bottom <= tileWorldRect.top || body.position.x >= tileWorldRect.right || body.position.y >= tileWorldRect.bottom);
        };
        module2.exports = TileIntersectsBody;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Bounce: __webpack_require__(1495),
          Collision: __webpack_require__(1496),
          Force: __webpack_require__(1497),
          Friction: __webpack_require__(1498),
          Gravity: __webpack_require__(1499),
          Mass: __webpack_require__(1500),
          Sensor: __webpack_require__(1501),
          SetBody: __webpack_require__(1502),
          Sleep: __webpack_require__(1503),
          Static: __webpack_require__(1520),
          Transform: __webpack_require__(1521),
          Velocity: __webpack_require__(1522)
        };
      },
      function(module2, exports2) {
        var Pair = {};
        module2.exports = Pair;
        (function() {
          Pair.create = function(collision, timestamp) {
            var bodyA = collision.bodyA, bodyB = collision.bodyB;
            var pair = {
              id: Pair.id(bodyA, bodyB),
              bodyA,
              bodyB,
              activeContacts: [],
              separation: 0,
              isActive: true,
              confirmedActive: true,
              isSensor: bodyA.isSensor || bodyB.isSensor,
              timeCreated: timestamp,
              timeUpdated: timestamp,
              collision: null,
              inverseMass: 0,
              friction: 0,
              frictionStatic: 0,
              restitution: 0,
              slop: 0
            };
            Pair.update(pair, collision, timestamp);
            return pair;
          };
          Pair.update = function(pair, collision, timestamp) {
            pair.collision = collision;
            if (collision.collided) {
              var supports = collision.supports, activeContacts = pair.activeContacts, parentA = collision.parentA, parentB = collision.parentB;
              pair.inverseMass = parentA.inverseMass + parentB.inverseMass;
              pair.friction = Math.min(parentA.friction, parentB.friction);
              pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);
              pair.restitution = Math.max(parentA.restitution, parentB.restitution);
              pair.slop = Math.max(parentA.slop, parentB.slop);
              for (var i2 = 0; i2 < supports.length; i2++) {
                activeContacts[i2] = supports[i2].contact;
              }
              var supportCount = supports.length;
              if (supportCount < activeContacts.length) {
                activeContacts.length = supportCount;
              }
              pair.separation = collision.depth;
              Pair.setActive(pair, true, timestamp);
            } else {
              if (pair.isActive === true)
                Pair.setActive(pair, false, timestamp);
            }
          };
          Pair.setActive = function(pair, isActive, timestamp) {
            if (isActive) {
              pair.isActive = true;
              pair.timeUpdated = timestamp;
            } else {
              pair.isActive = false;
              pair.activeContacts.length = 0;
            }
          };
          Pair.id = function(bodyA, bodyB) {
            if (bodyA.id < bodyB.id) {
              return "A" + bodyA.id + "B" + bodyB.id;
            } else {
              return "A" + bodyB.id + "B" + bodyA.id;
            }
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          CalculateFacesAt: __webpack_require__(252),
          CalculateFacesWithin: __webpack_require__(63),
          CheckIsoBounds: __webpack_require__(541),
          Copy: __webpack_require__(1420),
          CreateFromTiles: __webpack_require__(1421),
          CullBounds: __webpack_require__(543),
          CullTiles: __webpack_require__(544),
          Fill: __webpack_require__(1422),
          FilterTiles: __webpack_require__(1423),
          FindByIndex: __webpack_require__(1424),
          FindTile: __webpack_require__(1425),
          ForEachTile: __webpack_require__(1426),
          GetCullTilesFunction: __webpack_require__(1427),
          GetTileAt: __webpack_require__(158),
          GetTileAtWorldXY: __webpack_require__(1428),
          GetTilesWithin: __webpack_require__(26),
          GetTilesWithinShape: __webpack_require__(1429),
          GetTilesWithinWorldXY: __webpack_require__(529),
          GetTileToWorldXFunction: __webpack_require__(1430),
          GetTileToWorldXYFunction: __webpack_require__(1431),
          GetTileToWorldYFunction: __webpack_require__(1432),
          GetWorldToTileXFunction: __webpack_require__(1433),
          GetWorldToTileXYFunction: __webpack_require__(1434),
          GetWorldToTileYFunction: __webpack_require__(1435),
          HasTileAt: __webpack_require__(562),
          HasTileAtWorldXY: __webpack_require__(1436),
          HexagonalCullBounds: __webpack_require__(546),
          HexagonalCullTiles: __webpack_require__(545),
          HexagonalTileToWorldXY: __webpack_require__(550),
          HexagonalTileToWorldY: __webpack_require__(554),
          HexagonalWorldToTileXY: __webpack_require__(556),
          HexagonalWorldToTileY: __webpack_require__(560),
          IsInLayerBounds: __webpack_require__(119),
          IsometricCullTiles: __webpack_require__(547),
          IsometricTileToWorldXY: __webpack_require__(551),
          IsometricWorldToTileXY: __webpack_require__(557),
          PutTileAt: __webpack_require__(257),
          PutTileAtWorldXY: __webpack_require__(1437),
          PutTilesAt: __webpack_require__(1438),
          Randomize: __webpack_require__(1439),
          RemoveTileAt: __webpack_require__(563),
          RemoveTileAtWorldXY: __webpack_require__(1440),
          RenderDebug: __webpack_require__(1441),
          ReplaceByIndex: __webpack_require__(542),
          RunCull: __webpack_require__(159),
          SetCollision: __webpack_require__(1442),
          SetCollisionBetween: __webpack_require__(1443),
          SetCollisionByExclusion: __webpack_require__(1444),
          SetCollisionByProperty: __webpack_require__(1445),
          SetCollisionFromCollisionGroup: __webpack_require__(1446),
          SetLayerCollisionIndex: __webpack_require__(160),
          SetTileCollision: __webpack_require__(72),
          SetTileIndexCallback: __webpack_require__(1447),
          SetTileLocationCallback: __webpack_require__(1448),
          Shuffle: __webpack_require__(1449),
          StaggeredCullBounds: __webpack_require__(549),
          StaggeredCullTiles: __webpack_require__(548),
          StaggeredTileToWorldXY: __webpack_require__(552),
          StaggeredTileToWorldY: __webpack_require__(555),
          StaggeredWorldToTileXY: __webpack_require__(558),
          StaggeredWorldToTileY: __webpack_require__(561),
          SwapByIndex: __webpack_require__(1450),
          TileToWorldX: __webpack_require__(253),
          TileToWorldXY: __webpack_require__(553),
          TileToWorldY: __webpack_require__(254),
          WeightedRandomize: __webpack_require__(1451),
          WorldToTileX: __webpack_require__(255),
          WorldToTileXY: __webpack_require__(559),
          WorldToTileY: __webpack_require__(256)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTileAt = __webpack_require__(158);
        var CalculateFacesAt = function(tileX, tileY, layer) {
          var tile = GetTileAt(tileX, tileY, true, layer);
          var above = GetTileAt(tileX, tileY - 1, true, layer);
          var below = GetTileAt(tileX, tileY + 1, true, layer);
          var left = GetTileAt(tileX - 1, tileY, true, layer);
          var right = GetTileAt(tileX + 1, tileY, true, layer);
          var tileCollides = tile && tile.collides;
          if (tileCollides) {
            tile.faceTop = true;
            tile.faceBottom = true;
            tile.faceLeft = true;
            tile.faceRight = true;
          }
          if (above && above.collides) {
            if (tileCollides) {
              tile.faceTop = false;
            }
            above.faceBottom = !tileCollides;
          }
          if (below && below.collides) {
            if (tileCollides) {
              tile.faceBottom = false;
            }
            below.faceTop = !tileCollides;
          }
          if (left && left.collides) {
            if (tileCollides) {
              tile.faceLeft = false;
            }
            left.faceRight = !tileCollides;
          }
          if (right && right.collides) {
            if (tileCollides) {
              tile.faceRight = false;
            }
            right.faceLeft = !tileCollides;
          }
          if (tile && !tile.collides) {
            tile.resetFaces();
          }
          return tile;
        };
        module2.exports = CalculateFacesAt;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TileToWorldX = function(tileX, camera, layer) {
          var tileWidth = layer.baseTileWidth;
          var tilemapLayer = layer.tilemapLayer;
          var layerWorldX = 0;
          if (tilemapLayer) {
            if (!camera) {
              camera = tilemapLayer.scene.cameras.main;
            }
            layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
            tileWidth *= tilemapLayer.scaleX;
          }
          return layerWorldX + tileX * tileWidth;
        };
        module2.exports = TileToWorldX;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TileToWorldY = function(tileY, camera, layer) {
          var tileHeight = layer.baseTileHeight;
          var tilemapLayer = layer.tilemapLayer;
          var layerWorldY = 0;
          if (tilemapLayer) {
            if (!camera) {
              camera = tilemapLayer.scene.cameras.main;
            }
            layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
            tileHeight *= tilemapLayer.scaleY;
          }
          return layerWorldY + tileY * tileHeight;
        };
        module2.exports = TileToWorldY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var WorldToTileX = function(worldX, snapToFloor, camera, layer) {
          if (snapToFloor === void 0) {
            snapToFloor = true;
          }
          var tileWidth = layer.baseTileWidth;
          var tilemapLayer = layer.tilemapLayer;
          if (tilemapLayer) {
            if (!camera) {
              camera = tilemapLayer.scene.cameras.main;
            }
            worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
            tileWidth *= tilemapLayer.scaleX;
          }
          return snapToFloor ? Math.floor(worldX / tileWidth) : worldX / tileWidth;
        };
        module2.exports = WorldToTileX;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var WorldToTileY = function(worldY, snapToFloor, camera, layer) {
          if (snapToFloor === void 0) {
            snapToFloor = true;
          }
          var tileHeight = layer.baseTileHeight;
          var tilemapLayer = layer.tilemapLayer;
          if (tilemapLayer) {
            if (!camera) {
              camera = tilemapLayer.scene.cameras.main;
            }
            worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
            tileHeight *= tilemapLayer.scaleY;
          }
          return snapToFloor ? Math.floor(worldY / tileHeight) : worldY / tileHeight;
        };
        module2.exports = WorldToTileY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Tile = __webpack_require__(85);
        var IsInLayerBounds = __webpack_require__(119);
        var CalculateFacesAt = __webpack_require__(252);
        var SetTileCollision = __webpack_require__(72);
        var PutTileAt = function(tile, tileX, tileY, recalculateFaces, layer) {
          if (recalculateFaces === void 0) {
            recalculateFaces = true;
          }
          if (!IsInLayerBounds(tileX, tileY, layer)) {
            return null;
          }
          var oldTile = layer.data[tileY][tileX];
          var oldTileCollides = oldTile && oldTile.collides;
          if (tile instanceof Tile) {
            if (layer.data[tileY][tileX] === null) {
              layer.data[tileY][tileX] = new Tile(layer, tile.index, tileX, tileY, layer.tileWidth, layer.tileHeight);
            }
            layer.data[tileY][tileX].copy(tile);
          } else {
            var index2 = tile;
            if (layer.data[tileY][tileX] === null) {
              layer.data[tileY][tileX] = new Tile(layer, index2, tileX, tileY, layer.tileWidth, layer.tileHeight);
            } else {
              layer.data[tileY][tileX].index = index2;
            }
          }
          var newTile = layer.data[tileY][tileX];
          var collides = layer.collideIndexes.indexOf(newTile.index) !== -1;
          SetTileCollision(newTile, collides);
          if (recalculateFaces && oldTileCollides !== newTile.collides) {
            CalculateFacesAt(tileX, tileY, layer);
          }
          return newTile;
        };
        module2.exports = PutTileAt;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(29);
        var FromOrientationString = function(orientation) {
          orientation = orientation.toLowerCase();
          if (orientation === "isometric") {
            return CONST.ISOMETRIC;
          } else if (orientation === "staggered") {
            return CONST.STAGGERED;
          } else if (orientation === "hexagonal") {
            return CONST.HEXAGONAL;
          } else {
            return CONST.ORTHOGONAL;
          }
        };
        module2.exports = FromOrientationString;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Formats = __webpack_require__(40);
        var LayerData = __webpack_require__(120);
        var MapData = __webpack_require__(121);
        var Tile = __webpack_require__(85);
        var Parse2DArray = function(name, data, tileWidth, tileHeight, insertNull) {
          var layerData = new LayerData({
            tileWidth,
            tileHeight
          });
          var mapData = new MapData({
            name,
            tileWidth,
            tileHeight,
            format: Formats.ARRAY_2D,
            layers: [layerData]
          });
          var tiles = [];
          var height = data.length;
          var width = 0;
          for (var y2 = 0; y2 < data.length; y2++) {
            tiles[y2] = [];
            var row = data[y2];
            for (var x2 = 0; x2 < row.length; x2++) {
              var tileIndex = parseInt(row[x2], 10);
              if (isNaN(tileIndex) || tileIndex === -1) {
                tiles[y2][x2] = insertNull ? null : new Tile(layerData, -1, x2, y2, tileWidth, tileHeight);
              } else {
                tiles[y2][x2] = new Tile(layerData, tileIndex, x2, y2, tileWidth, tileHeight);
              }
            }
            if (width === 0) {
              width = row.length;
            }
          }
          mapData.width = layerData.width = width;
          mapData.height = layerData.height = height;
          mapData.widthInPixels = layerData.widthInPixels = width * tileWidth;
          mapData.heightInPixels = layerData.heightInPixels = height * tileHeight;
          layerData.data = tiles;
          return mapData;
        };
        module2.exports = Parse2DArray;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Pick = __webpack_require__(571);
        var ParseGID = __webpack_require__(261);
        var copyPoints = function(p2) {
          return { x: p2.x, y: p2.y };
        };
        var commonObjectProps = ["id", "name", "type", "rotation", "properties", "visible", "x", "y", "width", "height"];
        var ParseObject = function(tiledObject, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          var parsedObject = Pick(tiledObject, commonObjectProps);
          parsedObject.x += offsetX;
          parsedObject.y += offsetY;
          if (tiledObject.gid) {
            var gidInfo = ParseGID(tiledObject.gid);
            parsedObject.gid = gidInfo.gid;
            parsedObject.flippedHorizontal = gidInfo.flippedHorizontal;
            parsedObject.flippedVertical = gidInfo.flippedVertical;
            parsedObject.flippedAntiDiagonal = gidInfo.flippedAntiDiagonal;
          } else if (tiledObject.polyline) {
            parsedObject.polyline = tiledObject.polyline.map(copyPoints);
          } else if (tiledObject.polygon) {
            parsedObject.polygon = tiledObject.polygon.map(copyPoints);
          } else if (tiledObject.ellipse) {
            parsedObject.ellipse = tiledObject.ellipse;
          } else if (tiledObject.text) {
            parsedObject.text = tiledObject.text;
          } else if (tiledObject.point) {
            parsedObject.point = true;
          } else {
            parsedObject.rectangle = true;
          }
          return parsedObject;
        };
        module2.exports = ParseObject;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FLIPPED_HORIZONTAL = 2147483648;
        var FLIPPED_VERTICAL = 1073741824;
        var FLIPPED_ANTI_DIAGONAL = 536870912;
        var ParseGID = function(gid) {
          var flippedHorizontal = Boolean(gid & FLIPPED_HORIZONTAL);
          var flippedVertical = Boolean(gid & FLIPPED_VERTICAL);
          var flippedAntiDiagonal = Boolean(gid & FLIPPED_ANTI_DIAGONAL);
          gid = gid & ~(FLIPPED_HORIZONTAL | FLIPPED_VERTICAL | FLIPPED_ANTI_DIAGONAL);
          var rotation = 0;
          var flipped = false;
          if (flippedHorizontal && flippedVertical && flippedAntiDiagonal) {
            rotation = Math.PI / 2;
            flipped = true;
          } else if (flippedHorizontal && flippedVertical && !flippedAntiDiagonal) {
            rotation = Math.PI;
            flipped = false;
          } else if (flippedHorizontal && !flippedVertical && flippedAntiDiagonal) {
            rotation = Math.PI / 2;
            flipped = false;
          } else if (flippedHorizontal && !flippedVertical && !flippedAntiDiagonal) {
            rotation = 0;
            flipped = true;
          } else if (!flippedHorizontal && flippedVertical && flippedAntiDiagonal) {
            rotation = 3 * Math.PI / 2;
            flipped = false;
          } else if (!flippedHorizontal && flippedVertical && !flippedAntiDiagonal) {
            rotation = Math.PI;
            flipped = true;
          } else if (!flippedHorizontal && !flippedVertical && flippedAntiDiagonal) {
            rotation = 3 * Math.PI / 2;
            flipped = true;
          } else if (!flippedHorizontal && !flippedVertical && !flippedAntiDiagonal) {
            rotation = 0;
            flipped = false;
          }
          return {
            gid,
            flippedHorizontal,
            flippedVertical,
            flippedAntiDiagonal,
            rotation,
            flipped
          };
        };
        module2.exports = ParseGID;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Formats = __webpack_require__(40);
        var MapData = __webpack_require__(121);
        var Parse = __webpack_require__(564);
        var Tilemap = __webpack_require__(580);
        var ParseToTilemap = function(scene, key, tileWidth, tileHeight, width, height, data, insertNull) {
          if (tileWidth === void 0) {
            tileWidth = 32;
          }
          if (tileHeight === void 0) {
            tileHeight = 32;
          }
          if (width === void 0) {
            width = 10;
          }
          if (height === void 0) {
            height = 10;
          }
          if (insertNull === void 0) {
            insertNull = false;
          }
          var mapData = null;
          if (Array.isArray(data)) {
            var name = key !== void 0 ? key : "map";
            mapData = Parse(name, Formats.ARRAY_2D, data, tileWidth, tileHeight, insertNull);
          } else if (key !== void 0) {
            var tilemapData = scene.cache.tilemap.get(key);
            if (!tilemapData) {
              console.warn("No map data found for key " + key);
            } else {
              mapData = Parse(key, tilemapData.format, tilemapData.data, tileWidth, tileHeight, insertNull);
            }
          }
          if (mapData === null) {
            mapData = new MapData({
              tileWidth,
              tileHeight,
              width,
              height
            });
          }
          return new Tilemap(scene, mapData);
        };
        module2.exports = ParseToTilemap;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetValue = __webpack_require__(6);
        var GetTargets = function(config) {
          var targets = GetValue(config, "targets", null);
          if (targets === null) {
            return targets;
          }
          if (typeof targets === "function") {
            targets = targets.call();
          }
          if (!Array.isArray(targets)) {
            targets = [targets];
          }
          return targets;
        };
        module2.exports = GetTargets;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        function hasGetActive(def) {
          return !!def.getActive && typeof def.getActive === "function";
        }
        function hasGetStart(def) {
          return !!def.getStart && typeof def.getStart === "function";
        }
        function hasGetEnd(def) {
          return !!def.getEnd && typeof def.getEnd === "function";
        }
        function hasGetters(def) {
          return hasGetStart(def) || hasGetEnd(def) || hasGetActive(def);
        }
        var GetValueOp = function(key, propertyValue) {
          var callbacks;
          var getEnd = function(target, key2, value) {
            return value;
          };
          var getStart = function(target, key2, value) {
            return value;
          };
          var getActive = null;
          var t2 = typeof propertyValue;
          if (t2 === "number") {
            getEnd = function() {
              return propertyValue;
            };
          } else if (t2 === "string") {
            var op = propertyValue[0];
            var num = parseFloat(propertyValue.substr(2));
            switch (op) {
              case "+":
                getEnd = function(target, key2, value) {
                  return value + num;
                };
                break;
              case "-":
                getEnd = function(target, key2, value) {
                  return value - num;
                };
                break;
              case "*":
                getEnd = function(target, key2, value) {
                  return value * num;
                };
                break;
              case "/":
                getEnd = function(target, key2, value) {
                  return value / num;
                };
                break;
              default:
                getEnd = function() {
                  return parseFloat(propertyValue);
                };
            }
          } else if (t2 === "function") {
            getEnd = propertyValue;
          } else if (t2 === "object") {
            if (hasGetters(propertyValue)) {
              if (hasGetActive(propertyValue)) {
                getActive = propertyValue.getActive;
              }
              if (hasGetEnd(propertyValue)) {
                getEnd = propertyValue.getEnd;
              }
              if (hasGetStart(propertyValue)) {
                getStart = propertyValue.getStart;
              }
            } else if (propertyValue.hasOwnProperty("value")) {
              callbacks = GetValueOp(key, propertyValue.value);
            } else {
              var hasTo = propertyValue.hasOwnProperty("to");
              var hasFrom = propertyValue.hasOwnProperty("from");
              var hasStart = propertyValue.hasOwnProperty("start");
              if (hasTo && (hasFrom || hasStart)) {
                callbacks = GetValueOp(key, propertyValue.to);
                if (hasStart) {
                  var startCallbacks = GetValueOp(key, propertyValue.start);
                  callbacks.getActive = startCallbacks.getEnd;
                }
                if (hasFrom) {
                  var fromCallbacks = GetValueOp(key, propertyValue.from);
                  callbacks.getStart = fromCallbacks.getEnd;
                }
              }
            }
          }
          if (!callbacks) {
            callbacks = {
              getActive,
              getEnd,
              getStart
            };
          }
          return callbacks;
        };
        module2.exports = GetValueOp;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TWEEN_DEFAULTS = {
          targets: null,
          delay: 0,
          duration: 1e3,
          ease: "Power0",
          easeParams: null,
          hold: 0,
          repeat: 0,
          repeatDelay: 0,
          yoyo: false,
          flipX: false,
          flipY: false
        };
        module2.exports = TWEEN_DEFAULTS;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(267);
        var GameObjectCreator = __webpack_require__(16);
        var GameObjectFactory = __webpack_require__(5);
        var TWEEN_CONST = __webpack_require__(100);
        var MATH_CONST = __webpack_require__(14);
        var Tween = new Class({
          Extends: EventEmitter,
          initialize: function Tween2(parent, data, targets) {
            EventEmitter.call(this);
            this.parent = parent;
            this.parentIsTimeline = parent.hasOwnProperty("isTimeline");
            this.data = data;
            this.totalData = data.length;
            this.targets = targets;
            this.totalTargets = targets.length;
            this.useFrames = false;
            this.timeScale = 1;
            this.loop = 0;
            this.loopDelay = 0;
            this.loopCounter = 0;
            this.startDelay = 0;
            this.hasStarted = false;
            this.isSeeking = false;
            this.completeDelay = 0;
            this.countdown = 0;
            this.offset = 0;
            this.calculatedOffset = 0;
            this.state = TWEEN_CONST.PENDING_ADD;
            this._pausedState = TWEEN_CONST.INIT;
            this.paused = false;
            this.elapsed = 0;
            this.totalElapsed = 0;
            this.duration = 0;
            this.progress = 0;
            this.totalDuration = 0;
            this.totalProgress = 0;
            this.callbacks = {
              onActive: null,
              onComplete: null,
              onLoop: null,
              onRepeat: null,
              onStart: null,
              onStop: null,
              onUpdate: null,
              onYoyo: null
            };
            this.callbackScope;
          },
          getValue: function(index2) {
            if (index2 === void 0) {
              index2 = 0;
            }
            return this.data[index2].current;
          },
          setTimeScale: function(value) {
            this.timeScale = value;
            return this;
          },
          getTimeScale: function() {
            return this.timeScale;
          },
          isPlaying: function() {
            return this.state === TWEEN_CONST.ACTIVE;
          },
          isPaused: function() {
            return this.state === TWEEN_CONST.PAUSED;
          },
          hasTarget: function(target) {
            return this.targets.indexOf(target) !== -1;
          },
          updateTo: function(key, value, startToCurrent) {
            if (startToCurrent === void 0) {
              startToCurrent = false;
            }
            for (var i2 = 0; i2 < this.totalData; i2++) {
              var tweenData = this.data[i2];
              if (tweenData.key === key) {
                tweenData.end = value;
                if (startToCurrent) {
                  tweenData.start = tweenData.current;
                }
              }
            }
            return this;
          },
          restart: function() {
            this.elapsed = 0;
            this.progress = 0;
            this.totalElapsed = 0;
            this.totalProgress = 0;
            if (this.state === TWEEN_CONST.ACTIVE) {
              return this.seek(0);
            } else if (this.state === TWEEN_CONST.REMOVED) {
              this.seek(0);
              this.parent.makeActive(this);
              return this;
            } else if (this.state === TWEEN_CONST.PENDING_ADD) {
              return this;
            } else {
              return this.play();
            }
          },
          calcDuration: function() {
            var maxDuration = 0;
            var minDelay = MATH_CONST.MAX_SAFE_INTEGER;
            var data = this.data;
            for (var i2 = 0; i2 < this.totalData; i2++) {
              var tweenData = data[i2];
              tweenData.t1 = tweenData.duration + tweenData.hold;
              if (tweenData.yoyo) {
                tweenData.t1 += tweenData.duration;
              }
              tweenData.t2 = tweenData.t1 + tweenData.repeatDelay;
              tweenData.totalDuration = tweenData.delay + tweenData.t1;
              if (tweenData.repeat === -1) {
                tweenData.totalDuration += tweenData.t2 * 999999999999;
              } else if (tweenData.repeat > 0) {
                tweenData.totalDuration += tweenData.t2 * tweenData.repeat;
              }
              if (tweenData.totalDuration > maxDuration) {
                maxDuration = tweenData.totalDuration;
              }
              if (tweenData.delay < minDelay) {
                minDelay = tweenData.delay;
              }
            }
            this.duration = Math.max(maxDuration, 1e-3);
            this.loopCounter = this.loop === -1 ? 999999999999 : this.loop;
            if (this.loopCounter > 0) {
              this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter;
            } else {
              this.totalDuration = this.duration + this.completeDelay;
            }
            this.startDelay = minDelay;
          },
          init: function() {
            if (this.paused && !this.parentIsTimeline) {
              this.state = TWEEN_CONST.PENDING_ADD;
              this._pausedState = TWEEN_CONST.INIT;
              return false;
            }
            var data = this.data;
            var totalTargets = this.totalTargets;
            for (var i2 = 0; i2 < this.totalData; i2++) {
              var tweenData = data[i2];
              var target = tweenData.target;
              var gen = tweenData.gen;
              var key = tweenData.key;
              var targetIndex = tweenData.index;
              tweenData.delay = gen.delay(target, key, 0, targetIndex, totalTargets, this);
              tweenData.duration = Math.max(gen.duration(target, key, 0, targetIndex, totalTargets, this), 1e-3);
              tweenData.hold = gen.hold(target, key, 0, targetIndex, totalTargets, this);
              tweenData.repeat = gen.repeat(target, key, 0, targetIndex, totalTargets, this);
              tweenData.repeatDelay = gen.repeatDelay(target, key, 0, targetIndex, totalTargets, this);
            }
            this.calcDuration();
            this.progress = 0;
            this.totalProgress = 0;
            this.elapsed = 0;
            this.totalElapsed = 0;
            this.state = TWEEN_CONST.INIT;
            return true;
          },
          makeActive: function() {
            this.parent.makeActive(this);
            this.dispatchTweenEvent(Events.TWEEN_ACTIVE, this.callbacks.onActive);
          },
          nextState: function() {
            if (this.loopCounter > 0) {
              this.elapsed = 0;
              this.progress = 0;
              this.loopCounter--;
              this.resetTweenData(true);
              if (this.loopDelay > 0) {
                this.countdown = this.loopDelay;
                this.state = TWEEN_CONST.LOOP_DELAY;
              } else {
                this.state = TWEEN_CONST.ACTIVE;
                this.dispatchTweenEvent(Events.TWEEN_LOOP, this.callbacks.onLoop);
              }
            } else if (this.completeDelay > 0) {
              this.state = TWEEN_CONST.COMPLETE_DELAY;
              this.countdown = this.completeDelay;
            } else {
              this.state = TWEEN_CONST.PENDING_REMOVE;
              this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete);
            }
          },
          pause: function() {
            if (this.state === TWEEN_CONST.PAUSED) {
              return this;
            }
            this.paused = true;
            this._pausedState = this.state;
            this.state = TWEEN_CONST.PAUSED;
            return this;
          },
          play: function(resetFromTimeline) {
            if (resetFromTimeline === void 0) {
              resetFromTimeline = false;
            }
            var state = this.state;
            if (state === TWEEN_CONST.INIT && !this.parentIsTimeline) {
              this.resetTweenData(false);
              this.state = TWEEN_CONST.ACTIVE;
              return this;
            } else if (state === TWEEN_CONST.ACTIVE || state === TWEEN_CONST.PENDING_ADD && this._pausedState === TWEEN_CONST.PENDING_ADD) {
              return this;
            } else if (!this.parentIsTimeline && (state === TWEEN_CONST.PENDING_REMOVE || state === TWEEN_CONST.REMOVED)) {
              this.seek(0);
              this.parent.makeActive(this);
              return this;
            }
            if (this.parentIsTimeline) {
              this.resetTweenData(resetFromTimeline);
              if (this.calculatedOffset === 0) {
                this.state = TWEEN_CONST.ACTIVE;
              } else {
                this.countdown = this.calculatedOffset;
                this.state = TWEEN_CONST.OFFSET_DELAY;
              }
            } else if (this.paused) {
              this.paused = false;
              this.makeActive();
            } else {
              this.resetTweenData(resetFromTimeline);
              this.state = TWEEN_CONST.ACTIVE;
              this.makeActive();
            }
            return this;
          },
          resetTweenData: function(resetFromLoop) {
            var data = this.data;
            var total = this.totalData;
            var totalTargets = this.totalTargets;
            for (var i2 = 0; i2 < total; i2++) {
              var tweenData = data[i2];
              var target = tweenData.target;
              var key = tweenData.key;
              var targetIndex = tweenData.index;
              tweenData.progress = 0;
              tweenData.elapsed = 0;
              tweenData.repeatCounter = tweenData.repeat === -1 ? 999999999999 : tweenData.repeat;
              if (resetFromLoop) {
                tweenData.start = tweenData.getStartValue(target, key, tweenData.start, targetIndex, totalTargets, this);
                tweenData.end = tweenData.getEndValue(target, key, tweenData.end, targetIndex, totalTargets, this);
                tweenData.current = tweenData.start;
                tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
              } else {
                tweenData.state = TWEEN_CONST.PENDING_RENDER;
              }
              if (tweenData.delay > 0) {
                tweenData.elapsed = tweenData.delay;
                tweenData.state = TWEEN_CONST.DELAY;
              }
              if (tweenData.getActiveValue) {
                target[key] = tweenData.getActiveValue(tweenData.target, tweenData.key, tweenData.start);
              }
            }
          },
          resume: function() {
            if (this.state === TWEEN_CONST.PAUSED) {
              this.paused = false;
              this.state = this._pausedState;
            } else {
              this.play();
            }
            return this;
          },
          seek: function(toPosition, delta) {
            if (delta === void 0) {
              delta = 16.6;
            }
            if (this.state === TWEEN_CONST.REMOVED) {
              this.makeActive();
            }
            this.elapsed = 0;
            this.progress = 0;
            this.totalElapsed = 0;
            this.totalProgress = 0;
            var data = this.data;
            var totalTargets = this.totalTargets;
            for (var i2 = 0; i2 < this.totalData; i2++) {
              var tweenData = data[i2];
              var target = tweenData.target;
              var gen = tweenData.gen;
              var key = tweenData.key;
              var targetIndex = tweenData.index;
              tweenData.progress = 0;
              tweenData.elapsed = 0;
              tweenData.repeatCounter = tweenData.repeat === -1 ? 999999999999 : tweenData.repeat;
              tweenData.delay = gen.delay(target, key, 0, targetIndex, totalTargets, this);
              tweenData.duration = Math.max(gen.duration(target, key, 0, targetIndex, totalTargets, this), 1e-3);
              tweenData.hold = gen.hold(target, key, 0, targetIndex, totalTargets, this);
              tweenData.repeat = gen.repeat(target, key, 0, targetIndex, totalTargets, this);
              tweenData.repeatDelay = gen.repeatDelay(target, key, 0, targetIndex, totalTargets, this);
              tweenData.current = tweenData.start;
              tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
              this.updateTweenData(this, tweenData, 0, targetIndex, totalTargets);
              if (tweenData.delay > 0) {
                tweenData.elapsed = tweenData.delay;
                tweenData.state = TWEEN_CONST.DELAY;
              }
            }
            this.calcDuration();
            var wasPaused = false;
            if (this.state === TWEEN_CONST.PAUSED) {
              wasPaused = true;
              this.state = TWEEN_CONST.ACTIVE;
            }
            this.isSeeking = true;
            do {
              this.update(0, delta);
            } while (this.totalProgress < toPosition);
            this.isSeeking = false;
            if (wasPaused) {
              this.state = TWEEN_CONST.PAUSED;
            }
            return this;
          },
          setCallback: function(type, callback, params, scope) {
            this.callbacks[type] = { func: callback, scope, params };
            return this;
          },
          complete: function(delay) {
            if (delay === void 0) {
              delay = 0;
            }
            if (delay) {
              this.state = TWEEN_CONST.COMPLETE_DELAY;
              this.countdown = delay;
            } else {
              this.state = TWEEN_CONST.PENDING_REMOVE;
              this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete);
            }
            return this;
          },
          remove: function() {
            this.parent.remove(this);
            return this;
          },
          stop: function(resetTo) {
            if (this.state === TWEEN_CONST.ACTIVE) {
              if (resetTo !== void 0) {
                this.seek(resetTo);
              }
            }
            if (this.state !== TWEEN_CONST.REMOVED) {
              if (this.state === TWEEN_CONST.PAUSED || this.state === TWEEN_CONST.PENDING_ADD) {
                if (this.parentIsTimeline) {
                  this.parent.manager._destroy.push(this);
                  this.parent.manager._toProcess++;
                } else {
                  this.parent._destroy.push(this);
                  this.parent._toProcess++;
                }
              }
              this.dispatchTweenEvent(Events.TWEEN_STOP, this.callbacks.onStop);
              this.removeAllListeners();
              this.state = TWEEN_CONST.PENDING_REMOVE;
            }
            return this;
          },
          update: function(timestamp, delta) {
            if (this.state === TWEEN_CONST.PAUSED) {
              return false;
            }
            if (this.useFrames) {
              delta = 1 * this.parent.timeScale;
            }
            delta *= this.timeScale;
            this.elapsed += delta;
            this.progress = Math.min(this.elapsed / this.duration, 1);
            this.totalElapsed += delta;
            this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);
            switch (this.state) {
              case TWEEN_CONST.ACTIVE:
                if (!this.hasStarted && !this.isSeeking) {
                  this.startDelay -= delta;
                  if (this.startDelay <= 0) {
                    this.hasStarted = true;
                    this.dispatchTweenEvent(Events.TWEEN_START, this.callbacks.onStart);
                  }
                }
                var stillRunning = false;
                for (var i2 = 0; i2 < this.totalData; i2++) {
                  var tweenData = this.data[i2];
                  if (this.updateTweenData(this, tweenData, delta)) {
                    stillRunning = true;
                  }
                }
                if (!stillRunning) {
                  this.nextState();
                }
                break;
              case TWEEN_CONST.LOOP_DELAY:
                this.countdown -= delta;
                if (this.countdown <= 0) {
                  this.state = TWEEN_CONST.ACTIVE;
                  this.dispatchTweenEvent(Events.TWEEN_LOOP, this.callbacks.onLoop);
                }
                break;
              case TWEEN_CONST.OFFSET_DELAY:
                this.countdown -= delta;
                if (this.countdown <= 0) {
                  this.state = TWEEN_CONST.ACTIVE;
                }
                break;
              case TWEEN_CONST.COMPLETE_DELAY:
                this.countdown -= delta;
                if (this.countdown <= 0) {
                  this.state = TWEEN_CONST.PENDING_REMOVE;
                  this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete);
                }
                break;
            }
            return this.state === TWEEN_CONST.PENDING_REMOVE;
          },
          dispatchTweenDataEvent: function(event, callback, tweenData) {
            if (!this.isSeeking) {
              this.emit(event, this, tweenData.key, tweenData.target, tweenData.current, tweenData.previous);
              if (callback) {
                callback.params[1] = tweenData.target;
                callback.func.apply(callback.scope, callback.params);
              }
            }
          },
          dispatchTweenEvent: function(event, callback) {
            if (!this.isSeeking) {
              this.emit(event, this, this.targets);
              if (callback) {
                callback.params[1] = this.targets;
                callback.func.apply(callback.scope, callback.params);
              }
            }
          },
          setStateFromEnd: function(tween, tweenData, diff) {
            if (tweenData.yoyo) {
              tweenData.elapsed = diff;
              tweenData.progress = diff / tweenData.duration;
              if (tweenData.flipX) {
                tweenData.target.toggleFlipX();
              }
              if (tweenData.flipY) {
                tweenData.target.toggleFlipY();
              }
              this.dispatchTweenDataEvent(Events.TWEEN_YOYO, tween.callbacks.onYoyo, tweenData);
              tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
              return TWEEN_CONST.PLAYING_BACKWARD;
            } else if (tweenData.repeatCounter > 0) {
              tweenData.repeatCounter--;
              tweenData.elapsed = diff;
              tweenData.progress = diff / tweenData.duration;
              if (tweenData.flipX) {
                tweenData.target.toggleFlipX();
              }
              if (tweenData.flipY) {
                tweenData.target.toggleFlipY();
              }
              tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
              tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
              if (tweenData.repeatDelay > 0) {
                tweenData.elapsed = tweenData.repeatDelay - diff;
                tweenData.current = tweenData.start;
                tweenData.target[tweenData.key] = tweenData.current;
                return TWEEN_CONST.REPEAT_DELAY;
              } else {
                this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData);
                return TWEEN_CONST.PLAYING_FORWARD;
              }
            }
            return TWEEN_CONST.COMPLETE;
          },
          setStateFromStart: function(tween, tweenData, diff) {
            if (tweenData.repeatCounter > 0) {
              tweenData.repeatCounter--;
              tweenData.elapsed = diff;
              tweenData.progress = diff / tweenData.duration;
              if (tweenData.flipX) {
                tweenData.target.toggleFlipX();
              }
              if (tweenData.flipY) {
                tweenData.target.toggleFlipY();
              }
              tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
              if (tweenData.repeatDelay > 0) {
                tweenData.elapsed = tweenData.repeatDelay - diff;
                tweenData.current = tweenData.start;
                tweenData.target[tweenData.key] = tweenData.current;
                return TWEEN_CONST.REPEAT_DELAY;
              } else {
                this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData);
                return TWEEN_CONST.PLAYING_FORWARD;
              }
            }
            return TWEEN_CONST.COMPLETE;
          },
          updateTweenData: function(tween, tweenData, delta) {
            var target = tweenData.target;
            switch (tweenData.state) {
              case TWEEN_CONST.PLAYING_FORWARD:
              case TWEEN_CONST.PLAYING_BACKWARD:
                if (!target) {
                  tweenData.state = TWEEN_CONST.COMPLETE;
                  break;
                }
                var elapsed = tweenData.elapsed;
                var duration = tweenData.duration;
                var diff = 0;
                elapsed += delta;
                if (elapsed > duration) {
                  diff = elapsed - duration;
                  elapsed = duration;
                }
                var forward = tweenData.state === TWEEN_CONST.PLAYING_FORWARD;
                var progress = elapsed / duration;
                tweenData.elapsed = elapsed;
                tweenData.progress = progress;
                tweenData.previous = tweenData.current;
                if (progress === 1) {
                  if (forward) {
                    tweenData.current = tweenData.end;
                    target[tweenData.key] = tweenData.end;
                    if (tweenData.hold > 0) {
                      tweenData.elapsed = tweenData.hold - diff;
                      tweenData.state = TWEEN_CONST.HOLD_DELAY;
                    } else {
                      tweenData.state = this.setStateFromEnd(tween, tweenData, diff);
                    }
                  } else {
                    tweenData.current = tweenData.start;
                    target[tweenData.key] = tweenData.start;
                    tweenData.state = this.setStateFromStart(tween, tweenData, diff);
                  }
                } else {
                  var v2 = forward ? tweenData.ease(progress) : tweenData.ease(1 - progress);
                  tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v2;
                  target[tweenData.key] = tweenData.current;
                }
                this.dispatchTweenDataEvent(Events.TWEEN_UPDATE, tween.callbacks.onUpdate, tweenData);
                break;
              case TWEEN_CONST.DELAY:
                tweenData.elapsed -= delta;
                if (tweenData.elapsed <= 0) {
                  tweenData.elapsed = Math.abs(tweenData.elapsed);
                  tweenData.state = TWEEN_CONST.PENDING_RENDER;
                }
                break;
              case TWEEN_CONST.REPEAT_DELAY:
                tweenData.elapsed -= delta;
                if (tweenData.elapsed <= 0) {
                  tweenData.elapsed = Math.abs(tweenData.elapsed);
                  tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
                  this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData);
                }
                break;
              case TWEEN_CONST.HOLD_DELAY:
                tweenData.elapsed -= delta;
                if (tweenData.elapsed <= 0) {
                  tweenData.state = this.setStateFromEnd(tween, tweenData, Math.abs(tweenData.elapsed));
                }
                break;
              case TWEEN_CONST.PENDING_RENDER:
                if (target) {
                  tweenData.start = tweenData.getStartValue(target, tweenData.key, target[tweenData.key], tweenData.index, tween.totalTargets, tween);
                  tweenData.end = tweenData.getEndValue(target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
                  tweenData.current = tweenData.start;
                  target[tweenData.key] = tweenData.start;
                  tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
                } else {
                  tweenData.state = TWEEN_CONST.COMPLETE;
                }
                break;
            }
            return tweenData.state !== TWEEN_CONST.COMPLETE;
          }
        });
        Tween.TYPES = [
          "onActive",
          "onComplete",
          "onLoop",
          "onRepeat",
          "onStart",
          "onStop",
          "onUpdate",
          "onYoyo"
        ];
        GameObjectFactory.register("tween", function(config) {
          return this.scene.sys.tweens.add(config);
        });
        GameObjectCreator.register("tween", function(config) {
          return this.scene.sys.tweens.create(config);
        });
        module2.exports = Tween;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          TIMELINE_COMPLETE: __webpack_require__(1466),
          TIMELINE_LOOP: __webpack_require__(1467),
          TIMELINE_PAUSE: __webpack_require__(1468),
          TIMELINE_RESUME: __webpack_require__(1469),
          TIMELINE_START: __webpack_require__(1470),
          TIMELINE_UPDATE: __webpack_require__(1471),
          TWEEN_ACTIVE: __webpack_require__(1472),
          TWEEN_COMPLETE: __webpack_require__(1473),
          TWEEN_LOOP: __webpack_require__(1474),
          TWEEN_REPEAT: __webpack_require__(1475),
          TWEEN_START: __webpack_require__(1476),
          TWEEN_STOP: __webpack_require__(1477),
          TWEEN_UPDATE: __webpack_require__(1478),
          TWEEN_YOYO: __webpack_require__(1479)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TweenData = function(target, index2, key, getEnd, getStart, getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY) {
          return {
            target,
            index: index2,
            key,
            getActiveValue: getActive,
            getEndValue: getEnd,
            getStartValue: getStart,
            ease,
            duration: 0,
            totalDuration: 0,
            delay: 0,
            yoyo,
            hold: 0,
            repeat: 0,
            repeatDelay: 0,
            flipX,
            flipY,
            progress: 0,
            elapsed: 0,
            repeatCounter: 0,
            start: 0,
            previous: 0,
            current: 0,
            end: 0,
            t1: 0,
            t2: 0,
            gen: {
              delay,
              duration,
              hold,
              repeat,
              repeatDelay
            },
            state: 0
          };
        };
        module2.exports = TweenData;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MathWrap = __webpack_require__(68);
        var Wrap = function(angle) {
          return MathWrap(angle, -Math.PI, Math.PI);
        };
        module2.exports = Wrap;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Wrap = __webpack_require__(68);
        var WrapDegrees = function(angle) {
          return Wrap(angle, -180, 180);
        };
        module2.exports = WrapDegrees;
      },
      function(module2, exports2, __webpack_require__) {
        var Axes = {};
        module2.exports = Axes;
        var Vector = __webpack_require__(83);
        var Common = __webpack_require__(32);
        (function() {
          Axes.fromVertices = function(vertices) {
            var axes = {};
            for (var i2 = 0; i2 < vertices.length; i2++) {
              var j = (i2 + 1) % vertices.length, normal = Vector.normalise({
                x: vertices[j].y - vertices[i2].y,
                y: vertices[i2].x - vertices[j].x
              }), gradient = normal.y === 0 ? Infinity : normal.x / normal.y;
              gradient = gradient.toFixed(3).toString();
              axes[gradient] = normal;
            }
            return Common.values(axes);
          };
          Axes.rotate = function(axes, angle) {
            if (angle === 0)
              return;
            var cos = Math.cos(angle), sin = Math.sin(angle);
            for (var i2 = 0; i2 < axes.length; i2++) {
              var axis = axes[i2], xx;
              xx = axis.x * cos - axis.y * sin;
              axis.y = axis.x * sin + axis.y * cos;
              axis.x = xx;
            }
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          AFTER_ADD: __webpack_require__(1504),
          AFTER_REMOVE: __webpack_require__(1505),
          AFTER_UPDATE: __webpack_require__(1506),
          BEFORE_ADD: __webpack_require__(1507),
          BEFORE_REMOVE: __webpack_require__(1508),
          BEFORE_UPDATE: __webpack_require__(1509),
          COLLISION_ACTIVE: __webpack_require__(1510),
          COLLISION_END: __webpack_require__(1511),
          COLLISION_START: __webpack_require__(1512),
          DRAG_END: __webpack_require__(1513),
          DRAG: __webpack_require__(1514),
          DRAG_START: __webpack_require__(1515),
          PAUSE: __webpack_require__(1516),
          RESUME: __webpack_require__(1517),
          SLEEP_END: __webpack_require__(1518),
          SLEEP_START: __webpack_require__(1519)
        };
      },
      function(module2, exports2, __webpack_require__) {
        var Detector = {};
        module2.exports = Detector;
        var SAT = __webpack_require__(274);
        var Pair = __webpack_require__(250);
        var Bounds = __webpack_require__(84);
        (function() {
          Detector.collisions = function(broadphasePairs, engine) {
            var collisions = [], pairsTable = engine.pairs.table;
            var metrics = engine.metrics;
            for (var i2 = 0; i2 < broadphasePairs.length; i2++) {
              var bodyA = broadphasePairs[i2][0], bodyB = broadphasePairs[i2][1];
              if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))
                continue;
              if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))
                continue;
              metrics.midphaseTests += 1;
              if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {
                for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {
                  var partA = bodyA.parts[j];
                  for (var k2 = bodyB.parts.length > 1 ? 1 : 0; k2 < bodyB.parts.length; k2++) {
                    var partB = bodyB.parts[k2];
                    if (partA === bodyA && partB === bodyB || Bounds.overlaps(partA.bounds, partB.bounds)) {
                      var pairId = Pair.id(partA, partB), pair = pairsTable[pairId], previousCollision;
                      if (pair && pair.isActive) {
                        previousCollision = pair.collision;
                      } else {
                        previousCollision = null;
                      }
                      var collision = SAT.collides(partA, partB, previousCollision);
                      metrics.narrowphaseTests += 1;
                      if (collision.reused)
                        metrics.narrowReuseCount += 1;
                      if (collision.collided) {
                        collisions.push(collision);
                        metrics.narrowDetections += 1;
                      }
                    }
                  }
                }
              }
            }
            return collisions;
          };
          Detector.canCollide = function(filterA, filterB) {
            if (filterA.group === filterB.group && filterA.group !== 0)
              return filterA.group > 0;
            return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        var SAT = {};
        module2.exports = SAT;
        var Vertices = __webpack_require__(64);
        var Vector = __webpack_require__(83);
        (function() {
          SAT.collides = function(bodyA, bodyB, previousCollision) {
            var overlapAB, overlapBA, minOverlap, collision, canReusePrevCol = false;
            if (previousCollision) {
              var parentA = bodyA.parent, parentB = bodyB.parent, motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;
              canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;
              collision = previousCollision;
            } else {
              collision = { collided: false, bodyA, bodyB };
            }
            if (previousCollision && canReusePrevCol) {
              var axisBodyA = collision.axisBody, axisBodyB = axisBodyA === bodyA ? bodyB : bodyA, axes = [axisBodyA.axes[previousCollision.axisNumber]];
              minOverlap = SAT._overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);
              collision.reused = true;
              if (minOverlap.overlap <= 0) {
                collision.collided = false;
                return collision;
              }
            } else {
              overlapAB = SAT._overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);
              if (overlapAB.overlap <= 0) {
                collision.collided = false;
                return collision;
              }
              overlapBA = SAT._overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);
              if (overlapBA.overlap <= 0) {
                collision.collided = false;
                return collision;
              }
              if (overlapAB.overlap < overlapBA.overlap) {
                minOverlap = overlapAB;
                collision.axisBody = bodyA;
              } else {
                minOverlap = overlapBA;
                collision.axisBody = bodyB;
              }
              collision.axisNumber = minOverlap.axisNumber;
            }
            collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;
            collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;
            collision.collided = true;
            collision.depth = minOverlap.overlap;
            collision.parentA = collision.bodyA.parent;
            collision.parentB = collision.bodyB.parent;
            bodyA = collision.bodyA;
            bodyB = collision.bodyB;
            if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {
              collision.normal = {
                x: minOverlap.axis.x,
                y: minOverlap.axis.y
              };
            } else {
              collision.normal = {
                x: -minOverlap.axis.x,
                y: -minOverlap.axis.y
              };
            }
            collision.tangent = Vector.perp(collision.normal);
            collision.penetration = collision.penetration || {};
            collision.penetration.x = collision.normal.x * collision.depth;
            collision.penetration.y = collision.normal.y * collision.depth;
            var verticesB = SAT._findSupports(bodyA, bodyB, collision.normal), supports = [];
            if (Vertices.contains(bodyA.vertices, verticesB[0]))
              supports.push(verticesB[0]);
            if (Vertices.contains(bodyA.vertices, verticesB[1]))
              supports.push(verticesB[1]);
            if (supports.length < 2) {
              var verticesA = SAT._findSupports(bodyB, bodyA, Vector.neg(collision.normal));
              if (Vertices.contains(bodyB.vertices, verticesA[0]))
                supports.push(verticesA[0]);
              if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1]))
                supports.push(verticesA[1]);
            }
            if (supports.length < 1)
              supports = [verticesB[0]];
            collision.supports = supports;
            return collision;
          };
          SAT._overlapAxes = function(verticesA, verticesB, axes) {
            var projectionA = Vector._temp[0], projectionB = Vector._temp[1], result = { overlap: Number.MAX_VALUE }, overlap, axis;
            for (var i2 = 0; i2 < axes.length; i2++) {
              axis = axes[i2];
              SAT._projectToAxis(projectionA, verticesA, axis);
              SAT._projectToAxis(projectionB, verticesB, axis);
              overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);
              if (overlap <= 0) {
                result.overlap = overlap;
                return result;
              }
              if (overlap < result.overlap) {
                result.overlap = overlap;
                result.axis = axis;
                result.axisNumber = i2;
              }
            }
            return result;
          };
          SAT._projectToAxis = function(projection, vertices, axis) {
            var min = Vector.dot(vertices[0], axis), max = min;
            for (var i2 = 1; i2 < vertices.length; i2 += 1) {
              var dot = Vector.dot(vertices[i2], axis);
              if (dot > max) {
                max = dot;
              } else if (dot < min) {
                min = dot;
              }
            }
            projection.min = min;
            projection.max = max;
          };
          SAT._findSupports = function(bodyA, bodyB, normal) {
            var nearestDistance = Number.MAX_VALUE, vertexToBody = Vector._temp[0], vertices = bodyB.vertices, bodyAPosition = bodyA.position, distance, vertex, vertexA, vertexB;
            for (var i2 = 0; i2 < vertices.length; i2++) {
              vertex = vertices[i2];
              vertexToBody.x = vertex.x - bodyAPosition.x;
              vertexToBody.y = vertex.y - bodyAPosition.y;
              distance = -Vector.dot(normal, vertexToBody);
              if (distance < nearestDistance) {
                nearestDistance = distance;
                vertexA = vertex;
              }
            }
            var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;
            vertex = vertices[prevIndex];
            vertexToBody.x = vertex.x - bodyAPosition.x;
            vertexToBody.y = vertex.y - bodyAPosition.y;
            nearestDistance = -Vector.dot(normal, vertexToBody);
            vertexB = vertex;
            var nextIndex = (vertexA.index + 1) % vertices.length;
            vertex = vertices[nextIndex];
            vertexToBody.x = vertex.x - bodyAPosition.x;
            vertexToBody.y = vertex.y - bodyAPosition.y;
            distance = -Vector.dot(normal, vertexToBody);
            if (distance < nearestDistance) {
              vertexB = vertex;
            }
            return [vertexA, vertexB];
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          AlignTo: __webpack_require__(601),
          Angle: __webpack_require__(602),
          Call: __webpack_require__(603),
          GetFirst: __webpack_require__(604),
          GetLast: __webpack_require__(605),
          GridAlign: __webpack_require__(606),
          IncAlpha: __webpack_require__(678),
          IncX: __webpack_require__(679),
          IncXY: __webpack_require__(680),
          IncY: __webpack_require__(681),
          PlaceOnCircle: __webpack_require__(682),
          PlaceOnEllipse: __webpack_require__(683),
          PlaceOnLine: __webpack_require__(684),
          PlaceOnRectangle: __webpack_require__(685),
          PlaceOnTriangle: __webpack_require__(686),
          PlayAnimation: __webpack_require__(687),
          PropertyValueInc: __webpack_require__(46),
          PropertyValueSet: __webpack_require__(27),
          RandomCircle: __webpack_require__(688),
          RandomEllipse: __webpack_require__(689),
          RandomLine: __webpack_require__(690),
          RandomRectangle: __webpack_require__(691),
          RandomTriangle: __webpack_require__(692),
          Rotate: __webpack_require__(693),
          RotateAround: __webpack_require__(694),
          RotateAroundDistance: __webpack_require__(695),
          ScaleX: __webpack_require__(696),
          ScaleXY: __webpack_require__(697),
          ScaleY: __webpack_require__(698),
          SetAlpha: __webpack_require__(699),
          SetBlendMode: __webpack_require__(700),
          SetDepth: __webpack_require__(701),
          SetHitArea: __webpack_require__(702),
          SetOrigin: __webpack_require__(703),
          SetRotation: __webpack_require__(704),
          SetScale: __webpack_require__(705),
          SetScaleX: __webpack_require__(706),
          SetScaleY: __webpack_require__(707),
          SetScrollFactor: __webpack_require__(708),
          SetScrollFactorX: __webpack_require__(709),
          SetScrollFactorY: __webpack_require__(710),
          SetTint: __webpack_require__(711),
          SetVisible: __webpack_require__(712),
          SetX: __webpack_require__(713),
          SetXY: __webpack_require__(714),
          SetY: __webpack_require__(715),
          ShiftPosition: __webpack_require__(716),
          Shuffle: __webpack_require__(717),
          SmootherStep: __webpack_require__(718),
          SmoothStep: __webpack_require__(719),
          Spread: __webpack_require__(720),
          ToggleVisible: __webpack_require__(721),
          WrapInRectangle: __webpack_require__(722)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       samme
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ALIGN_CONST = __webpack_require__(123);
        var AlignToMap = [];
        AlignToMap[ALIGN_CONST.BOTTOM_CENTER] = __webpack_require__(277);
        AlignToMap[ALIGN_CONST.BOTTOM_LEFT] = __webpack_require__(278);
        AlignToMap[ALIGN_CONST.BOTTOM_RIGHT] = __webpack_require__(279);
        AlignToMap[ALIGN_CONST.LEFT_BOTTOM] = __webpack_require__(280);
        AlignToMap[ALIGN_CONST.LEFT_CENTER] = __webpack_require__(281);
        AlignToMap[ALIGN_CONST.LEFT_TOP] = __webpack_require__(282);
        AlignToMap[ALIGN_CONST.RIGHT_BOTTOM] = __webpack_require__(283);
        AlignToMap[ALIGN_CONST.RIGHT_CENTER] = __webpack_require__(284);
        AlignToMap[ALIGN_CONST.RIGHT_TOP] = __webpack_require__(285);
        AlignToMap[ALIGN_CONST.TOP_CENTER] = __webpack_require__(286);
        AlignToMap[ALIGN_CONST.TOP_LEFT] = __webpack_require__(287);
        AlignToMap[ALIGN_CONST.TOP_RIGHT] = __webpack_require__(288);
        var QuickSet = function(child, alignTo, position, offsetX, offsetY) {
          return AlignToMap[position](child, alignTo, offsetX, offsetY);
        };
        module2.exports = QuickSet;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetBottom = __webpack_require__(42);
        var GetCenterX = __webpack_require__(87);
        var SetCenterX = __webpack_require__(88);
        var SetTop = __webpack_require__(52);
        var BottomCenter = function(gameObject, alignTo, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetCenterX(gameObject, GetCenterX(alignTo) + offsetX);
          SetTop(gameObject, GetBottom(alignTo) + offsetY);
          return gameObject;
        };
        module2.exports = BottomCenter;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetBottom = __webpack_require__(42);
        var GetLeft = __webpack_require__(43);
        var SetLeft = __webpack_require__(53);
        var SetTop = __webpack_require__(52);
        var BottomLeft = function(gameObject, alignTo, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetLeft(gameObject, GetLeft(alignTo) - offsetX);
          SetTop(gameObject, GetBottom(alignTo) + offsetY);
          return gameObject;
        };
        module2.exports = BottomLeft;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetBottom = __webpack_require__(42);
        var GetRight = __webpack_require__(44);
        var SetRight = __webpack_require__(54);
        var SetTop = __webpack_require__(52);
        var BottomRight = function(gameObject, alignTo, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetRight(gameObject, GetRight(alignTo) + offsetX);
          SetTop(gameObject, GetBottom(alignTo) + offsetY);
          return gameObject;
        };
        module2.exports = BottomRight;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetBottom = __webpack_require__(42);
        var GetLeft = __webpack_require__(43);
        var SetBottom = __webpack_require__(55);
        var SetRight = __webpack_require__(54);
        var LeftBottom = function(gameObject, alignTo, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetRight(gameObject, GetLeft(alignTo) - offsetX);
          SetBottom(gameObject, GetBottom(alignTo) + offsetY);
          return gameObject;
        };
        module2.exports = LeftBottom;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCenterY = __webpack_require__(89);
        var GetLeft = __webpack_require__(43);
        var SetCenterY = __webpack_require__(90);
        var SetRight = __webpack_require__(54);
        var LeftCenter = function(gameObject, alignTo, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetRight(gameObject, GetLeft(alignTo) - offsetX);
          SetCenterY(gameObject, GetCenterY(alignTo) + offsetY);
          return gameObject;
        };
        module2.exports = LeftCenter;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetLeft = __webpack_require__(43);
        var GetTop = __webpack_require__(45);
        var SetRight = __webpack_require__(54);
        var SetTop = __webpack_require__(52);
        var LeftTop = function(gameObject, alignTo, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetRight(gameObject, GetLeft(alignTo) - offsetX);
          SetTop(gameObject, GetTop(alignTo) - offsetY);
          return gameObject;
        };
        module2.exports = LeftTop;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetBottom = __webpack_require__(42);
        var GetRight = __webpack_require__(44);
        var SetBottom = __webpack_require__(55);
        var SetLeft = __webpack_require__(53);
        var RightBottom = function(gameObject, alignTo, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetLeft(gameObject, GetRight(alignTo) + offsetX);
          SetBottom(gameObject, GetBottom(alignTo) + offsetY);
          return gameObject;
        };
        module2.exports = RightBottom;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCenterY = __webpack_require__(89);
        var GetRight = __webpack_require__(44);
        var SetCenterY = __webpack_require__(90);
        var SetLeft = __webpack_require__(53);
        var RightCenter = function(gameObject, alignTo, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetLeft(gameObject, GetRight(alignTo) + offsetX);
          SetCenterY(gameObject, GetCenterY(alignTo) + offsetY);
          return gameObject;
        };
        module2.exports = RightCenter;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetRight = __webpack_require__(44);
        var GetTop = __webpack_require__(45);
        var SetLeft = __webpack_require__(53);
        var SetTop = __webpack_require__(52);
        var RightTop = function(gameObject, alignTo, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetLeft(gameObject, GetRight(alignTo) + offsetX);
          SetTop(gameObject, GetTop(alignTo) - offsetY);
          return gameObject;
        };
        module2.exports = RightTop;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCenterX = __webpack_require__(87);
        var GetTop = __webpack_require__(45);
        var SetBottom = __webpack_require__(55);
        var SetCenterX = __webpack_require__(88);
        var TopCenter = function(gameObject, alignTo, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetCenterX(gameObject, GetCenterX(alignTo) + offsetX);
          SetBottom(gameObject, GetTop(alignTo) - offsetY);
          return gameObject;
        };
        module2.exports = TopCenter;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetLeft = __webpack_require__(43);
        var GetTop = __webpack_require__(45);
        var SetBottom = __webpack_require__(55);
        var SetLeft = __webpack_require__(53);
        var TopLeft = function(gameObject, alignTo, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetLeft(gameObject, GetLeft(alignTo) - offsetX);
          SetBottom(gameObject, GetTop(alignTo) - offsetY);
          return gameObject;
        };
        module2.exports = TopLeft;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetRight = __webpack_require__(44);
        var GetTop = __webpack_require__(45);
        var SetBottom = __webpack_require__(55);
        var SetRight = __webpack_require__(54);
        var TopRight = function(gameObject, alignTo, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetRight(gameObject, GetRight(alignTo) + offsetX);
          SetBottom(gameObject, GetTop(alignTo) - offsetY);
          return gameObject;
        };
        module2.exports = TopRight;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ALIGN_CONST = __webpack_require__(123);
        var AlignInMap = [];
        AlignInMap[ALIGN_CONST.BOTTOM_CENTER] = __webpack_require__(290);
        AlignInMap[ALIGN_CONST.BOTTOM_LEFT] = __webpack_require__(291);
        AlignInMap[ALIGN_CONST.BOTTOM_RIGHT] = __webpack_require__(292);
        AlignInMap[ALIGN_CONST.CENTER] = __webpack_require__(293);
        AlignInMap[ALIGN_CONST.LEFT_CENTER] = __webpack_require__(295);
        AlignInMap[ALIGN_CONST.RIGHT_CENTER] = __webpack_require__(296);
        AlignInMap[ALIGN_CONST.TOP_CENTER] = __webpack_require__(297);
        AlignInMap[ALIGN_CONST.TOP_LEFT] = __webpack_require__(298);
        AlignInMap[ALIGN_CONST.TOP_RIGHT] = __webpack_require__(299);
        AlignInMap[ALIGN_CONST.LEFT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_LEFT];
        AlignInMap[ALIGN_CONST.LEFT_TOP] = AlignInMap[ALIGN_CONST.TOP_LEFT];
        AlignInMap[ALIGN_CONST.RIGHT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_RIGHT];
        AlignInMap[ALIGN_CONST.RIGHT_TOP] = AlignInMap[ALIGN_CONST.TOP_RIGHT];
        var QuickSet = function(child, alignIn, position, offsetX, offsetY) {
          return AlignInMap[position](child, alignIn, offsetX, offsetY);
        };
        module2.exports = QuickSet;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetBottom = __webpack_require__(42);
        var GetCenterX = __webpack_require__(87);
        var SetBottom = __webpack_require__(55);
        var SetCenterX = __webpack_require__(88);
        var BottomCenter = function(gameObject, alignIn, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
          SetBottom(gameObject, GetBottom(alignIn) + offsetY);
          return gameObject;
        };
        module2.exports = BottomCenter;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetBottom = __webpack_require__(42);
        var GetLeft = __webpack_require__(43);
        var SetBottom = __webpack_require__(55);
        var SetLeft = __webpack_require__(53);
        var BottomLeft = function(gameObject, alignIn, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetLeft(gameObject, GetLeft(alignIn) - offsetX);
          SetBottom(gameObject, GetBottom(alignIn) + offsetY);
          return gameObject;
        };
        module2.exports = BottomLeft;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetBottom = __webpack_require__(42);
        var GetRight = __webpack_require__(44);
        var SetBottom = __webpack_require__(55);
        var SetRight = __webpack_require__(54);
        var BottomRight = function(gameObject, alignIn, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetRight(gameObject, GetRight(alignIn) + offsetX);
          SetBottom(gameObject, GetBottom(alignIn) + offsetY);
          return gameObject;
        };
        module2.exports = BottomRight;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CenterOn = __webpack_require__(294);
        var GetCenterX = __webpack_require__(87);
        var GetCenterY = __webpack_require__(89);
        var Center = function(gameObject, alignIn, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          CenterOn(gameObject, GetCenterX(alignIn) + offsetX, GetCenterY(alignIn) + offsetY);
          return gameObject;
        };
        module2.exports = Center;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetCenterX = __webpack_require__(88);
        var SetCenterY = __webpack_require__(90);
        var CenterOn = function(gameObject, x2, y2) {
          SetCenterX(gameObject, x2);
          return SetCenterY(gameObject, y2);
        };
        module2.exports = CenterOn;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCenterY = __webpack_require__(89);
        var GetLeft = __webpack_require__(43);
        var SetCenterY = __webpack_require__(90);
        var SetLeft = __webpack_require__(53);
        var LeftCenter = function(gameObject, alignIn, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetLeft(gameObject, GetLeft(alignIn) - offsetX);
          SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
          return gameObject;
        };
        module2.exports = LeftCenter;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCenterY = __webpack_require__(89);
        var GetRight = __webpack_require__(44);
        var SetCenterY = __webpack_require__(90);
        var SetRight = __webpack_require__(54);
        var RightCenter = function(gameObject, alignIn, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetRight(gameObject, GetRight(alignIn) + offsetX);
          SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
          return gameObject;
        };
        module2.exports = RightCenter;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCenterX = __webpack_require__(87);
        var GetTop = __webpack_require__(45);
        var SetCenterX = __webpack_require__(88);
        var SetTop = __webpack_require__(52);
        var TopCenter = function(gameObject, alignIn, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
          SetTop(gameObject, GetTop(alignIn) - offsetY);
          return gameObject;
        };
        module2.exports = TopCenter;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetLeft = __webpack_require__(43);
        var GetTop = __webpack_require__(45);
        var SetLeft = __webpack_require__(53);
        var SetTop = __webpack_require__(52);
        var TopLeft = function(gameObject, alignIn, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetLeft(gameObject, GetLeft(alignIn) - offsetX);
          SetTop(gameObject, GetTop(alignIn) - offsetY);
          return gameObject;
        };
        module2.exports = TopLeft;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetRight = __webpack_require__(44);
        var GetTop = __webpack_require__(45);
        var SetRight = __webpack_require__(54);
        var SetTop = __webpack_require__(52);
        var TopRight = function(gameObject, alignIn, offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          SetRight(gameObject, GetRight(alignIn) + offsetX);
          SetTop(gameObject, GetTop(alignIn) - offsetY);
          return gameObject;
        };
        module2.exports = TopRight;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CircumferencePoint = __webpack_require__(169);
        var FromPercent = __webpack_require__(98);
        var MATH_CONST = __webpack_require__(14);
        var Point = __webpack_require__(4);
        var GetPoint = function(circle, position, out) {
          if (out === void 0) {
            out = new Point();
          }
          var angle = FromPercent(position, 0, MATH_CONST.PI2);
          return CircumferencePoint(circle, angle, out);
        };
        module2.exports = GetPoint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Circumference = __webpack_require__(302);
        var CircumferencePoint = __webpack_require__(169);
        var FromPercent = __webpack_require__(98);
        var MATH_CONST = __webpack_require__(14);
        var GetPoints = function(circle, quantity, stepRate, out) {
          if (out === void 0) {
            out = [];
          }
          if (!quantity && stepRate > 0) {
            quantity = Circumference(circle) / stepRate;
          }
          for (var i2 = 0; i2 < quantity; i2++) {
            var angle = FromPercent(i2 / quantity, 0, MATH_CONST.PI2);
            out.push(CircumferencePoint(circle, angle));
          }
          return out;
        };
        module2.exports = GetPoints;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Circumference = function(circle) {
          return 2 * (Math.PI * circle.radius);
        };
        module2.exports = Circumference;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clamp = __webpack_require__(18);
        var _FLAG = 2;
        var AlphaSingle = {
          _alpha: 1,
          clearAlpha: function() {
            return this.setAlpha(1);
          },
          setAlpha: function(value) {
            if (value === void 0) {
              value = 1;
            }
            this.alpha = value;
            return this;
          },
          alpha: {
            get: function() {
              return this._alpha;
            },
            set: function(value) {
              var v2 = Clamp(value, 0, 1);
              this._alpha = v2;
              if (v2 === 0) {
                this.renderFlags &= ~_FLAG;
              } else {
                this.renderFlags |= _FLAG;
              }
            }
          }
        };
        module2.exports = AlphaSingle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BlendModes = __webpack_require__(35);
        var BlendMode = {
          _blendMode: BlendModes.NORMAL,
          blendMode: {
            get: function() {
              return this._blendMode;
            },
            set: function(value) {
              if (typeof value === "string") {
                value = BlendModes[value];
              }
              value |= 0;
              if (value >= -1) {
                this._blendMode = value;
              }
            }
          },
          setBlendMode: function(value) {
            this.blendMode = value;
            return this;
          }
        };
        module2.exports = BlendMode;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Depth = {
          _depth: 0,
          depth: {
            get: function() {
              return this._depth;
            },
            set: function(value) {
              if (this.displayList) {
                this.displayList.queueDepthSort();
              }
              this._depth = value;
            }
          },
          setDepth: function(value) {
            if (value === void 0) {
              value = 0;
            }
            this.depth = value;
            return this;
          }
        };
        module2.exports = Depth;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetPoint = __webpack_require__(171);
        var Perimeter = __webpack_require__(130);
        var GetPoints = function(rectangle, quantity, stepRate, out) {
          if (out === void 0) {
            out = [];
          }
          if (!quantity && stepRate > 0) {
            quantity = Perimeter(rectangle) / stepRate;
          }
          for (var i2 = 0; i2 < quantity; i2++) {
            var position = i2 / quantity;
            out.push(GetPoint(rectangle, position));
          }
          return out;
        };
        module2.exports = GetPoints;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var GetPoint = function(line, position, out) {
          if (out === void 0) {
            out = new Point();
          }
          out.x = line.x1 + (line.x2 - line.x1) * position;
          out.y = line.y1 + (line.y2 - line.y1) * position;
          return out;
        };
        module2.exports = GetPoint;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateAround = function(point, x2, y2, angle) {
          var c = Math.cos(angle);
          var s = Math.sin(angle);
          var tx = point.x - x2;
          var ty = point.y - y2;
          point.x = tx * c - ty * s + x2;
          point.y = tx * s + ty * c + y2;
          return point;
        };
        module2.exports = RotateAround;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BitmapMask = __webpack_require__(310);
        var GeometryMask = __webpack_require__(311);
        var Mask = {
          mask: null,
          setMask: function(mask) {
            this.mask = mask;
            return this;
          },
          clearMask: function(destroyMask) {
            if (destroyMask === void 0) {
              destroyMask = false;
            }
            if (destroyMask && this.mask) {
              this.mask.destroy();
            }
            this.mask = null;
            return this;
          },
          createBitmapMask: function(renderable) {
            if (renderable === void 0 && (this.texture || this.shader)) {
              renderable = this;
            }
            return new BitmapMask(this.scene, renderable);
          },
          createGeometryMask: function(graphics) {
            if (graphics === void 0 && this.type === "Graphics") {
              graphics = this;
            }
            return new GeometryMask(this.scene, graphics);
          }
        };
        module2.exports = Mask;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GameEvents = __webpack_require__(22);
        var RenderEvents = __webpack_require__(91);
        var BitmapMask = new Class({
          initialize: function BitmapMask2(scene, renderable) {
            var renderer = scene.sys.renderer;
            this.renderer = renderer;
            this.bitmapMask = renderable;
            this.maskTexture = null;
            this.mainTexture = null;
            this.dirty = true;
            this.mainFramebuffer = null;
            this.maskFramebuffer = null;
            this.invertAlpha = false;
            this.isStencil = false;
            this.createMask();
            scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, this.createMask, this);
            if (renderer) {
              renderer.on(RenderEvents.RESIZE, this.createMask, this);
            }
          },
          createMask: function() {
            var renderer = this.renderer;
            if (!renderer || !renderer.gl) {
              return;
            }
            if (this.mainTexture) {
              this.clearMask();
            }
            var width = renderer.width;
            var height = renderer.height;
            var pot = (width & width - 1) === 0 && (height & height - 1) === 0;
            var gl2 = renderer.gl;
            var wrap = pot ? gl2.REPEAT : gl2.CLAMP_TO_EDGE;
            var filter = gl2.LINEAR;
            this.mainTexture = renderer.createTexture2D(0, filter, filter, wrap, wrap, gl2.RGBA, null, width, height);
            this.maskTexture = renderer.createTexture2D(0, filter, filter, wrap, wrap, gl2.RGBA, null, width, height);
            this.mainFramebuffer = renderer.createFramebuffer(width, height, this.mainTexture, true);
            this.maskFramebuffer = renderer.createFramebuffer(width, height, this.maskTexture, true);
          },
          clearMask: function() {
            var renderer = this.renderer;
            if (!renderer || !renderer.gl || !this.mainTexture) {
              return;
            }
            renderer.deleteTexture(this.mainTexture);
            renderer.deleteTexture(this.maskTexture);
            renderer.deleteFramebuffer(this.mainFramebuffer);
            renderer.deleteFramebuffer(this.maskFramebuffer);
            this.mainTexture = null;
            this.maskTexture = null;
            this.mainFramebuffer = null;
            this.maskFramebuffer = null;
          },
          setBitmap: function(renderable) {
            this.bitmapMask = renderable;
          },
          preRenderWebGL: function(renderer, maskedObject, camera) {
            renderer.pipelines.BITMAPMASK_PIPELINE.beginMask(this, maskedObject, camera);
          },
          postRenderWebGL: function(renderer, camera) {
            renderer.pipelines.BITMAPMASK_PIPELINE.endMask(this, camera);
          },
          preRenderCanvas: function() {
          },
          postRenderCanvas: function() {
          },
          destroy: function() {
            this.clearMask();
            if (this.renderer) {
              this.renderer.off(RenderEvents.RESIZE, this.createMask, this);
            }
            this.bitmapMask = null;
            this.prevFramebuffer = null;
            this.renderer = null;
          }
        });
        module2.exports = BitmapMask;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GeometryMask = new Class({
          initialize: function GeometryMask2(scene, graphicsGeometry) {
            this.geometryMask = graphicsGeometry;
            this.invertAlpha = false;
            this.isStencil = true;
            this.level = 0;
          },
          setShape: function(graphicsGeometry) {
            this.geometryMask = graphicsGeometry;
            return this;
          },
          setInvertAlpha: function(value) {
            if (value === void 0) {
              value = true;
            }
            this.invertAlpha = value;
            return this;
          },
          preRenderWebGL: function(renderer, child, camera) {
            var gl2 = renderer.gl;
            renderer.flush();
            if (renderer.maskStack.length === 0) {
              gl2.enable(gl2.STENCIL_TEST);
              gl2.clear(gl2.STENCIL_BUFFER_BIT);
              renderer.maskCount = 0;
            }
            if (renderer.currentCameraMask.mask !== this) {
              renderer.currentMask.mask = this;
            }
            renderer.maskStack.push({ mask: this, camera });
            this.applyStencil(renderer, camera, true);
            renderer.maskCount++;
          },
          applyStencil: function(renderer, camera, inc) {
            var gl2 = renderer.gl;
            var geometryMask = this.geometryMask;
            var level = renderer.maskCount;
            gl2.colorMask(false, false, false, false);
            if (inc) {
              gl2.stencilFunc(gl2.EQUAL, level, 255);
              gl2.stencilOp(gl2.KEEP, gl2.KEEP, gl2.INCR);
            } else {
              gl2.stencilFunc(gl2.EQUAL, level + 1, 255);
              gl2.stencilOp(gl2.KEEP, gl2.KEEP, gl2.DECR);
            }
            geometryMask.renderWebGL(renderer, geometryMask, camera);
            renderer.flush();
            gl2.colorMask(true, true, true, true);
            gl2.stencilOp(gl2.KEEP, gl2.KEEP, gl2.KEEP);
            if (inc) {
              if (this.invertAlpha) {
                gl2.stencilFunc(gl2.NOTEQUAL, level + 1, 255);
              } else {
                gl2.stencilFunc(gl2.EQUAL, level + 1, 255);
              }
            } else if (this.invertAlpha) {
              gl2.stencilFunc(gl2.NOTEQUAL, level, 255);
            } else {
              gl2.stencilFunc(gl2.EQUAL, level, 255);
            }
          },
          postRenderWebGL: function(renderer) {
            var gl2 = renderer.gl;
            renderer.maskStack.pop();
            renderer.maskCount--;
            renderer.flush();
            var current = renderer.currentMask;
            if (renderer.maskStack.length === 0) {
              current.mask = null;
              gl2.disable(gl2.STENCIL_TEST);
            } else {
              var prev = renderer.maskStack[renderer.maskStack.length - 1];
              prev.mask.applyStencil(renderer, prev.camera, false);
              if (renderer.currentCameraMask.mask !== prev.mask) {
                current.mask = prev.mask;
                current.camera = prev.camera;
              } else {
                current.mask = null;
              }
            }
          },
          preRenderCanvas: function(renderer, mask, camera) {
            var geometryMask = this.geometryMask;
            renderer.currentContext.save();
            geometryMask.renderCanvas(renderer, geometryMask, camera, null, null, true);
            renderer.currentContext.clip();
          },
          postRenderCanvas: function(renderer) {
            renderer.currentContext.restore();
          },
          destroy: function() {
            this.geometryMask = null;
          }
        });
        module2.exports = GeometryMask;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ScrollFactor = {
          scrollFactorX: 1,
          scrollFactorY: 1,
          setScrollFactor: function(x2, y2) {
            if (y2 === void 0) {
              y2 = x2;
            }
            this.scrollFactorX = x2;
            this.scrollFactorY = y2;
            return this;
          }
        };
        module2.exports = ScrollFactor;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MATH_CONST = __webpack_require__(14);
        var TransformMatrix = __webpack_require__(25);
        var TransformXY = __webpack_require__(177);
        var WrapAngle = __webpack_require__(269);
        var WrapAngleDegrees = __webpack_require__(270);
        var Vector2 = __webpack_require__(3);
        var _FLAG = 4;
        var Transform = {
          _scaleX: 1,
          _scaleY: 1,
          _rotation: 0,
          x: 0,
          y: 0,
          z: 0,
          w: 0,
          scale: {
            get: function() {
              return (this._scaleX + this._scaleY) / 2;
            },
            set: function(value) {
              this._scaleX = value;
              this._scaleY = value;
              if (value === 0) {
                this.renderFlags &= ~_FLAG;
              } else {
                this.renderFlags |= _FLAG;
              }
            }
          },
          scaleX: {
            get: function() {
              return this._scaleX;
            },
            set: function(value) {
              this._scaleX = value;
              if (value === 0) {
                this.renderFlags &= ~_FLAG;
              } else {
                this.renderFlags |= _FLAG;
              }
            }
          },
          scaleY: {
            get: function() {
              return this._scaleY;
            },
            set: function(value) {
              this._scaleY = value;
              if (value === 0) {
                this.renderFlags &= ~_FLAG;
              } else {
                this.renderFlags |= _FLAG;
              }
            }
          },
          angle: {
            get: function() {
              return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);
            },
            set: function(value) {
              this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
            }
          },
          rotation: {
            get: function() {
              return this._rotation;
            },
            set: function(value) {
              this._rotation = WrapAngle(value);
            }
          },
          setPosition: function(x2, y2, z2, w2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = x2;
            }
            if (z2 === void 0) {
              z2 = 0;
            }
            if (w2 === void 0) {
              w2 = 0;
            }
            this.x = x2;
            this.y = y2;
            this.z = z2;
            this.w = w2;
            return this;
          },
          copyPosition: function(source) {
            if (source.x !== void 0) {
              this.x = source.x;
            }
            if (source.y !== void 0) {
              this.y = source.y;
            }
            if (source.z !== void 0) {
              this.z = source.z;
            }
            if (source.w !== void 0) {
              this.w = source.w;
            }
            return this;
          },
          setRandomPosition: function(x2, y2, width, height) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = this.scene.sys.scale.width;
            }
            if (height === void 0) {
              height = this.scene.sys.scale.height;
            }
            this.x = x2 + Math.random() * width;
            this.y = y2 + Math.random() * height;
            return this;
          },
          setRotation: function(radians) {
            if (radians === void 0) {
              radians = 0;
            }
            this.rotation = radians;
            return this;
          },
          setAngle: function(degrees) {
            if (degrees === void 0) {
              degrees = 0;
            }
            this.angle = degrees;
            return this;
          },
          setScale: function(x2, y2) {
            if (x2 === void 0) {
              x2 = 1;
            }
            if (y2 === void 0) {
              y2 = x2;
            }
            this.scaleX = x2;
            this.scaleY = y2;
            return this;
          },
          setX: function(value) {
            if (value === void 0) {
              value = 0;
            }
            this.x = value;
            return this;
          },
          setY: function(value) {
            if (value === void 0) {
              value = 0;
            }
            this.y = value;
            return this;
          },
          setZ: function(value) {
            if (value === void 0) {
              value = 0;
            }
            this.z = value;
            return this;
          },
          setW: function(value) {
            if (value === void 0) {
              value = 0;
            }
            this.w = value;
            return this;
          },
          getLocalTransformMatrix: function(tempMatrix) {
            if (tempMatrix === void 0) {
              tempMatrix = new TransformMatrix();
            }
            return tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
          },
          getWorldTransformMatrix: function(tempMatrix, parentMatrix) {
            if (tempMatrix === void 0) {
              tempMatrix = new TransformMatrix();
            }
            if (parentMatrix === void 0) {
              parentMatrix = new TransformMatrix();
            }
            var parent = this.parentContainer;
            if (!parent) {
              return this.getLocalTransformMatrix(tempMatrix);
            }
            tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
            while (parent) {
              parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY);
              parentMatrix.multiply(tempMatrix, tempMatrix);
              parent = parent.parentContainer;
            }
            return tempMatrix;
          },
          getLocalPoint: function(x2, y2, point, camera) {
            if (!point) {
              point = new Vector2();
            }
            if (!camera) {
              camera = this.scene.sys.cameras.main;
            }
            var csx = camera.scrollX;
            var csy = camera.scrollY;
            var px = x2 + csx * this.scrollFactorX - csx;
            var py = y2 + csy * this.scrollFactorY - csy;
            if (this.parentContainer) {
              this.getWorldTransformMatrix().applyInverse(px, py, point);
            } else {
              TransformXY(px, py, this.x, this.y, this.rotation, this.scaleX, this.scaleY, point);
            }
            if (this._originComponent) {
              point.x += this._displayOriginX;
              point.y += this._displayOriginY;
            }
            return point;
          },
          getParentRotation: function() {
            var rotation = 0;
            var parent = this.parentContainer;
            while (parent) {
              rotation += parent.rotation;
              parent = parent.parentContainer;
            }
            return rotation;
          }
        };
        module2.exports = Transform;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var _FLAG = 1;
        var Visible = {
          _visible: true,
          visible: {
            get: function() {
              return this._visible;
            },
            set: function(value) {
              if (value) {
                this._visible = true;
                this.renderFlags |= _FLAG;
              } else {
                this._visible = false;
                this.renderFlags &= ~_FLAG;
              }
            }
          },
          setVisible: function(value) {
            this.visible = value;
            return this;
          }
        };
        module2.exports = Visible;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          CHANGE_DATA: __webpack_require__(638),
          CHANGE_DATA_KEY: __webpack_require__(639),
          DESTROY: __webpack_require__(640),
          REMOVE_DATA: __webpack_require__(641),
          SET_DATA: __webpack_require__(642)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Perimeter = __webpack_require__(130);
        var Point = __webpack_require__(4);
        var MarchingAnts = function(rect, step, quantity, out) {
          if (out === void 0) {
            out = [];
          }
          if (!step && !quantity) {
            return out;
          }
          if (!step) {
            step = Perimeter(rect) / quantity;
          } else {
            quantity = Math.round(Perimeter(rect) / step);
          }
          var x2 = rect.x;
          var y2 = rect.y;
          var face = 0;
          for (var i2 = 0; i2 < quantity; i2++) {
            out.push(new Point(x2, y2));
            switch (face) {
              case 0:
                x2 += step;
                if (x2 >= rect.right) {
                  face = 1;
                  y2 += x2 - rect.right;
                  x2 = rect.right;
                }
                break;
              case 1:
                y2 += step;
                if (y2 >= rect.bottom) {
                  face = 2;
                  x2 -= y2 - rect.bottom;
                  y2 = rect.bottom;
                }
                break;
              case 2:
                x2 -= step;
                if (x2 <= rect.left) {
                  face = 3;
                  y2 -= rect.left - x2;
                  x2 = rect.left;
                }
                break;
              case 3:
                y2 -= step;
                if (y2 <= rect.top) {
                  face = 0;
                  y2 = rect.top;
                }
                break;
            }
          }
          return out;
        };
        module2.exports = MarchingAnts;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BresenhamPoints = function(line, stepRate, results) {
          if (stepRate === void 0) {
            stepRate = 1;
          }
          if (results === void 0) {
            results = [];
          }
          var x1 = Math.round(line.x1);
          var y1 = Math.round(line.y1);
          var x2 = Math.round(line.x2);
          var y2 = Math.round(line.y2);
          var dx = Math.abs(x2 - x1);
          var dy = Math.abs(y2 - y1);
          var sx = x1 < x2 ? 1 : -1;
          var sy = y1 < y2 ? 1 : -1;
          var err = dx - dy;
          results.push({ x: x1, y: y1 });
          var i2 = 1;
          while (!(x1 === x2 && y1 === y2)) {
            var e2 = err << 1;
            if (e2 > -dy) {
              err -= dy;
              x1 += sx;
            }
            if (e2 < dx) {
              err += dx;
              y1 += sy;
            }
            if (i2 % stepRate === 0) {
              results.push({ x: x1, y: y1 });
            }
            i2++;
          }
          return results;
        };
        module2.exports = BresenhamPoints;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FindClosestInSorted = function(value, array, key) {
          if (!array.length) {
            return NaN;
          } else if (array.length === 1) {
            return array[0];
          }
          var i2 = 1;
          var low;
          var high;
          if (key) {
            if (value < array[0][key]) {
              return array[0];
            }
            while (array[i2][key] < value) {
              i2++;
            }
          } else {
            while (array[i2] < value) {
              i2++;
            }
          }
          if (i2 > array.length) {
            i2 = array.length;
          }
          if (key) {
            low = array[i2 - 1][key];
            high = array[i2][key];
            return high - value <= value - low ? array[i2] : array[i2 - 1];
          } else {
            low = array[i2 - 1];
            high = array[i2];
            return high - value <= value - low ? high : low;
          }
        };
        module2.exports = FindClosestInSorted;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var AnimationFrame = new Class({
          initialize: function AnimationFrame2(textureKey, textureFrame, index2, frame, isKeyFrame) {
            if (isKeyFrame === void 0) {
              isKeyFrame = false;
            }
            this.textureKey = textureKey;
            this.textureFrame = textureFrame;
            this.index = index2;
            this.frame = frame;
            this.isFirst = false;
            this.isLast = false;
            this.prevFrame = null;
            this.nextFrame = null;
            this.duration = 0;
            this.progress = 0;
            this.isKeyFrame = isKeyFrame;
          },
          toJSON: function() {
            return {
              key: this.textureKey,
              frame: this.textureFrame,
              duration: this.duration,
              keyframe: this.isKeyFrame
            };
          },
          destroy: function() {
            this.frame = void 0;
          }
        });
        module2.exports = AnimationFrame;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SortByDigits = function(array) {
          var re2 = /\D/g;
          array.sort(function(a, b2) {
            return parseInt(a.replace(re2, ""), 10) - parseInt(b2.replace(re2, ""), 10);
          });
          return array;
        };
        module2.exports = SortByDigits;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Animation = __webpack_require__(185);
        var Class = __webpack_require__(0);
        var CustomMap = __webpack_require__(102);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(132);
        var GameEvents = __webpack_require__(22);
        var GetFastValue = __webpack_require__(2);
        var GetValue = __webpack_require__(6);
        var Pad = __webpack_require__(186);
        var NumberArray = __webpack_require__(322);
        var AnimationManager = new Class({
          Extends: EventEmitter,
          initialize: function AnimationManager2(game) {
            EventEmitter.call(this);
            this.game = game;
            this.textureManager = null;
            this.globalTimeScale = 1;
            this.anims = new CustomMap();
            this.mixes = new CustomMap();
            this.paused = false;
            this.name = "AnimationManager";
            game.events.once(GameEvents.BOOT, this.boot, this);
          },
          boot: function() {
            this.textureManager = this.game.textures;
            this.game.events.once(GameEvents.DESTROY, this.destroy, this);
          },
          addMix: function(animA, animB, delay) {
            var anims = this.anims;
            var mixes = this.mixes;
            var keyA = typeof animA === "string" ? animA : animA.key;
            var keyB = typeof animB === "string" ? animB : animB.key;
            if (anims.has(keyA) && anims.has(keyB)) {
              var mixObj = mixes.get(keyA);
              if (!mixObj) {
                mixObj = {};
              }
              mixObj[keyB] = delay;
              mixes.set(keyA, mixObj);
            }
            return this;
          },
          removeMix: function(animA, animB) {
            var mixes = this.mixes;
            var keyA = typeof animA === "string" ? animA : animA.key;
            var mixObj = mixes.get(keyA);
            if (mixObj) {
              if (animB) {
                var keyB = typeof animB === "string" ? animB : animB.key;
                if (mixObj.hasOwnProperty(keyB)) {
                  delete mixObj[keyB];
                }
              } else if (!animB) {
                mixes.delete(keyA);
              }
            }
            return this;
          },
          getMix: function(animA, animB) {
            var mixes = this.mixes;
            var keyA = typeof animA === "string" ? animA : animA.key;
            var keyB = typeof animB === "string" ? animB : animB.key;
            var mixObj = mixes.get(keyA);
            if (mixObj && mixObj.hasOwnProperty(keyB)) {
              return mixObj[keyB];
            } else {
              return 0;
            }
          },
          add: function(key, animation) {
            if (this.anims.has(key)) {
              console.warn("Animation key exists: " + key);
              return this;
            }
            animation.key = key;
            this.anims.set(key, animation);
            this.emit(Events.ADD_ANIMATION, key, animation);
            return this;
          },
          exists: function(key) {
            return this.anims.has(key);
          },
          createFromAseprite: function(key, tags) {
            var output = [];
            var data = this.game.cache.json.get(key);
            if (!data) {
              return output;
            }
            var _this = this;
            var meta = GetValue(data, "meta", null);
            var frames = GetValue(data, "frames", null);
            if (meta && frames) {
              var frameTags = GetValue(meta, "frameTags", []);
              frameTags.forEach(function(tag) {
                var animFrames = [];
                var name = GetFastValue(tag, "name", null);
                var from = GetFastValue(tag, "from", 0);
                var to = GetFastValue(tag, "to", 0);
                var direction = GetFastValue(tag, "direction", "forward");
                if (!name) {
                  return;
                }
                if (!tags || tags && tags.indexOf(name) > -1) {
                  var tempFrames = [];
                  var minDuration = Number.MAX_SAFE_INTEGER;
                  for (var i2 = from; i2 <= to; i2++) {
                    var frameKey = i2.toString();
                    var frame = frames[frameKey];
                    if (frame) {
                      var frameDuration = GetFastValue(frame, "duration", Number.MAX_SAFE_INTEGER);
                      if (frameDuration < minDuration) {
                        minDuration = frameDuration;
                      }
                      tempFrames.push({ frame: frameKey, duration: frameDuration });
                    }
                  }
                  tempFrames.forEach(function(entry) {
                    animFrames.push({
                      key,
                      frame: entry.frame,
                      duration: minDuration - entry.duration
                    });
                  });
                  var totalDuration = minDuration * animFrames.length;
                  if (direction === "reverse") {
                    animFrames = animFrames.reverse();
                  }
                  var createConfig = {
                    key: name,
                    frames: animFrames,
                    duration: totalDuration,
                    yoyo: direction === "pingpong"
                  };
                  var result = _this.create(createConfig);
                  if (result) {
                    output.push(result);
                  }
                }
              });
            }
            return output;
          },
          create: function(config) {
            var key = config.key;
            var anim = false;
            if (key) {
              anim = this.get(key);
              if (!anim) {
                anim = new Animation(this, key, config);
                this.anims.set(key, anim);
                this.emit(Events.ADD_ANIMATION, key, anim);
              }
            }
            return anim;
          },
          fromJSON: function(data, clearCurrentAnimations) {
            if (clearCurrentAnimations === void 0) {
              clearCurrentAnimations = false;
            }
            if (clearCurrentAnimations) {
              this.anims.clear();
            }
            if (typeof data === "string") {
              data = JSON.parse(data);
            }
            var output = [];
            if (data.hasOwnProperty("anims") && Array.isArray(data.anims)) {
              for (var i2 = 0; i2 < data.anims.length; i2++) {
                output.push(this.create(data.anims[i2]));
              }
              if (data.hasOwnProperty("globalTimeScale")) {
                this.globalTimeScale = data.globalTimeScale;
              }
            } else if (data.hasOwnProperty("key") && data.type === "frame") {
              output.push(this.create(data));
            }
            return output;
          },
          generateFrameNames: function(key, config) {
            var prefix = GetValue(config, "prefix", "");
            var start = GetValue(config, "start", 0);
            var end = GetValue(config, "end", 0);
            var suffix = GetValue(config, "suffix", "");
            var zeroPad = GetValue(config, "zeroPad", 0);
            var out = GetValue(config, "outputArray", []);
            var frames = GetValue(config, "frames", false);
            var texture = this.textureManager.get(key);
            if (!texture) {
              return out;
            }
            var i2;
            if (!config) {
              frames = texture.getFrameNames();
              for (i2 = 0; i2 < frames.length; i2++) {
                out.push({ key, frame: frames[i2] });
              }
            } else {
              if (!frames) {
                frames = NumberArray(start, end);
              }
              for (i2 = 0; i2 < frames.length; i2++) {
                var frame = prefix + Pad(frames[i2], zeroPad, "0", 1) + suffix;
                if (texture.has(frame)) {
                  out.push({ key, frame });
                } else {
                  console.warn("generateFrameNames: Frame missing: " + frame + " from texture: " + key);
                }
              }
            }
            return out;
          },
          generateFrameNumbers: function(key, config) {
            var start = GetValue(config, "start", 0);
            var end = GetValue(config, "end", -1);
            var first = GetValue(config, "first", false);
            var out = GetValue(config, "outputArray", []);
            var frames = GetValue(config, "frames", false);
            var texture = this.textureManager.get(key);
            if (!texture) {
              return out;
            }
            if (first && texture.has(first)) {
              out.push({ key, frame: first });
            }
            if (!frames) {
              if (end === -1) {
                end = texture.frameTotal - 2;
              }
              frames = NumberArray(start, end);
            }
            for (var i2 = 0; i2 < frames.length; i2++) {
              if (texture.has(frames[i2])) {
                out.push({ key, frame: frames[i2] });
              } else {
                console.warn("generateFrameNumbers: Frame " + i2 + " missing from texture: " + key);
              }
            }
            return out;
          },
          get: function(key) {
            return this.anims.get(key);
          },
          pauseAll: function() {
            if (!this.paused) {
              this.paused = true;
              this.emit(Events.PAUSE_ALL);
            }
            return this;
          },
          play: function(key, children) {
            if (!Array.isArray(children)) {
              children = [children];
            }
            for (var i2 = 0; i2 < children.length; i2++) {
              children[i2].anims.play(key);
            }
            return this;
          },
          staggerPlay: function(key, children, stagger, staggerFirst) {
            if (stagger === void 0) {
              stagger = 0;
            }
            if (staggerFirst === void 0) {
              staggerFirst = true;
            }
            if (!Array.isArray(children)) {
              children = [children];
            }
            var len = children.length;
            if (!staggerFirst) {
              len--;
            }
            for (var i2 = 0; i2 < children.length; i2++) {
              var time = stagger < 0 ? Math.abs(stagger) * (len - i2) : stagger * i2;
              children[i2].anims.playAfterDelay(key, time);
            }
            return this;
          },
          remove: function(key) {
            var anim = this.get(key);
            if (anim) {
              this.emit(Events.REMOVE_ANIMATION, key, anim);
              this.anims.delete(key);
              this.removeMix(key);
            }
            return anim;
          },
          resumeAll: function() {
            if (this.paused) {
              this.paused = false;
              this.emit(Events.RESUME_ALL);
            }
            return this;
          },
          toJSON: function(key) {
            var output = {
              anims: [],
              globalTimeScale: this.globalTimeScale
            };
            if (key !== void 0 && key !== "") {
              output.anims.push(this.anims.get(key).toJSON());
            } else {
              this.anims.each(function(animationKey, animation) {
                output.anims.push(animation.toJSON());
              });
            }
            return output;
          },
          destroy: function() {
            this.anims.clear();
            this.mixes.clear();
            this.textureManager = null;
            this.game = null;
          }
        });
        module2.exports = AnimationManager;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var NumberArray = function(start, end, prefix, suffix) {
          var result = [];
          var i2;
          var asString = false;
          if (prefix || suffix) {
            asString = true;
            if (!prefix) {
              prefix = "";
            }
            if (!suffix) {
              suffix = "";
            }
          }
          if (end < start) {
            for (i2 = start; i2 >= end; i2--) {
              if (asString) {
                result.push(prefix + i2.toString() + suffix);
              } else {
                result.push(i2);
              }
            }
          } else {
            for (i2 = start; i2 <= end; i2++) {
              if (asString) {
                result.push(prefix + i2.toString() + suffix);
              } else {
                result.push(i2);
              }
            }
          }
          return result;
        };
        module2.exports = NumberArray;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CustomMap = __webpack_require__(102);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(324);
        var BaseCache = new Class({
          initialize: function BaseCache2() {
            this.entries = new CustomMap();
            this.events = new EventEmitter();
          },
          add: function(key, data) {
            this.entries.set(key, data);
            this.events.emit(Events.ADD, this, key, data);
            return this;
          },
          has: function(key) {
            return this.entries.has(key);
          },
          exists: function(key) {
            return this.entries.has(key);
          },
          get: function(key) {
            return this.entries.get(key);
          },
          remove: function(key) {
            var entry = this.get(key);
            if (entry) {
              this.entries.delete(key);
              this.events.emit(Events.REMOVE, this, key, entry.data);
            }
            return this;
          },
          getKeys: function() {
            return this.entries.keys();
          },
          destroy: function() {
            this.entries.clear();
            this.events.removeAllListeners();
            this.entries = null;
            this.events = null;
          }
        });
        module2.exports = BaseCache;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          ADD: __webpack_require__(736),
          REMOVE: __webpack_require__(737)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BaseCache = __webpack_require__(323);
        var Class = __webpack_require__(0);
        var GameEvents = __webpack_require__(22);
        var CacheManager = new Class({
          initialize: function CacheManager2(game) {
            this.game = game;
            this.binary = new BaseCache();
            this.bitmapFont = new BaseCache();
            this.json = new BaseCache();
            this.physics = new BaseCache();
            this.shader = new BaseCache();
            this.audio = new BaseCache();
            this.video = new BaseCache();
            this.text = new BaseCache();
            this.html = new BaseCache();
            this.obj = new BaseCache();
            this.tilemap = new BaseCache();
            this.xml = new BaseCache();
            this.custom = {};
            this.game.events.once(GameEvents.DESTROY, this.destroy, this);
          },
          addCustom: function(key) {
            if (!this.custom.hasOwnProperty(key)) {
              this.custom[key] = new BaseCache();
            }
            return this.custom[key];
          },
          destroy: function() {
            var keys = [
              "binary",
              "bitmapFont",
              "json",
              "physics",
              "shader",
              "audio",
              "video",
              "text",
              "html",
              "obj",
              "tilemap",
              "xml"
            ];
            for (var i2 = 0; i2 < keys.length; i2++) {
              this[keys[i2]].destroy();
              this[keys[i2]] = null;
            }
            for (var key in this.custom) {
              this.custom[key].destroy();
            }
            this.custom = null;
            this.game = null;
          }
        });
        module2.exports = CacheManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BaseCamera = __webpack_require__(133);
        var CenterOn = __webpack_require__(190);
        var Clamp = __webpack_require__(18);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var Effects = __webpack_require__(333);
        var Events = __webpack_require__(37);
        var Linear = __webpack_require__(135);
        var Rectangle = __webpack_require__(10);
        var Vector2 = __webpack_require__(3);
        var Camera = new Class({
          Extends: BaseCamera,
          Mixins: [
            Components.Flip,
            Components.Tint,
            Components.Pipeline
          ],
          initialize: function Camera2(x2, y2, width, height) {
            BaseCamera.call(this, x2, y2, width, height);
            this.postPipelines = [];
            this.pipelineData = {};
            this.inputEnabled = true;
            this.fadeEffect = new Effects.Fade(this);
            this.flashEffect = new Effects.Flash(this);
            this.shakeEffect = new Effects.Shake(this);
            this.panEffect = new Effects.Pan(this);
            this.rotateToEffect = new Effects.RotateTo(this);
            this.zoomEffect = new Effects.Zoom(this);
            this.lerp = new Vector2(1, 1);
            this.followOffset = new Vector2();
            this.deadzone = null;
            this._follow = null;
          },
          setDeadzone: function(width, height) {
            if (width === void 0) {
              this.deadzone = null;
            } else {
              if (this.deadzone) {
                this.deadzone.width = width;
                this.deadzone.height = height;
              } else {
                this.deadzone = new Rectangle(0, 0, width, height);
              }
              if (this._follow) {
                var originX = this.width / 2;
                var originY = this.height / 2;
                var fx = this._follow.x - this.followOffset.x;
                var fy = this._follow.y - this.followOffset.y;
                this.midPoint.set(fx, fy);
                this.scrollX = fx - originX;
                this.scrollY = fy - originY;
              }
              CenterOn(this.deadzone, this.midPoint.x, this.midPoint.y);
            }
            return this;
          },
          fadeIn: function(duration, red, green, blue, callback, context) {
            return this.fadeEffect.start(false, duration, red, green, blue, true, callback, context);
          },
          fadeOut: function(duration, red, green, blue, callback, context) {
            return this.fadeEffect.start(true, duration, red, green, blue, true, callback, context);
          },
          fadeFrom: function(duration, red, green, blue, force, callback, context) {
            return this.fadeEffect.start(false, duration, red, green, blue, force, callback, context);
          },
          fade: function(duration, red, green, blue, force, callback, context) {
            return this.fadeEffect.start(true, duration, red, green, blue, force, callback, context);
          },
          flash: function(duration, red, green, blue, force, callback, context) {
            return this.flashEffect.start(duration, red, green, blue, force, callback, context);
          },
          shake: function(duration, intensity, force, callback, context) {
            return this.shakeEffect.start(duration, intensity, force, callback, context);
          },
          pan: function(x2, y2, duration, ease, force, callback, context) {
            return this.panEffect.start(x2, y2, duration, ease, force, callback, context);
          },
          rotateTo: function(radians, shortestPath, duration, ease, force, callback, context) {
            return this.rotateToEffect.start(radians, shortestPath, duration, ease, force, callback, context);
          },
          zoomTo: function(zoom, duration, ease, force, callback, context) {
            return this.zoomEffect.start(zoom, duration, ease, force, callback, context);
          },
          preRender: function() {
            this.renderList.length = 0;
            var width = this.width;
            var height = this.height;
            var halfWidth = width * 0.5;
            var halfHeight = height * 0.5;
            var zoom = this.zoom;
            var matrix = this.matrix;
            var originX = width * this.originX;
            var originY = height * this.originY;
            var follow = this._follow;
            var deadzone = this.deadzone;
            var sx = this.scrollX;
            var sy = this.scrollY;
            if (deadzone) {
              CenterOn(deadzone, this.midPoint.x, this.midPoint.y);
            }
            var emitFollowEvent = false;
            if (follow && !this.panEffect.isRunning) {
              var fx = follow.x - this.followOffset.x;
              var fy = follow.y - this.followOffset.y;
              if (deadzone) {
                if (fx < deadzone.x) {
                  sx = Linear(sx, sx - (deadzone.x - fx), this.lerp.x);
                } else if (fx > deadzone.right) {
                  sx = Linear(sx, sx + (fx - deadzone.right), this.lerp.x);
                }
                if (fy < deadzone.y) {
                  sy = Linear(sy, sy - (deadzone.y - fy), this.lerp.y);
                } else if (fy > deadzone.bottom) {
                  sy = Linear(sy, sy + (fy - deadzone.bottom), this.lerp.y);
                }
              } else {
                sx = Linear(sx, fx - originX, this.lerp.x);
                sy = Linear(sy, fy - originY, this.lerp.y);
              }
              emitFollowEvent = true;
            }
            if (this.useBounds) {
              sx = this.clampX(sx);
              sy = this.clampY(sy);
            }
            if (this.roundPixels) {
              originX = Math.round(originX);
              originY = Math.round(originY);
              sx = Math.round(sx);
              sy = Math.round(sy);
            }
            this.scrollX = sx;
            this.scrollY = sy;
            var midX = sx + halfWidth;
            var midY = sy + halfHeight;
            this.midPoint.set(midX, midY);
            var displayWidth = width / zoom;
            var displayHeight = height / zoom;
            var vwx = midX - displayWidth / 2;
            var vwy = midY - displayHeight / 2;
            if (this.roundPixels) {
              vwx = Math.round(vwx);
              vwy = Math.round(vwy);
            }
            this.worldView.setTo(vwx, vwy, displayWidth, displayHeight);
            matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoom, zoom);
            matrix.translate(-originX, -originY);
            this.shakeEffect.preRender();
            if (emitFollowEvent) {
              this.emit(Events.FOLLOW_UPDATE, this, follow);
            }
          },
          setLerp: function(x2, y2) {
            if (x2 === void 0) {
              x2 = 1;
            }
            if (y2 === void 0) {
              y2 = x2;
            }
            this.lerp.set(x2, y2);
            return this;
          },
          setFollowOffset: function(x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            this.followOffset.set(x2, y2);
            return this;
          },
          startFollow: function(target, roundPixels, lerpX, lerpY, offsetX, offsetY) {
            if (roundPixels === void 0) {
              roundPixels = false;
            }
            if (lerpX === void 0) {
              lerpX = 1;
            }
            if (lerpY === void 0) {
              lerpY = lerpX;
            }
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = offsetX;
            }
            this._follow = target;
            this.roundPixels = roundPixels;
            lerpX = Clamp(lerpX, 0, 1);
            lerpY = Clamp(lerpY, 0, 1);
            this.lerp.set(lerpX, lerpY);
            this.followOffset.set(offsetX, offsetY);
            var originX = this.width / 2;
            var originY = this.height / 2;
            var fx = target.x - offsetX;
            var fy = target.y - offsetY;
            this.midPoint.set(fx, fy);
            this.scrollX = fx - originX;
            this.scrollY = fy - originY;
            if (this.useBounds) {
              this.scrollX = this.clampX(this.scrollX);
              this.scrollY = this.clampY(this.scrollY);
            }
            return this;
          },
          stopFollow: function() {
            this._follow = null;
            return this;
          },
          resetFX: function() {
            this.rotateToEffect.reset();
            this.panEffect.reset();
            this.shakeEffect.reset();
            this.flashEffect.reset();
            this.fadeEffect.reset();
            return this;
          },
          update: function(time, delta) {
            if (this.visible) {
              this.rotateToEffect.update(time, delta);
              this.panEffect.update(time, delta);
              this.zoomEffect.update(time, delta);
              this.shakeEffect.update(time, delta);
              this.flashEffect.update(time, delta);
              this.fadeEffect.update(time, delta);
            }
          },
          destroy: function() {
            this.resetFX();
            BaseCamera.prototype.destroy.call(this);
            this._follow = null;
            this.deadzone = null;
          }
        });
        module2.exports = Camera;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Color = __webpack_require__(38);
        var HexStringToColor = function(hex) {
          var color = new Color();
          hex = hex.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(m2, r3, g3, b3) {
            return r3 + r3 + g3 + g3 + b3 + b3;
          });
          var result = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          if (result) {
            var r2 = parseInt(result[1], 16);
            var g2 = parseInt(result[2], 16);
            var b2 = parseInt(result[3], 16);
            color.setTo(r2, g2, b2);
          }
          return color;
        };
        module2.exports = HexStringToColor;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetColor32 = function(red, green, blue, alpha) {
          return alpha << 24 | red << 16 | green << 8 | blue;
        };
        module2.exports = GetColor32;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RGBToHSV = function(r2, g2, b2, out) {
          if (out === void 0) {
            out = { h: 0, s: 0, v: 0 };
          }
          r2 /= 255;
          g2 /= 255;
          b2 /= 255;
          var min = Math.min(r2, g2, b2);
          var max = Math.max(r2, g2, b2);
          var d = max - min;
          var h2 = 0;
          var s = max === 0 ? 0 : d / max;
          var v2 = max;
          if (max !== min) {
            if (max === r2) {
              h2 = (g2 - b2) / d + (g2 < b2 ? 6 : 0);
            } else if (max === g2) {
              h2 = (b2 - r2) / d + 2;
            } else if (max === b2) {
              h2 = (r2 - g2) / d + 4;
            }
            h2 /= 6;
          }
          if (out.hasOwnProperty("_h")) {
            out._h = h2;
            out._s = s;
            out._v = v2;
          } else {
            out.h = h2;
            out.s = s;
            out.v = v2;
          }
          return out;
        };
        module2.exports = RGBToHSV;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var IntegerToRGB = function(color) {
          if (color > 16777215) {
            return {
              a: color >>> 24,
              r: color >> 16 & 255,
              g: color >> 8 & 255,
              b: color & 255
            };
          } else {
            return {
              a: 255,
              r: color >> 16 & 255,
              g: color >> 8 & 255,
              b: color & 255
            };
          }
        };
        module2.exports = IntegerToRGB;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Color = __webpack_require__(38);
        var ObjectToColor = function(input) {
          return new Color(input.r, input.g, input.b, input.a);
        };
        module2.exports = ObjectToColor;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Color = __webpack_require__(38);
        var RGBStringToColor = function(rgb) {
          var color = new Color();
          var result = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(rgb.toLowerCase());
          if (result) {
            var r2 = parseInt(result[1], 10);
            var g2 = parseInt(result[2], 10);
            var b2 = parseInt(result[3], 10);
            var a = result[4] !== void 0 ? parseFloat(result[4]) : 1;
            color.setTo(r2, g2, b2, a * 255);
          }
          return color;
        };
        module2.exports = RGBStringToColor;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Fade: __webpack_require__(761),
          Flash: __webpack_require__(762),
          Pan: __webpack_require__(763),
          Shake: __webpack_require__(796),
          RotateTo: __webpack_require__(797),
          Zoom: __webpack_require__(798)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          In: __webpack_require__(764),
          Out: __webpack_require__(765),
          InOut: __webpack_require__(766)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          In: __webpack_require__(767),
          Out: __webpack_require__(768),
          InOut: __webpack_require__(769)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          In: __webpack_require__(770),
          Out: __webpack_require__(771),
          InOut: __webpack_require__(772)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          In: __webpack_require__(773),
          Out: __webpack_require__(774),
          InOut: __webpack_require__(775)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          In: __webpack_require__(776),
          Out: __webpack_require__(777),
          InOut: __webpack_require__(778)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          In: __webpack_require__(779),
          Out: __webpack_require__(780),
          InOut: __webpack_require__(781)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = __webpack_require__(782);
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          In: __webpack_require__(783),
          Out: __webpack_require__(784),
          InOut: __webpack_require__(785)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          In: __webpack_require__(786),
          Out: __webpack_require__(787),
          InOut: __webpack_require__(788)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          In: __webpack_require__(789),
          Out: __webpack_require__(790),
          InOut: __webpack_require__(791)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          In: __webpack_require__(792),
          Out: __webpack_require__(793),
          InOut: __webpack_require__(794)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = __webpack_require__(795);
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(33);
        var Device = __webpack_require__(347);
        var GetFastValue = __webpack_require__(2);
        var GetValue = __webpack_require__(6);
        var IsPlainObject2 = __webpack_require__(7);
        var PhaserMath = __webpack_require__(193);
        var NOOP = __webpack_require__(1);
        var DefaultPlugins = __webpack_require__(197);
        var ValueToColor = __webpack_require__(187);
        var Config = new Class({
          initialize: function Config2(config) {
            if (config === void 0) {
              config = {};
            }
            var defaultBannerColor = [
              "#ff0000",
              "#ffff00",
              "#00ff00",
              "#00ffff",
              "#000000"
            ];
            var defaultBannerTextColor = "#ffffff";
            this.width = GetValue(config, "width", 1024);
            this.height = GetValue(config, "height", 768);
            this.zoom = GetValue(config, "zoom", 1);
            this.parent = GetValue(config, "parent", void 0);
            this.scaleMode = GetValue(config, "scaleMode", 0);
            this.expandParent = GetValue(config, "expandParent", true);
            this.autoRound = GetValue(config, "autoRound", false);
            this.autoCenter = GetValue(config, "autoCenter", 0);
            this.resizeInterval = GetValue(config, "resizeInterval", 500);
            this.fullscreenTarget = GetValue(config, "fullscreenTarget", null);
            this.minWidth = GetValue(config, "minWidth", 0);
            this.maxWidth = GetValue(config, "maxWidth", 0);
            this.minHeight = GetValue(config, "minHeight", 0);
            this.maxHeight = GetValue(config, "maxHeight", 0);
            var scaleConfig = GetValue(config, "scale", null);
            if (scaleConfig) {
              this.width = GetValue(scaleConfig, "width", this.width);
              this.height = GetValue(scaleConfig, "height", this.height);
              this.zoom = GetValue(scaleConfig, "zoom", this.zoom);
              this.parent = GetValue(scaleConfig, "parent", this.parent);
              this.scaleMode = GetValue(scaleConfig, "mode", this.scaleMode);
              this.expandParent = GetValue(scaleConfig, "expandParent", this.expandParent);
              this.autoRound = GetValue(scaleConfig, "autoRound", this.autoRound);
              this.autoCenter = GetValue(scaleConfig, "autoCenter", this.autoCenter);
              this.resizeInterval = GetValue(scaleConfig, "resizeInterval", this.resizeInterval);
              this.fullscreenTarget = GetValue(scaleConfig, "fullscreenTarget", this.fullscreenTarget);
              this.minWidth = GetValue(scaleConfig, "min.width", this.minWidth);
              this.maxWidth = GetValue(scaleConfig, "max.width", this.maxWidth);
              this.minHeight = GetValue(scaleConfig, "min.height", this.minHeight);
              this.maxHeight = GetValue(scaleConfig, "max.height", this.maxHeight);
            }
            this.renderType = GetValue(config, "type", CONST.AUTO);
            this.canvas = GetValue(config, "canvas", null);
            this.context = GetValue(config, "context", null);
            this.canvasStyle = GetValue(config, "canvasStyle", null);
            this.customEnvironment = GetValue(config, "customEnvironment", false);
            this.sceneConfig = GetValue(config, "scene", null);
            this.seed = GetValue(config, "seed", [(Date.now() * Math.random()).toString()]);
            PhaserMath.RND = new PhaserMath.RandomDataGenerator(this.seed);
            this.gameTitle = GetValue(config, "title", "");
            this.gameURL = GetValue(config, "url", "https://phaser.io");
            this.gameVersion = GetValue(config, "version", "");
            this.autoFocus = GetValue(config, "autoFocus", true);
            this.domCreateContainer = GetValue(config, "dom.createContainer", false);
            this.domBehindCanvas = GetValue(config, "dom.behindCanvas", false);
            this.domPointerEvents = GetValue(config, "dom.pointerEvents", "none");
            this.inputKeyboard = GetValue(config, "input.keyboard", true);
            this.inputKeyboardEventTarget = GetValue(config, "input.keyboard.target", window);
            this.inputKeyboardCapture = GetValue(config, "input.keyboard.capture", []);
            this.inputMouse = GetValue(config, "input.mouse", true);
            this.inputMouseEventTarget = GetValue(config, "input.mouse.target", null);
            this.inputMousePreventDefaultDown = GetValue(config, "input.mouse.preventDefaultDown", true);
            this.inputMousePreventDefaultUp = GetValue(config, "input.mouse.preventDefaultUp", true);
            this.inputMousePreventDefaultMove = GetValue(config, "input.mouse.preventDefaultMove", true);
            this.inputMousePreventDefaultWheel = GetValue(config, "input.mouse.preventDefaultWheel", true);
            this.inputTouch = GetValue(config, "input.touch", Device.input.touch);
            this.inputTouchEventTarget = GetValue(config, "input.touch.target", null);
            this.inputTouchCapture = GetValue(config, "input.touch.capture", true);
            this.inputActivePointers = GetValue(config, "input.activePointers", 1);
            this.inputSmoothFactor = GetValue(config, "input.smoothFactor", 0);
            this.inputWindowEvents = GetValue(config, "input.windowEvents", true);
            this.inputGamepad = GetValue(config, "input.gamepad", false);
            this.inputGamepadEventTarget = GetValue(config, "input.gamepad.target", window);
            this.disableContextMenu = GetValue(config, "disableContextMenu", false);
            this.audio = GetValue(config, "audio", {});
            this.hideBanner = GetValue(config, "banner", null) === false;
            this.hidePhaser = GetValue(config, "banner.hidePhaser", false);
            this.bannerTextColor = GetValue(config, "banner.text", defaultBannerTextColor);
            this.bannerBackgroundColor = GetValue(config, "banner.background", defaultBannerColor);
            if (this.gameTitle === "" && this.hidePhaser) {
              this.hideBanner = true;
            }
            this.fps = GetValue(config, "fps", null);
            var renderConfig = GetValue(config, "render", config);
            this.pipeline = GetValue(renderConfig, "pipeline", null);
            this.antialias = GetValue(renderConfig, "antialias", true);
            this.antialiasGL = GetValue(renderConfig, "antialiasGL", true);
            this.mipmapFilter = GetValue(renderConfig, "mipmapFilter", "LINEAR");
            this.desynchronized = GetValue(renderConfig, "desynchronized", false);
            this.roundPixels = GetValue(renderConfig, "roundPixels", false);
            this.pixelArt = GetValue(renderConfig, "pixelArt", this.zoom !== 1);
            if (this.pixelArt) {
              this.antialias = false;
              this.antialiasGL = false;
              this.roundPixels = true;
            }
            this.transparent = GetValue(renderConfig, "transparent", false);
            this.clearBeforeRender = GetValue(renderConfig, "clearBeforeRender", true);
            this.preserveDrawingBuffer = GetValue(renderConfig, "preserveDrawingBuffer", false);
            this.premultipliedAlpha = GetValue(renderConfig, "premultipliedAlpha", true);
            this.failIfMajorPerformanceCaveat = GetValue(renderConfig, "failIfMajorPerformanceCaveat", false);
            this.powerPreference = GetValue(renderConfig, "powerPreference", "default");
            this.batchSize = GetValue(renderConfig, "batchSize", 4096);
            this.maxTextures = GetValue(renderConfig, "maxTextures", -1);
            this.maxLights = GetValue(renderConfig, "maxLights", 10);
            var bgc = GetValue(config, "backgroundColor", 0);
            this.backgroundColor = ValueToColor(bgc);
            if (this.transparent) {
              this.backgroundColor = ValueToColor(0);
              this.backgroundColor.alpha = 0;
            }
            this.preBoot = GetValue(config, "callbacks.preBoot", NOOP);
            this.postBoot = GetValue(config, "callbacks.postBoot", NOOP);
            this.physics = GetValue(config, "physics", {});
            this.defaultPhysicsSystem = GetValue(this.physics, "default", false);
            this.loaderBaseURL = GetValue(config, "loader.baseURL", "");
            this.loaderPath = GetValue(config, "loader.path", "");
            var defaultParallel = Device.os.android ? 6 : 32;
            this.loaderMaxParallelDownloads = GetValue(config, "loader.maxParallelDownloads", defaultParallel);
            this.loaderCrossOrigin = GetValue(config, "loader.crossOrigin", void 0);
            this.loaderResponseType = GetValue(config, "loader.responseType", "");
            this.loaderAsync = GetValue(config, "loader.async", true);
            this.loaderUser = GetValue(config, "loader.user", "");
            this.loaderPassword = GetValue(config, "loader.password", "");
            this.loaderTimeout = GetValue(config, "loader.timeout", 0);
            this.loaderWithCredentials = GetValue(config, "loader.withCredentials", false);
            this.installGlobalPlugins = [];
            this.installScenePlugins = [];
            var plugins = GetValue(config, "plugins", null);
            var defaultPlugins = DefaultPlugins.DefaultScene;
            if (plugins) {
              if (Array.isArray(plugins)) {
                this.defaultPlugins = plugins;
              } else if (IsPlainObject2(plugins)) {
                this.installGlobalPlugins = GetFastValue(plugins, "global", []);
                this.installScenePlugins = GetFastValue(plugins, "scene", []);
                if (Array.isArray(plugins.default)) {
                  defaultPlugins = plugins.default;
                } else if (Array.isArray(plugins.defaultMerge)) {
                  defaultPlugins = defaultPlugins.concat(plugins.defaultMerge);
                }
              }
            }
            this.defaultPlugins = defaultPlugins;
            var pngPrefix = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg";
            this.defaultImage = GetValue(config, "images.default", pngPrefix + "AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==");
            this.missingImage = GetValue(config, "images.missing", pngPrefix + "CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==");
            this.whiteImage = GetValue(config, "images.white", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABdJREFUeNpi/P//PwMMMDEgAdwcgAADAJZuAwXJYZOzAAAAAElFTkSuQmCC");
            if (window) {
              if (window.FORCE_WEBGL) {
                this.renderType = CONST.WEBGL;
              } else if (window.FORCE_CANVAS) {
                this.renderType = CONST.CANVAS;
              }
            }
          }
        });
        module2.exports = Config;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          os: __webpack_require__(105),
          browser: __webpack_require__(136),
          features: __webpack_require__(191),
          input: __webpack_require__(808),
          audio: __webpack_require__(809),
          video: __webpack_require__(810),
          fullscreen: __webpack_require__(811),
          canvasFeatures: __webpack_require__(348)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CanvasPool = __webpack_require__(31);
        var CanvasFeatures = {
          supportInverseAlpha: false,
          supportNewBlendModes: false
        };
        function checkBlendMode() {
          var pngHead = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/";
          var pngEnd = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==";
          var magenta = new Image();
          magenta.onload = function() {
            var yellow = new Image();
            yellow.onload = function() {
              var canvas = CanvasPool.create(yellow, 6, 1);
              var context = canvas.getContext("2d");
              context.globalCompositeOperation = "multiply";
              context.drawImage(magenta, 0, 0);
              context.drawImage(yellow, 2, 0);
              if (!context.getImageData(2, 0, 1, 1)) {
                return false;
              }
              var data = context.getImageData(2, 0, 1, 1).data;
              CanvasPool.remove(yellow);
              CanvasFeatures.supportNewBlendModes = data[0] === 255 && data[1] === 0 && data[2] === 0;
            };
            yellow.src = pngHead + "/wCKxvRF" + pngEnd;
          };
          magenta.src = pngHead + "AP804Oa6" + pngEnd;
          return false;
        }
        function checkInverseAlpha() {
          var canvas = CanvasPool.create(this, 2, 1);
          var context = canvas.getContext("2d");
          context.fillStyle = "rgba(10, 20, 30, 0.5)";
          context.fillRect(0, 0, 1, 1);
          var s1 = context.getImageData(0, 0, 1, 1);
          if (s1 === null) {
            return false;
          }
          context.putImageData(s1, 1, 0);
          var s2 = context.getImageData(1, 0, 1, 1);
          return s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3];
        }
        function init() {
          if (typeof importScripts !== "function" && document !== void 0) {
            CanvasFeatures.supportNewBlendModes = checkBlendMode();
            CanvasFeatures.supportInverseAlpha = checkInverseAlpha();
          }
          return CanvasFeatures;
        }
        module2.exports = init();
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Between = function(x1, y1, x2, y2) {
          return Math.atan2(y2 - y1, x2 - x1);
        };
        module2.exports = Between;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BetweenPoints = function(point1, point2) {
          return Math.atan2(point2.y - point1.y, point2.x - point1.x);
        };
        module2.exports = BetweenPoints;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Normalize = function(angle) {
          angle = angle % (2 * Math.PI);
          if (angle >= 0) {
            return angle;
          } else {
            return angle + 2 * Math.PI;
          }
        };
        module2.exports = Normalize;
      },
      function(module2, exports2) {
        /**
         * @author       samme
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DistanceBetweenPoints = function(a, b2) {
          var dx = a.x - b2.x;
          var dy = a.y - b2.y;
          return Math.sqrt(dx * dx + dy * dy);
        };
        module2.exports = DistanceBetweenPoints;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DistanceSquared = function(x1, y1, x2, y2) {
          var dx = x1 - x2;
          var dy = y1 - y2;
          return dx * dx + dy * dy;
        };
        module2.exports = DistanceSquared;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GreaterThan = function(a, b2, epsilon) {
          if (epsilon === void 0) {
            epsilon = 1e-4;
          }
          return a > b2 - epsilon;
        };
        module2.exports = GreaterThan;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var LessThan = function(a, b2, epsilon) {
          if (epsilon === void 0) {
            epsilon = 1e-4;
          }
          return a < b2 + epsilon;
        };
        module2.exports = LessThan;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Factorial = __webpack_require__(357);
        var Bernstein = function(n2, i2) {
          return Factorial(n2) / Factorial(i2) / Factorial(n2 - i2);
        };
        module2.exports = Bernstein;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Factorial = function(value) {
          if (value === 0) {
            return 1;
          }
          var res = value;
          while (--value) {
            res *= value;
          }
          return res;
        };
        module2.exports = Factorial;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        function P0(t2, p2) {
          var k2 = 1 - t2;
          return k2 * k2 * k2 * p2;
        }
        function P1(t2, p2) {
          var k2 = 1 - t2;
          return 3 * k2 * k2 * t2 * p2;
        }
        function P2(t2, p2) {
          return 3 * (1 - t2) * t2 * t2 * p2;
        }
        function P3(t2, p2) {
          return t2 * t2 * t2 * p2;
        }
        var CubicBezierInterpolation = function(t2, p0, p1, p2, p3) {
          return P0(t2, p0) + P1(t2, p1) + P2(t2, p2) + P3(t2, p3);
        };
        module2.exports = CubicBezierInterpolation;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        function P0(t2, p2) {
          var k2 = 1 - t2;
          return k2 * k2 * p2;
        }
        function P1(t2, p2) {
          return 2 * (1 - t2) * t2 * p2;
        }
        function P2(t2, p2) {
          return t2 * t2 * p2;
        }
        var QuadraticBezierInterpolation = function(t2, p0, p1, p2) {
          return P0(t2, p0) + P1(t2, p1) + P2(t2, p2);
        };
        module2.exports = QuadraticBezierInterpolation;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SmoothStep = __webpack_require__(184);
        var SmoothStepInterpolation = function(t2, min, max) {
          return min + (max - min) * SmoothStep(t2, 0, 1);
        };
        module2.exports = SmoothStepInterpolation;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetPowerOfTwo = function(value) {
          var index2 = Math.log(value) / 0.6931471805599453;
          return 1 << Math.ceil(index2);
        };
        module2.exports = GetPowerOfTwo;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rotate = function(point, angle) {
          var x2 = point.x;
          var y2 = point.y;
          point.x = x2 * Math.cos(angle) - y2 * Math.sin(angle);
          point.y = x2 * Math.sin(angle) + y2 * Math.cos(angle);
          return point;
        };
        module2.exports = Rotate;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RoundAwayFromZero = function(value) {
          return value > 0 ? Math.ceil(value) : Math.floor(value);
        };
        module2.exports = RoundAwayFromZero;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Matrix3 = new Class({
          initialize: function Matrix32(m2) {
            this.val = new Float32Array(9);
            if (m2) {
              this.copy(m2);
            } else {
              this.identity();
            }
          },
          clone: function() {
            return new Matrix3(this);
          },
          set: function(src) {
            return this.copy(src);
          },
          copy: function(src) {
            var out = this.val;
            var a = src.val;
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            return this;
          },
          fromMat4: function(m2) {
            var a = m2.val;
            var out = this.val;
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[4];
            out[4] = a[5];
            out[5] = a[6];
            out[6] = a[8];
            out[7] = a[9];
            out[8] = a[10];
            return this;
          },
          fromArray: function(a) {
            var out = this.val;
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            return this;
          },
          identity: function() {
            var out = this.val;
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 1;
            out[5] = 0;
            out[6] = 0;
            out[7] = 0;
            out[8] = 1;
            return this;
          },
          transpose: function() {
            var a = this.val;
            var a01 = a[1];
            var a02 = a[2];
            var a12 = a[5];
            a[1] = a[3];
            a[2] = a[6];
            a[3] = a01;
            a[5] = a[7];
            a[6] = a02;
            a[7] = a12;
            return this;
          },
          invert: function() {
            var a = this.val;
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a10 = a[3];
            var a11 = a[4];
            var a12 = a[5];
            var a20 = a[6];
            var a21 = a[7];
            var a22 = a[8];
            var b01 = a22 * a11 - a12 * a21;
            var b11 = -a22 * a10 + a12 * a20;
            var b21 = a21 * a10 - a11 * a20;
            var det = a00 * b01 + a01 * b11 + a02 * b21;
            if (!det) {
              return null;
            }
            det = 1 / det;
            a[0] = b01 * det;
            a[1] = (-a22 * a01 + a02 * a21) * det;
            a[2] = (a12 * a01 - a02 * a11) * det;
            a[3] = b11 * det;
            a[4] = (a22 * a00 - a02 * a20) * det;
            a[5] = (-a12 * a00 + a02 * a10) * det;
            a[6] = b21 * det;
            a[7] = (-a21 * a00 + a01 * a20) * det;
            a[8] = (a11 * a00 - a01 * a10) * det;
            return this;
          },
          adjoint: function() {
            var a = this.val;
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a10 = a[3];
            var a11 = a[4];
            var a12 = a[5];
            var a20 = a[6];
            var a21 = a[7];
            var a22 = a[8];
            a[0] = a11 * a22 - a12 * a21;
            a[1] = a02 * a21 - a01 * a22;
            a[2] = a01 * a12 - a02 * a11;
            a[3] = a12 * a20 - a10 * a22;
            a[4] = a00 * a22 - a02 * a20;
            a[5] = a02 * a10 - a00 * a12;
            a[6] = a10 * a21 - a11 * a20;
            a[7] = a01 * a20 - a00 * a21;
            a[8] = a00 * a11 - a01 * a10;
            return this;
          },
          determinant: function() {
            var a = this.val;
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a10 = a[3];
            var a11 = a[4];
            var a12 = a[5];
            var a20 = a[6];
            var a21 = a[7];
            var a22 = a[8];
            return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
          },
          multiply: function(src) {
            var a = this.val;
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a10 = a[3];
            var a11 = a[4];
            var a12 = a[5];
            var a20 = a[6];
            var a21 = a[7];
            var a22 = a[8];
            var b2 = src.val;
            var b00 = b2[0];
            var b01 = b2[1];
            var b02 = b2[2];
            var b10 = b2[3];
            var b11 = b2[4];
            var b12 = b2[5];
            var b20 = b2[6];
            var b21 = b2[7];
            var b22 = b2[8];
            a[0] = b00 * a00 + b01 * a10 + b02 * a20;
            a[1] = b00 * a01 + b01 * a11 + b02 * a21;
            a[2] = b00 * a02 + b01 * a12 + b02 * a22;
            a[3] = b10 * a00 + b11 * a10 + b12 * a20;
            a[4] = b10 * a01 + b11 * a11 + b12 * a21;
            a[5] = b10 * a02 + b11 * a12 + b12 * a22;
            a[6] = b20 * a00 + b21 * a10 + b22 * a20;
            a[7] = b20 * a01 + b21 * a11 + b22 * a21;
            a[8] = b20 * a02 + b21 * a12 + b22 * a22;
            return this;
          },
          translate: function(v2) {
            var a = this.val;
            var x2 = v2.x;
            var y2 = v2.y;
            a[6] = x2 * a[0] + y2 * a[3] + a[6];
            a[7] = x2 * a[1] + y2 * a[4] + a[7];
            a[8] = x2 * a[2] + y2 * a[5] + a[8];
            return this;
          },
          rotate: function(rad) {
            var a = this.val;
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a10 = a[3];
            var a11 = a[4];
            var a12 = a[5];
            var s = Math.sin(rad);
            var c = Math.cos(rad);
            a[0] = c * a00 + s * a10;
            a[1] = c * a01 + s * a11;
            a[2] = c * a02 + s * a12;
            a[3] = c * a10 - s * a00;
            a[4] = c * a11 - s * a01;
            a[5] = c * a12 - s * a02;
            return this;
          },
          scale: function(v2) {
            var a = this.val;
            var x2 = v2.x;
            var y2 = v2.y;
            a[0] = x2 * a[0];
            a[1] = x2 * a[1];
            a[2] = x2 * a[2];
            a[3] = y2 * a[3];
            a[4] = y2 * a[4];
            a[5] = y2 * a[5];
            return this;
          },
          fromQuat: function(q2) {
            var x2 = q2.x;
            var y2 = q2.y;
            var z2 = q2.z;
            var w2 = q2.w;
            var x22 = x2 + x2;
            var y22 = y2 + y2;
            var z22 = z2 + z2;
            var xx = x2 * x22;
            var xy = x2 * y22;
            var xz = x2 * z22;
            var yy = y2 * y22;
            var yz = y2 * z22;
            var zz = z2 * z22;
            var wx = w2 * x22;
            var wy = w2 * y22;
            var wz = w2 * z22;
            var out = this.val;
            out[0] = 1 - (yy + zz);
            out[3] = xy + wz;
            out[6] = xz - wy;
            out[1] = xy - wz;
            out[4] = 1 - (xx + zz);
            out[7] = yz + wx;
            out[2] = xz + wy;
            out[5] = yz - wx;
            out[8] = 1 - (xx + yy);
            return this;
          },
          normalFromMat4: function(m2) {
            var a = m2.val;
            var out = this.val;
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a03 = a[3];
            var a10 = a[4];
            var a11 = a[5];
            var a12 = a[6];
            var a13 = a[7];
            var a20 = a[8];
            var a21 = a[9];
            var a22 = a[10];
            var a23 = a[11];
            var a30 = a[12];
            var a31 = a[13];
            var a32 = a[14];
            var a33 = a[15];
            var b00 = a00 * a11 - a01 * a10;
            var b01 = a00 * a12 - a02 * a10;
            var b02 = a00 * a13 - a03 * a10;
            var b03 = a01 * a12 - a02 * a11;
            var b04 = a01 * a13 - a03 * a11;
            var b05 = a02 * a13 - a03 * a12;
            var b06 = a20 * a31 - a21 * a30;
            var b07 = a20 * a32 - a22 * a30;
            var b08 = a20 * a33 - a23 * a30;
            var b09 = a21 * a32 - a22 * a31;
            var b10 = a21 * a33 - a23 * a31;
            var b11 = a22 * a33 - a23 * a32;
            var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            if (!det) {
              return null;
            }
            det = 1 / det;
            out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
            out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
            out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
            out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
            out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
            out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
            out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
            out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
            out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
            return this;
          }
        });
        module2.exports = Matrix3;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Matrix3 = __webpack_require__(364);
        var NOOP = __webpack_require__(1);
        var Vector3 = __webpack_require__(39);
        var EPSILON = 1e-6;
        var siNext = new Int8Array([1, 2, 0]);
        var tmp = new Float32Array([0, 0, 0]);
        var xUnitVec3 = new Vector3(1, 0, 0);
        var yUnitVec3 = new Vector3(0, 1, 0);
        var tmpvec = new Vector3();
        var tmpMat3 = new Matrix3();
        var Quaternion = new Class({
          initialize: function Quaternion2(x2, y2, z2, w2) {
            this.onChangeCallback = NOOP;
            this.set(x2, y2, z2, w2);
          },
          x: {
            get: function() {
              return this._x;
            },
            set: function(value) {
              this._x = value;
              this.onChangeCallback(this);
            }
          },
          y: {
            get: function() {
              return this._y;
            },
            set: function(value) {
              this._y = value;
              this.onChangeCallback(this);
            }
          },
          z: {
            get: function() {
              return this._z;
            },
            set: function(value) {
              this._z = value;
              this.onChangeCallback(this);
            }
          },
          w: {
            get: function() {
              return this._w;
            },
            set: function(value) {
              this._w = value;
              this.onChangeCallback(this);
            }
          },
          copy: function(src) {
            return this.set(src);
          },
          set: function(x2, y2, z2, w2, update) {
            if (update === void 0) {
              update = true;
            }
            if (typeof x2 === "object") {
              this._x = x2.x || 0;
              this._y = x2.y || 0;
              this._z = x2.z || 0;
              this._w = x2.w || 0;
            } else {
              this._x = x2 || 0;
              this._y = y2 || 0;
              this._z = z2 || 0;
              this._w = w2 || 0;
            }
            if (update) {
              this.onChangeCallback(this);
            }
            return this;
          },
          add: function(v2) {
            this._x += v2.x;
            this._y += v2.y;
            this._z += v2.z;
            this._w += v2.w;
            this.onChangeCallback(this);
            return this;
          },
          subtract: function(v2) {
            this._x -= v2.x;
            this._y -= v2.y;
            this._z -= v2.z;
            this._w -= v2.w;
            this.onChangeCallback(this);
            return this;
          },
          scale: function(scale) {
            this._x *= scale;
            this._y *= scale;
            this._z *= scale;
            this._w *= scale;
            this.onChangeCallback(this);
            return this;
          },
          length: function() {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var w2 = this.w;
            return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2);
          },
          lengthSq: function() {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var w2 = this.w;
            return x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2;
          },
          normalize: function() {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            var w2 = this.w;
            var len = x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2;
            if (len > 0) {
              len = 1 / Math.sqrt(len);
              this._x = x2 * len;
              this._y = y2 * len;
              this._z = z2 * len;
              this._w = w2 * len;
            }
            this.onChangeCallback(this);
            return this;
          },
          dot: function(v2) {
            return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
          },
          lerp: function(v2, t2) {
            if (t2 === void 0) {
              t2 = 0;
            }
            var ax = this.x;
            var ay = this.y;
            var az = this.z;
            var aw = this.w;
            return this.set(ax + t2 * (v2.x - ax), ay + t2 * (v2.y - ay), az + t2 * (v2.z - az), aw + t2 * (v2.w - aw));
          },
          rotationTo: function(a, b2) {
            var dot = a.x * b2.x + a.y * b2.y + a.z * b2.z;
            if (dot < -0.999999) {
              if (tmpvec.copy(xUnitVec3).cross(a).length() < EPSILON) {
                tmpvec.copy(yUnitVec3).cross(a);
              }
              tmpvec.normalize();
              return this.setAxisAngle(tmpvec, Math.PI);
            } else if (dot > 0.999999) {
              return this.set(0, 0, 0, 1);
            } else {
              tmpvec.copy(a).cross(b2);
              this._x = tmpvec.x;
              this._y = tmpvec.y;
              this._z = tmpvec.z;
              this._w = 1 + dot;
              return this.normalize();
            }
          },
          setAxes: function(view, right, up) {
            var m2 = tmpMat3.val;
            m2[0] = right.x;
            m2[3] = right.y;
            m2[6] = right.z;
            m2[1] = up.x;
            m2[4] = up.y;
            m2[7] = up.z;
            m2[2] = -view.x;
            m2[5] = -view.y;
            m2[8] = -view.z;
            return this.fromMat3(tmpMat3).normalize();
          },
          identity: function() {
            return this.set(0, 0, 0, 1);
          },
          setAxisAngle: function(axis, rad) {
            rad = rad * 0.5;
            var s = Math.sin(rad);
            return this.set(s * axis.x, s * axis.y, s * axis.z, Math.cos(rad));
          },
          multiply: function(b2) {
            var ax = this.x;
            var ay = this.y;
            var az = this.z;
            var aw = this.w;
            var bx = b2.x;
            var by = b2.y;
            var bz = b2.z;
            var bw = b2.w;
            return this.set(ax * bw + aw * bx + ay * bz - az * by, ay * bw + aw * by + az * bx - ax * bz, az * bw + aw * bz + ax * by - ay * bx, aw * bw - ax * bx - ay * by - az * bz);
          },
          slerp: function(b2, t2) {
            var ax = this.x;
            var ay = this.y;
            var az = this.z;
            var aw = this.w;
            var bx = b2.x;
            var by = b2.y;
            var bz = b2.z;
            var bw = b2.w;
            var cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0) {
              cosom = -cosom;
              bx = -bx;
              by = -by;
              bz = -bz;
              bw = -bw;
            }
            var scale0 = 1 - t2;
            var scale1 = t2;
            if (1 - cosom > EPSILON) {
              var omega = Math.acos(cosom);
              var sinom = Math.sin(omega);
              scale0 = Math.sin((1 - t2) * omega) / sinom;
              scale1 = Math.sin(t2 * omega) / sinom;
            }
            return this.set(scale0 * ax + scale1 * bx, scale0 * ay + scale1 * by, scale0 * az + scale1 * bz, scale0 * aw + scale1 * bw);
          },
          invert: function() {
            var a0 = this.x;
            var a1 = this.y;
            var a2 = this.z;
            var a3 = this.w;
            var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
            var invDot = dot ? 1 / dot : 0;
            return this.set(-a0 * invDot, -a1 * invDot, -a2 * invDot, a3 * invDot);
          },
          conjugate: function() {
            this._x = -this.x;
            this._y = -this.y;
            this._z = -this.z;
            this.onChangeCallback(this);
            return this;
          },
          rotateX: function(rad) {
            rad *= 0.5;
            var ax = this.x;
            var ay = this.y;
            var az = this.z;
            var aw = this.w;
            var bx = Math.sin(rad);
            var bw = Math.cos(rad);
            return this.set(ax * bw + aw * bx, ay * bw + az * bx, az * bw - ay * bx, aw * bw - ax * bx);
          },
          rotateY: function(rad) {
            rad *= 0.5;
            var ax = this.x;
            var ay = this.y;
            var az = this.z;
            var aw = this.w;
            var by = Math.sin(rad);
            var bw = Math.cos(rad);
            return this.set(ax * bw - az * by, ay * bw + aw * by, az * bw + ax * by, aw * bw - ay * by);
          },
          rotateZ: function(rad) {
            rad *= 0.5;
            var ax = this.x;
            var ay = this.y;
            var az = this.z;
            var aw = this.w;
            var bz = Math.sin(rad);
            var bw = Math.cos(rad);
            return this.set(ax * bw + ay * bz, ay * bw - ax * bz, az * bw + aw * bz, aw * bw - az * bz);
          },
          calculateW: function() {
            var x2 = this.x;
            var y2 = this.y;
            var z2 = this.z;
            this.w = -Math.sqrt(1 - x2 * x2 - y2 * y2 - z2 * z2);
            return this;
          },
          setFromEuler: function(euler, update) {
            var x2 = euler.x / 2;
            var y2 = euler.y / 2;
            var z2 = euler.z / 2;
            var c1 = Math.cos(x2);
            var c2 = Math.cos(y2);
            var c3 = Math.cos(z2);
            var s1 = Math.sin(x2);
            var s2 = Math.sin(y2);
            var s3 = Math.sin(z2);
            switch (euler.order) {
              case "XYZ": {
                this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
                break;
              }
              case "YXZ": {
                this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
                break;
              }
              case "ZXY": {
                this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
                break;
              }
              case "ZYX": {
                this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
                break;
              }
              case "YZX": {
                this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
                break;
              }
              case "XZY": {
                this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
                break;
              }
            }
            return this;
          },
          setFromRotationMatrix: function(mat4) {
            var m2 = mat4.val;
            var m11 = m2[0];
            var m12 = m2[4];
            var m13 = m2[8];
            var m21 = m2[1];
            var m22 = m2[5];
            var m23 = m2[9];
            var m31 = m2[2];
            var m32 = m2[6];
            var m33 = m2[10];
            var trace = m11 + m22 + m33;
            var s;
            if (trace > 0) {
              s = 0.5 / Math.sqrt(trace + 1);
              this.set((m32 - m23) * s, (m13 - m31) * s, (m21 - m12) * s, 0.25 / s);
            } else if (m11 > m22 && m11 > m33) {
              s = 2 * Math.sqrt(1 + m11 - m22 - m33);
              this.set(0.25 * s, (m12 + m21) / s, (m13 + m31) / s, (m32 - m23) / s);
            } else if (m22 > m33) {
              s = 2 * Math.sqrt(1 + m22 - m11 - m33);
              this.set((m12 + m21) / s, 0.25 * s, (m23 + m32) / s, (m13 - m31) / s);
            } else {
              s = 2 * Math.sqrt(1 + m33 - m11 - m22);
              this.set((m13 + m31) / s, (m23 + m32) / s, 0.25 * s, (m21 - m12) / s);
            }
            return this;
          },
          fromMat3: function(mat) {
            var m2 = mat.val;
            var fTrace = m2[0] + m2[4] + m2[8];
            var fRoot;
            if (fTrace > 0) {
              fRoot = Math.sqrt(fTrace + 1);
              this.w = 0.5 * fRoot;
              fRoot = 0.5 / fRoot;
              this._x = (m2[7] - m2[5]) * fRoot;
              this._y = (m2[2] - m2[6]) * fRoot;
              this._z = (m2[3] - m2[1]) * fRoot;
            } else {
              var i2 = 0;
              if (m2[4] > m2[0]) {
                i2 = 1;
              }
              if (m2[8] > m2[i2 * 3 + i2]) {
                i2 = 2;
              }
              var j = siNext[i2];
              var k2 = siNext[j];
              fRoot = Math.sqrt(m2[i2 * 3 + i2] - m2[j * 3 + j] - m2[k2 * 3 + k2] + 1);
              tmp[i2] = 0.5 * fRoot;
              fRoot = 0.5 / fRoot;
              tmp[j] = (m2[j * 3 + i2] + m2[i2 * 3 + j]) * fRoot;
              tmp[k2] = (m2[k2 * 3 + i2] + m2[i2 * 3 + k2]) * fRoot;
              this._x = tmp[0];
              this._y = tmp[1];
              this._z = tmp[2];
              this._w = (m2[k2 * 3 + j] - m2[j * 3 + k2]) * fRoot;
            }
            this.onChangeCallback(this);
            return this;
          }
        });
        module2.exports = Quaternion;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CanvasInterpolation = __webpack_require__(367);
        var CanvasPool = __webpack_require__(31);
        var CONST = __webpack_require__(33);
        var Features = __webpack_require__(191);
        var CreateRenderer = function(game) {
          var config = game.config;
          if ((config.customEnvironment || config.canvas) && config.renderType === CONST.AUTO) {
            throw new Error("Must set explicit renderType in custom environment");
          }
          if (!config.customEnvironment && !config.canvas && config.renderType !== CONST.HEADLESS) {
            if (config.renderType === CONST.CANVAS || config.renderType !== CONST.CANVAS && !Features.webGL) {
              if (Features.canvas) {
                config.renderType = CONST.CANVAS;
              } else {
                throw new Error("Cannot create Canvas or WebGL context, aborting.");
              }
            } else {
              config.renderType = CONST.WEBGL;
            }
          }
          if (!config.antialias) {
            CanvasPool.disableSmoothing();
          }
          var baseSize = game.scale.baseSize;
          var width = baseSize.width;
          var height = baseSize.height;
          if (config.canvas) {
            game.canvas = config.canvas;
            game.canvas.width = width;
            game.canvas.height = height;
          } else {
            game.canvas = CanvasPool.create(game, width, height, config.renderType);
          }
          if (config.canvasStyle) {
            game.canvas.style = config.canvasStyle;
          }
          if (!config.antialias) {
            CanvasInterpolation.setCrisp(game.canvas);
          }
          if (config.renderType === CONST.HEADLESS) {
            return;
          }
          var CanvasRenderer;
          var WebGLRenderer;
          {
            CanvasRenderer = __webpack_require__(368);
            WebGLRenderer = __webpack_require__(371);
            if (config.renderType === CONST.WEBGL) {
              game.renderer = new WebGLRenderer(game);
            } else {
              game.renderer = new CanvasRenderer(game);
              game.context = game.renderer.gameContext;
            }
          }
        };
        module2.exports = CreateRenderer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CanvasInterpolation = {
          setCrisp: function(canvas) {
            var types = ["optimizeSpeed", "-moz-crisp-edges", "-o-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "crisp-edges", "pixelated"];
            types.forEach(function(type) {
              canvas.style["image-rendering"] = type;
            });
            canvas.style.msInterpolationMode = "nearest-neighbor";
            return canvas;
          },
          setBicubic: function(canvas) {
            canvas.style["image-rendering"] = "auto";
            canvas.style.msInterpolationMode = "bicubic";
            return canvas;
          }
        };
        module2.exports = CanvasInterpolation;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Felipe Alfonso <@bitnenfer>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CameraEvents = __webpack_require__(37);
        var CanvasSnapshot = __webpack_require__(369);
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(33);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(91);
        var GetBlendModes = __webpack_require__(370);
        var ScaleEvents = __webpack_require__(104);
        var TextureEvents = __webpack_require__(106);
        var TransformMatrix = __webpack_require__(25);
        var CanvasRenderer = new Class({
          Extends: EventEmitter,
          initialize: function CanvasRenderer2(game) {
            EventEmitter.call(this);
            var gameConfig = game.config;
            this.config = {
              clearBeforeRender: gameConfig.clearBeforeRender,
              backgroundColor: gameConfig.backgroundColor,
              antialias: gameConfig.antialias,
              roundPixels: gameConfig.roundPixels
            };
            this.game = game;
            this.type = CONST.CANVAS;
            this.drawCount = 0;
            this.width = 0;
            this.height = 0;
            this.gameCanvas = game.canvas;
            var contextOptions = {
              alpha: game.config.transparent,
              desynchronized: game.config.desynchronized
            };
            this.gameContext = gameConfig.context ? gameConfig.context : this.gameCanvas.getContext("2d", contextOptions);
            this.currentContext = this.gameContext;
            this.antialias = game.config.antialias;
            this.blendModes = GetBlendModes();
            this.snapshotState = {
              x: 0,
              y: 0,
              width: 1,
              height: 1,
              getPixel: false,
              callback: null,
              type: "image/png",
              encoder: 0.92
            };
            this._tempMatrix1 = new TransformMatrix();
            this._tempMatrix2 = new TransformMatrix();
            this._tempMatrix3 = new TransformMatrix();
            this.isBooted = false;
            this.init();
          },
          init: function() {
            this.game.textures.once(TextureEvents.READY, this.boot, this);
          },
          boot: function() {
            var game = this.game;
            var baseSize = game.scale.baseSize;
            this.width = baseSize.width;
            this.height = baseSize.height;
            this.isBooted = true;
            game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
            this.resize(baseSize.width, baseSize.height);
          },
          onResize: function(gameSize, baseSize) {
            if (baseSize.width !== this.width || baseSize.height !== this.height) {
              this.resize(baseSize.width, baseSize.height);
            }
          },
          resize: function(width, height) {
            this.width = width;
            this.height = height;
            this.emit(Events.RESIZE, width, height);
          },
          resetTransform: function() {
            this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
          },
          setBlendMode: function(blendMode) {
            this.currentContext.globalCompositeOperation = blendMode;
            return this;
          },
          setContext: function(ctx) {
            this.currentContext = ctx ? ctx : this.gameContext;
            return this;
          },
          setAlpha: function(alpha) {
            this.currentContext.globalAlpha = alpha;
            return this;
          },
          preRender: function() {
            var ctx = this.gameContext;
            var config = this.config;
            var width = this.width;
            var height = this.height;
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = "source-over";
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            if (config.clearBeforeRender) {
              ctx.clearRect(0, 0, width, height);
              if (!config.transparent) {
                ctx.fillStyle = config.backgroundColor.rgba;
                ctx.fillRect(0, 0, width, height);
              }
            }
            ctx.save();
            this.drawCount = 0;
            this.emit(Events.PRE_RENDER);
          },
          render: function(scene, children, camera) {
            var childCount = children.length;
            this.emit(Events.RENDER, scene, camera);
            var cx = camera.x;
            var cy = camera.y;
            var cw = camera.width;
            var ch2 = camera.height;
            var ctx = camera.renderToTexture ? camera.context : scene.sys.context;
            ctx.save();
            if (this.game.scene.customViewports) {
              ctx.beginPath();
              ctx.rect(cx, cy, cw, ch2);
              ctx.clip();
            }
            this.currentContext = ctx;
            var mask = camera.mask;
            if (mask) {
              mask.preRenderCanvas(this, null, camera._maskCamera);
            }
            if (!camera.transparent) {
              ctx.fillStyle = camera.backgroundColor.rgba;
              ctx.fillRect(cx, cy, cw, ch2);
            }
            ctx.globalAlpha = camera.alpha;
            ctx.globalCompositeOperation = "source-over";
            this.drawCount += childCount;
            if (camera.renderToTexture) {
              camera.emit(CameraEvents.PRE_RENDER, camera);
            }
            camera.matrix.copyToContext(ctx);
            for (var i2 = 0; i2 < childCount; i2++) {
              var child = children[i2];
              if (child.mask) {
                child.mask.preRenderCanvas(this, child, camera);
              }
              child.renderCanvas(this, child, camera);
              if (child.mask) {
                child.mask.postRenderCanvas(this, child, camera);
              }
            }
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.globalCompositeOperation = "source-over";
            ctx.globalAlpha = 1;
            camera.flashEffect.postRenderCanvas(ctx);
            camera.fadeEffect.postRenderCanvas(ctx);
            camera.dirty = false;
            if (mask) {
              mask.postRenderCanvas(this);
            }
            ctx.restore();
            if (camera.renderToTexture) {
              camera.emit(CameraEvents.POST_RENDER, camera);
              if (camera.renderToGame) {
                scene.sys.context.drawImage(camera.canvas, cx, cy);
              }
            }
          },
          postRender: function() {
            var ctx = this.gameContext;
            ctx.restore();
            this.emit(Events.POST_RENDER);
            var state = this.snapshotState;
            if (state.callback) {
              CanvasSnapshot(this.gameCanvas, state);
              state.callback = null;
            }
          },
          snapshotCanvas: function(canvas, callback, getPixel, x2, y2, width, height, type, encoderOptions) {
            if (getPixel === void 0) {
              getPixel = false;
            }
            this.snapshotArea(x2, y2, width, height, callback, type, encoderOptions);
            var state = this.snapshotState;
            state.getPixel = getPixel;
            CanvasSnapshot(this.canvas, state);
            state.callback = null;
            return this;
          },
          snapshot: function(callback, type, encoderOptions) {
            return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, callback, type, encoderOptions);
          },
          snapshotArea: function(x2, y2, width, height, callback, type, encoderOptions) {
            var state = this.snapshotState;
            state.callback = callback;
            state.type = type;
            state.encoder = encoderOptions;
            state.getPixel = false;
            state.x = x2;
            state.y = y2;
            state.width = Math.min(width, this.gameCanvas.width);
            state.height = Math.min(height, this.gameCanvas.height);
            return this;
          },
          snapshotPixel: function(x2, y2, callback) {
            this.snapshotArea(x2, y2, 1, 1, callback);
            this.snapshotState.getPixel = true;
            return this;
          },
          batchSprite: function(sprite, frame, camera, parentTransformMatrix) {
            var alpha = camera.alpha * sprite.alpha;
            if (alpha === 0) {
              return;
            }
            var ctx = this.currentContext;
            var camMatrix = this._tempMatrix1;
            var spriteMatrix = this._tempMatrix2;
            var cd2 = frame.canvasData;
            var frameX = cd2.x;
            var frameY = cd2.y;
            var frameWidth = frame.cutWidth;
            var frameHeight = frame.cutHeight;
            var customPivot = frame.customPivot;
            var res = frame.source.resolution;
            var displayOriginX = sprite.displayOriginX;
            var displayOriginY = sprite.displayOriginY;
            var x2 = -displayOriginX + frame.x;
            var y2 = -displayOriginY + frame.y;
            if (sprite.isCropped) {
              var crop = sprite._crop;
              if (crop.flipX !== sprite.flipX || crop.flipY !== sprite.flipY) {
                frame.updateCropUVs(crop, sprite.flipX, sprite.flipY);
              }
              frameWidth = crop.cw;
              frameHeight = crop.ch;
              frameX = crop.cx;
              frameY = crop.cy;
              x2 = -displayOriginX + crop.x;
              y2 = -displayOriginY + crop.y;
              if (sprite.flipX) {
                if (x2 >= 0) {
                  x2 = -(x2 + frameWidth);
                } else if (x2 < 0) {
                  x2 = Math.abs(x2) - frameWidth;
                }
              }
              if (sprite.flipY) {
                if (y2 >= 0) {
                  y2 = -(y2 + frameHeight);
                } else if (y2 < 0) {
                  y2 = Math.abs(y2) - frameHeight;
                }
              }
            }
            var flipX = 1;
            var flipY = 1;
            if (sprite.flipX) {
              if (!customPivot) {
                x2 += -frame.realWidth + displayOriginX * 2;
              }
              flipX = -1;
            }
            if (sprite.flipY) {
              if (!customPivot) {
                y2 += -frame.realHeight + displayOriginY * 2;
              }
              flipY = -1;
            }
            spriteMatrix.applyITRS(sprite.x, sprite.y, sprite.rotation, sprite.scaleX * flipX, sprite.scaleY * flipY);
            camMatrix.copyFrom(camera.matrix);
            if (parentTransformMatrix) {
              camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY);
              spriteMatrix.e = sprite.x;
              spriteMatrix.f = sprite.y;
            } else {
              spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX;
              spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY;
            }
            camMatrix.multiply(spriteMatrix);
            ctx.save();
            camMatrix.setToContext(ctx);
            ctx.globalCompositeOperation = this.blendModes[sprite.blendMode];
            ctx.globalAlpha = alpha;
            ctx.imageSmoothingEnabled = !(!this.antialias || frame.source.scaleMode);
            if (sprite.mask) {
              sprite.mask.preRenderCanvas(this, sprite, camera);
            }
            ctx.drawImage(frame.source.image, frameX, frameY, frameWidth, frameHeight, x2, y2, frameWidth / res, frameHeight / res);
            if (sprite.mask) {
              sprite.mask.postRenderCanvas(this, sprite, camera);
            }
            ctx.restore();
          },
          destroy: function() {
            this.removeAllListeners();
            this.game = null;
            this.gameCanvas = null;
            this.gameContext = null;
          }
        });
        module2.exports = CanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CanvasPool = __webpack_require__(31);
        var Color = __webpack_require__(38);
        var GetFastValue = __webpack_require__(2);
        var CanvasSnapshot = function(canvas, config) {
          var callback = GetFastValue(config, "callback");
          var type = GetFastValue(config, "type", "image/png");
          var encoderOptions = GetFastValue(config, "encoder", 0.92);
          var x2 = Math.abs(Math.round(GetFastValue(config, "x", 0)));
          var y2 = Math.abs(Math.round(GetFastValue(config, "y", 0)));
          var width = GetFastValue(config, "width", canvas.width);
          var height = GetFastValue(config, "height", canvas.height);
          var getPixel = GetFastValue(config, "getPixel", false);
          if (getPixel) {
            var context = canvas.getContext("2d");
            var imageData = context.getImageData(x2, y2, 1, 1);
            var data = imageData.data;
            callback.call(null, new Color(data[0], data[1], data[2], data[3] / 255));
          } else if (x2 !== 0 || y2 !== 0 || width !== canvas.width || height !== canvas.height) {
            var copyCanvas = CanvasPool.createWebGL(this, width, height);
            var ctx = copyCanvas.getContext("2d");
            ctx.drawImage(canvas, x2, y2, width, height, 0, 0, width, height);
            var image1 = new Image();
            image1.onerror = function() {
              callback.call(null);
              CanvasPool.remove(copyCanvas);
            };
            image1.onload = function() {
              callback.call(null, image1);
              CanvasPool.remove(copyCanvas);
            };
            image1.src = copyCanvas.toDataURL(type, encoderOptions);
          } else {
            var image2 = new Image();
            image2.onerror = function() {
              callback.call(null);
            };
            image2.onload = function() {
              callback.call(null, image2);
            };
            image2.src = canvas.toDataURL(type, encoderOptions);
          }
        };
        module2.exports = CanvasSnapshot;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var modes = __webpack_require__(35);
        var CanvasFeatures = __webpack_require__(348);
        var GetBlendModes = function() {
          var output = [];
          var useNew = CanvasFeatures.supportNewBlendModes;
          var so = "source-over";
          output[modes.NORMAL] = so;
          output[modes.ADD] = "lighter";
          output[modes.MULTIPLY] = useNew ? "multiply" : so;
          output[modes.SCREEN] = useNew ? "screen" : so;
          output[modes.OVERLAY] = useNew ? "overlay" : so;
          output[modes.DARKEN] = useNew ? "darken" : so;
          output[modes.LIGHTEN] = useNew ? "lighten" : so;
          output[modes.COLOR_DODGE] = useNew ? "color-dodge" : so;
          output[modes.COLOR_BURN] = useNew ? "color-burn" : so;
          output[modes.HARD_LIGHT] = useNew ? "hard-light" : so;
          output[modes.SOFT_LIGHT] = useNew ? "soft-light" : so;
          output[modes.DIFFERENCE] = useNew ? "difference" : so;
          output[modes.EXCLUSION] = useNew ? "exclusion" : so;
          output[modes.HUE] = useNew ? "hue" : so;
          output[modes.SATURATION] = useNew ? "saturation" : so;
          output[modes.COLOR] = useNew ? "color" : so;
          output[modes.LUMINOSITY] = useNew ? "luminosity" : so;
          output[modes.ERASE] = "destination-out";
          output[modes.SOURCE_IN] = "source-in";
          output[modes.SOURCE_OUT] = "source-out";
          output[modes.SOURCE_ATOP] = "source-atop";
          output[modes.DESTINATION_OVER] = "destination-over";
          output[modes.DESTINATION_IN] = "destination-in";
          output[modes.DESTINATION_OUT] = "destination-out";
          output[modes.DESTINATION_ATOP] = "destination-atop";
          output[modes.LIGHTER] = "lighter";
          output[modes.COPY] = "copy";
          output[modes.XOR] = "xor";
          return output;
        };
        module2.exports = GetBlendModes;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Felipe Alfonso <@bitnenfer>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ArrayRemove = __webpack_require__(93);
        var CameraEvents = __webpack_require__(37);
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(33);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(91);
        var GameEvents = __webpack_require__(22);
        var IsSizePowerOfTwo = __webpack_require__(138);
        var Matrix4 = __webpack_require__(69);
        var NOOP = __webpack_require__(1);
        var PipelineManager = __webpack_require__(372);
        var RenderTarget = __webpack_require__(141);
        var ScaleEvents = __webpack_require__(104);
        var TextureEvents = __webpack_require__(106);
        var Utils = __webpack_require__(12);
        var WebGLSnapshot = __webpack_require__(383);
        var WebGLRenderer = new Class({
          Extends: EventEmitter,
          initialize: function WebGLRenderer2(game) {
            EventEmitter.call(this);
            var gameConfig = game.config;
            var contextCreationConfig = {
              alpha: gameConfig.transparent,
              desynchronized: gameConfig.desynchronized,
              depth: false,
              antialias: gameConfig.antialiasGL,
              premultipliedAlpha: gameConfig.premultipliedAlpha,
              stencil: true,
              failIfMajorPerformanceCaveat: gameConfig.failIfMajorPerformanceCaveat,
              powerPreference: gameConfig.powerPreference,
              preserveDrawingBuffer: gameConfig.preserveDrawingBuffer
            };
            this.config = {
              clearBeforeRender: gameConfig.clearBeforeRender,
              antialias: gameConfig.antialias,
              backgroundColor: gameConfig.backgroundColor,
              contextCreation: contextCreationConfig,
              roundPixels: gameConfig.roundPixels,
              maxTextures: gameConfig.maxTextures,
              maxTextureSize: gameConfig.maxTextureSize,
              batchSize: gameConfig.batchSize,
              maxLights: gameConfig.maxLights,
              mipmapFilter: gameConfig.mipmapFilter
            };
            this.game = game;
            this.type = CONST.WEBGL;
            this.pipelines = null;
            this.width = 0;
            this.height = 0;
            this.canvas = game.canvas;
            this.blendModes = [];
            this.contextLost = false;
            this.snapshotState = {
              x: 0,
              y: 0,
              width: 1,
              height: 1,
              getPixel: false,
              callback: null,
              type: "image/png",
              encoder: 0.92,
              isFramebuffer: false,
              bufferWidth: 0,
              bufferHeight: 0
            };
            this.currentActiveTexture = 0;
            this.startActiveTexture = 0;
            this.maxTextures = 0;
            this.textureIndexes;
            this.tempTextures;
            this.textureZero;
            this.normalTexture;
            this.currentFramebuffer = null;
            this.fboStack = [];
            this.currentProgram = null;
            this.currentBlendMode = Infinity;
            this.currentScissorEnabled = false;
            this.currentScissor = null;
            this.scissorStack = [];
            this.contextLostHandler = NOOP;
            this.contextRestoredHandler = NOOP;
            this.gl = null;
            this.supportedExtensions = null;
            this.instancedArraysExtension = null;
            this.vaoExtension = null;
            this.extensions = {};
            this.glFormats = [];
            this.compression = {
              ETC1: false,
              PVRTC: false,
              S3TC: false
            };
            this.drawingBufferHeight = 0;
            this.blankTexture = null;
            this.whiteTexture = null;
            this.maskCount = 0;
            this.maskStack = [];
            this.currentMask = { mask: null, camera: null };
            this.currentCameraMask = { mask: null, camera: null };
            this.glFuncMap = null;
            this.currentType = "";
            this.newType = false;
            this.nextTypeMatch = false;
            this.finalType = false;
            this.mipmapFilter = null;
            this.textureFlush = 0;
            this.isTextureClean = false;
            this.defaultScissor = [0, 0, 0, 0];
            this.isBooted = false;
            this.renderTarget = null;
            this.projectionMatrix;
            this.projectionWidth = 0;
            this.projectionHeight = 0;
            this.init(this.config);
          },
          init: function(config) {
            var gl2;
            var game = this.game;
            var canvas = this.canvas;
            var clearColor = config.backgroundColor;
            if (game.config.context) {
              gl2 = game.config.context;
            } else {
              gl2 = canvas.getContext("webgl", config.contextCreation) || canvas.getContext("experimental-webgl", config.contextCreation);
            }
            if (!gl2 || gl2.isContextLost()) {
              this.contextLost = true;
              throw new Error("WebGL unsupported");
            }
            this.gl = gl2;
            var _this = this;
            this.contextLostHandler = function(event) {
              _this.contextLost = true;
              _this.game.events.emit(GameEvents.CONTEXT_LOST, _this);
              event.preventDefault();
            };
            this.contextRestoredHandler = function() {
              _this.contextLost = false;
              _this.init(_this.config);
              _this.game.events.emit(GameEvents.CONTEXT_RESTORED, _this);
            };
            canvas.addEventListener("webglcontextlost", this.contextLostHandler, false);
            canvas.addEventListener("webglcontextrestored", this.contextRestoredHandler, false);
            game.context = gl2;
            for (var i2 = 0; i2 <= 27; i2++) {
              this.blendModes.push({ func: [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], equation: gl2.FUNC_ADD });
            }
            this.blendModes[1].func = [gl2.ONE, gl2.DST_ALPHA];
            this.blendModes[2].func = [gl2.DST_COLOR, gl2.ONE_MINUS_SRC_ALPHA];
            this.blendModes[3].func = [gl2.ONE, gl2.ONE_MINUS_SRC_COLOR];
            this.blendModes[17] = { func: [gl2.ZERO, gl2.ONE_MINUS_SRC_ALPHA], equation: gl2.FUNC_REVERSE_SUBTRACT };
            this.glFormats[0] = gl2.BYTE;
            this.glFormats[1] = gl2.SHORT;
            this.glFormats[2] = gl2.UNSIGNED_BYTE;
            this.glFormats[3] = gl2.UNSIGNED_SHORT;
            this.glFormats[4] = gl2.FLOAT;
            this.glFuncMap = {
              mat2: { func: gl2.uniformMatrix2fv, length: 1, matrix: true },
              mat3: { func: gl2.uniformMatrix3fv, length: 1, matrix: true },
              mat4: { func: gl2.uniformMatrix4fv, length: 1, matrix: true },
              "1f": { func: gl2.uniform1f, length: 1 },
              "1fv": { func: gl2.uniform1fv, length: 1 },
              "1i": { func: gl2.uniform1i, length: 1 },
              "1iv": { func: gl2.uniform1iv, length: 1 },
              "2f": { func: gl2.uniform2f, length: 2 },
              "2fv": { func: gl2.uniform2fv, length: 1 },
              "2i": { func: gl2.uniform2i, length: 2 },
              "2iv": { func: gl2.uniform2iv, length: 1 },
              "3f": { func: gl2.uniform3f, length: 3 },
              "3fv": { func: gl2.uniform3fv, length: 1 },
              "3i": { func: gl2.uniform3i, length: 3 },
              "3iv": { func: gl2.uniform3iv, length: 1 },
              "4f": { func: gl2.uniform4f, length: 4 },
              "4fv": { func: gl2.uniform4fv, length: 1 },
              "4i": { func: gl2.uniform4i, length: 4 },
              "4iv": { func: gl2.uniform4iv, length: 1 }
            };
            var exts = gl2.getSupportedExtensions();
            if (!config.maxTextures || config.maxTextures === -1) {
              config.maxTextures = gl2.getParameter(gl2.MAX_TEXTURE_IMAGE_UNITS);
            }
            if (!config.maxTextureSize) {
              config.maxTextureSize = gl2.getParameter(gl2.MAX_TEXTURE_SIZE);
            }
            var extString = "WEBGL_compressed_texture_";
            var wkExtString = "WEBKIT_" + extString;
            this.compression.ETC1 = gl2.getExtension(extString + "etc1") || gl2.getExtension(wkExtString + "etc1");
            this.compression.PVRTC = gl2.getExtension(extString + "pvrtc") || gl2.getExtension(wkExtString + "pvrtc");
            this.compression.S3TC = gl2.getExtension(extString + "s3tc") || gl2.getExtension(wkExtString + "s3tc");
            this.supportedExtensions = exts;
            var angleString = "ANGLE_instanced_arrays";
            this.instancedArraysExtension = exts.indexOf(angleString) > -1 ? gl2.getExtension(angleString) : null;
            var vaoString = "OES_vertex_array_object";
            this.vaoExtension = exts.indexOf(vaoString) > -1 ? gl2.getExtension(vaoString) : null;
            gl2.disable(gl2.DEPTH_TEST);
            gl2.disable(gl2.CULL_FACE);
            gl2.enable(gl2.BLEND);
            gl2.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);
            this.mipmapFilter = gl2[config.mipmapFilter];
            this.maxTextures = Utils.checkShaderMax(gl2, config.maxTextures);
            this.textureIndexes = [];
            var tempTextures = this.tempTextures;
            if (Array.isArray(tempTextures)) {
              for (var t2 = 0; i2 < this.maxTextures; t2++) {
                gl2.deleteTexture(tempTextures[t2]);
              }
            } else {
              tempTextures = new Array(this.maxTextures);
            }
            for (var index2 = 0; index2 < this.maxTextures; index2++) {
              var tempTexture = gl2.createTexture();
              gl2.activeTexture(gl2.TEXTURE0 + index2);
              gl2.bindTexture(gl2.TEXTURE_2D, tempTexture);
              gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, 1, 1, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));
              tempTextures[index2] = tempTexture;
              this.textureIndexes.push(index2);
            }
            this.tempTextures = tempTextures;
            this.currentActiveTexture = 1;
            this.startActiveTexture++;
            gl2.activeTexture(gl2.TEXTURE1);
            this.pipelines = new PipelineManager(this);
            this.setBlendMode(CONST.BlendModes.NORMAL);
            this.projectionMatrix = new Matrix4().identity();
            game.textures.once(TextureEvents.READY, this.boot, this);
            return this;
          },
          boot: function() {
            var game = this.game;
            var pipelineManager = this.pipelines;
            var baseSize = game.scale.baseSize;
            this.width = baseSize.width;
            this.height = baseSize.height;
            this.isBooted = true;
            this.renderTarget = new RenderTarget(this, this.width, this.height, 1, 0, true, true);
            pipelineManager.boot(game.config.pipeline);
            this.blankTexture = game.textures.getFrame("__DEFAULT");
            this.whiteTexture = game.textures.getFrame("__WHITE");
            var gl2 = this.gl;
            gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
            gl2.enable(gl2.SCISSOR_TEST);
            game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
            this.resize(baseSize.width, baseSize.height);
          },
          onResize: function(gameSize, baseSize) {
            if (baseSize.width !== this.width || baseSize.height !== this.height) {
              this.resize(baseSize.width, baseSize.height);
            }
          },
          beginCapture: function(width, height) {
            if (width === void 0) {
              width = this.width;
            }
            if (height === void 0) {
              height = this.height;
            }
            this.renderTarget.bind(true, width, height);
            this.setProjectionMatrix(width, height);
            this.resetTextures();
          },
          endCapture: function() {
            this.renderTarget.unbind(true);
            this.resetProjectionMatrix();
            return this.renderTarget;
          },
          resize: function(width, height) {
            var gl2 = this.gl;
            this.width = width;
            this.height = height;
            this.setProjectionMatrix(width, height);
            gl2.viewport(0, 0, width, height);
            this.drawingBufferHeight = gl2.drawingBufferHeight;
            gl2.scissor(0, gl2.drawingBufferHeight - height, width, height);
            this.defaultScissor[2] = width;
            this.defaultScissor[3] = height;
            this.emit(Events.RESIZE, width, height);
            return this;
          },
          getAspectRatio: function() {
            return this.width / this.height;
          },
          setProjectionMatrix: function(width, height) {
            if (width !== this.projectionWidth || height !== this.projectionHeight) {
              this.projectionWidth = width;
              this.projectionHeight = height;
              this.projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);
            }
            return this;
          },
          resetProjectionMatrix: function() {
            this.projectionWidth = this.width;
            this.projectionHeight = this.height;
            this.projectionMatrix.ortho(0, this.width, this.height, 0, -1e3, 1e3);
          },
          hasExtension: function(extensionName) {
            return this.supportedExtensions ? this.supportedExtensions.indexOf(extensionName) : false;
          },
          getExtension: function(extensionName) {
            if (!this.hasExtension(extensionName)) {
              return null;
            }
            if (!(extensionName in this.extensions)) {
              this.extensions[extensionName] = this.gl.getExtension(extensionName);
            }
            return this.extensions[extensionName];
          },
          flush: function() {
            this.pipelines.flush();
          },
          pushScissor: function(x2, y2, width, height, drawingBufferHeight) {
            if (drawingBufferHeight === void 0) {
              drawingBufferHeight = this.drawingBufferHeight;
            }
            var scissorStack = this.scissorStack;
            var scissor = [x2, y2, width, height];
            scissorStack.push(scissor);
            this.setScissor(x2, y2, width, height, drawingBufferHeight);
            this.currentScissor = scissor;
            return scissor;
          },
          setScissor: function(x2, y2, width, height, drawingBufferHeight) {
            if (drawingBufferHeight === void 0) {
              drawingBufferHeight = this.drawingBufferHeight;
            }
            var gl2 = this.gl;
            var current = this.currentScissor;
            var setScissor = width > 0 && height > 0;
            if (current && setScissor) {
              var cx = current[0];
              var cy = current[1];
              var cw = current[2];
              var ch2 = current[3];
              setScissor = cx !== x2 || cy !== y2 || cw !== width || ch2 !== height;
            }
            if (setScissor) {
              this.flush();
              gl2.scissor(x2, drawingBufferHeight - y2 - height, width, height);
            }
          },
          resetScissor: function() {
            var gl2 = this.gl;
            gl2.enable(gl2.SCISSOR_TEST);
            var current = this.currentScissor;
            if (current) {
              var x2 = current[0];
              var y2 = current[1];
              var width = current[2];
              var height = current[3];
              if (width > 0 && height > 0) {
                gl2.scissor(x2, this.drawingBufferHeight - y2 - height, width, height);
              }
            }
          },
          popScissor: function() {
            var scissorStack = this.scissorStack;
            scissorStack.pop();
            var scissor = scissorStack[scissorStack.length - 1];
            if (scissor) {
              this.setScissor(scissor[0], scissor[1], scissor[2], scissor[3]);
            }
            this.currentScissor = scissor;
          },
          hasActiveStencilMask: function() {
            var mask = this.currentMask.mask;
            var camMask = this.currentCameraMask.mask;
            return mask && mask.isStencil || camMask && camMask.isStencil;
          },
          resetViewport: function() {
            var gl2 = this.gl;
            gl2.viewport(0, 0, this.width, this.height);
            this.drawingBufferHeight = gl2.drawingBufferHeight;
          },
          setBlendMode: function(blendModeId, force) {
            if (force === void 0) {
              force = false;
            }
            var gl2 = this.gl;
            var blendMode = this.blendModes[blendModeId];
            if (force || blendModeId !== CONST.BlendModes.SKIP_CHECK && this.currentBlendMode !== blendModeId) {
              this.flush();
              gl2.enable(gl2.BLEND);
              gl2.blendEquation(blendMode.equation);
              if (blendMode.func.length > 2) {
                gl2.blendFuncSeparate(blendMode.func[0], blendMode.func[1], blendMode.func[2], blendMode.func[3]);
              } else {
                gl2.blendFunc(blendMode.func[0], blendMode.func[1]);
              }
              this.currentBlendMode = blendModeId;
              return true;
            }
            return false;
          },
          addBlendMode: function(func, equation) {
            var index2 = this.blendModes.push({ func, equation });
            return index2 - 1;
          },
          updateBlendMode: function(index2, func, equation) {
            if (this.blendModes[index2]) {
              this.blendModes[index2].func = func;
              if (equation) {
                this.blendModes[index2].equation = equation;
              }
            }
            return this;
          },
          removeBlendMode: function(index2) {
            if (index2 > 17 && this.blendModes[index2]) {
              this.blendModes.splice(index2, 1);
            }
            return this;
          },
          setBlankTexture: function() {
            this.setTexture2D(this.blankTexture.glTexture);
          },
          setTextureSource: function(textureSource) {
            if (this.pipelines.forceZero()) {
              this.setTextureZero(textureSource.glTexture, true);
              return 0;
            }
            var gl2 = this.gl;
            var currentActiveTexture = this.currentActiveTexture;
            if (textureSource.glIndexCounter < this.startActiveTexture) {
              textureSource.glIndexCounter = this.startActiveTexture;
              if (currentActiveTexture < this.maxTextures) {
                textureSource.glIndex = currentActiveTexture;
                gl2.activeTexture(gl2.TEXTURE0 + currentActiveTexture);
                gl2.bindTexture(gl2.TEXTURE_2D, textureSource.glTexture);
                this.currentActiveTexture++;
              } else {
                this.flush();
                this.startActiveTexture++;
                this.textureFlush++;
                textureSource.glIndexCounter = this.startActiveTexture;
                textureSource.glIndex = 1;
                gl2.activeTexture(gl2.TEXTURE1);
                gl2.bindTexture(gl2.TEXTURE_2D, textureSource.glTexture);
                this.currentActiveTexture = 2;
              }
            }
            this.isTextureClean = false;
            return textureSource.glIndex;
          },
          isNewNormalMap: function(texture, normalMap) {
            return this.textureZero !== texture || this.normalTexture !== normalMap;
          },
          setTextureZero: function(texture, flush) {
            if (this.textureZero !== texture) {
              if (flush) {
                this.flush();
              }
              var gl2 = this.gl;
              gl2.activeTexture(gl2.TEXTURE0);
              gl2.bindTexture(gl2.TEXTURE_2D, texture);
              this.textureZero = texture;
            }
          },
          clearTextureZero: function() {
            this.textureZero = null;
          },
          setNormalMap: function(texture) {
            if (this.normalTexture !== texture) {
              var gl2 = this.gl;
              gl2.activeTexture(gl2.TEXTURE1);
              gl2.bindTexture(gl2.TEXTURE_2D, texture);
              this.normalTexture = texture;
              if (this.currentActiveTexture === 1) {
                this.currentActiveTexture = 2;
              }
            }
          },
          clearNormalMap: function() {
            this.normalTexture = null;
            this.startActiveTexture++;
            this.currentActiveTexture = 1;
            this.textureFlush++;
          },
          unbindTextures: function() {
            var gl2 = this.gl;
            var temp = this.tempTextures;
            for (var i2 = 0; i2 < temp.length; i2++) {
              gl2.activeTexture(gl2.TEXTURE0 + i2);
              gl2.bindTexture(gl2.TEXTURE_2D, null);
            }
            this.normalTexture = null;
            this.textureZero = null;
            this.currentActiveTexture = 1;
            this.startActiveTexture++;
            this.textureFlush++;
          },
          resetTextures: function(all) {
            if (all === void 0) {
              all = false;
            }
            if (this.isTextureClean) {
              return;
            }
            this.flush();
            var gl2 = this.gl;
            var temp = this.tempTextures;
            if (all) {
              for (var i2 = 0; i2 < temp.length; i2++) {
                gl2.activeTexture(gl2.TEXTURE0 + i2);
                gl2.bindTexture(gl2.TEXTURE_2D, temp[i2]);
              }
              gl2.activeTexture(gl2.TEXTURE1);
              gl2.bindTexture(gl2.TEXTURE_2D, temp[1]);
              this.isTextureClean = true;
            } else {
              gl2.activeTexture(gl2.TEXTURE0);
              gl2.bindTexture(gl2.TEXTURE_2D, temp[0]);
              gl2.activeTexture(gl2.TEXTURE1);
              gl2.bindTexture(gl2.TEXTURE_2D, temp[1]);
            }
            this.normalTexture = null;
            this.textureZero = null;
            this.currentActiveTexture = 1;
            this.startActiveTexture++;
            this.textureFlush++;
          },
          setTexture2D: function(texture) {
            if (this.pipelines.forceZero()) {
              this.setTextureZero(texture, true);
              return 0;
            }
            var gl2 = this.gl;
            var currentActiveTexture = this.currentActiveTexture;
            if (texture.glIndexCounter < this.startActiveTexture) {
              texture.glIndexCounter = this.startActiveTexture;
              if (currentActiveTexture < this.maxTextures) {
                texture.glIndex = currentActiveTexture;
                gl2.activeTexture(gl2.TEXTURE0 + currentActiveTexture);
                gl2.bindTexture(gl2.TEXTURE_2D, texture);
                this.currentActiveTexture++;
              } else {
                this.flush();
                this.startActiveTexture++;
                this.textureFlush++;
                texture.glIndexCounter = this.startActiveTexture;
                texture.glIndex = 1;
                gl2.activeTexture(gl2.TEXTURE1);
                gl2.bindTexture(gl2.TEXTURE_2D, texture);
                this.currentActiveTexture = 2;
              }
            }
            this.isTextureClean = false;
            return texture.glIndex;
          },
          pushFramebuffer: function(framebuffer, updateScissor, resetTextures, setViewport) {
            if (framebuffer === this.currentFramebuffer) {
              return this;
            }
            this.fboStack.push(framebuffer);
            return this.setFramebuffer(framebuffer, updateScissor, resetTextures, setViewport);
          },
          setFramebuffer: function(framebuffer, updateScissor, resetTextures, setViewport) {
            if (updateScissor === void 0) {
              updateScissor = false;
            }
            if (resetTextures === void 0) {
              resetTextures = false;
            }
            if (setViewport === void 0) {
              setViewport = true;
            }
            if (framebuffer === this.currentFramebuffer) {
              return this;
            }
            var gl2 = this.gl;
            var width = this.width;
            var height = this.height;
            if (framebuffer && framebuffer.renderTexture && setViewport) {
              width = framebuffer.renderTexture.width;
              height = framebuffer.renderTexture.height;
            } else {
              this.flush();
            }
            gl2.bindFramebuffer(gl2.FRAMEBUFFER, framebuffer);
            if (setViewport) {
              gl2.viewport(0, 0, width, height);
            }
            if (updateScissor) {
              if (framebuffer) {
                this.drawingBufferHeight = height;
                this.pushScissor(0, 0, width, height);
              } else {
                this.drawingBufferHeight = this.height;
                this.popScissor();
              }
            }
            this.currentFramebuffer = framebuffer;
            if (resetTextures) {
              this.resetTextures();
            }
            return this;
          },
          popFramebuffer: function(updateScissor, resetTextures, setViewport) {
            if (updateScissor === void 0) {
              updateScissor = false;
            }
            if (resetTextures === void 0) {
              resetTextures = false;
            }
            if (setViewport === void 0) {
              setViewport = true;
            }
            var fboStack = this.fboStack;
            fboStack.pop();
            var framebuffer = fboStack[fboStack.length - 1];
            if (!framebuffer) {
              framebuffer = null;
            }
            this.setFramebuffer(framebuffer, updateScissor, resetTextures, setViewport);
            return framebuffer;
          },
          setProgram: function(program) {
            if (program !== this.currentProgram) {
              this.flush();
              this.gl.useProgram(program);
              this.currentProgram = program;
              return true;
            }
            return false;
          },
          resetProgram: function() {
            this.gl.useProgram(this.currentProgram);
            return this;
          },
          createTextureFromSource: function(source, width, height, scaleMode) {
            var gl2 = this.gl;
            var minFilter = gl2.NEAREST;
            var magFilter = gl2.NEAREST;
            var wrap = gl2.CLAMP_TO_EDGE;
            var texture = null;
            width = source ? source.width : width;
            height = source ? source.height : height;
            var pow = IsSizePowerOfTwo(width, height);
            if (pow) {
              wrap = gl2.REPEAT;
            }
            if (scaleMode === CONST.ScaleModes.LINEAR && this.config.antialias) {
              minFilter = pow ? this.mipmapFilter : gl2.LINEAR;
              magFilter = gl2.LINEAR;
            }
            if (!source && typeof width === "number" && typeof height === "number") {
              texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl2.RGBA, null, width, height);
            } else {
              texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl2.RGBA, source);
            }
            return texture;
          },
          createTexture2D: function(mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma, forceSize, flipY) {
            pma = pma === void 0 || pma === null ? true : pma;
            if (forceSize === void 0) {
              forceSize = false;
            }
            if (flipY === void 0) {
              flipY = false;
            }
            var gl2 = this.gl;
            var texture = gl2.createTexture();
            gl2.activeTexture(gl2.TEXTURE0);
            var currentTexture = gl2.getParameter(gl2.TEXTURE_BINDING_2D);
            gl2.bindTexture(gl2.TEXTURE_2D, texture);
            gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, minFilter);
            gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, magFilter);
            gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, wrapS);
            gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, wrapT);
            gl2.pixelStorei(gl2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, pma);
            gl2.pixelStorei(gl2.UNPACK_FLIP_Y_WEBGL, flipY);
            if (pixels === null || pixels === void 0) {
              gl2.texImage2D(gl2.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl2.UNSIGNED_BYTE, null);
            } else {
              if (!forceSize) {
                width = pixels.width;
                height = pixels.height;
              }
              gl2.texImage2D(gl2.TEXTURE_2D, mipLevel, format, format, gl2.UNSIGNED_BYTE, pixels);
            }
            if (IsSizePowerOfTwo(width, height)) {
              gl2.generateMipmap(gl2.TEXTURE_2D);
            }
            if (currentTexture) {
              gl2.bindTexture(gl2.TEXTURE_2D, currentTexture);
            }
            texture.isAlphaPremultiplied = pma;
            texture.isRenderTexture = false;
            texture.width = width;
            texture.height = height;
            texture.glIndex = 0;
            texture.glIndexCounter = -1;
            return texture;
          },
          createFramebuffer: function(width, height, renderTexture, addDepthStencilBuffer) {
            var gl2 = this.gl;
            var framebuffer = gl2.createFramebuffer();
            var complete = 0;
            this.setFramebuffer(framebuffer);
            if (addDepthStencilBuffer) {
              var depthStencilBuffer = gl2.createRenderbuffer();
              gl2.bindRenderbuffer(gl2.RENDERBUFFER, depthStencilBuffer);
              gl2.renderbufferStorage(gl2.RENDERBUFFER, gl2.DEPTH_STENCIL, width, height);
              gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, gl2.DEPTH_STENCIL_ATTACHMENT, gl2.RENDERBUFFER, depthStencilBuffer);
            }
            renderTexture.isRenderTexture = true;
            renderTexture.isAlphaPremultiplied = false;
            gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, renderTexture, 0);
            complete = gl2.checkFramebufferStatus(gl2.FRAMEBUFFER);
            if (complete !== gl2.FRAMEBUFFER_COMPLETE) {
              var errors = {
                36054: "Incomplete Attachment",
                36055: "Missing Attachment",
                36057: "Incomplete Dimensions",
                36061: "Framebuffer Unsupported"
              };
              throw new Error("Framebuffer status: " + errors[complete]);
            }
            framebuffer.renderTexture = renderTexture;
            this.setFramebuffer(null);
            this.resetTextures();
            return framebuffer;
          },
          createProgram: function(vertexShader, fragmentShader) {
            var gl2 = this.gl;
            var program = gl2.createProgram();
            var vs = gl2.createShader(gl2.VERTEX_SHADER);
            var fs = gl2.createShader(gl2.FRAGMENT_SHADER);
            gl2.shaderSource(vs, vertexShader);
            gl2.shaderSource(fs, fragmentShader);
            gl2.compileShader(vs);
            gl2.compileShader(fs);
            if (!gl2.getShaderParameter(vs, gl2.COMPILE_STATUS)) {
              throw new Error("Vertex Shader failed:\n" + gl2.getShaderInfoLog(vs));
            }
            if (!gl2.getShaderParameter(fs, gl2.COMPILE_STATUS)) {
              throw new Error("Fragment Shader failed:\n" + gl2.getShaderInfoLog(fs));
            }
            gl2.attachShader(program, vs);
            gl2.attachShader(program, fs);
            gl2.linkProgram(program);
            if (!gl2.getProgramParameter(program, gl2.LINK_STATUS)) {
              throw new Error("Link Program failed:\n" + gl2.getProgramInfoLog(program));
            }
            gl2.useProgram(program);
            return program;
          },
          createVertexBuffer: function(initialDataOrSize, bufferUsage) {
            var gl2 = this.gl;
            var vertexBuffer = gl2.createBuffer();
            gl2.bindBuffer(gl2.ARRAY_BUFFER, vertexBuffer);
            gl2.bufferData(gl2.ARRAY_BUFFER, initialDataOrSize, bufferUsage);
            gl2.bindBuffer(gl2.ARRAY_BUFFER, null);
            return vertexBuffer;
          },
          createIndexBuffer: function(initialDataOrSize, bufferUsage) {
            var gl2 = this.gl;
            var indexBuffer = gl2.createBuffer();
            gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl2.bufferData(gl2.ELEMENT_ARRAY_BUFFER, initialDataOrSize, bufferUsage);
            gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, null);
            return indexBuffer;
          },
          deleteTexture: function(texture, reset) {
            if (reset) {
              this.resetTextures(true);
            }
            if (texture) {
              this.gl.deleteTexture(texture);
            }
            return this;
          },
          deleteFramebuffer: function(framebuffer) {
            if (framebuffer) {
              this.gl.deleteFramebuffer(framebuffer);
              ArrayRemove(this.fboStack, framebuffer);
              if (this.currentFramebuffer === framebuffer) {
                this.currentFramebuffer = null;
              }
            }
            return this;
          },
          deleteProgram: function(program) {
            if (program) {
              this.gl.deleteProgram(program);
            }
            return this;
          },
          deleteBuffer: function(buffer) {
            this.gl.deleteBuffer(buffer);
            return this;
          },
          preRenderCamera: function(camera) {
            var cx = camera.x;
            var cy = camera.y;
            var cw = camera.width;
            var ch2 = camera.height;
            var color = camera.backgroundColor;
            camera.emit(CameraEvents.PRE_RENDER, camera);
            this.pipelines.preBatchCamera(camera);
            this.pushScissor(cx, cy, cw, ch2);
            if (camera.mask) {
              this.currentCameraMask.mask = camera.mask;
              this.currentCameraMask.camera = camera._maskCamera;
              camera.mask.preRenderWebGL(this, camera, camera._maskCamera);
            }
            if (color.alphaGL > 0) {
              var pipeline = this.pipelines.setMulti();
              pipeline.drawFillRect(cx, cy, cw, ch2, Utils.getTintFromFloats(color.blueGL, color.greenGL, color.redGL, 1), color.alphaGL);
            }
          },
          getCurrentStencilMask: function() {
            var prev = null;
            var stack = this.maskStack;
            var cameraMask = this.currentCameraMask;
            if (stack.length > 0) {
              prev = stack[stack.length - 1];
            } else if (cameraMask.mask && cameraMask.mask.isStencil) {
              prev = cameraMask;
            }
            return prev;
          },
          postRenderCamera: function(camera) {
            var flashEffect = camera.flashEffect;
            var fadeEffect = camera.fadeEffect;
            if (flashEffect.isRunning || (fadeEffect.isRunning || fadeEffect.isComplete)) {
              var pipeline = this.pipelines.setMulti();
              flashEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);
              fadeEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);
            }
            camera.dirty = false;
            this.popScissor();
            if (camera.mask) {
              this.currentCameraMask.mask = null;
              camera.mask.postRenderWebGL(this, camera._maskCamera);
            }
            this.pipelines.postBatchCamera(camera);
            camera.emit(CameraEvents.POST_RENDER, camera);
          },
          preRender: function() {
            if (this.contextLost) {
              return;
            }
            var gl2 = this.gl;
            gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
            if (this.config.clearBeforeRender) {
              var clearColor = this.config.backgroundColor;
              gl2.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);
              gl2.clear(gl2.COLOR_BUFFER_BIT | gl2.DEPTH_BUFFER_BIT | gl2.STENCIL_BUFFER_BIT);
            }
            gl2.enable(gl2.SCISSOR_TEST);
            this.currentScissor = this.defaultScissor;
            this.scissorStack.length = 0;
            this.scissorStack.push(this.currentScissor);
            if (this.game.scene.customViewports) {
              gl2.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height);
            }
            this.currentMask.mask = null;
            this.currentCameraMask.mask = null;
            this.maskStack.length = 0;
            this.textureFlush = 0;
            this.emit(Events.PRE_RENDER);
          },
          render: function(scene, children, camera) {
            if (this.contextLost) {
              return;
            }
            var childCount = children.length;
            this.emit(Events.RENDER, scene, camera);
            this.preRenderCamera(camera);
            if (childCount === 0) {
              this.setBlendMode(CONST.BlendModes.NORMAL);
              this.postRenderCamera(camera);
              return;
            }
            this.currentType = "";
            var current = this.currentMask;
            for (var i2 = 0; i2 < childCount; i2++) {
              this.finalType = i2 === childCount - 1;
              var child = children[i2];
              var mask = child.mask;
              current = this.currentMask;
              if (current.mask && current.mask !== mask) {
                current.mask.postRenderWebGL(this, current.camera);
              }
              if (mask && current.mask !== mask) {
                mask.preRenderWebGL(this, child, camera);
              }
              if (child.blendMode !== this.currentBlendMode) {
                this.setBlendMode(child.blendMode);
              }
              var type = child.type;
              if (type !== this.currentType) {
                this.newType = true;
                this.currentType = type;
              }
              if (!this.finalType) {
                this.nextTypeMatch = children[i2 + 1].type === this.currentType;
              } else {
                this.nextTypeMatch = false;
              }
              child.renderWebGL(this, child, camera);
              this.newType = false;
            }
            current = this.currentMask;
            if (current.mask) {
              current.mask.postRenderWebGL(this, current.camera);
            }
            this.setBlendMode(CONST.BlendModes.NORMAL);
            this.postRenderCamera(camera);
          },
          postRender: function() {
            if (this.contextLost) {
              return;
            }
            this.flush();
            this.emit(Events.POST_RENDER);
            var state = this.snapshotState;
            if (state.callback) {
              WebGLSnapshot(this.canvas, state);
              state.callback = null;
            }
            if (this.textureFlush > 0) {
              this.startActiveTexture++;
              this.currentActiveTexture = 1;
            }
          },
          snapshot: function(callback, type, encoderOptions) {
            return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, callback, type, encoderOptions);
          },
          snapshotArea: function(x2, y2, width, height, callback, type, encoderOptions) {
            var state = this.snapshotState;
            state.callback = callback;
            state.type = type;
            state.encoder = encoderOptions;
            state.getPixel = false;
            state.x = x2;
            state.y = y2;
            state.width = Math.min(width, this.gl.drawingBufferWidth);
            state.height = Math.min(height, this.gl.drawingBufferHeight);
            return this;
          },
          snapshotPixel: function(x2, y2, callback) {
            this.snapshotArea(x2, y2, 1, 1, callback);
            this.snapshotState.getPixel = true;
            return this;
          },
          snapshotFramebuffer: function(framebuffer, bufferWidth, bufferHeight, callback, getPixel, x2, y2, width, height, type, encoderOptions) {
            if (getPixel === void 0) {
              getPixel = false;
            }
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = bufferWidth;
            }
            if (height === void 0) {
              height = bufferHeight;
            }
            var currentFramebuffer = this.currentFramebuffer;
            this.snapshotArea(x2, y2, width, height, callback, type, encoderOptions);
            var state = this.snapshotState;
            state.getPixel = getPixel;
            state.isFramebuffer = true;
            state.bufferWidth = bufferWidth;
            state.bufferHeight = bufferHeight;
            this.setFramebuffer(framebuffer);
            WebGLSnapshot(this.canvas, state);
            this.setFramebuffer(currentFramebuffer);
            state.callback = null;
            state.isFramebuffer = false;
            return this;
          },
          canvasToTexture: function(srcCanvas, dstTexture, noRepeat, flipY) {
            if (noRepeat === void 0) {
              noRepeat = false;
            }
            if (flipY === void 0) {
              flipY = false;
            }
            if (!dstTexture) {
              return this.createCanvasTexture(srcCanvas, noRepeat, flipY);
            } else {
              return this.updateCanvasTexture(srcCanvas, dstTexture, flipY);
            }
          },
          createCanvasTexture: function(srcCanvas, noRepeat, flipY) {
            if (noRepeat === void 0) {
              noRepeat = false;
            }
            if (flipY === void 0) {
              flipY = false;
            }
            var gl2 = this.gl;
            var minFilter = gl2.NEAREST;
            var magFilter = gl2.NEAREST;
            var width = srcCanvas.width;
            var height = srcCanvas.height;
            var wrapping = gl2.CLAMP_TO_EDGE;
            var pow = IsSizePowerOfTwo(width, height);
            if (!noRepeat && pow) {
              wrapping = gl2.REPEAT;
            }
            if (this.config.antialias) {
              minFilter = pow ? this.mipmapFilter : gl2.LINEAR;
              magFilter = gl2.LINEAR;
            }
            return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl2.RGBA, srcCanvas, width, height, true, false, flipY);
          },
          updateCanvasTexture: function(srcCanvas, dstTexture, flipY) {
            if (flipY === void 0) {
              flipY = false;
            }
            var gl2 = this.gl;
            var width = srcCanvas.width;
            var height = srcCanvas.height;
            if (width > 0 && height > 0) {
              gl2.activeTexture(gl2.TEXTURE0);
              var currentTexture = gl2.getParameter(gl2.TEXTURE_BINDING_2D);
              gl2.bindTexture(gl2.TEXTURE_2D, dstTexture);
              gl2.pixelStorei(gl2.UNPACK_FLIP_Y_WEBGL, flipY);
              gl2.pixelStorei(gl2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
              gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, gl2.RGBA, gl2.UNSIGNED_BYTE, srcCanvas);
              dstTexture.width = width;
              dstTexture.height = height;
              if (currentTexture) {
                gl2.bindTexture(gl2.TEXTURE_2D, currentTexture);
              }
            }
            return dstTexture;
          },
          createVideoTexture: function(srcVideo, noRepeat, flipY) {
            if (noRepeat === void 0) {
              noRepeat = false;
            }
            if (flipY === void 0) {
              flipY = false;
            }
            var gl2 = this.gl;
            var minFilter = gl2.NEAREST;
            var magFilter = gl2.NEAREST;
            var width = srcVideo.videoWidth;
            var height = srcVideo.videoHeight;
            var wrapping = gl2.CLAMP_TO_EDGE;
            var pow = IsSizePowerOfTwo(width, height);
            if (!noRepeat && pow) {
              wrapping = gl2.REPEAT;
            }
            if (this.config.antialias) {
              minFilter = pow ? this.mipmapFilter : gl2.LINEAR;
              magFilter = gl2.LINEAR;
            }
            return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl2.RGBA, srcVideo, width, height, true, true, flipY);
          },
          updateVideoTexture: function(srcVideo, dstTexture, flipY) {
            if (flipY === void 0) {
              flipY = false;
            }
            var gl2 = this.gl;
            var width = srcVideo.videoWidth;
            var height = srcVideo.videoHeight;
            if (width > 0 && height > 0) {
              gl2.activeTexture(gl2.TEXTURE0);
              var currentTexture = gl2.getParameter(gl2.TEXTURE_BINDING_2D);
              gl2.bindTexture(gl2.TEXTURE_2D, dstTexture);
              gl2.pixelStorei(gl2.UNPACK_FLIP_Y_WEBGL, flipY);
              gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, gl2.RGBA, gl2.UNSIGNED_BYTE, srcVideo);
              dstTexture.width = width;
              dstTexture.height = height;
              if (currentTexture) {
                gl2.bindTexture(gl2.TEXTURE_2D, currentTexture);
              }
            }
            return dstTexture;
          },
          setTextureFilter: function(texture, filter) {
            var gl2 = this.gl;
            var glFilter = [gl2.LINEAR, gl2.NEAREST][filter];
            gl2.activeTexture(gl2.TEXTURE0);
            var currentTexture = gl2.getParameter(gl2.TEXTURE_BINDING_2D);
            gl2.bindTexture(gl2.TEXTURE_2D, texture);
            gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, glFilter);
            gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, glFilter);
            if (currentTexture) {
              gl2.bindTexture(gl2.TEXTURE_2D, currentTexture);
            }
            return this;
          },
          getMaxTextureSize: function() {
            return this.config.maxTextureSize;
          },
          destroy: function() {
            this.canvas.removeEventListener("webglcontextlost", this.contextLostHandler, false);
            this.canvas.removeEventListener("webglcontextrestored", this.contextRestoredHandler, false);
            var gl2 = this.gl;
            var temp = this.tempTextures;
            for (var i2 = 0; i2 < temp.length; i2++) {
              gl2.deleteTexture(temp[i2]);
            }
            this.pipelines.destroy();
            this.removeAllListeners();
            this.fboStack = [];
            this.maskStack = [];
            this.extensions = {};
            this.textureIndexes = [];
            this.gl = null;
            this.game = null;
            this.canvas = null;
            this.contextLost = true;
            this.currentMask = null;
            this.currentCameraMask = null;
          }
        });
        module2.exports = WebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(92);
        var CustomMap = __webpack_require__(102);
        var BitmapMaskPipeline = __webpack_require__(373);
        var GraphicsPipeline = __webpack_require__(376);
        var LightPipeline = __webpack_require__(377);
        var MultiPipeline = __webpack_require__(108);
        var PointLightPipeline = __webpack_require__(378);
        var RopePipeline = __webpack_require__(379);
        var SinglePipeline = __webpack_require__(380);
        var UtilityPipeline = __webpack_require__(381);
        var PipelineManager = new Class({
          initialize: function PipelineManager2(renderer) {
            this.game = renderer.game;
            this.renderer = renderer;
            this.classes = new CustomMap([
              [CONST.UTILITY_PIPELINE, UtilityPipeline],
              [CONST.MULTI_PIPELINE, MultiPipeline],
              [CONST.BITMAPMASK_PIPELINE, BitmapMaskPipeline],
              [CONST.SINGLE_PIPELINE, SinglePipeline],
              [CONST.ROPE_PIPELINE, RopePipeline],
              [CONST.LIGHT_PIPELINE, LightPipeline],
              [CONST.POINTLIGHT_PIPELINE, PointLightPipeline],
              [CONST.GRAPHICS_PIPELINE, GraphicsPipeline]
            ]);
            this.postPipelineClasses = new CustomMap();
            this.pipelines = new CustomMap();
            this.current = null;
            this.previous = null;
            this.MULTI_PIPELINE = null;
            this.BITMAPMASK_PIPELINE = null;
            this.UTILITY_PIPELINE = null;
            this.fullFrame1;
            this.fullFrame2;
            this.halfFrame1;
            this.halfFrame2;
          },
          boot: function(pipelineConfig) {
            var instance;
            var pipelineName;
            var _this = this;
            var game = this.game;
            this.classes.each(function(pipelineName2, pipeline) {
              instance = _this.add(pipelineName2, new pipeline({ game }));
              if (pipelineName2 === CONST.UTILITY_PIPELINE) {
                _this.UTILITY_PIPELINE = instance;
                _this.fullFrame1 = instance.fullFrame1;
                _this.fullFrame2 = instance.fullFrame2;
                _this.halfFrame1 = instance.halfFrame1;
                _this.halfFrame2 = instance.halfFrame2;
              }
            });
            this.MULTI_PIPELINE = this.get(CONST.MULTI_PIPELINE);
            this.BITMAPMASK_PIPELINE = this.get(CONST.BITMAPMASK_PIPELINE);
            if (pipelineConfig) {
              for (pipelineName in pipelineConfig) {
                var pipelineClass = pipelineConfig[pipelineName];
                instance = new pipelineClass(game);
                if (instance.isPostFX) {
                  this.postPipelineClasses.set(pipelineName, pipelineClass);
                } else if (!this.has(pipelineName)) {
                  this.classes.set(pipelineName, pipelineClass);
                  this.add(pipelineName, instance);
                }
              }
            }
          },
          add: function(name, pipeline) {
            if (pipeline.isPostFX) {
              console.warn(name + " is a Post Pipeline. Use `addPostPipeline` instead");
              return;
            }
            var pipelines = this.pipelines;
            var renderer = this.renderer;
            if (!pipelines.has(name)) {
              pipeline.name = name;
              pipeline.manager = this;
              pipelines.set(name, pipeline);
            } else {
              console.warn("Pipeline exists: " + name);
            }
            if (!pipeline.hasBooted) {
              pipeline.boot();
            }
            if (renderer.width !== 0 && renderer.height !== 0) {
              pipeline.resize(renderer.width, renderer.height);
            }
            return pipeline;
          },
          addPostPipeline: function(name, pipeline) {
            if (!this.postPipelineClasses.has(name)) {
              this.postPipelineClasses.set(name, pipeline);
            }
          },
          flush: function() {
            if (this.current) {
              this.current.flush();
            }
          },
          has: function(pipeline) {
            var pipelines = this.pipelines;
            if (typeof pipeline === "string") {
              return pipelines.has(pipeline);
            } else if (pipelines.contains(pipeline)) {
              return true;
            }
            return false;
          },
          get: function(pipeline) {
            var pipelines = this.pipelines;
            if (typeof pipeline === "string") {
              return pipelines.get(pipeline);
            } else if (pipelines.contains(pipeline)) {
              return pipeline;
            }
          },
          getPostPipeline: function(pipeline, gameObject) {
            var pipelineClasses = this.postPipelineClasses;
            var instance;
            if (typeof pipeline === "string") {
              instance = pipelineClasses.get(pipeline);
            } else if (typeof pipeline === "function") {
              if (pipelineClasses.contains(pipeline)) {
                instance = pipeline;
              }
            } else if (typeof pipeline === "object") {
              instance = pipelineClasses.get(pipeline.name);
            }
            if (instance) {
              var newPipeline = new instance(this.game);
              if (gameObject) {
                newPipeline.gameObject = gameObject;
              }
              return newPipeline;
            }
          },
          remove: function(name, removeClass, removePostPipelineClass) {
            if (removeClass === void 0) {
              removeClass = true;
            }
            if (removePostPipelineClass === void 0) {
              removePostPipelineClass = true;
            }
            this.pipelines.delete(name);
            if (removeClass) {
              this.classes.delete(name);
            }
            if (removePostPipelineClass) {
              this.postPipelineClasses.delete(name);
            }
          },
          set: function(pipeline, gameObject, currentShader) {
            if (pipeline.isPostFX) {
              return;
            }
            if (!this.isCurrent(pipeline, currentShader)) {
              this.flush();
              if (this.current) {
                this.current.unbind();
              }
              this.current = pipeline;
              pipeline.bind(currentShader);
            }
            pipeline.updateProjectionMatrix();
            pipeline.onBind(gameObject);
            return pipeline;
          },
          preBatch: function(gameObject) {
            if (gameObject.hasPostPipeline) {
              this.flush();
              var pipelines = gameObject.postPipelines;
              for (var i2 = pipelines.length - 1; i2 >= 0; i2--) {
                var pipeline = pipelines[i2];
                if (pipeline.active) {
                  pipeline.preBatch(gameObject);
                }
              }
            }
          },
          postBatch: function(gameObject) {
            if (gameObject.hasPostPipeline) {
              this.flush();
              var pipelines = gameObject.postPipelines;
              for (var i2 = 0; i2 < pipelines.length; i2++) {
                var pipeline = pipelines[i2];
                if (pipeline.active) {
                  pipeline.postBatch(gameObject);
                }
              }
            }
          },
          preBatchCamera: function(camera) {
            if (camera.hasPostPipeline) {
              this.flush();
              var pipelines = camera.postPipelines;
              for (var i2 = pipelines.length - 1; i2 >= 0; i2--) {
                var pipeline = pipelines[i2];
                if (pipeline.active) {
                  pipeline.preBatch(camera);
                }
              }
            }
          },
          postBatchCamera: function(camera) {
            if (camera.hasPostPipeline) {
              this.flush();
              var pipelines = camera.postPipelines;
              for (var i2 = 0; i2 < pipelines.length; i2++) {
                var pipeline = pipelines[i2];
                if (pipeline.active) {
                  pipeline.postBatch(camera);
                }
              }
            }
          },
          isCurrent: function(pipeline, currentShader) {
            var renderer = this.renderer;
            var current = this.current;
            if (current && !currentShader) {
              currentShader = current.currentShader;
            }
            return !(current !== pipeline || currentShader.program !== renderer.currentProgram);
          },
          copyFrame: function(source, target, brightness, clear, clearAlpha) {
            this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(source, target, brightness, clear, clearAlpha);
            return this;
          },
          copyToGame: function(source) {
            this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(source);
            return this;
          },
          drawFrame: function(source, target, clearAlpha, colorMatrix) {
            this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(source, target, clearAlpha, colorMatrix);
            return this;
          },
          blendFrames: function(source1, source2, target, strength, clearAlpha) {
            this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(source1, source2, target, strength, clearAlpha);
            return this;
          },
          blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
            this.setUtility(this.UTILITY_PIPELINE.addShader).blendFramesAdditive(source1, source2, target, strength, clearAlpha);
            return this;
          },
          clearFrame: function(target, clearAlpha) {
            this.UTILITY_PIPELINE.clearFrame(target, clearAlpha);
            return this;
          },
          blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode) {
            this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);
            return this;
          },
          copyFrameRect: function(source, target, x2, y2, width, height, clear, clearAlpha) {
            this.UTILITY_PIPELINE.copyFrameRect(source, target, x2, y2, width, height, clear, clearAlpha);
            return this;
          },
          forceZero: function() {
            return this.current && this.current.forceZero;
          },
          setMulti: function() {
            return this.set(this.MULTI_PIPELINE);
          },
          setUtility: function(currentShader) {
            return this.UTILITY_PIPELINE.bind(currentShader);
          },
          rebind: function(pipeline) {
            if (pipeline === void 0 && this.previous) {
              pipeline = this.previous;
            }
            var renderer = this.renderer;
            var gl2 = renderer.gl;
            gl2.disable(gl2.DEPTH_TEST);
            gl2.disable(gl2.CULL_FACE);
            if (renderer.hasActiveStencilMask()) {
              gl2.clear(gl2.DEPTH_BUFFER_BIT);
            } else {
              gl2.disable(gl2.STENCIL_TEST);
              gl2.clear(gl2.DEPTH_BUFFER_BIT | gl2.STENCIL_BUFFER_BIT);
            }
            gl2.viewport(0, 0, renderer.width, renderer.height);
            renderer.currentProgram = null;
            renderer.setBlendMode(0, true);
            var entries = this.pipelines.entries;
            for (var key in entries) {
              entries[key].glReset = true;
            }
            if (pipeline) {
              this.current = pipeline;
              pipeline.rebind();
            }
            renderer.resetTextures();
          },
          clear: function() {
            var renderer = this.renderer;
            this.flush();
            if (this.current) {
              this.current.unbind();
              this.previous = this.current;
              this.current = null;
            } else {
              this.previous = null;
            }
            renderer.currentProgram = null;
            renderer.setBlendMode(0, true);
          },
          destroy: function() {
            this.flush();
            this.classes.clear();
            this.postPipelineClasses.clear();
            this.pipelines.clear();
            this.renderer = null;
            this.game = null;
            this.classes = null;
            this.postPipelineClasses = null;
            this.pipelines = null;
            this.current = null;
            this.previous = null;
          }
        });
        module2.exports = PipelineManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Felipe Alfonso <@bitnenfer>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetFastValue = __webpack_require__(2);
        var ShaderSourceFS = __webpack_require__(866);
        var ShaderSourceVS = __webpack_require__(867);
        var WEBGL_CONST = __webpack_require__(107);
        var WebGLPipeline = __webpack_require__(58);
        var BitmapMaskPipeline = new Class({
          Extends: WebGLPipeline,
          initialize: function BitmapMaskPipeline2(config) {
            config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS), config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS), config.batchSize = GetFastValue(config, "batchSize", 1), config.vertices = GetFastValue(config, "vertices", [-1, 1, -1, -7, 7, 1]), config.attributes = GetFastValue(config, "attributes", [
              {
                name: "inPosition",
                size: 2,
                type: WEBGL_CONST.FLOAT
              }
            ]);
            WebGLPipeline.call(this, config);
          },
          boot: function() {
            WebGLPipeline.prototype.boot.call(this);
            this.set1i("uMainSampler", 0);
            this.set1i("uMaskSampler", 1);
          },
          resize: function(width, height) {
            WebGLPipeline.prototype.resize.call(this, width, height);
            this.set2f("uResolution", width, height);
          },
          beginMask: function(mask, maskedObject, camera) {
            var gl2 = this.gl;
            if (mask.bitmapMask && gl2) {
              var renderer = this.renderer;
              renderer.flush();
              renderer.pushFramebuffer(mask.mainFramebuffer);
              gl2.disable(gl2.STENCIL_TEST);
              gl2.clearColor(0, 0, 0, 0);
              gl2.clear(gl2.COLOR_BUFFER_BIT);
              if (renderer.currentCameraMask.mask !== mask) {
                renderer.currentMask.mask = mask;
                renderer.currentMask.camera = camera;
              }
            }
          },
          endMask: function(mask, camera) {
            var gl2 = this.gl;
            var renderer = this.renderer;
            var bitmapMask = mask.bitmapMask;
            if (bitmapMask && gl2) {
              renderer.flush();
              renderer.pushFramebuffer(mask.maskFramebuffer);
              gl2.clearColor(0, 0, 0, 0);
              gl2.clear(gl2.COLOR_BUFFER_BIT);
              renderer.setBlendMode(0, true);
              bitmapMask.renderWebGL(renderer, bitmapMask, camera);
              renderer.flush();
              renderer.popFramebuffer();
              renderer.popFramebuffer();
              var prev = renderer.getCurrentStencilMask();
              if (prev) {
                gl2.enable(gl2.STENCIL_TEST);
                prev.mask.applyStencil(renderer, prev.camera, true);
              } else {
                renderer.currentMask.mask = null;
              }
              renderer.pipelines.set(this);
              gl2.activeTexture(gl2.TEXTURE1);
              gl2.bindTexture(gl2.TEXTURE_2D, mask.maskTexture);
              gl2.activeTexture(gl2.TEXTURE0);
              gl2.bindTexture(gl2.TEXTURE_2D, mask.mainTexture);
              this.set1i("uInvertMaskAlpha", mask.invertAlpha);
              gl2.drawArrays(this.topology, 0, 3);
              renderer.resetTextures();
            }
          }
        });
        module2.exports = BitmapMaskPipeline;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          AFTER_FLUSH: __webpack_require__(868),
          BEFORE_FLUSH: __webpack_require__(869),
          BIND: __webpack_require__(870),
          BOOT: __webpack_require__(871),
          DESTROY: __webpack_require__(872),
          REBIND: __webpack_require__(873),
          RESIZE: __webpack_require__(874)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetFastValue = __webpack_require__(2);
        var WEBGL_CONST = __webpack_require__(107);
        var WebGLShader = new Class({
          initialize: function WebGLShader2(pipeline, name, vertexShader, fragmentShader, attributes) {
            this.pipeline = pipeline;
            this.name = name;
            this.renderer = pipeline.renderer;
            this.gl = this.renderer.gl;
            this.program = this.renderer.createProgram(vertexShader, fragmentShader);
            this.attributes;
            this.vertexComponentCount = 0;
            this.vertexSize = 0;
            this.uniforms = {};
            this.createAttributes(attributes);
            this.createUniforms();
          },
          createAttributes: function(attributes) {
            var count = 0;
            var offset = 0;
            var result = [];
            this.vertexComponentCount = 0;
            for (var i2 = 0; i2 < attributes.length; i2++) {
              var element = attributes[i2];
              var name = element.name;
              var size = GetFastValue(element, "size", 1);
              var glType = GetFastValue(element, "type", WEBGL_CONST.FLOAT);
              var type = glType.enum;
              var typeSize = glType.size;
              var normalized = element.normalized ? true : false;
              result.push({
                name,
                size,
                type,
                normalized,
                offset,
                enabled: false,
                location: -1
              });
              if (typeSize === 4) {
                count += size;
              } else {
                count++;
              }
              offset += size * typeSize;
            }
            this.vertexSize = offset;
            this.vertexComponentCount = count;
            this.attributes = result;
          },
          bind: function(setAttributes, flush) {
            if (setAttributes === void 0) {
              setAttributes = false;
            }
            if (flush === void 0) {
              flush = false;
            }
            if (flush) {
              this.pipeline.flush();
            }
            this.renderer.setProgram(this.program);
            if (setAttributes) {
              this.setAttribPointers();
            }
            return this;
          },
          rebind: function() {
            this.renderer.setProgram(this.program);
            this.setAttribPointers(true);
            return this;
          },
          setAttribPointers: function(reset) {
            if (reset === void 0) {
              reset = false;
            }
            var gl2 = this.gl;
            var vertexSize = this.vertexSize;
            var attributes = this.attributes;
            var program = this.program;
            for (var i2 = 0; i2 < attributes.length; i2++) {
              var element = attributes[i2];
              var size = element.size;
              var type = element.type;
              var offset = element.offset;
              var enabled = element.enabled;
              var location = element.location;
              var normalized = element.normalized ? true : false;
              if (reset) {
                var attribLocation = gl2.getAttribLocation(program, element.name);
                if (attribLocation >= 0) {
                  gl2.enableVertexAttribArray(attribLocation);
                  gl2.vertexAttribPointer(attribLocation, size, type, normalized, vertexSize, offset);
                  element.enabled = true;
                  element.location = attribLocation;
                } else if (attribLocation !== -1) {
                  gl2.disableVertexAttribArray(attribLocation);
                }
              } else if (enabled) {
                gl2.vertexAttribPointer(location, size, type, normalized, vertexSize, offset);
              } else if (!enabled && location > -1) {
                gl2.disableVertexAttribArray(location);
                element.location = -1;
              }
            }
            return this;
          },
          createUniforms: function() {
            var gl2 = this.gl;
            var program = this.program;
            var uniforms = this.uniforms;
            var i2;
            var name;
            var location;
            var totalUniforms = gl2.getProgramParameter(program, gl2.ACTIVE_UNIFORMS);
            for (i2 = 0; i2 < totalUniforms; i2++) {
              var info = gl2.getActiveUniform(program, i2);
              if (info) {
                name = info.name;
                location = gl2.getUniformLocation(program, name);
                if (location !== null) {
                  uniforms[name] = {
                    name,
                    location,
                    value1: null,
                    value2: null,
                    value3: null,
                    value4: null
                  };
                }
                var struct = name.indexOf("[");
                if (struct > 0) {
                  name = name.substr(0, struct);
                  if (!uniforms.hasOwnProperty(name)) {
                    location = gl2.getUniformLocation(program, name);
                    if (location !== null) {
                      uniforms[name] = {
                        name,
                        location,
                        value1: null,
                        value2: null,
                        value3: null,
                        value4: null
                      };
                    }
                  }
                }
              }
            }
            return this;
          },
          hasUniform: function(name) {
            return this.uniforms.hasOwnProperty(name);
          },
          resetUniform: function(name) {
            var uniform = this.uniforms[name];
            if (uniform) {
              uniform.value1 = null;
              uniform.value2 = null;
              uniform.value3 = null;
              uniform.value4 = null;
            }
            return this;
          },
          setUniform1: function(setter, name, value1, skipCheck) {
            var uniform = this.uniforms[name];
            if (!uniform) {
              return this;
            }
            if (skipCheck || uniform.value1 !== value1) {
              uniform.value1 = value1;
              this.renderer.setProgram(this.program);
              setter.call(this.gl, uniform.location, value1);
              this.pipeline.currentShader = this;
            }
            return this;
          },
          setUniform2: function(setter, name, value1, value2, skipCheck) {
            var uniform = this.uniforms[name];
            if (!uniform) {
              return this;
            }
            if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2) {
              uniform.value1 = value1;
              uniform.value2 = value2;
              this.renderer.setProgram(this.program);
              setter.call(this.gl, uniform.location, value1, value2);
              this.pipeline.currentShader = this;
            }
            return this;
          },
          setUniform3: function(setter, name, value1, value2, value3, skipCheck) {
            var uniform = this.uniforms[name];
            if (!uniform) {
              return this;
            }
            if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3) {
              uniform.value1 = value1;
              uniform.value2 = value2;
              uniform.value3 = value3;
              this.renderer.setProgram(this.program);
              setter.call(this.gl, uniform.location, value1, value2, value3);
              this.pipeline.currentShader = this;
            }
            return this;
          },
          setUniform4: function(setter, name, value1, value2, value3, value4, skipCheck) {
            var uniform = this.uniforms[name];
            if (!uniform) {
              return this;
            }
            if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3 || uniform.value4 !== value4) {
              uniform.value1 = value1;
              uniform.value2 = value2;
              uniform.value3 = value3;
              uniform.value4 = value4;
              this.renderer.setProgram(this.program);
              setter.call(this.gl, uniform.location, value1, value2, value3, value4);
              this.pipeline.currentShader = this;
            }
            return this;
          },
          set1f: function(name, x2) {
            return this.setUniform1(this.gl.uniform1f, name, x2);
          },
          set2f: function(name, x2, y2) {
            return this.setUniform2(this.gl.uniform2f, name, x2, y2);
          },
          set3f: function(name, x2, y2, z2) {
            return this.setUniform3(this.gl.uniform3f, name, x2, y2, z2);
          },
          set4f: function(name, x2, y2, z2, w2) {
            return this.setUniform4(this.gl.uniform4f, name, x2, y2, z2, w2);
          },
          set1fv: function(name, arr) {
            return this.setUniform1(this.gl.uniform1fv, name, arr, true);
          },
          set2fv: function(name, arr) {
            return this.setUniform1(this.gl.uniform2fv, name, arr, true);
          },
          set3fv: function(name, arr) {
            return this.setUniform1(this.gl.uniform3fv, name, arr, true);
          },
          set4fv: function(name, arr) {
            return this.setUniform1(this.gl.uniform4fv, name, arr, true);
          },
          set1iv: function(name, arr) {
            return this.setUniform1(this.gl.uniform1iv, name, arr, true);
          },
          set2iv: function(name, arr) {
            return this.setUniform1(this.gl.uniform2iv, name, arr, true);
          },
          set3iv: function(name, arr) {
            return this.setUniform1(this.gl.uniform3iv, name, arr, true);
          },
          set4iv: function(name, arr) {
            return this.setUniform1(this.gl.uniform4iv, name, arr, true);
          },
          set1i: function(name, x2) {
            return this.setUniform1(this.gl.uniform1i, name, x2);
          },
          set2i: function(name, x2, y2) {
            return this.setUniform2(this.gl.uniform2i, name, x2, y2);
          },
          set3i: function(name, x2, y2, z2) {
            return this.setUniform3(this.gl.uniform3i, name, x2, y2, z2);
          },
          set4i: function(name, x2, y2, z2, w2) {
            return this.setUniform4(this.gl.uniform4i, name, x2, y2, z2, w2);
          },
          setMatrix2fv: function(name, transpose, matrix) {
            return this.setUniform2(this.gl.uniformMatrix2fv, name, transpose, matrix, true);
          },
          setMatrix3fv: function(name, transpose, matrix) {
            return this.setUniform2(this.gl.uniformMatrix3fv, name, transpose, matrix, true);
          },
          setMatrix4fv: function(name, transpose, matrix) {
            return this.setUniform2(this.gl.uniformMatrix4fv, name, transpose, matrix, true);
          },
          destroy: function() {
            this.gl.deleteProgram(this.program);
            this.pipeline = null;
            this.renderer = null;
            this.gl = null;
            this.program = null;
            this.attributes = null;
            this.uniforms = null;
          }
        });
        module2.exports = WebGLShader;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Felipe Alfonso <@bitnenfer>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Earcut = __webpack_require__(59);
        var GetFastValue = __webpack_require__(2);
        var ShaderSourceFS = __webpack_require__(875);
        var ShaderSourceVS = __webpack_require__(876);
        var TransformMatrix = __webpack_require__(25);
        var WEBGL_CONST = __webpack_require__(107);
        var WebGLPipeline = __webpack_require__(58);
        var GraphicsPipeline = new Class({
          Extends: WebGLPipeline,
          initialize: function GraphicsPipeline2(config) {
            config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS);
            config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS);
            config.attributes = GetFastValue(config, "attributes", [
              {
                name: "inPosition",
                size: 2
              },
              {
                name: "inColor",
                size: 4,
                type: WEBGL_CONST.UNSIGNED_BYTE,
                normalized: true
              }
            ]);
            WebGLPipeline.call(this, config);
            this.calcMatrix = new TransformMatrix();
            this.tempTriangle = [
              { x: 0, y: 0, width: 0 },
              { x: 0, y: 0, width: 0 },
              { x: 0, y: 0, width: 0 },
              { x: 0, y: 0, width: 0 }
            ];
            this.strokeTint = { TL: 0, TR: 0, BL: 0, BR: 0 };
            this.fillTint = { TL: 0, TR: 0, BL: 0, BR: 0 };
            this.currentFrame = { u0: 0, v0: 0, u1: 1, v1: 1 };
            this.firstQuad = [0, 0, 0, 0, 0];
            this.prevQuad = [0, 0, 0, 0, 0];
            this.polygonCache = [];
          },
          batchFillRect: function(x2, y2, width, height, currentMatrix, parentMatrix) {
            this.renderer.pipelines.set(this);
            var calcMatrix = this.calcMatrix;
            if (parentMatrix) {
              parentMatrix.multiply(currentMatrix, calcMatrix);
            }
            var xw = x2 + width;
            var yh2 = y2 + height;
            var x0 = calcMatrix.getX(x2, y2);
            var y0 = calcMatrix.getY(x2, y2);
            var x1 = calcMatrix.getX(x2, yh2);
            var y1 = calcMatrix.getY(x2, yh2);
            var x22 = calcMatrix.getX(xw, yh2);
            var y22 = calcMatrix.getY(xw, yh2);
            var x3 = calcMatrix.getX(xw, y2);
            var y3 = calcMatrix.getY(xw, y2);
            var tint = this.fillTint;
            this.batchQuad(x0, y0, x1, y1, x22, y22, x3, y3, tint.TL, tint.TR, tint.BL, tint.BR);
          },
          batchFillTriangle: function(x0, y0, x1, y1, x2, y2, currentMatrix, parentMatrix) {
            this.renderer.pipelines.set(this);
            var calcMatrix = this.calcMatrix;
            if (parentMatrix) {
              parentMatrix.multiply(currentMatrix, calcMatrix);
            }
            var tx0 = calcMatrix.getX(x0, y0);
            var ty0 = calcMatrix.getY(x0, y0);
            var tx1 = calcMatrix.getX(x1, y1);
            var ty1 = calcMatrix.getY(x1, y1);
            var tx2 = calcMatrix.getX(x2, y2);
            var ty2 = calcMatrix.getY(x2, y2);
            var tint = this.fillTint;
            this.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, tint.TL, tint.TR, tint.BL);
          },
          batchStrokeTriangle: function(x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix) {
            var tempTriangle = this.tempTriangle;
            tempTriangle[0].x = x0;
            tempTriangle[0].y = y0;
            tempTriangle[0].width = lineWidth;
            tempTriangle[1].x = x1;
            tempTriangle[1].y = y1;
            tempTriangle[1].width = lineWidth;
            tempTriangle[2].x = x2;
            tempTriangle[2].y = y2;
            tempTriangle[2].width = lineWidth;
            tempTriangle[3].x = x0;
            tempTriangle[3].y = y0;
            tempTriangle[3].width = lineWidth;
            this.batchStrokePath(tempTriangle, lineWidth, false, currentMatrix, parentMatrix);
          },
          batchFillPath: function(path, currentMatrix, parentMatrix) {
            this.renderer.pipelines.set(this);
            var calcMatrix = this.calcMatrix;
            if (parentMatrix) {
              parentMatrix.multiply(currentMatrix, calcMatrix);
            }
            var length = path.length;
            var polygonCache = this.polygonCache;
            var polygonIndexArray;
            var point;
            var tintTL = this.fillTint.TL;
            var tintTR = this.fillTint.TR;
            var tintBL = this.fillTint.BL;
            for (var pathIndex = 0; pathIndex < length; ++pathIndex) {
              point = path[pathIndex];
              polygonCache.push(point.x, point.y);
            }
            polygonIndexArray = Earcut(polygonCache);
            length = polygonIndexArray.length;
            for (var index2 = 0; index2 < length; index2 += 3) {
              var p0 = polygonIndexArray[index2 + 0] * 2;
              var p1 = polygonIndexArray[index2 + 1] * 2;
              var p2 = polygonIndexArray[index2 + 2] * 2;
              var x0 = polygonCache[p0 + 0];
              var y0 = polygonCache[p0 + 1];
              var x1 = polygonCache[p1 + 0];
              var y1 = polygonCache[p1 + 1];
              var x2 = polygonCache[p2 + 0];
              var y2 = polygonCache[p2 + 1];
              var tx0 = calcMatrix.getX(x0, y0);
              var ty0 = calcMatrix.getY(x0, y0);
              var tx1 = calcMatrix.getX(x1, y1);
              var ty1 = calcMatrix.getY(x1, y1);
              var tx2 = calcMatrix.getX(x2, y2);
              var ty2 = calcMatrix.getY(x2, y2);
              this.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, tintTL, tintTR, tintBL);
            }
            polygonCache.length = 0;
          },
          batchStrokePath: function(path, lineWidth, pathOpen, currentMatrix, parentMatrix) {
            this.renderer.pipelines.set(this);
            this.prevQuad[4] = 0;
            this.firstQuad[4] = 0;
            var pathLength = path.length - 1;
            for (var pathIndex = 0; pathIndex < pathLength; pathIndex++) {
              var point0 = path[pathIndex];
              var point1 = path[pathIndex + 1];
              this.batchLine(point0.x, point0.y, point1.x, point1.y, point0.width / 2, point1.width / 2, lineWidth, pathIndex, !pathOpen && pathIndex === pathLength - 1, currentMatrix, parentMatrix);
            }
          },
          batchLine: function(ax, ay, bx, by, aLineWidth, bLineWidth, lineWidth, index2, closePath, currentMatrix, parentMatrix) {
            this.renderer.pipelines.set(this);
            var calcMatrix = this.calcMatrix;
            if (parentMatrix) {
              parentMatrix.multiply(currentMatrix, calcMatrix);
            }
            var dx = bx - ax;
            var dy = by - ay;
            var len = Math.sqrt(dx * dx + dy * dy);
            var al0 = aLineWidth * (by - ay) / len;
            var al1 = aLineWidth * (ax - bx) / len;
            var bl0 = bLineWidth * (by - ay) / len;
            var bl1 = bLineWidth * (ax - bx) / len;
            var lx0 = bx - bl0;
            var ly0 = by - bl1;
            var lx1 = ax - al0;
            var ly1 = ay - al1;
            var lx2 = bx + bl0;
            var ly2 = by + bl1;
            var lx3 = ax + al0;
            var ly3 = ay + al1;
            var brX = calcMatrix.getX(lx0, ly0);
            var brY = calcMatrix.getY(lx0, ly0);
            var blX = calcMatrix.getX(lx1, ly1);
            var blY = calcMatrix.getY(lx1, ly1);
            var trX = calcMatrix.getX(lx2, ly2);
            var trY = calcMatrix.getY(lx2, ly2);
            var tlX = calcMatrix.getX(lx3, ly3);
            var tlY = calcMatrix.getY(lx3, ly3);
            var tint = this.strokeTint;
            var tintTL = tint.TL;
            var tintTR = tint.TR;
            var tintBL = tint.BL;
            var tintBR = tint.BR;
            this.batchQuad(tlX, tlY, blX, blY, brX, brY, trX, trY, tintTL, tintTR, tintBL, tintBR);
            if (lineWidth <= 2) {
              return;
            }
            var prev = this.prevQuad;
            var first = this.firstQuad;
            if (index2 > 0 && prev[4]) {
              this.batchQuad(tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], tintTL, tintTR, tintBL, tintBR);
            } else {
              first[0] = tlX;
              first[1] = tlY;
              first[2] = blX;
              first[3] = blY;
              first[4] = 1;
            }
            if (closePath && first[4]) {
              this.batchQuad(brX, brY, trX, trY, first[0], first[1], first[2], first[3], tintTL, tintTR, tintBL, tintBR);
            } else {
              prev[0] = brX;
              prev[1] = brY;
              prev[2] = trX;
              prev[3] = trY;
              prev[4] = 1;
            }
          },
          batchVert: function(x2, y2, tint) {
            var vertexViewF32 = this.vertexViewF32;
            var vertexViewU32 = this.vertexViewU32;
            var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
            vertexViewF32[++vertexOffset] = x2;
            vertexViewF32[++vertexOffset] = y2;
            vertexViewU32[++vertexOffset] = tint;
            this.vertexCount++;
          },
          batchQuad: function(x0, y0, x1, y1, x2, y2, x3, y3, tintTL, tintTR, tintBL, tintBR) {
            var hasFlushed = false;
            if (this.shouldFlush(6)) {
              this.flush();
              hasFlushed = true;
            }
            this.batchVert(x0, y0, tintTL);
            this.batchVert(x1, y1, tintBL);
            this.batchVert(x2, y2, tintBR);
            this.batchVert(x0, y0, tintTL);
            this.batchVert(x2, y2, tintBR);
            this.batchVert(x3, y3, tintTR);
            return hasFlushed;
          },
          batchTri: function(x0, y0, x1, y1, x2, y2, tintTL, tintTR, tintBL) {
            var hasFlushed = false;
            if (this.shouldFlush(3)) {
              this.flush();
              hasFlushed = true;
            }
            this.batchVert(x0, y0, tintTL);
            this.batchVert(x1, y1, tintTR);
            this.batchVert(x2, y2, tintBL);
            return hasFlushed;
          },
          destroy: function() {
            WebGLPipeline.prototype.destroy.call(this);
            this.polygonCache = null;
            return this;
          }
        });
        module2.exports = GraphicsPipeline;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Felipe Alfonso <@bitnenfer>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetFastValue = __webpack_require__(2);
        var LightShaderSourceFS = __webpack_require__(877);
        var MultiPipeline = __webpack_require__(108);
        var Vec2 = __webpack_require__(3);
        var WebGLPipeline = __webpack_require__(58);
        var LIGHT_COUNT = 10;
        var tempVec2 = new Vec2();
        var LightPipeline = new Class({
          Extends: MultiPipeline,
          initialize: function LightPipeline2(config) {
            LIGHT_COUNT = config.game.renderer.config.maxLights;
            var fragShader = GetFastValue(config, "fragShader", LightShaderSourceFS);
            var shaders = [];
            for (var i2 = 1; i2 <= LIGHT_COUNT; i2++) {
              shaders.push({
                name: "lights" + i2,
                fragShader: fragShader.replace("%LIGHT_COUNT%", i2.toString())
              });
            }
            config.shaders = shaders;
            MultiPipeline.call(this, config);
            this.inverseRotationMatrix = new Float32Array([
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1
            ]);
            this.defaultNormalMap;
            this.lightsActive = true;
          },
          boot: function() {
            WebGLPipeline.prototype.boot.call(this);
            var gl2 = this.gl;
            var tempTexture = gl2.createTexture();
            gl2.activeTexture(gl2.TEXTURE0);
            gl2.bindTexture(gl2.TEXTURE_2D, tempTexture);
            gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, 1, 1, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, new Uint8Array([127, 127, 255, 255]));
            this.defaultNormalMap = { glTexture: tempTexture };
            for (var i2 = 0; i2 < this.shaders.length; i2++) {
              this["lightShader" + (i2 + 1)] = this.shaders[i2];
            }
          },
          onRender: function(scene, camera) {
            var lightManager = scene.sys.lights;
            this.lightsActive = false;
            if (!lightManager || !lightManager.active) {
              return;
            }
            var lights = lightManager.getLights(camera);
            var lightsCount = lights.length;
            if (lightsCount === 0) {
              return;
            }
            this.lightsActive = true;
            this.setShader(this["lightShader" + lightsCount], true);
            var i2;
            var renderer = this.renderer;
            var height = renderer.height;
            var cameraMatrix = camera.matrix;
            this.set1i("uMainSampler", 0);
            this.set1i("uNormSampler", 1);
            this.set2f("uResolution", this.width / 2, this.height / 2);
            this.set4f("uCamera", camera.x, camera.y, camera.rotation, camera.zoom);
            this.set3f("uAmbientLightColor", lightManager.ambientColor.r, lightManager.ambientColor.g, lightManager.ambientColor.b);
            for (i2 = 0; i2 < lightsCount; i2++) {
              var light = lights[i2].light;
              var color = light.color;
              var lightName = "uLights[" + i2 + "].";
              cameraMatrix.transformPoint(light.x, light.y, tempVec2);
              this.set2f(lightName + "position", tempVec2.x - camera.scrollX * light.scrollFactorX * camera.zoom, height - (tempVec2.y - camera.scrollY * light.scrollFactorY * camera.zoom));
              this.set3f(lightName + "color", color.r, color.g, color.b);
              this.set1f(lightName + "intensity", light.intensity);
              this.set1f(lightName + "radius", light.radius);
            }
            this.currentNormalMapRotation = null;
          },
          setNormalMapRotation: function(rotation) {
            if (rotation !== this.currentNormalMapRotation || this.vertexCount === 0) {
              if (this.vertexCount > 0) {
                this.flush();
              }
              var inverseRotationMatrix = this.inverseRotationMatrix;
              if (rotation) {
                var rot = -rotation;
                var c = Math.cos(rot);
                var s = Math.sin(rot);
                inverseRotationMatrix[1] = s;
                inverseRotationMatrix[3] = -s;
                inverseRotationMatrix[0] = inverseRotationMatrix[4] = c;
              } else {
                inverseRotationMatrix[0] = inverseRotationMatrix[4] = 1;
                inverseRotationMatrix[1] = inverseRotationMatrix[3] = 0;
              }
              this.setMatrix3fv("uInverseRotationMatrix", false, inverseRotationMatrix);
              this.currentNormalMapRotation = rotation;
            }
          },
          setTexture2D: function(texture, gameObject) {
            var renderer = this.renderer;
            if (texture === void 0) {
              texture = renderer.tempTextures[0];
            }
            var normalTexture = this.getNormalMap(gameObject);
            if (renderer.isNewNormalMap(texture, normalTexture)) {
              this.flush();
              renderer.setTextureZero(texture);
              renderer.setNormalMap(normalTexture);
            }
            var rotation = gameObject ? gameObject.rotation : 0;
            this.setNormalMapRotation(rotation);
            this.currentUnit = 0;
            return 0;
          },
          setGameObject: function(gameObject, frame) {
            if (frame === void 0) {
              frame = gameObject.frame;
            }
            var renderer = this.renderer;
            var texture = frame.glTexture;
            var normalTexture = this.getNormalMap(gameObject);
            if (renderer.isNewNormalMap()) {
              this.flush();
              renderer.setTextureZero(texture);
              renderer.setNormalMap(normalTexture);
            }
            this.setNormalMapRotation(gameObject.rotation);
            this.currentUnit = 0;
            return 0;
          },
          getNormalMap: function(gameObject) {
            var normalTexture;
            if (!gameObject) {
              normalTexture = this.defaultNormalMap;
            } else if (gameObject.displayTexture) {
              normalTexture = gameObject.displayTexture.dataSource[gameObject.displayFrame.sourceIndex];
            } else if (gameObject.texture) {
              normalTexture = gameObject.texture.dataSource[gameObject.frame.sourceIndex];
            } else if (gameObject.tileset) {
              if (Array.isArray(gameObject.tileset)) {
                normalTexture = gameObject.tileset[0].image.dataSource[0];
              } else {
                normalTexture = gameObject.tileset.image.dataSource[0];
              }
            }
            if (!normalTexture) {
              normalTexture = this.defaultNormalMap;
            }
            return normalTexture.glTexture;
          },
          batchSprite: function(gameObject, camera, parentTransformMatrix) {
            if (this.lightsActive) {
              MultiPipeline.prototype.batchSprite.call(this, gameObject, camera, parentTransformMatrix);
            }
          },
          batchTexture: function(gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit) {
            if (this.lightsActive) {
              MultiPipeline.prototype.batchTexture.call(this, gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit);
            }
          },
          batchTextureFrame: function(frame, x2, y2, tint, alpha, transformMatrix, parentTransformMatrix) {
            if (this.lightsActive) {
              MultiPipeline.prototype.batchTextureFrame.call(this, frame, x2, y2, tint, alpha, transformMatrix, parentTransformMatrix);
            }
          }
        });
        LightPipeline.LIGHT_COUNT = LIGHT_COUNT;
        module2.exports = LightPipeline;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetFastValue = __webpack_require__(2);
        var PointLightShaderSourceFS = __webpack_require__(880);
        var PointLightShaderSourceVS = __webpack_require__(881);
        var WebGLPipeline = __webpack_require__(58);
        var PointLightPipeline = new Class({
          Extends: WebGLPipeline,
          initialize: function PointLightPipeline2(config) {
            config.vertShader = GetFastValue(config, "vertShader", PointLightShaderSourceVS);
            config.fragShader = GetFastValue(config, "fragShader", PointLightShaderSourceFS);
            config.attributes = GetFastValue(config, "attributes", [
              {
                name: "inPosition",
                size: 2
              },
              {
                name: "inLightPosition",
                size: 2
              },
              {
                name: "inLightRadius"
              },
              {
                name: "inLightAttenuation"
              },
              {
                name: "inLightColor",
                size: 4
              }
            ]);
            WebGLPipeline.call(this, config);
          },
          onRender: function(scene, camera) {
            this.set2f("uResolution", this.width, this.height);
            this.set1f("uCameraZoom", camera.zoom);
          },
          batchPointLight: function(light, camera, x0, y0, x1, y1, x2, y2, x3, y3, lightX, lightY) {
            var color = light.color;
            var intensity = light.intensity;
            var radius = light.radius;
            var attenuation = light.attenuation;
            var r2 = color.r * intensity;
            var g2 = color.g * intensity;
            var b2 = color.b * intensity;
            var a = camera.alpha * light.alpha;
            if (this.shouldFlush(6)) {
              this.flush();
            }
            this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r2, g2, b2, a);
            this.batchLightVert(x1, y1, lightX, lightY, radius, attenuation, r2, g2, b2, a);
            this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r2, g2, b2, a);
            this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r2, g2, b2, a);
            this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r2, g2, b2, a);
            this.batchLightVert(x3, y3, lightX, lightY, radius, attenuation, r2, g2, b2, a);
          },
          batchLightVert: function(x2, y2, lightX, lightY, radius, attenuation, r2, g2, b2, a) {
            var vertexViewF32 = this.vertexViewF32;
            var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
            vertexViewF32[++vertexOffset] = x2;
            vertexViewF32[++vertexOffset] = y2;
            vertexViewF32[++vertexOffset] = lightX;
            vertexViewF32[++vertexOffset] = lightY;
            vertexViewF32[++vertexOffset] = radius;
            vertexViewF32[++vertexOffset] = attenuation;
            vertexViewF32[++vertexOffset] = r2;
            vertexViewF32[++vertexOffset] = g2;
            vertexViewF32[++vertexOffset] = b2;
            vertexViewF32[++vertexOffset] = a;
            this.vertexCount++;
          }
        });
        module2.exports = PointLightPipeline;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetFastValue = __webpack_require__(2);
        var MultiPipeline = __webpack_require__(108);
        var RopePipeline = new Class({
          Extends: MultiPipeline,
          initialize: function RopePipeline2(config) {
            config.topology = 5;
            config.batchSize = GetFastValue(config, "batchSize", 256);
            MultiPipeline.call(this, config);
          }
        });
        module2.exports = RopePipeline;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetFastValue = __webpack_require__(2);
        var MultiPipeline = __webpack_require__(108);
        var ShaderSourceFS = __webpack_require__(882);
        var ShaderSourceVS = __webpack_require__(883);
        var WebGLPipeline = __webpack_require__(58);
        var SinglePipeline = new Class({
          Extends: MultiPipeline,
          initialize: function SinglePipeline2(config) {
            config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS), config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS), config.forceZero = true;
            MultiPipeline.call(this, config);
          },
          boot: function() {
            WebGLPipeline.prototype.boot.call(this);
            this.set1i("uMainSampler", 0);
          }
        });
        module2.exports = SinglePipeline;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AddBlendFS = __webpack_require__(884);
        var BlendModes = __webpack_require__(35);
        var Class = __webpack_require__(0);
        var ColorMatrix = __webpack_require__(198);
        var ColorMatrixFS = __webpack_require__(885);
        var CopyFS = __webpack_require__(886);
        var GetFastValue = __webpack_require__(2);
        var LinearBlendFS = __webpack_require__(887);
        var QuadVS = __webpack_require__(382);
        var WebGLPipeline = __webpack_require__(58);
        var UtilityPipeline = new Class({
          Extends: WebGLPipeline,
          initialize: function UtilityPipeline2(config) {
            config.renderTarget = GetFastValue(config, "renderTarget", [
              {
                scale: 1
              },
              {
                scale: 1
              },
              {
                scale: 0.5
              },
              {
                scale: 0.5
              }
            ]);
            config.vertShader = GetFastValue(config, "vertShader", QuadVS);
            config.shaders = GetFastValue(config, "shaders", [
              {
                name: "Copy",
                fragShader: CopyFS
              },
              {
                name: "AddBlend",
                fragShader: AddBlendFS
              },
              {
                name: "LinearBlend",
                fragShader: LinearBlendFS
              },
              {
                name: "ColorMatrix",
                fragShader: ColorMatrixFS
              }
            ]);
            config.attributes = GetFastValue(config, "attributes", [
              {
                name: "inPosition",
                size: 2
              },
              {
                name: "inTexCoord",
                size: 2
              }
            ]);
            config.vertices = [
              -1,
              -1,
              0,
              0,
              -1,
              1,
              0,
              1,
              1,
              1,
              1,
              1,
              -1,
              -1,
              0,
              0,
              1,
              1,
              1,
              1,
              1,
              -1,
              1,
              0
            ];
            config.batchSize = 1;
            WebGLPipeline.call(this, config);
            this.colorMatrix = new ColorMatrix();
            this.copyShader;
            this.addShader;
            this.linearShader;
            this.colorMatrixShader;
            this.fullFrame1;
            this.fullFrame2;
            this.halfFrame1;
            this.halfFrame2;
          },
          boot: function() {
            WebGLPipeline.prototype.boot.call(this);
            var shaders = this.shaders;
            var targets = this.renderTargets;
            this.copyShader = shaders[0];
            this.addShader = shaders[1];
            this.linearShader = shaders[2];
            this.colorMatrixShader = shaders[3];
            this.fullFrame1 = targets[0];
            this.fullFrame2 = targets[1];
            this.halfFrame1 = targets[2];
            this.halfFrame2 = targets[3];
          },
          copyFrame: function(source, target, brightness, clear, clearAlpha) {
            if (brightness === void 0) {
              brightness = 1;
            }
            if (clear === void 0) {
              clear = true;
            }
            if (clearAlpha === void 0) {
              clearAlpha = true;
            }
            var gl2 = this.gl;
            this.setShader(this.copyShader);
            this.set1i("uMainSampler", 0);
            this.set1f("uBrightness", brightness);
            gl2.activeTexture(gl2.TEXTURE0);
            gl2.bindTexture(gl2.TEXTURE_2D, source.texture);
            if (target) {
              gl2.viewport(0, 0, target.width, target.height);
              gl2.bindFramebuffer(gl2.FRAMEBUFFER, target.framebuffer);
              gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, target.texture, 0);
            } else {
              gl2.viewport(0, 0, source.width, source.height);
            }
            if (clear) {
              if (clearAlpha) {
                gl2.clearColor(0, 0, 0, 0);
              } else {
                gl2.clearColor(0, 0, 0, 1);
              }
              gl2.clear(gl2.COLOR_BUFFER_BIT);
            }
            gl2.bufferData(gl2.ARRAY_BUFFER, this.vertexData, gl2.STATIC_DRAW);
            gl2.drawArrays(gl2.TRIANGLES, 0, 6);
            gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
            gl2.bindTexture(gl2.TEXTURE_2D, null);
          },
          blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode) {
            if (brightness === void 0) {
              brightness = 1;
            }
            if (clear === void 0) {
              clear = true;
            }
            if (clearAlpha === void 0) {
              clearAlpha = true;
            }
            if (eraseMode === void 0) {
              eraseMode = false;
            }
            var gl2 = this.gl;
            this.setShader(this.copyShader);
            this.set1i("uMainSampler", 0);
            this.set1f("uBrightness", brightness);
            gl2.activeTexture(gl2.TEXTURE0);
            gl2.bindTexture(gl2.TEXTURE_2D, source.texture);
            if (source.height > target.height) {
              gl2.viewport(0, 0, source.width, source.height);
              this.setTargetUVs(source, target);
            } else {
              var diff = target.height - source.height;
              gl2.viewport(0, diff, source.width, source.height);
            }
            gl2.bindFramebuffer(gl2.FRAMEBUFFER, target.framebuffer);
            gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, target.texture, 0);
            if (clear) {
              if (clearAlpha) {
                gl2.clearColor(0, 0, 0, 0);
              } else {
                gl2.clearColor(0, 0, 0, 1);
              }
              gl2.clear(gl2.COLOR_BUFFER_BIT);
            }
            if (eraseMode) {
              var blendMode = this.renderer.currentBlendMode;
              this.renderer.setBlendMode(BlendModes.ERASE);
            }
            gl2.bufferData(gl2.ARRAY_BUFFER, this.vertexData, gl2.STATIC_DRAW);
            gl2.drawArrays(gl2.TRIANGLES, 0, 6);
            if (eraseMode) {
              this.renderer.setBlendMode(blendMode);
            }
            gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
            gl2.bindTexture(gl2.TEXTURE_2D, null);
            this.resetUVs();
          },
          copyFrameRect: function(source, target, x2, y2, width, height, clear, clearAlpha) {
            if (clear === void 0) {
              clear = true;
            }
            if (clearAlpha === void 0) {
              clearAlpha = true;
            }
            var gl2 = this.gl;
            gl2.bindFramebuffer(gl2.FRAMEBUFFER, source.framebuffer);
            gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, source.texture, 0);
            if (clear) {
              if (clearAlpha) {
                gl2.clearColor(0, 0, 0, 0);
              } else {
                gl2.clearColor(0, 0, 0, 1);
              }
              gl2.clear(gl2.COLOR_BUFFER_BIT);
            }
            gl2.activeTexture(gl2.TEXTURE0);
            gl2.bindTexture(gl2.TEXTURE_2D, target.texture);
            gl2.copyTexSubImage2D(gl2.TEXTURE_2D, 0, 0, 0, x2, y2, width, height);
            gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
            gl2.bindTexture(gl2.TEXTURE_2D, null);
          },
          copyToGame: function(source) {
            var gl2 = this.gl;
            this.setShader(this.copyShader);
            this.set1i("uMainSampler", 0);
            this.set1f("uBrightness", 1);
            this.renderer.popFramebuffer();
            gl2.activeTexture(gl2.TEXTURE0);
            gl2.bindTexture(gl2.TEXTURE_2D, source.texture);
            gl2.bufferData(gl2.ARRAY_BUFFER, this.vertexData, gl2.STATIC_DRAW);
            gl2.drawArrays(gl2.TRIANGLES, 0, 6);
            this.renderer.resetTextures();
          },
          drawFrame: function(source, target, clearAlpha, colorMatrix) {
            if (clearAlpha === void 0) {
              clearAlpha = true;
            }
            if (colorMatrix === void 0) {
              colorMatrix = this.colorMatrix;
            }
            var gl2 = this.gl;
            this.setShader(this.colorMatrixShader);
            this.set1i("uMainSampler", 0);
            this.set1fv("uColorMatrix", colorMatrix.getData());
            this.set1f("uAlpha", colorMatrix.alpha);
            gl2.activeTexture(gl2.TEXTURE0);
            gl2.bindTexture(gl2.TEXTURE_2D, source.texture);
            if (target) {
              gl2.viewport(0, 0, target.width, target.height);
              gl2.bindFramebuffer(gl2.FRAMEBUFFER, target.framebuffer);
              gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, target.texture, 0);
            } else {
              gl2.viewport(0, 0, source.width, source.height);
            }
            if (clearAlpha) {
              gl2.clearColor(0, 0, 0, 0);
            } else {
              gl2.clearColor(0, 0, 0, 1);
            }
            gl2.clear(gl2.COLOR_BUFFER_BIT);
            gl2.bufferData(gl2.ARRAY_BUFFER, this.vertexData, gl2.STATIC_DRAW);
            gl2.drawArrays(gl2.TRIANGLES, 0, 6);
            gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
            gl2.bindTexture(gl2.TEXTURE_2D, null);
          },
          blendFrames: function(source1, source2, target, strength, clearAlpha, blendShader) {
            if (strength === void 0) {
              strength = 1;
            }
            if (clearAlpha === void 0) {
              clearAlpha = true;
            }
            if (blendShader === void 0) {
              blendShader = this.linearShader;
            }
            var gl2 = this.gl;
            this.setShader(blendShader);
            this.set1i("uMainSampler1", 0);
            this.set1i("uMainSampler2", 1);
            this.set1f("uStrength", strength);
            gl2.activeTexture(gl2.TEXTURE0);
            gl2.bindTexture(gl2.TEXTURE_2D, source1.texture);
            gl2.activeTexture(gl2.TEXTURE1);
            gl2.bindTexture(gl2.TEXTURE_2D, source2.texture);
            if (target) {
              gl2.bindFramebuffer(gl2.FRAMEBUFFER, target.framebuffer);
              gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, target.texture, 0);
              gl2.viewport(0, 0, target.width, target.height);
            } else {
              gl2.viewport(0, 0, source1.width, source1.height);
            }
            if (clearAlpha) {
              gl2.clearColor(0, 0, 0, 0);
            } else {
              gl2.clearColor(0, 0, 0, 1);
            }
            gl2.clear(gl2.COLOR_BUFFER_BIT);
            gl2.bufferData(gl2.ARRAY_BUFFER, this.vertexData, gl2.STATIC_DRAW);
            gl2.drawArrays(gl2.TRIANGLES, 0, 6);
            gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
            gl2.bindTexture(gl2.TEXTURE_2D, null);
          },
          blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
            this.blendFrames(source1, source2, target, strength, clearAlpha, this.addShader);
          },
          clearFrame: function(target, clearAlpha) {
            if (clearAlpha === void 0) {
              clearAlpha = true;
            }
            var gl2 = this.gl;
            gl2.viewport(0, 0, target.width, target.height);
            gl2.bindFramebuffer(gl2.FRAMEBUFFER, target.framebuffer);
            if (clearAlpha) {
              gl2.clearColor(0, 0, 0, 0);
            } else {
              gl2.clearColor(0, 0, 0, 1);
            }
            gl2.clear(gl2.COLOR_BUFFER_BIT);
            var fbo = this.renderer.currentFramebuffer;
            gl2.bindFramebuffer(gl2.FRAMEBUFFER, fbo);
          },
          setUVs: function(uA, vA, uB, vB, uC, vC, uD, vD) {
            var vertexViewF32 = this.vertexViewF32;
            vertexViewF32[2] = uA;
            vertexViewF32[3] = vA;
            vertexViewF32[6] = uB;
            vertexViewF32[7] = vB;
            vertexViewF32[10] = uC;
            vertexViewF32[11] = vC;
            vertexViewF32[14] = uA;
            vertexViewF32[15] = vA;
            vertexViewF32[18] = uC;
            vertexViewF32[19] = vC;
            vertexViewF32[22] = uD;
            vertexViewF32[23] = vD;
          },
          setTargetUVs: function(source, target) {
            var diff = target.height / source.height;
            if (diff > 0.5) {
              diff = 0.5 - (diff - 0.5);
            } else {
              diff = 0.5 + (0.5 - diff);
            }
            this.setUVs(0, diff, 0, 1 + diff, 1, 1 + diff, 1, diff);
          },
          flipX: function() {
            this.setUVs(1, 0, 1, 1, 0, 1, 0, 0);
          },
          flipY: function() {
            this.setUVs(0, 1, 0, 0, 1, 0, 1, 1);
          },
          resetUVs: function() {
            this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
          }
        });
        module2.exports = UtilityPipeline;
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_QUAD_VS",
          "",
          "precision mediump float;",
          "",
          "attribute vec2 inPosition;",
          "attribute vec2 inTexCoord;",
          "",
          "varying vec2 outFragCoord;",
          "varying vec2 outTexCoord;",
          "",
          "void main ()",
          "{",
          "    outFragCoord = inPosition.xy * 0.5 + 0.5;",
          "    outTexCoord = inTexCoord;",
          "",
          "    gl_Position = vec4(inPosition, 0, 1);",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CanvasPool = __webpack_require__(31);
        var Color = __webpack_require__(38);
        var GetFastValue = __webpack_require__(2);
        var WebGLSnapshot = function(sourceCanvas, config) {
          var gl2 = sourceCanvas.getContext("experimental-webgl");
          var callback = GetFastValue(config, "callback");
          var type = GetFastValue(config, "type", "image/png");
          var encoderOptions = GetFastValue(config, "encoder", 0.92);
          var x2 = GetFastValue(config, "x", 0);
          var y2 = GetFastValue(config, "y", 0);
          var getPixel = GetFastValue(config, "getPixel", false);
          var isFramebuffer = GetFastValue(config, "isFramebuffer", false);
          var bufferWidth = isFramebuffer ? GetFastValue(config, "bufferWidth", 1) : gl2.drawingBufferWidth;
          var bufferHeight = isFramebuffer ? GetFastValue(config, "bufferHeight", 1) : gl2.drawingBufferHeight;
          if (getPixel) {
            var pixel = new Uint8Array(4);
            var destY = isFramebuffer ? y2 : bufferHeight - y2;
            gl2.readPixels(x2, destY, 1, 1, gl2.RGBA, gl2.UNSIGNED_BYTE, pixel);
            callback.call(null, new Color(pixel[0], pixel[1], pixel[2], pixel[3] / 255));
          } else {
            var width = GetFastValue(config, "width", bufferWidth);
            var height = GetFastValue(config, "height", bufferHeight);
            var total = width * height * 4;
            var pixels = new Uint8Array(total);
            gl2.readPixels(x2, bufferHeight - y2 - height, width, height, gl2.RGBA, gl2.UNSIGNED_BYTE, pixels);
            var canvas = CanvasPool.createWebGL(this, width, height);
            var ctx = canvas.getContext("2d");
            var imageData = ctx.getImageData(0, 0, width, height);
            var data = imageData.data;
            for (var py = 0; py < height; py++) {
              for (var px = 0; px < width; px++) {
                var sourceIndex = ((height - py - 1) * width + px) * 4;
                var destIndex = (py * width + px) * 4;
                data[destIndex + 0] = pixels[sourceIndex + 0];
                data[destIndex + 1] = pixels[sourceIndex + 1];
                data[destIndex + 2] = pixels[sourceIndex + 2];
                data[destIndex + 3] = pixels[sourceIndex + 3];
              }
            }
            ctx.putImageData(imageData, 0, 0);
            var image = new Image();
            image.onerror = function() {
              callback.call(null);
              CanvasPool.remove(canvas);
            };
            image.onload = function() {
              callback.call(null, image);
              CanvasPool.remove(canvas);
            };
            image.src = canvas.toDataURL(type, encoderOptions);
          }
        };
        module2.exports = WebGLSnapshot;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(33);
        var DebugHeader = function(game) {
          var config = game.config;
          if (config.hideBanner) {
            return;
          }
          var renderType = "WebGL";
          if (config.renderType === CONST.CANVAS) {
            renderType = "Canvas";
          } else if (config.renderType === CONST.HEADLESS) {
            renderType = "Headless";
          }
          var audioConfig = config.audio;
          var deviceAudio = game.device.audio;
          var audioType;
          if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
            audioType = "Web Audio";
          } else if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
            audioType = "No Audio";
          } else {
            audioType = "HTML5 Audio";
          }
          if (!game.device.browser.ie) {
            var c = "";
            var args = [c];
            if (Array.isArray(config.bannerBackgroundColor)) {
              var lastColor;
              config.bannerBackgroundColor.forEach(function(color) {
                c = c.concat("%c ");
                args.push("background: " + color);
                lastColor = color;
              });
              args[args.length - 1] = "color: " + config.bannerTextColor + "; background: " + lastColor;
            } else {
              c = c.concat("%c ");
              args.push("color: " + config.bannerTextColor + "; background: " + config.bannerBackgroundColor);
            }
            args.push("background: transparent");
            if (config.gameTitle) {
              c = c.concat(config.gameTitle);
              if (config.gameVersion) {
                c = c.concat(" v" + config.gameVersion);
              }
              if (!config.hidePhaser) {
                c = c.concat(" / ");
              }
            }
            var fb2 = "";
            if (!config.hidePhaser) {
              c = c.concat("Phaser v" + CONST.VERSION + fb2 + " (" + renderType + " | " + audioType + ")");
            }
            c = c.concat(" %c " + config.gameURL);
            args[0] = c;
            console.log.apply(console, args);
          } else if (window["console"]) {
            console.log("Phaser v" + CONST.VERSION + " / https://phaser.io");
          }
        };
        module2.exports = DebugHeader;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetValue = __webpack_require__(6);
        var NOOP = __webpack_require__(1);
        var RequestAnimationFrame = __webpack_require__(386);
        var TimeStep = new Class({
          initialize: function TimeStep2(game, config) {
            this.game = game;
            this.raf = new RequestAnimationFrame();
            this.started = false;
            this.running = false;
            this.minFps = GetValue(config, "min", 5);
            this.targetFps = GetValue(config, "target", 60);
            this._min = 1e3 / this.minFps;
            this._target = 1e3 / this.targetFps;
            this.actualFps = this.targetFps;
            this.nextFpsUpdate = 0;
            this.framesThisSecond = 0;
            this.callback = NOOP;
            this.forceSetTimeOut = GetValue(config, "forceSetTimeOut", false);
            this.time = 0;
            this.startTime = 0;
            this.lastTime = 0;
            this.frame = 0;
            this.inFocus = true;
            this._pauseTime = 0;
            this._coolDown = 0;
            this.delta = 0;
            this.deltaIndex = 0;
            this.deltaHistory = [];
            this.deltaSmoothingMax = GetValue(config, "deltaHistory", 10);
            this.panicMax = GetValue(config, "panicMax", 120);
            this.rawDelta = 0;
            this.now = 0;
            this.smoothStep = GetValue(config, "smoothStep", true);
          },
          blur: function() {
            this.inFocus = false;
          },
          focus: function() {
            this.inFocus = true;
            this.resetDelta();
          },
          pause: function() {
            this._pauseTime = window.performance.now();
          },
          resume: function() {
            this.resetDelta();
            this.startTime += this.time - this._pauseTime;
          },
          resetDelta: function() {
            var now = window.performance.now();
            this.time = now;
            this.lastTime = now;
            this.nextFpsUpdate = now + 1e3;
            this.framesThisSecond = 0;
            for (var i2 = 0; i2 < this.deltaSmoothingMax; i2++) {
              this.deltaHistory[i2] = Math.min(this._target, this.deltaHistory[i2]);
            }
            this.delta = 0;
            this.deltaIndex = 0;
            this._coolDown = this.panicMax;
          },
          start: function(callback) {
            if (this.started) {
              return this;
            }
            this.started = true;
            this.running = true;
            for (var i2 = 0; i2 < this.deltaSmoothingMax; i2++) {
              this.deltaHistory[i2] = this._target;
            }
            this.resetDelta();
            this.startTime = window.performance.now();
            this.callback = callback;
            this.raf.start(this.step.bind(this), this.forceSetTimeOut, this._target);
          },
          step: function() {
            var time = window.performance.now();
            this.now = time;
            var before = time - this.lastTime;
            if (before < 0) {
              before = 0;
            }
            this.rawDelta = before;
            var idx = this.deltaIndex;
            var history = this.deltaHistory;
            var max = this.deltaSmoothingMax;
            var dt = before;
            var avg = before;
            if (this.smoothStep) {
              if (this._coolDown > 0 || !this.inFocus) {
                this._coolDown--;
                dt = Math.min(dt, this._target);
              }
              if (dt > this._min) {
                dt = history[idx];
                dt = Math.min(dt, this._min);
              }
              history[idx] = dt;
              this.deltaIndex++;
              if (this.deltaIndex > max) {
                this.deltaIndex = 0;
              }
              avg = 0;
              for (var i2 = 0; i2 < max; i2++) {
                avg += history[i2];
              }
              avg /= max;
            }
            this.delta = avg;
            this.time += this.rawDelta;
            if (time > this.nextFpsUpdate) {
              this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps;
              this.nextFpsUpdate = time + 1e3;
              this.framesThisSecond = 0;
            }
            this.framesThisSecond++;
            var interpolation = avg / this._target;
            this.callback(time, avg, interpolation);
            this.lastTime = time;
            this.frame++;
          },
          tick: function() {
            this.step();
          },
          sleep: function() {
            if (this.running) {
              this.raf.stop();
              this.running = false;
            }
          },
          wake: function(seamless) {
            if (this.running) {
              return;
            } else if (seamless) {
              this.startTime += -this.lastTime + (this.lastTime + window.performance.now());
            }
            this.raf.start(this.step.bind(this), this.useRAF);
            this.running = true;
            this.step();
          },
          getDuration: function() {
            return Math.round(this.lastTime - this.startTime) / 1e3;
          },
          getDurationMS: function() {
            return Math.round(this.lastTime - this.startTime);
          },
          stop: function() {
            this.running = false;
            this.started = false;
            this.raf.stop();
            return this;
          },
          destroy: function() {
            this.stop();
            this.callback = NOOP;
            this.raf = null;
            this.game = null;
          }
        });
        module2.exports = TimeStep;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var NOOP = __webpack_require__(1);
        var RequestAnimationFrame = new Class({
          initialize: function RequestAnimationFrame2() {
            this.isRunning = false;
            this.callback = NOOP;
            this.tick = 0;
            this.isSetTimeOut = false;
            this.timeOutID = null;
            this.lastTime = 0;
            this.target = 0;
            var _this = this;
            this.step = function step() {
              var timestamp = window.performance.now();
              _this.lastTime = _this.tick;
              _this.tick = timestamp;
              _this.callback(timestamp);
              _this.timeOutID = window.requestAnimationFrame(step);
            };
            this.stepTimeout = function stepTimeout() {
              var d = Date.now();
              var delay = Math.min(Math.max(_this.target * 2 + _this.tick - d, 0), _this.target);
              _this.lastTime = _this.tick;
              _this.tick = d;
              _this.callback(d);
              _this.timeOutID = window.setTimeout(stepTimeout, delay);
            };
          },
          start: function(callback, forceSetTimeOut, targetFPS) {
            if (this.isRunning) {
              return;
            }
            this.callback = callback;
            this.isSetTimeOut = forceSetTimeOut;
            this.target = targetFPS;
            this.isRunning = true;
            this.timeOutID = forceSetTimeOut ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step);
          },
          stop: function() {
            this.isRunning = false;
            if (this.isSetTimeOut) {
              clearTimeout(this.timeOutID);
            } else {
              window.cancelAnimationFrame(this.timeOutID);
            }
          },
          destroy: function() {
            this.stop();
            this.callback = NOOP;
          }
        });
        module2.exports = RequestAnimationFrame;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Events = __webpack_require__(22);
        var VisibilityHandler = function(game) {
          var hiddenVar;
          var eventEmitter = game.events;
          if (document.hidden !== void 0) {
            hiddenVar = "visibilitychange";
          } else {
            var vendors = ["webkit", "moz", "ms"];
            vendors.forEach(function(prefix) {
              if (document[prefix + "Hidden"] !== void 0) {
                document.hidden = function() {
                  return document[prefix + "Hidden"];
                };
                hiddenVar = prefix + "visibilitychange";
              }
            });
          }
          var onChange = function(event) {
            if (document.hidden || event.type === "pause") {
              eventEmitter.emit(Events.HIDDEN);
            } else {
              eventEmitter.emit(Events.VISIBLE);
            }
          };
          if (hiddenVar) {
            document.addEventListener(hiddenVar, onChange, false);
          }
          window.onblur = function() {
            eventEmitter.emit(Events.BLUR);
          };
          window.onfocus = function() {
            eventEmitter.emit(Events.FOCUS);
          };
          if (window.focus && game.config.autoFocus) {
            window.focus();
          }
        };
        module2.exports = VisibilityHandler;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Arne16 = __webpack_require__(389);
        var CanvasPool = __webpack_require__(31);
        var GetValue = __webpack_require__(6);
        var GenerateTexture = function(config) {
          var data = GetValue(config, "data", []);
          var canvas = GetValue(config, "canvas", null);
          var palette = GetValue(config, "palette", Arne16);
          var pixelWidth = GetValue(config, "pixelWidth", 1);
          var pixelHeight = GetValue(config, "pixelHeight", pixelWidth);
          var resizeCanvas = GetValue(config, "resizeCanvas", true);
          var clearCanvas = GetValue(config, "clearCanvas", true);
          var preRender = GetValue(config, "preRender", null);
          var postRender = GetValue(config, "postRender", null);
          var width = Math.floor(Math.abs(data[0].length * pixelWidth));
          var height = Math.floor(Math.abs(data.length * pixelHeight));
          if (!canvas) {
            canvas = CanvasPool.create2D(this, width, height);
            resizeCanvas = false;
            clearCanvas = false;
          }
          if (resizeCanvas) {
            canvas.width = width;
            canvas.height = height;
          }
          var ctx = canvas.getContext("2d");
          if (clearCanvas) {
            ctx.clearRect(0, 0, width, height);
          }
          if (preRender) {
            preRender(canvas, ctx);
          }
          for (var y2 = 0; y2 < data.length; y2++) {
            var row = data[y2];
            for (var x2 = 0; x2 < row.length; x2++) {
              var d = row[x2];
              if (d !== "." && d !== " ") {
                ctx.fillStyle = palette[d];
                ctx.fillRect(x2 * pixelWidth, y2 * pixelHeight, pixelWidth, pixelHeight);
              }
            }
          }
          if (postRender) {
            postRender(canvas, ctx);
          }
          return canvas;
        };
        module2.exports = GenerateTexture;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          0: "#000",
          1: "#9D9D9D",
          2: "#FFF",
          3: "#BE2633",
          4: "#E06F8B",
          5: "#493C2B",
          6: "#A46422",
          7: "#EB8931",
          8: "#F7E26B",
          9: "#2F484E",
          A: "#44891A",
          B: "#A3CE27",
          C: "#1B2632",
          D: "#005784",
          E: "#31A2F2",
          F: "#B2DCEF"
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CubicBezier = __webpack_require__(358);
        var Curve = __webpack_require__(94);
        var Vector2 = __webpack_require__(3);
        var CubicBezierCurve = new Class({
          Extends: Curve,
          initialize: function CubicBezierCurve2(p0, p1, p2, p3) {
            Curve.call(this, "CubicBezierCurve");
            if (Array.isArray(p0)) {
              p3 = new Vector2(p0[6], p0[7]);
              p2 = new Vector2(p0[4], p0[5]);
              p1 = new Vector2(p0[2], p0[3]);
              p0 = new Vector2(p0[0], p0[1]);
            }
            this.p0 = p0;
            this.p1 = p1;
            this.p2 = p2;
            this.p3 = p3;
          },
          getStartPoint: function(out) {
            if (out === void 0) {
              out = new Vector2();
            }
            return out.copy(this.p0);
          },
          getResolution: function(divisions) {
            return divisions;
          },
          getPoint: function(t2, out) {
            if (out === void 0) {
              out = new Vector2();
            }
            var p0 = this.p0;
            var p1 = this.p1;
            var p2 = this.p2;
            var p3 = this.p3;
            return out.set(CubicBezier(t2, p0.x, p1.x, p2.x, p3.x), CubicBezier(t2, p0.y, p1.y, p2.y, p3.y));
          },
          draw: function(graphics, pointsTotal) {
            if (pointsTotal === void 0) {
              pointsTotal = 32;
            }
            var points = this.getPoints(pointsTotal);
            graphics.beginPath();
            graphics.moveTo(this.p0.x, this.p0.y);
            for (var i2 = 1; i2 < points.length; i2++) {
              graphics.lineTo(points[i2].x, points[i2].y);
            }
            graphics.strokePath();
            return graphics;
          },
          toJSON: function() {
            return {
              type: this.type,
              points: [
                this.p0.x,
                this.p0.y,
                this.p1.x,
                this.p1.y,
                this.p2.x,
                this.p2.y,
                this.p3.x,
                this.p3.y
              ]
            };
          }
        });
        CubicBezierCurve.fromJSON = function(data) {
          var points = data.points;
          var p0 = new Vector2(points[0], points[1]);
          var p1 = new Vector2(points[2], points[3]);
          var p2 = new Vector2(points[4], points[5]);
          var p3 = new Vector2(points[6], points[7]);
          return new CubicBezierCurve(p0, p1, p2, p3);
        };
        module2.exports = CubicBezierCurve;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Curve = __webpack_require__(94);
        var DegToRad = __webpack_require__(36);
        var GetValue = __webpack_require__(6);
        var RadToDeg = __webpack_require__(196);
        var Vector2 = __webpack_require__(3);
        var EllipseCurve = new Class({
          Extends: Curve,
          initialize: function EllipseCurve2(x2, y2, xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {
            if (typeof x2 === "object") {
              var config = x2;
              x2 = GetValue(config, "x", 0);
              y2 = GetValue(config, "y", 0);
              xRadius = GetValue(config, "xRadius", 0);
              yRadius = GetValue(config, "yRadius", xRadius);
              startAngle = GetValue(config, "startAngle", 0);
              endAngle = GetValue(config, "endAngle", 360);
              clockwise = GetValue(config, "clockwise", false);
              rotation = GetValue(config, "rotation", 0);
            } else {
              if (yRadius === void 0) {
                yRadius = xRadius;
              }
              if (startAngle === void 0) {
                startAngle = 0;
              }
              if (endAngle === void 0) {
                endAngle = 360;
              }
              if (clockwise === void 0) {
                clockwise = false;
              }
              if (rotation === void 0) {
                rotation = 0;
              }
            }
            Curve.call(this, "EllipseCurve");
            this.p0 = new Vector2(x2, y2);
            this._xRadius = xRadius;
            this._yRadius = yRadius;
            this._startAngle = DegToRad(startAngle);
            this._endAngle = DegToRad(endAngle);
            this._clockwise = clockwise;
            this._rotation = DegToRad(rotation);
          },
          getStartPoint: function(out) {
            if (out === void 0) {
              out = new Vector2();
            }
            return this.getPoint(0, out);
          },
          getResolution: function(divisions) {
            return divisions * 2;
          },
          getPoint: function(t2, out) {
            if (out === void 0) {
              out = new Vector2();
            }
            var twoPi = Math.PI * 2;
            var deltaAngle = this._endAngle - this._startAngle;
            var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
            while (deltaAngle < 0) {
              deltaAngle += twoPi;
            }
            while (deltaAngle > twoPi) {
              deltaAngle -= twoPi;
            }
            if (deltaAngle < Number.EPSILON) {
              if (samePoints) {
                deltaAngle = 0;
              } else {
                deltaAngle = twoPi;
              }
            }
            if (this._clockwise && !samePoints) {
              if (deltaAngle === twoPi) {
                deltaAngle = -twoPi;
              } else {
                deltaAngle = deltaAngle - twoPi;
              }
            }
            var angle = this._startAngle + t2 * deltaAngle;
            var x2 = this.p0.x + this._xRadius * Math.cos(angle);
            var y2 = this.p0.y + this._yRadius * Math.sin(angle);
            if (this._rotation !== 0) {
              var cos = Math.cos(this._rotation);
              var sin = Math.sin(this._rotation);
              var tx = x2 - this.p0.x;
              var ty = y2 - this.p0.y;
              x2 = tx * cos - ty * sin + this.p0.x;
              y2 = tx * sin + ty * cos + this.p0.y;
            }
            return out.set(x2, y2);
          },
          setXRadius: function(value) {
            this.xRadius = value;
            return this;
          },
          setYRadius: function(value) {
            this.yRadius = value;
            return this;
          },
          setWidth: function(value) {
            this.xRadius = value / 2;
            return this;
          },
          setHeight: function(value) {
            this.yRadius = value / 2;
            return this;
          },
          setStartAngle: function(value) {
            this.startAngle = value;
            return this;
          },
          setEndAngle: function(value) {
            this.endAngle = value;
            return this;
          },
          setClockwise: function(value) {
            this.clockwise = value;
            return this;
          },
          setRotation: function(value) {
            this.rotation = value;
            return this;
          },
          x: {
            get: function() {
              return this.p0.x;
            },
            set: function(value) {
              this.p0.x = value;
            }
          },
          y: {
            get: function() {
              return this.p0.y;
            },
            set: function(value) {
              this.p0.y = value;
            }
          },
          xRadius: {
            get: function() {
              return this._xRadius;
            },
            set: function(value) {
              this._xRadius = value;
            }
          },
          yRadius: {
            get: function() {
              return this._yRadius;
            },
            set: function(value) {
              this._yRadius = value;
            }
          },
          startAngle: {
            get: function() {
              return RadToDeg(this._startAngle);
            },
            set: function(value) {
              this._startAngle = DegToRad(value);
            }
          },
          endAngle: {
            get: function() {
              return RadToDeg(this._endAngle);
            },
            set: function(value) {
              this._endAngle = DegToRad(value);
            }
          },
          clockwise: {
            get: function() {
              return this._clockwise;
            },
            set: function(value) {
              this._clockwise = value;
            }
          },
          angle: {
            get: function() {
              return RadToDeg(this._rotation);
            },
            set: function(value) {
              this._rotation = DegToRad(value);
            }
          },
          rotation: {
            get: function() {
              return this._rotation;
            },
            set: function(value) {
              this._rotation = value;
            }
          },
          toJSON: function() {
            return {
              type: this.type,
              x: this.p0.x,
              y: this.p0.y,
              xRadius: this._xRadius,
              yRadius: this._yRadius,
              startAngle: RadToDeg(this._startAngle),
              endAngle: RadToDeg(this._endAngle),
              clockwise: this._clockwise,
              rotation: RadToDeg(this._rotation)
            };
          }
        });
        EllipseCurve.fromJSON = function(data) {
          return new EllipseCurve(data);
        };
        module2.exports = EllipseCurve;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Curve = __webpack_require__(94);
        var FromPoints = __webpack_require__(199);
        var Rectangle = __webpack_require__(10);
        var Vector2 = __webpack_require__(3);
        var LineCurve = new Class({
          Extends: Curve,
          initialize: function LineCurve2(p0, p1) {
            Curve.call(this, "LineCurve");
            if (Array.isArray(p0)) {
              p1 = new Vector2(p0[2], p0[3]);
              p0 = new Vector2(p0[0], p0[1]);
            }
            this.p0 = p0;
            this.p1 = p1;
            this.arcLengthDivisions = 1;
          },
          getBounds: function(out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            return FromPoints([this.p0, this.p1], out);
          },
          getStartPoint: function(out) {
            if (out === void 0) {
              out = new Vector2();
            }
            return out.copy(this.p0);
          },
          getResolution: function(divisions) {
            if (divisions === void 0) {
              divisions = 1;
            }
            return divisions;
          },
          getPoint: function(t2, out) {
            if (out === void 0) {
              out = new Vector2();
            }
            if (t2 === 1) {
              return out.copy(this.p1);
            }
            out.copy(this.p1).subtract(this.p0).scale(t2).add(this.p0);
            return out;
          },
          getPointAt: function(u2, out) {
            return this.getPoint(u2, out);
          },
          getTangent: function(t2, out) {
            if (out === void 0) {
              out = new Vector2();
            }
            out.copy(this.p1).subtract(this.p0).normalize();
            return out;
          },
          getUtoTmapping: function(u2, distance, divisions) {
            var t2;
            if (distance) {
              var arcLengths = this.getLengths(divisions);
              var lineLength = arcLengths[arcLengths.length - 1];
              var targetLineLength = Math.min(distance, lineLength);
              t2 = targetLineLength / lineLength;
            } else {
              t2 = u2;
            }
            return t2;
          },
          draw: function(graphics) {
            graphics.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y);
            return graphics;
          },
          toJSON: function() {
            return {
              type: this.type,
              points: [
                this.p0.x,
                this.p0.y,
                this.p1.x,
                this.p1.y
              ]
            };
          }
        });
        LineCurve.fromJSON = function(data) {
          var points = data.points;
          var p0 = new Vector2(points[0], points[1]);
          var p1 = new Vector2(points[2], points[3]);
          return new LineCurve(p0, p1);
        };
        module2.exports = LineCurve;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Vector2 = __webpack_require__(3);
        var MoveTo = new Class({
          initialize: function MoveTo2(x2, y2) {
            this.active = false;
            this.p0 = new Vector2(x2, y2);
          },
          getPoint: function(t2, out) {
            if (out === void 0) {
              out = new Vector2();
            }
            return out.copy(this.p0);
          },
          getPointAt: function(u2, out) {
            return this.getPoint(u2, out);
          },
          getResolution: function() {
            return 1;
          },
          getLength: function() {
            return 0;
          },
          toJSON: function() {
            return {
              type: "MoveTo",
              points: [
                this.p0.x,
                this.p0.y
              ]
            };
          }
        });
        module2.exports = MoveTo;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Curve = __webpack_require__(94);
        var QuadraticBezierInterpolation = __webpack_require__(359);
        var Vector2 = __webpack_require__(3);
        var QuadraticBezier = new Class({
          Extends: Curve,
          initialize: function QuadraticBezier2(p0, p1, p2) {
            Curve.call(this, "QuadraticBezier");
            if (Array.isArray(p0)) {
              p2 = new Vector2(p0[4], p0[5]);
              p1 = new Vector2(p0[2], p0[3]);
              p0 = new Vector2(p0[0], p0[1]);
            }
            this.p0 = p0;
            this.p1 = p1;
            this.p2 = p2;
          },
          getStartPoint: function(out) {
            if (out === void 0) {
              out = new Vector2();
            }
            return out.copy(this.p0);
          },
          getResolution: function(divisions) {
            return divisions;
          },
          getPoint: function(t2, out) {
            if (out === void 0) {
              out = new Vector2();
            }
            var p0 = this.p0;
            var p1 = this.p1;
            var p2 = this.p2;
            return out.set(QuadraticBezierInterpolation(t2, p0.x, p1.x, p2.x), QuadraticBezierInterpolation(t2, p0.y, p1.y, p2.y));
          },
          draw: function(graphics, pointsTotal) {
            if (pointsTotal === void 0) {
              pointsTotal = 32;
            }
            var points = this.getPoints(pointsTotal);
            graphics.beginPath();
            graphics.moveTo(this.p0.x, this.p0.y);
            for (var i2 = 1; i2 < points.length; i2++) {
              graphics.lineTo(points[i2].x, points[i2].y);
            }
            graphics.strokePath();
            return graphics;
          },
          toJSON: function() {
            return {
              type: this.type,
              points: [
                this.p0.x,
                this.p0.y,
                this.p1.x,
                this.p1.y,
                this.p2.x,
                this.p2.y
              ]
            };
          }
        });
        QuadraticBezier.fromJSON = function(data) {
          var points = data.points;
          var p0 = new Vector2(points[0], points[1]);
          var p1 = new Vector2(points[2], points[3]);
          var p2 = new Vector2(points[4], points[5]);
          return new QuadraticBezier(p0, p1, p2);
        };
        module2.exports = QuadraticBezier;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CatmullRom = __webpack_require__(194);
        var Class = __webpack_require__(0);
        var Curve = __webpack_require__(94);
        var Vector2 = __webpack_require__(3);
        var SplineCurve = new Class({
          Extends: Curve,
          initialize: function SplineCurve2(points) {
            if (points === void 0) {
              points = [];
            }
            Curve.call(this, "SplineCurve");
            this.points = [];
            this.addPoints(points);
          },
          addPoints: function(points) {
            for (var i2 = 0; i2 < points.length; i2++) {
              var p2 = new Vector2();
              if (typeof points[i2] === "number") {
                p2.x = points[i2];
                p2.y = points[i2 + 1];
                i2++;
              } else if (Array.isArray(points[i2])) {
                p2.x = points[i2][0];
                p2.y = points[i2][1];
              } else {
                p2.x = points[i2].x;
                p2.y = points[i2].y;
              }
              this.points.push(p2);
            }
            return this;
          },
          addPoint: function(x2, y2) {
            var vec = new Vector2(x2, y2);
            this.points.push(vec);
            return vec;
          },
          getStartPoint: function(out) {
            if (out === void 0) {
              out = new Vector2();
            }
            return out.copy(this.points[0]);
          },
          getResolution: function(divisions) {
            return divisions * this.points.length;
          },
          getPoint: function(t2, out) {
            if (out === void 0) {
              out = new Vector2();
            }
            var points = this.points;
            var point = (points.length - 1) * t2;
            var intPoint = Math.floor(point);
            var weight = point - intPoint;
            var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
            var p1 = points[intPoint];
            var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
            var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
            return out.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
          },
          toJSON: function() {
            var points = [];
            for (var i2 = 0; i2 < this.points.length; i2++) {
              points.push(this.points[i2].x);
              points.push(this.points[i2].y);
            }
            return {
              type: this.type,
              points
            };
          }
        });
        SplineCurve.fromJSON = function(data) {
          return new SplineCurve(data.points);
        };
        module2.exports = SplineCurve;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var BaseShader = new Class({
          initialize: function BaseShader2(key, fragmentSrc, vertexSrc, uniforms) {
            if (!fragmentSrc || fragmentSrc === "") {
              fragmentSrc = [
                "precision mediump float;",
                "uniform vec2 resolution;",
                "varying vec2 fragCoord;",
                "void main () {",
                "    vec2 uv = fragCoord / resolution.xy;",
                "    gl_FragColor = vec4(uv.xyx, 1.0);",
                "}"
              ].join("\n");
            }
            if (!vertexSrc || vertexSrc === "") {
              vertexSrc = [
                "precision mediump float;",
                "uniform mat4 uProjectionMatrix;",
                "uniform mat4 uViewMatrix;",
                "uniform vec2 uResolution;",
                "attribute vec2 inPosition;",
                "varying vec2 fragCoord;",
                "varying vec2 outTexCoord;",
                "void main () {",
                "   gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);",
                "   fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);",
                "   outTexCoord = vec2(inPosition.x / uResolution.x, fragCoord.y / uResolution.y);",
                "}"
              ].join("\n");
            }
            if (uniforms === void 0) {
              uniforms = null;
            }
            this.key = key;
            this.fragmentSrc = fragmentSrc;
            this.vertexSrc = vertexSrc;
            this.uniforms = uniforms;
          }
        });
        module2.exports = BaseShader;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Color = __webpack_require__(38);
        Color.ColorSpectrum = __webpack_require__(909);
        Color.ColorToRGBA = __webpack_require__(910);
        Color.ComponentToHex = __webpack_require__(398);
        Color.GetColor = __webpack_require__(103);
        Color.GetColor32 = __webpack_require__(328);
        Color.HexStringToColor = __webpack_require__(327);
        Color.HSLToColor = __webpack_require__(911);
        Color.HSVColorWheel = __webpack_require__(912);
        Color.HSVToRGB = __webpack_require__(188);
        Color.HueToComponent = __webpack_require__(399);
        Color.IntegerToColor = __webpack_require__(189);
        Color.IntegerToRGB = __webpack_require__(330);
        Color.Interpolate = __webpack_require__(913);
        Color.ObjectToColor = __webpack_require__(331);
        Color.RandomRGB = __webpack_require__(914);
        Color.RGBStringToColor = __webpack_require__(332);
        Color.RGBToHSV = __webpack_require__(329);
        Color.RGBToString = __webpack_require__(915);
        Color.ValueToColor = __webpack_require__(187);
        module2.exports = Color;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ComponentToHex = function(color) {
          var hex = color.toString(16);
          return hex.length === 1 ? "0" + hex : hex;
        };
        module2.exports = ComponentToHex;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var HueToComponent = function(p2, q2, t2) {
          if (t2 < 0) {
            t2 += 1;
          }
          if (t2 > 1) {
            t2 -= 1;
          }
          if (t2 < 1 / 6) {
            return p2 + (q2 - p2) * 6 * t2;
          }
          if (t2 < 1 / 2) {
            return q2;
          }
          if (t2 < 2 / 3) {
            return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
          }
          return p2;
        };
        module2.exports = HueToComponent;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var OS = __webpack_require__(105);
        var DOMContentLoaded = function(callback) {
          if (document.readyState === "complete" || document.readyState === "interactive") {
            callback();
            return;
          }
          var check = function() {
            document.removeEventListener("deviceready", check, true);
            document.removeEventListener("DOMContentLoaded", check, true);
            window.removeEventListener("load", check, true);
            callback();
          };
          if (!document.body) {
            window.setTimeout(check, 20);
          } else if (OS.cordova) {
            document.addEventListener("deviceready", check, false);
          } else {
            document.addEventListener("DOMContentLoaded", check, true);
            window.addEventListener("load", check, true);
          }
        };
        module2.exports = DOMContentLoaded;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetInnerHeight = function(iOS) {
          if (!iOS) {
            return window.innerHeight;
          }
          var axis = Math.abs(window.orientation);
          var size = { w: 0, h: 0 };
          var ruler = document.createElement("div");
          ruler.setAttribute("style", "position: fixed; height: 100vh; width: 0; top: 0");
          document.documentElement.appendChild(ruler);
          size.w = axis === 90 ? ruler.offsetHeight : window.innerWidth;
          size.h = axis === 90 ? window.innerWidth : ruler.offsetHeight;
          document.documentElement.removeChild(ruler);
          ruler = null;
          if (Math.abs(window.orientation) !== 90) {
            return size.h;
          } else {
            return size.w;
          }
        };
        module2.exports = GetInnerHeight;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(201);
        var GetScreenOrientation = function(width, height) {
          var screen2 = window.screen;
          var orientation = screen2 ? screen2.orientation || screen2.mozOrientation || screen2.msOrientation : false;
          if (orientation && typeof orientation.type === "string") {
            return orientation.type;
          } else if (typeof orientation === "string") {
            return orientation;
          }
          if (typeof window.orientation === "number") {
            return window.orientation === 0 || window.orientation === 180 ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
          } else if (window.matchMedia) {
            if (window.matchMedia("(orientation: portrait)").matches) {
              return CONST.ORIENTATION.PORTRAIT;
            } else if (window.matchMedia("(orientation: landscape)").matches) {
              return CONST.ORIENTATION.LANDSCAPE;
            }
          } else {
            return height > width ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
          }
        };
        module2.exports = GetScreenOrientation;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          NO_CENTER: 0,
          CENTER_BOTH: 1,
          CENTER_HORIZONTALLY: 2,
          CENTER_VERTICALLY: 3
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          LANDSCAPE: "landscape-primary",
          PORTRAIT: "portrait-primary"
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          NONE: 0,
          WIDTH_CONTROLS_HEIGHT: 1,
          HEIGHT_CONTROLS_WIDTH: 2,
          FIT: 3,
          ENVELOP: 4,
          RESIZE: 5
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          NO_ZOOM: 1,
          ZOOM_2X: 2,
          ZOOM_4X: 4,
          MAX_ZOOM: -1
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTarget = function(element) {
          var target;
          if (element !== "") {
            if (typeof element === "string") {
              target = document.getElementById(element);
            } else if (element && element.nodeType === 1) {
              target = element;
            }
          }
          if (!target) {
            target = document.body;
          }
          return target;
        };
        module2.exports = GetTarget;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ParseXML = function(data) {
          var xml = "";
          try {
            if (window["DOMParser"]) {
              var domparser = new DOMParser();
              xml = domparser.parseFromString(data, "text/xml");
            } else {
              xml = new ActiveXObject("Microsoft.XMLDOM");
              xml.loadXML(data);
            }
          } catch (e) {
            xml = null;
          }
          if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
            return null;
          } else {
            return xml;
          }
        };
        module2.exports = ParseXML;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(203);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(51);
        var GameEvents = __webpack_require__(22);
        var Keyboard = __webpack_require__(410);
        var Mouse = __webpack_require__(411);
        var Pointer = __webpack_require__(412);
        var Touch = __webpack_require__(413);
        var TransformMatrix = __webpack_require__(25);
        var TransformXY = __webpack_require__(177);
        var InputManager = new Class({
          initialize: function InputManager2(game, config) {
            this.game = game;
            this.scaleManager;
            this.canvas;
            this.config = config;
            this.enabled = true;
            this.events = new EventEmitter();
            this.isOver = true;
            this.defaultCursor = "";
            this.keyboard = config.inputKeyboard ? new Keyboard(this) : null;
            this.mouse = config.inputMouse ? new Mouse(this) : null;
            this.touch = config.inputTouch ? new Touch(this) : null;
            this.pointers = [];
            this.pointersTotal = config.inputActivePointers;
            if (config.inputTouch && this.pointersTotal === 1) {
              this.pointersTotal = 2;
            }
            for (var i2 = 0; i2 <= this.pointersTotal; i2++) {
              var pointer = new Pointer(this, i2);
              pointer.smoothFactor = config.inputSmoothFactor;
              this.pointers.push(pointer);
            }
            this.mousePointer = config.inputMouse ? this.pointers[0] : null;
            this.activePointer = this.pointers[0];
            this.globalTopOnly = true;
            this.time = 0;
            this._tempPoint = { x: 0, y: 0 };
            this._tempHitTest = [];
            this._tempMatrix = new TransformMatrix();
            this._tempMatrix2 = new TransformMatrix();
            this._tempSkip = false;
            this.mousePointerContainer = [this.mousePointer];
            game.events.once(GameEvents.BOOT, this.boot, this);
          },
          boot: function() {
            this.canvas = this.game.canvas;
            this.scaleManager = this.game.scale;
            this.events.emit(Events.MANAGER_BOOT);
            this.game.events.on(GameEvents.PRE_RENDER, this.preRender, this);
            this.game.events.once(GameEvents.DESTROY, this.destroy, this);
          },
          setCanvasOver: function(event) {
            this.isOver = true;
            this.events.emit(Events.GAME_OVER, event);
          },
          setCanvasOut: function(event) {
            this.isOver = false;
            this.events.emit(Events.GAME_OUT, event);
          },
          preRender: function() {
            var time = this.game.loop.now;
            var delta = this.game.loop.delta;
            var scenes = this.game.scene.getScenes(true, true);
            this.time = time;
            this.events.emit(Events.MANAGER_UPDATE);
            for (var i2 = 0; i2 < scenes.length; i2++) {
              var scene = scenes[i2];
              if (scene.sys.input && scene.sys.input.updatePoll(time, delta) && this.globalTopOnly) {
                return;
              }
            }
          },
          setDefaultCursor: function(cursor) {
            this.defaultCursor = cursor;
            if (this.canvas.style.cursor !== cursor) {
              this.canvas.style.cursor = cursor;
            }
          },
          setCursor: function(interactiveObject) {
            if (interactiveObject.cursor) {
              this.canvas.style.cursor = interactiveObject.cursor;
            }
          },
          resetCursor: function(interactiveObject) {
            if (interactiveObject.cursor && this.canvas) {
              this.canvas.style.cursor = this.defaultCursor;
            }
          },
          addPointer: function(quantity) {
            if (quantity === void 0) {
              quantity = 1;
            }
            var output = [];
            if (this.pointersTotal + quantity > 10) {
              quantity = 10 - this.pointersTotal;
            }
            for (var i2 = 0; i2 < quantity; i2++) {
              var id2 = this.pointers.length;
              var pointer = new Pointer(this, id2);
              pointer.smoothFactor = this.config.inputSmoothFactor;
              this.pointers.push(pointer);
              this.pointersTotal++;
              output.push(pointer);
            }
            return output;
          },
          updateInputPlugins: function(type, pointers) {
            var scenes = this.game.scene.getScenes(true, true);
            this._tempSkip = false;
            for (var i2 = 0; i2 < scenes.length; i2++) {
              var scene = scenes[i2];
              if (scene.sys.input) {
                var capture = scene.sys.input.update(type, pointers);
                if (capture && this.globalTopOnly || this._tempSkip) {
                  return;
                }
              }
            }
          },
          onTouchStart: function(event) {
            var pointers = this.pointers;
            var changed = [];
            for (var c = 0; c < event.changedTouches.length; c++) {
              var changedTouch = event.changedTouches[c];
              for (var i2 = 1; i2 < this.pointersTotal; i2++) {
                var pointer = pointers[i2];
                if (!pointer.active) {
                  pointer.touchstart(changedTouch, event);
                  this.activePointer = pointer;
                  changed.push(pointer);
                  break;
                }
              }
            }
            this.updateInputPlugins(CONST.TOUCH_START, changed);
          },
          onTouchMove: function(event) {
            var pointers = this.pointers;
            var changed = [];
            for (var c = 0; c < event.changedTouches.length; c++) {
              var changedTouch = event.changedTouches[c];
              for (var i2 = 1; i2 < this.pointersTotal; i2++) {
                var pointer = pointers[i2];
                if (pointer.active && pointer.identifier === changedTouch.identifier) {
                  pointer.touchmove(changedTouch, event);
                  this.activePointer = pointer;
                  changed.push(pointer);
                  break;
                }
              }
            }
            this.updateInputPlugins(CONST.TOUCH_MOVE, changed);
          },
          onTouchEnd: function(event) {
            var pointers = this.pointers;
            var changed = [];
            for (var c = 0; c < event.changedTouches.length; c++) {
              var changedTouch = event.changedTouches[c];
              for (var i2 = 1; i2 < this.pointersTotal; i2++) {
                var pointer = pointers[i2];
                if (pointer.active && pointer.identifier === changedTouch.identifier) {
                  pointer.touchend(changedTouch, event);
                  changed.push(pointer);
                  break;
                }
              }
            }
            this.updateInputPlugins(CONST.TOUCH_END, changed);
          },
          onTouchCancel: function(event) {
            var pointers = this.pointers;
            var changed = [];
            for (var c = 0; c < event.changedTouches.length; c++) {
              var changedTouch = event.changedTouches[c];
              for (var i2 = 1; i2 < this.pointersTotal; i2++) {
                var pointer = pointers[i2];
                if (pointer.active && pointer.identifier === changedTouch.identifier) {
                  pointer.touchcancel(changedTouch, event);
                  changed.push(pointer);
                  break;
                }
              }
            }
            this.updateInputPlugins(CONST.TOUCH_CANCEL, changed);
          },
          onMouseDown: function(event) {
            var mousePointer = this.mousePointer;
            mousePointer.down(event);
            mousePointer.updateMotion();
            this.activePointer = mousePointer;
            this.updateInputPlugins(CONST.MOUSE_DOWN, this.mousePointerContainer);
          },
          onMouseMove: function(event) {
            var mousePointer = this.mousePointer;
            mousePointer.move(event);
            mousePointer.updateMotion();
            this.activePointer = mousePointer;
            this.updateInputPlugins(CONST.MOUSE_MOVE, this.mousePointerContainer);
          },
          onMouseUp: function(event) {
            var mousePointer = this.mousePointer;
            mousePointer.up(event);
            mousePointer.updateMotion();
            this.activePointer = mousePointer;
            this.updateInputPlugins(CONST.MOUSE_UP, this.mousePointerContainer);
          },
          onMouseWheel: function(event) {
            var mousePointer = this.mousePointer;
            mousePointer.wheel(event);
            this.activePointer = mousePointer;
            this.updateInputPlugins(CONST.MOUSE_WHEEL, this.mousePointerContainer);
          },
          onPointerLockChange: function(event) {
            var isLocked = this.mouse.locked;
            this.mousePointer.locked = isLocked;
            this.events.emit(Events.POINTERLOCK_CHANGE, event, isLocked);
          },
          inputCandidate: function(gameObject, camera) {
            var input = gameObject.input;
            if (!input || !input.enabled || !input.alwaysEnabled && !gameObject.willRender(camera)) {
              return false;
            }
            var visible = true;
            var parent = gameObject.parentContainer;
            if (parent) {
              do {
                if (!parent.willRender(camera)) {
                  visible = false;
                  break;
                }
                parent = parent.parentContainer;
              } while (parent);
            }
            return visible;
          },
          hitTest: function(pointer, gameObjects, camera, output) {
            if (output === void 0) {
              output = this._tempHitTest;
            }
            var tempPoint = this._tempPoint;
            var csx = camera.scrollX;
            var csy = camera.scrollY;
            output.length = 0;
            var x2 = pointer.x;
            var y2 = pointer.y;
            camera.getWorldPoint(x2, y2, tempPoint);
            pointer.worldX = tempPoint.x;
            pointer.worldY = tempPoint.y;
            var point = { x: 0, y: 0 };
            var matrix = this._tempMatrix;
            var parentMatrix = this._tempMatrix2;
            for (var i2 = 0; i2 < gameObjects.length; i2++) {
              var gameObject = gameObjects[i2];
              if (!this.inputCandidate(gameObject, camera)) {
                continue;
              }
              var px = tempPoint.x + csx * gameObject.scrollFactorX - csx;
              var py = tempPoint.y + csy * gameObject.scrollFactorY - csy;
              if (gameObject.parentContainer) {
                gameObject.getWorldTransformMatrix(matrix, parentMatrix);
                matrix.applyInverse(px, py, point);
              } else {
                TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, point);
              }
              if (this.pointWithinHitArea(gameObject, point.x, point.y)) {
                output.push(gameObject);
              }
            }
            return output;
          },
          pointWithinHitArea: function(gameObject, x2, y2) {
            x2 += gameObject.displayOriginX;
            y2 += gameObject.displayOriginY;
            var input = gameObject.input;
            if (input && input.hitAreaCallback(input.hitArea, x2, y2, gameObject)) {
              input.localX = x2;
              input.localY = y2;
              return true;
            } else {
              return false;
            }
          },
          pointWithinInteractiveObject: function(object, x2, y2) {
            if (!object.hitArea) {
              return false;
            }
            x2 += object.gameObject.displayOriginX;
            y2 += object.gameObject.displayOriginY;
            object.localX = x2;
            object.localY = y2;
            return object.hitAreaCallback(object.hitArea, x2, y2, object);
          },
          transformPointer: function(pointer, pageX, pageY, wasMove) {
            var p0 = pointer.position;
            var p1 = pointer.prevPosition;
            p1.x = p0.x;
            p1.y = p0.y;
            var x2 = this.scaleManager.transformX(pageX);
            var y2 = this.scaleManager.transformY(pageY);
            var a = pointer.smoothFactor;
            if (!wasMove || a === 0) {
              p0.x = x2;
              p0.y = y2;
            } else {
              p0.x = x2 * a + p1.x * (1 - a);
              p0.y = y2 * a + p1.y * (1 - a);
            }
          },
          destroy: function() {
            this.events.removeAllListeners();
            this.game.events.off(GameEvents.PRE_RENDER);
            if (this.keyboard) {
              this.keyboard.destroy();
            }
            if (this.mouse) {
              this.mouse.destroy();
            }
            if (this.touch) {
              this.touch.destroy();
            }
            for (var i2 = 0; i2 < this.pointers.length; i2++) {
              this.pointers[i2].destroy();
            }
            this.pointers = [];
            this._tempHitTest = [];
            this._tempMatrix.destroy();
            this.canvas = null;
            this.game = null;
          }
        });
        module2.exports = InputManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ArrayRemove = __webpack_require__(93);
        var Class = __webpack_require__(0);
        var GameEvents = __webpack_require__(22);
        var InputEvents = __webpack_require__(51);
        var KeyCodes = __webpack_require__(143);
        var NOOP = __webpack_require__(1);
        var KeyboardManager = new Class({
          initialize: function KeyboardManager2(inputManager) {
            this.manager = inputManager;
            this.queue = [];
            this.preventDefault = true;
            this.captures = [];
            this.enabled = false;
            this.target;
            this.onKeyDown = NOOP;
            this.onKeyUp = NOOP;
            inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
          },
          boot: function() {
            var config = this.manager.config;
            this.enabled = config.inputKeyboard;
            this.target = config.inputKeyboardEventTarget;
            this.addCapture(config.inputKeyboardCapture);
            if (!this.target && window) {
              this.target = window;
            }
            if (this.enabled && this.target) {
              this.startListeners();
            }
            this.manager.game.events.on(GameEvents.POST_STEP, this.postUpdate, this);
          },
          startListeners: function() {
            var _this = this;
            this.onKeyDown = function(event) {
              if (event.defaultPrevented || !_this.enabled || !_this.manager) {
                return;
              }
              _this.queue.push(event);
              _this.manager.events.emit(InputEvents.MANAGER_PROCESS);
              var modified = event.altKey || event.ctrlKey || event.shiftKey || event.metaKey;
              if (_this.preventDefault && !modified && _this.captures.indexOf(event.keyCode) > -1) {
                event.preventDefault();
              }
            };
            this.onKeyUp = function(event) {
              if (event.defaultPrevented || !_this.enabled || !_this.manager) {
                return;
              }
              _this.queue.push(event);
              _this.manager.events.emit(InputEvents.MANAGER_PROCESS);
              var modified = event.altKey || event.ctrlKey || event.shiftKey || event.metaKey;
              if (_this.preventDefault && !modified && _this.captures.indexOf(event.keyCode) > -1) {
                event.preventDefault();
              }
            };
            var target = this.target;
            if (target) {
              target.addEventListener("keydown", this.onKeyDown, false);
              target.addEventListener("keyup", this.onKeyUp, false);
              this.enabled = true;
            }
          },
          stopListeners: function() {
            var target = this.target;
            target.removeEventListener("keydown", this.onKeyDown, false);
            target.removeEventListener("keyup", this.onKeyUp, false);
            this.enabled = false;
          },
          postUpdate: function() {
            this.queue = [];
          },
          addCapture: function(keycode) {
            if (typeof keycode === "string") {
              keycode = keycode.split(",");
            }
            if (!Array.isArray(keycode)) {
              keycode = [keycode];
            }
            var captures = this.captures;
            for (var i2 = 0; i2 < keycode.length; i2++) {
              var code = keycode[i2];
              if (typeof code === "string") {
                code = KeyCodes[code.trim().toUpperCase()];
              }
              if (captures.indexOf(code) === -1) {
                captures.push(code);
              }
            }
            this.preventDefault = captures.length > 0;
          },
          removeCapture: function(keycode) {
            if (typeof keycode === "string") {
              keycode = keycode.split(",");
            }
            if (!Array.isArray(keycode)) {
              keycode = [keycode];
            }
            var captures = this.captures;
            for (var i2 = 0; i2 < keycode.length; i2++) {
              var code = keycode[i2];
              if (typeof code === "string") {
                code = KeyCodes[code.toUpperCase()];
              }
              ArrayRemove(captures, code);
            }
            this.preventDefault = captures.length > 0;
          },
          clearCaptures: function() {
            this.captures = [];
            this.preventDefault = false;
          },
          destroy: function() {
            this.stopListeners();
            this.clearCaptures();
            this.queue = [];
            this.manager.game.events.off(GameEvents.POST_RENDER, this.postUpdate, this);
            this.target = null;
            this.enabled = false;
            this.manager = null;
          }
        });
        module2.exports = KeyboardManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Features = __webpack_require__(191);
        var InputEvents = __webpack_require__(51);
        var NOOP = __webpack_require__(1);
        var MouseManager = new Class({
          initialize: function MouseManager2(inputManager) {
            this.manager = inputManager;
            this.preventDefaultDown = true;
            this.preventDefaultUp = true;
            this.preventDefaultMove = true;
            this.preventDefaultWheel = false;
            this.enabled = false;
            this.target;
            this.locked = false;
            this.onMouseMove = NOOP;
            this.onMouseDown = NOOP;
            this.onMouseUp = NOOP;
            this.onMouseDownWindow = NOOP;
            this.onMouseUpWindow = NOOP;
            this.onMouseOver = NOOP;
            this.onMouseOut = NOOP;
            this.onMouseWheel = NOOP;
            this.pointerLockChange = NOOP;
            this.isTop = true;
            inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
          },
          boot: function() {
            var config = this.manager.config;
            this.enabled = config.inputMouse;
            this.target = config.inputMouseEventTarget;
            this.passive = config.inputMousePassive;
            this.preventDefaultDown = config.inputMousePreventDefaultDown;
            this.preventDefaultUp = config.inputMousePreventDefaultUp;
            this.preventDefaultMove = config.inputMousePreventDefaultMove;
            this.preventDefaultWheel = config.inputMousePreventDefaultWheel;
            if (!this.target) {
              this.target = this.manager.game.canvas;
            } else if (typeof this.target === "string") {
              this.target = document.getElementById(this.target);
            }
            if (config.disableContextMenu) {
              this.disableContextMenu();
            }
            if (this.enabled && this.target) {
              this.startListeners();
            }
          },
          disableContextMenu: function() {
            document.body.addEventListener("contextmenu", function(event) {
              event.preventDefault();
              return false;
            });
            return this;
          },
          requestPointerLock: function() {
            if (Features.pointerLock) {
              var element = this.target;
              element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
              element.requestPointerLock();
            }
          },
          releasePointerLock: function() {
            if (Features.pointerLock) {
              document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
              document.exitPointerLock();
            }
          },
          startListeners: function() {
            var target = this.target;
            if (!target) {
              return;
            }
            var _this = this;
            var manager = this.manager;
            var canvas = manager.canvas;
            var autoFocus = window && window.focus && manager.game.config.autoFocus;
            this.onMouseMove = function(event) {
              if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                manager.onMouseMove(event);
                if (_this.preventDefaultMove) {
                  event.preventDefault();
                }
              }
            };
            this.onMouseDown = function(event) {
              if (autoFocus) {
                window.focus();
              }
              if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                manager.onMouseDown(event);
                if (_this.preventDefaultDown && event.target === canvas) {
                  event.preventDefault();
                }
              }
            };
            this.onMouseDownWindow = function(event) {
              if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
                manager.onMouseDown(event);
              }
            };
            this.onMouseUp = function(event) {
              if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                manager.onMouseUp(event);
                if (_this.preventDefaultUp && event.target === canvas) {
                  event.preventDefault();
                }
              }
            };
            this.onMouseUpWindow = function(event) {
              if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
                manager.onMouseUp(event);
              }
            };
            this.onMouseOver = function(event) {
              if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                manager.setCanvasOver(event);
              }
            };
            this.onMouseOut = function(event) {
              if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                manager.setCanvasOut(event);
              }
            };
            this.onMouseWheel = function(event) {
              if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                manager.onMouseWheel(event);
              }
              if (_this.preventDefaultWheel && event.target === canvas) {
                event.preventDefault();
              }
            };
            var passive = { passive: true };
            target.addEventListener("mousemove", this.onMouseMove);
            target.addEventListener("mousedown", this.onMouseDown);
            target.addEventListener("mouseup", this.onMouseUp);
            target.addEventListener("mouseover", this.onMouseOver, passive);
            target.addEventListener("mouseout", this.onMouseOut, passive);
            if (this.preventDefaultWheel) {
              target.addEventListener("wheel", this.onMouseWheel, { passive: false });
            } else {
              target.addEventListener("wheel", this.onMouseWheel, passive);
            }
            if (window && manager.game.config.inputWindowEvents) {
              try {
                window.top.addEventListener("mousedown", this.onMouseDownWindow, passive);
                window.top.addEventListener("mouseup", this.onMouseUpWindow, passive);
              } catch (exception) {
                window.addEventListener("mousedown", this.onMouseDownWindow, passive);
                window.addEventListener("mouseup", this.onMouseUpWindow, passive);
                this.isTop = false;
              }
            }
            if (Features.pointerLock) {
              this.pointerLockChange = function(event) {
                var element = _this.target;
                _this.locked = document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ? true : false;
                manager.onPointerLockChange(event);
              };
              document.addEventListener("pointerlockchange", this.pointerLockChange, true);
              document.addEventListener("mozpointerlockchange", this.pointerLockChange, true);
              document.addEventListener("webkitpointerlockchange", this.pointerLockChange, true);
            }
            this.enabled = true;
          },
          stopListeners: function() {
            var target = this.target;
            target.removeEventListener("mousemove", this.onMouseMove);
            target.removeEventListener("mousedown", this.onMouseDown);
            target.removeEventListener("mouseup", this.onMouseUp);
            target.removeEventListener("mouseover", this.onMouseOver);
            target.removeEventListener("mouseout", this.onMouseOut);
            if (window) {
              target = this.isTop ? window.top : window;
              target.removeEventListener("mousedown", this.onMouseDownWindow);
              target.removeEventListener("mouseup", this.onMouseUpWindow);
            }
            if (Features.pointerLock) {
              document.removeEventListener("pointerlockchange", this.pointerLockChange, true);
              document.removeEventListener("mozpointerlockchange", this.pointerLockChange, true);
              document.removeEventListener("webkitpointerlockchange", this.pointerLockChange, true);
            }
          },
          destroy: function() {
            this.stopListeners();
            this.target = null;
            this.enabled = false;
            this.manager = null;
          }
        });
        module2.exports = MouseManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Angle = __webpack_require__(349);
        var Class = __webpack_require__(0);
        var Distance = __webpack_require__(50);
        var FuzzyEqual = __webpack_require__(124);
        var SmoothStepInterpolation = __webpack_require__(360);
        var Vector2 = __webpack_require__(3);
        var OS = __webpack_require__(105);
        var Pointer = new Class({
          initialize: function Pointer2(manager, id2) {
            this.manager = manager;
            this.id = id2;
            this.event;
            this.downElement;
            this.upElement;
            this.camera = null;
            this.button = 0;
            this.buttons = 0;
            this.position = new Vector2();
            this.prevPosition = new Vector2();
            this.midPoint = new Vector2(-1, -1);
            this.velocity = new Vector2();
            this.angle = 0;
            this.distance = 0;
            this.smoothFactor = 0;
            this.motionFactor = 0.2;
            this.worldX = 0;
            this.worldY = 0;
            this.moveTime = 0;
            this.downX = 0;
            this.downY = 0;
            this.downTime = 0;
            this.upX = 0;
            this.upY = 0;
            this.upTime = 0;
            this.primaryDown = false;
            this.isDown = false;
            this.wasTouch = false;
            this.wasCanceled = false;
            this.movementX = 0;
            this.movementY = 0;
            this.identifier = 0;
            this.pointerId = null;
            this.active = id2 === 0 ? true : false;
            this.locked = false;
            this.deltaX = 0;
            this.deltaY = 0;
            this.deltaZ = 0;
          },
          updateWorldPoint: function(camera) {
            var temp = camera.getWorldPoint(this.x, this.y);
            this.worldX = temp.x;
            this.worldY = temp.y;
            return this;
          },
          positionToCamera: function(camera, output) {
            return camera.getWorldPoint(this.x, this.y, output);
          },
          updateMotion: function() {
            var cx = this.position.x;
            var cy = this.position.y;
            var mx = this.midPoint.x;
            var my = this.midPoint.y;
            if (cx === mx && cy === my) {
              return;
            }
            var vx = SmoothStepInterpolation(this.motionFactor, mx, cx);
            var vy = SmoothStepInterpolation(this.motionFactor, my, cy);
            if (FuzzyEqual(vx, cx, 0.1)) {
              vx = cx;
            }
            if (FuzzyEqual(vy, cy, 0.1)) {
              vy = cy;
            }
            this.midPoint.set(vx, vy);
            var dx = cx - vx;
            var dy = cy - vy;
            this.velocity.set(dx, dy);
            this.angle = Angle(vx, vy, cx, cy);
            this.distance = Math.sqrt(dx * dx + dy * dy);
          },
          up: function(event) {
            if ("buttons" in event) {
              this.buttons = event.buttons;
            }
            this.event = event;
            this.button = event.button;
            this.upElement = event.target;
            this.manager.transformPointer(this, event.pageX, event.pageY, false);
            if (event.button === 0) {
              this.primaryDown = false;
              this.upX = this.x;
              this.upY = this.y;
            }
            if (this.buttons === 0) {
              this.isDown = false;
              this.upTime = event.timeStamp;
              this.wasTouch = false;
            }
          },
          down: function(event) {
            if ("buttons" in event) {
              this.buttons = event.buttons;
            }
            this.event = event;
            this.button = event.button;
            this.downElement = event.target;
            this.manager.transformPointer(this, event.pageX, event.pageY, false);
            if (event.button === 0) {
              this.primaryDown = true;
              this.downX = this.x;
              this.downY = this.y;
            }
            if (OS.macOS && event.ctrlKey) {
              this.buttons = 2;
              this.primaryDown = false;
            }
            if (!this.isDown) {
              this.isDown = true;
              this.downTime = event.timeStamp;
            }
            this.wasTouch = false;
          },
          move: function(event) {
            if ("buttons" in event) {
              this.buttons = event.buttons;
            }
            this.event = event;
            this.manager.transformPointer(this, event.pageX, event.pageY, true);
            if (this.locked) {
              this.movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
              this.movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            }
            this.moveTime = event.timeStamp;
            this.wasTouch = false;
          },
          wheel: function(event) {
            if ("buttons" in event) {
              this.buttons = event.buttons;
            }
            this.event = event;
            this.manager.transformPointer(this, event.pageX, event.pageY, false);
            this.deltaX = event.deltaX;
            this.deltaY = event.deltaY;
            this.deltaZ = event.deltaZ;
            this.wasTouch = false;
          },
          touchstart: function(touch, event) {
            if (touch["pointerId"]) {
              this.pointerId = touch.pointerId;
            }
            this.identifier = touch.identifier;
            this.target = touch.target;
            this.active = true;
            this.buttons = 1;
            this.event = event;
            this.downElement = touch.target;
            this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
            this.primaryDown = true;
            this.downX = this.x;
            this.downY = this.y;
            this.downTime = event.timeStamp;
            this.isDown = true;
            this.wasTouch = true;
            this.wasCanceled = false;
            this.updateMotion();
          },
          touchmove: function(touch, event) {
            this.event = event;
            this.manager.transformPointer(this, touch.pageX, touch.pageY, true);
            this.moveTime = event.timeStamp;
            this.wasTouch = true;
            this.updateMotion();
          },
          touchend: function(touch, event) {
            this.buttons = 0;
            this.event = event;
            this.upElement = touch.target;
            this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
            this.primaryDown = false;
            this.upX = this.x;
            this.upY = this.y;
            this.upTime = event.timeStamp;
            this.isDown = false;
            this.wasTouch = true;
            this.wasCanceled = false;
            this.active = false;
            this.updateMotion();
          },
          touchcancel: function(touch, event) {
            this.buttons = 0;
            this.event = event;
            this.upElement = touch.target;
            this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
            this.primaryDown = false;
            this.upX = this.x;
            this.upY = this.y;
            this.upTime = event.timeStamp;
            this.isDown = false;
            this.wasTouch = true;
            this.wasCanceled = true;
            this.active = false;
          },
          noButtonDown: function() {
            return this.buttons === 0;
          },
          leftButtonDown: function() {
            return this.buttons & 1 ? true : false;
          },
          rightButtonDown: function() {
            return this.buttons & 2 ? true : false;
          },
          middleButtonDown: function() {
            return this.buttons & 4 ? true : false;
          },
          backButtonDown: function() {
            return this.buttons & 8 ? true : false;
          },
          forwardButtonDown: function() {
            return this.buttons & 16 ? true : false;
          },
          leftButtonReleased: function() {
            return this.button === 0 && !this.isDown;
          },
          rightButtonReleased: function() {
            return this.button === 2 && !this.isDown;
          },
          middleButtonReleased: function() {
            return this.button === 1 && !this.isDown;
          },
          backButtonReleased: function() {
            return this.button === 3 && !this.isDown;
          },
          forwardButtonReleased: function() {
            return this.button === 4 && !this.isDown;
          },
          getDistance: function() {
            if (this.isDown) {
              return Distance(this.downX, this.downY, this.x, this.y);
            } else {
              return Distance(this.downX, this.downY, this.upX, this.upY);
            }
          },
          getDistanceX: function() {
            if (this.isDown) {
              return Math.abs(this.downX - this.x);
            } else {
              return Math.abs(this.downX - this.upX);
            }
          },
          getDistanceY: function() {
            if (this.isDown) {
              return Math.abs(this.downY - this.y);
            } else {
              return Math.abs(this.downY - this.upY);
            }
          },
          getDuration: function() {
            if (this.isDown) {
              return this.manager.time - this.downTime;
            } else {
              return this.upTime - this.downTime;
            }
          },
          getAngle: function() {
            if (this.isDown) {
              return Angle(this.downX, this.downY, this.x, this.y);
            } else {
              return Angle(this.downX, this.downY, this.upX, this.upY);
            }
          },
          getInterpolatedPosition: function(steps, out) {
            if (steps === void 0) {
              steps = 10;
            }
            if (out === void 0) {
              out = [];
            }
            var prevX = this.prevPosition.x;
            var prevY = this.prevPosition.y;
            var curX = this.position.x;
            var curY = this.position.y;
            for (var i2 = 0; i2 < steps; i2++) {
              var t2 = 1 / steps * i2;
              out[i2] = { x: SmoothStepInterpolation(t2, prevX, curX), y: SmoothStepInterpolation(t2, prevY, curY) };
            }
            return out;
          },
          destroy: function() {
            this.camera = null;
            this.manager = null;
            this.position = null;
          },
          x: {
            get: function() {
              return this.position.x;
            },
            set: function(value) {
              this.position.x = value;
            }
          },
          y: {
            get: function() {
              return this.position.y;
            },
            set: function(value) {
              this.position.y = value;
            }
          },
          time: {
            get: function() {
              return this.event ? this.event.timeStamp : 0;
            }
          }
        });
        module2.exports = Pointer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var InputEvents = __webpack_require__(51);
        var NOOP = __webpack_require__(1);
        var TouchManager = new Class({
          initialize: function TouchManager2(inputManager) {
            this.manager = inputManager;
            this.capture = true;
            this.enabled = false;
            this.target;
            this.onTouchStart = NOOP;
            this.onTouchStartWindow = NOOP;
            this.onTouchMove = NOOP;
            this.onTouchEnd = NOOP;
            this.onTouchEndWindow = NOOP;
            this.onTouchCancel = NOOP;
            this.onTouchCancelWindow = NOOP;
            this.onTouchOver = NOOP;
            this.onTouchOut = NOOP;
            inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
          },
          boot: function() {
            var config = this.manager.config;
            this.enabled = config.inputTouch;
            this.target = config.inputTouchEventTarget;
            this.capture = config.inputTouchCapture;
            if (!this.target) {
              this.target = this.manager.game.canvas;
            }
            if (config.disableContextMenu) {
              this.disableContextMenu();
            }
            if (this.enabled && this.target) {
              this.startListeners();
            }
          },
          disableContextMenu: function() {
            document.body.addEventListener("contextmenu", function(event) {
              event.preventDefault();
              return false;
            });
            return this;
          },
          startListeners: function() {
            var _this = this;
            var canvas = this.manager.canvas;
            var autoFocus = window && window.focus && this.manager.game.config.autoFocus;
            this.onTouchStart = function(event) {
              if (autoFocus) {
                window.focus();
              }
              if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                _this.manager.onTouchStart(event);
                if (_this.capture && event.cancelable && event.target === canvas) {
                  event.preventDefault();
                }
              }
            };
            this.onTouchStartWindow = function(event) {
              if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && event.target !== canvas) {
                _this.manager.onTouchStart(event);
              }
            };
            this.onTouchMove = function(event) {
              if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                _this.manager.onTouchMove(event);
                if (_this.capture && event.cancelable) {
                  event.preventDefault();
                }
              }
            };
            this.onTouchEnd = function(event) {
              if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                _this.manager.onTouchEnd(event);
                if (_this.capture && event.cancelable && event.target === canvas) {
                  event.preventDefault();
                }
              }
            };
            this.onTouchEndWindow = function(event) {
              if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && event.target !== canvas) {
                _this.manager.onTouchEnd(event);
              }
            };
            this.onTouchCancel = function(event) {
              if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                _this.manager.onTouchCancel(event);
                if (_this.capture) {
                  event.preventDefault();
                }
              }
            };
            this.onTouchCancelWindow = function(event) {
              if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                _this.manager.onTouchCancel(event);
              }
            };
            this.onTouchOver = function(event) {
              if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                _this.manager.setCanvasOver(event);
              }
            };
            this.onTouchOut = function(event) {
              if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                _this.manager.setCanvasOut(event);
              }
            };
            var target = this.target;
            if (!target) {
              return;
            }
            var passive = { passive: true };
            var nonPassive = { passive: false };
            target.addEventListener("touchstart", this.onTouchStart, this.capture ? nonPassive : passive);
            target.addEventListener("touchmove", this.onTouchMove, this.capture ? nonPassive : passive);
            target.addEventListener("touchend", this.onTouchEnd, this.capture ? nonPassive : passive);
            target.addEventListener("touchcancel", this.onTouchCancel, this.capture ? nonPassive : passive);
            target.addEventListener("touchover", this.onTouchOver, this.capture ? nonPassive : passive);
            target.addEventListener("touchout", this.onTouchOut, this.capture ? nonPassive : passive);
            if (window && this.manager.game.config.inputWindowEvents) {
              window.addEventListener("touchstart", this.onTouchStartWindow, nonPassive);
              window.addEventListener("touchend", this.onTouchEndWindow, nonPassive);
              window.addEventListener("touchcancel", this.onTouchCancelWindow, nonPassive);
            }
            this.enabled = true;
          },
          stopListeners: function() {
            var target = this.target;
            target.removeEventListener("touchstart", this.onTouchStart);
            target.removeEventListener("touchmove", this.onTouchMove);
            target.removeEventListener("touchend", this.onTouchEnd);
            target.removeEventListener("touchcancel", this.onTouchCancel);
            target.removeEventListener("touchover", this.onTouchOver);
            target.removeEventListener("touchout", this.onTouchOut);
            if (window) {
              window.removeEventListener("touchstart", this.onTouchStartWindow);
              window.removeEventListener("touchend", this.onTouchEndWindow);
            }
          },
          destroy: function() {
            this.stopListeners();
            this.target = null;
            this.enabled = false;
            this.manager = null;
          }
        });
        module2.exports = TouchManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GameEvents = __webpack_require__(22);
        var EventEmitter = __webpack_require__(9);
        var FileTypesManager = __webpack_require__(8);
        var GameObjectCreator = __webpack_require__(16);
        var GameObjectFactory = __webpack_require__(5);
        var GetFastValue = __webpack_require__(2);
        var PluginCache = __webpack_require__(24);
        var Remove = __webpack_require__(93);
        var PluginManager = new Class({
          Extends: EventEmitter,
          initialize: function PluginManager2(game) {
            EventEmitter.call(this);
            this.game = game;
            this.plugins = [];
            this.scenePlugins = [];
            this._pendingGlobal = [];
            this._pendingScene = [];
            if (game.isBooted) {
              this.boot();
            } else {
              game.events.once(GameEvents.BOOT, this.boot, this);
            }
          },
          boot: function() {
            var i2;
            var entry;
            var key;
            var plugin;
            var start;
            var mapping;
            var data;
            var config = this.game.config;
            var list = config.installGlobalPlugins;
            list = list.concat(this._pendingGlobal);
            for (i2 = 0; i2 < list.length; i2++) {
              entry = list[i2];
              key = GetFastValue(entry, "key", null);
              plugin = GetFastValue(entry, "plugin", null);
              start = GetFastValue(entry, "start", false);
              mapping = GetFastValue(entry, "mapping", null);
              data = GetFastValue(entry, "data", null);
              if (key) {
                if (plugin) {
                  this.install(key, plugin, start, mapping, data);
                } else {
                  console.warn("Missing `plugin` for key: " + key);
                }
              }
            }
            list = config.installScenePlugins;
            list = list.concat(this._pendingScene);
            for (i2 = 0; i2 < list.length; i2++) {
              entry = list[i2];
              key = GetFastValue(entry, "key", null);
              plugin = GetFastValue(entry, "plugin", null);
              mapping = GetFastValue(entry, "mapping", null);
              if (key) {
                if (plugin) {
                  this.installScenePlugin(key, plugin, mapping);
                } else {
                  console.warn("Missing `plugin` for key: " + key);
                }
              }
            }
            this._pendingGlobal = [];
            this._pendingScene = [];
            this.game.events.once(GameEvents.DESTROY, this.destroy, this);
          },
          addToScene: function(sys, globalPlugins, scenePlugins) {
            var i2;
            var pluginKey;
            var pluginList;
            var game = this.game;
            var scene = sys.scene;
            var map = sys.settings.map;
            var isBooted = sys.settings.isBooted;
            for (i2 = 0; i2 < globalPlugins.length; i2++) {
              pluginKey = globalPlugins[i2];
              if (game[pluginKey]) {
                sys[pluginKey] = game[pluginKey];
                if (map.hasOwnProperty(pluginKey)) {
                  scene[map[pluginKey]] = sys[pluginKey];
                }
              } else if (pluginKey === "game" && map.hasOwnProperty(pluginKey)) {
                scene[map[pluginKey]] = game;
              }
            }
            for (var s = 0; s < scenePlugins.length; s++) {
              pluginList = scenePlugins[s];
              for (i2 = 0; i2 < pluginList.length; i2++) {
                pluginKey = pluginList[i2];
                if (!PluginCache.hasCore(pluginKey)) {
                  continue;
                }
                var source = PluginCache.getCore(pluginKey);
                var mapKey = source.mapping;
                var plugin = new source.plugin(scene, this, mapKey);
                sys[mapKey] = plugin;
                if (source.custom) {
                  scene[mapKey] = plugin;
                } else if (map.hasOwnProperty(mapKey)) {
                  scene[map[mapKey]] = plugin;
                }
                if (isBooted) {
                  plugin.boot();
                }
              }
            }
            pluginList = this.plugins;
            for (i2 = 0; i2 < pluginList.length; i2++) {
              var entry = pluginList[i2];
              if (entry.mapping) {
                scene[entry.mapping] = entry.plugin;
              }
            }
          },
          getDefaultScenePlugins: function() {
            var list = this.game.config.defaultPlugins;
            list = list.concat(this.scenePlugins);
            return list;
          },
          installScenePlugin: function(key, plugin, mapping, addToScene, fromLoader) {
            if (fromLoader === void 0) {
              fromLoader = false;
            }
            if (typeof plugin !== "function") {
              console.warn("Invalid Scene Plugin: " + key);
              return;
            }
            if (!PluginCache.hasCore(key)) {
              PluginCache.register(key, plugin, mapping, true);
              this.scenePlugins.push(key);
            } else if (!fromLoader && PluginCache.hasCore(key)) {
              console.warn("Scene Plugin key in use: " + key);
              return;
            }
            if (addToScene) {
              var instance = new plugin(addToScene, this, key);
              addToScene.sys[key] = instance;
              if (mapping && mapping !== "") {
                addToScene[mapping] = instance;
              }
              instance.boot();
            }
          },
          install: function(key, plugin, start, mapping, data) {
            if (start === void 0) {
              start = false;
            }
            if (mapping === void 0) {
              mapping = null;
            }
            if (data === void 0) {
              data = null;
            }
            if (typeof plugin !== "function") {
              console.warn("Invalid Plugin: " + key);
              return null;
            }
            if (PluginCache.hasCustom(key)) {
              console.warn("Plugin key in use: " + key);
              return null;
            }
            if (mapping !== null) {
              start = true;
            }
            if (!this.game.isBooted) {
              this._pendingGlobal.push({ key, plugin, start, mapping, data });
            } else {
              PluginCache.registerCustom(key, plugin, mapping, data);
              if (start) {
                return this.start(key);
              }
            }
            return null;
          },
          getIndex: function(key) {
            var list = this.plugins;
            for (var i2 = 0; i2 < list.length; i2++) {
              var entry = list[i2];
              if (entry.key === key) {
                return i2;
              }
            }
            return -1;
          },
          getEntry: function(key) {
            var idx = this.getIndex(key);
            if (idx !== -1) {
              return this.plugins[idx];
            }
          },
          isActive: function(key) {
            var entry = this.getEntry(key);
            return entry && entry.active;
          },
          start: function(key, runAs) {
            if (runAs === void 0) {
              runAs = key;
            }
            var entry = this.getEntry(runAs);
            if (entry && !entry.active) {
              entry.active = true;
              entry.plugin.start();
            } else if (!entry) {
              entry = this.createEntry(key, runAs);
            }
            return entry ? entry.plugin : null;
          },
          createEntry: function(key, runAs) {
            var entry = PluginCache.getCustom(key);
            if (entry) {
              var instance = new entry.plugin(this);
              entry = {
                key: runAs,
                plugin: instance,
                active: true,
                mapping: entry.mapping,
                data: entry.data
              };
              this.plugins.push(entry);
              instance.init(entry.data);
              instance.start();
            }
            return entry;
          },
          stop: function(key) {
            var entry = this.getEntry(key);
            if (entry && entry.active) {
              entry.active = false;
              entry.plugin.stop();
            }
            return this;
          },
          get: function(key, autoStart) {
            if (autoStart === void 0) {
              autoStart = true;
            }
            var entry = this.getEntry(key);
            if (entry) {
              return entry.plugin;
            } else {
              var plugin = this.getClass(key);
              if (plugin && autoStart) {
                entry = this.createEntry(key, key);
                return entry ? entry.plugin : null;
              } else if (plugin) {
                return plugin;
              }
            }
            return null;
          },
          getClass: function(key) {
            return PluginCache.getCustomClass(key);
          },
          removeGlobalPlugin: function(key) {
            var entry = this.getEntry(key);
            if (entry) {
              Remove(this.plugins, entry);
            }
            PluginCache.removeCustom(key);
          },
          removeScenePlugin: function(key) {
            Remove(this.scenePlugins, key);
            PluginCache.remove(key);
          },
          registerGameObject: function(key, factoryCallback, creatorCallback) {
            if (factoryCallback) {
              GameObjectFactory.register(key, factoryCallback);
            }
            if (creatorCallback) {
              GameObjectCreator.register(key, creatorCallback);
            }
            return this;
          },
          removeGameObject: function(key, removeFromFactory, removeFromCreator) {
            if (removeFromFactory === void 0) {
              removeFromFactory = true;
            }
            if (removeFromCreator === void 0) {
              removeFromCreator = true;
            }
            if (removeFromFactory) {
              GameObjectFactory.remove(key);
            }
            if (removeFromCreator) {
              GameObjectCreator.remove(key);
            }
            return this;
          },
          registerFileType: function(key, callback, addToScene) {
            FileTypesManager.register(key, callback);
            if (addToScene && addToScene.sys.load) {
              addToScene.sys.load[key] = callback;
            }
          },
          destroy: function() {
            for (var i2 = 0; i2 < this.plugins.length; i2++) {
              this.plugins[i2].plugin.destroy();
            }
            PluginCache.destroyCustomPlugins();
            if (this.game.noReturn) {
              PluginCache.destroyCorePlugins();
            }
            this.game = null;
            this.plugins = [];
            this.scenePlugins = [];
          }
        });
        module2.exports = PluginManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(201);
        var Class = __webpack_require__(0);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(104);
        var GameEvents = __webpack_require__(22);
        var GetInnerHeight = __webpack_require__(401);
        var GetTarget = __webpack_require__(407);
        var GetScreenOrientation = __webpack_require__(402);
        var NOOP = __webpack_require__(1);
        var Rectangle = __webpack_require__(10);
        var Size = __webpack_require__(416);
        var SnapFloor = __webpack_require__(76);
        var Vector2 = __webpack_require__(3);
        var ScaleManager = new Class({
          Extends: EventEmitter,
          initialize: function ScaleManager2(game) {
            EventEmitter.call(this);
            this.game = game;
            this.canvas;
            this.canvasBounds = new Rectangle();
            this.parent = null;
            this.parentIsWindow = false;
            this.parentSize = new Size();
            this.gameSize = new Size();
            this.baseSize = new Size();
            this.displaySize = new Size();
            this.scaleMode = CONST.SCALE_MODE.NONE;
            this.zoom = 1;
            this._resetZoom = false;
            this.displayScale = new Vector2(1, 1);
            this.autoRound = false;
            this.autoCenter = CONST.CENTER.NO_CENTER;
            this.orientation = CONST.ORIENTATION.LANDSCAPE;
            this.fullscreen;
            this.fullscreenTarget = null;
            this._createdFullscreenTarget = false;
            this.dirty = false;
            this.resizeInterval = 500;
            this._lastCheck = 0;
            this._checkOrientation = false;
            this.listeners = {
              orientationChange: NOOP,
              windowResize: NOOP,
              fullScreenChange: NOOP,
              fullScreenError: NOOP
            };
          },
          preBoot: function() {
            this.parseConfig(this.game.config);
            this.game.events.once(GameEvents.BOOT, this.boot, this);
          },
          boot: function() {
            var game = this.game;
            this.canvas = game.canvas;
            this.fullscreen = game.device.fullscreen;
            if (this.scaleMode !== CONST.SCALE_MODE.RESIZE) {
              this.displaySize.setAspectMode(this.scaleMode);
            }
            if (this.scaleMode === CONST.SCALE_MODE.NONE) {
              this.resize(this.width, this.height);
            } else {
              this.getParentBounds();
              if (this.parentSize.width > 0 && this.parentSize.height > 0) {
                this.displaySize.setParent(this.parentSize);
              }
              this.refresh();
            }
            game.events.on(GameEvents.PRE_STEP, this.step, this);
            game.events.once(GameEvents.READY, this.refresh, this);
            game.events.once(GameEvents.DESTROY, this.destroy, this);
            this.startListeners();
          },
          parseConfig: function(config) {
            this.getParent(config);
            this.getParentBounds();
            var width = config.width;
            var height = config.height;
            var scaleMode = config.scaleMode;
            var zoom = config.zoom;
            var autoRound = config.autoRound;
            if (typeof width === "string") {
              var parentWidth = this.parentSize.width;
              if (parentWidth === 0) {
                parentWidth = window.innerWidth;
              }
              var parentScaleX = parseInt(width, 10) / 100;
              width = Math.floor(parentWidth * parentScaleX);
            }
            if (typeof height === "string") {
              var parentHeight = this.parentSize.height;
              if (parentHeight === 0) {
                parentHeight = window.innerHeight;
              }
              var parentScaleY = parseInt(height, 10) / 100;
              height = Math.floor(parentHeight * parentScaleY);
            }
            this.scaleMode = scaleMode;
            this.autoRound = autoRound;
            this.autoCenter = config.autoCenter;
            this.resizeInterval = config.resizeInterval;
            if (autoRound) {
              width = Math.floor(width);
              height = Math.floor(height);
            }
            this.gameSize.setSize(width, height);
            if (zoom === CONST.ZOOM.MAX_ZOOM) {
              zoom = this.getMaxZoom();
            }
            this.zoom = zoom;
            if (zoom !== 1) {
              this._resetZoom = true;
            }
            this.baseSize.setSize(width, height);
            if (autoRound) {
              this.baseSize.width = Math.floor(this.baseSize.width);
              this.baseSize.height = Math.floor(this.baseSize.height);
            }
            if (config.minWidth > 0) {
              this.displaySize.setMin(config.minWidth * zoom, config.minHeight * zoom);
            }
            if (config.maxWidth > 0) {
              this.displaySize.setMax(config.maxWidth * zoom, config.maxHeight * zoom);
            }
            this.displaySize.setSize(width, height);
            this.orientation = GetScreenOrientation(width, height);
          },
          getParent: function(config) {
            var parent = config.parent;
            if (parent === null) {
              return;
            }
            this.parent = GetTarget(parent);
            this.parentIsWindow = this.parent === document.body;
            if (config.expandParent && config.scaleMode !== CONST.SCALE_MODE.NONE) {
              var DOMRect = this.parent.getBoundingClientRect();
              if (this.parentIsWindow || DOMRect.height === 0) {
                document.documentElement.style.height = "100%";
                document.body.style.height = "100%";
                DOMRect = this.parent.getBoundingClientRect();
                if (!this.parentIsWindow && DOMRect.height === 0) {
                  this.parent.style.overflow = "hidden";
                  this.parent.style.width = "100%";
                  this.parent.style.height = "100%";
                }
              }
            }
            if (config.fullscreenTarget && !this.fullscreenTarget) {
              this.fullscreenTarget = GetTarget(config.fullscreenTarget);
            }
          },
          getParentBounds: function() {
            if (!this.parent) {
              return false;
            }
            var parentSize = this.parentSize;
            var DOMRect = this.parent.getBoundingClientRect();
            if (this.parentIsWindow && this.game.device.os.iOS) {
              DOMRect.height = GetInnerHeight(true);
            }
            var newWidth = DOMRect.width;
            var newHeight = DOMRect.height;
            if (parentSize.width !== newWidth || parentSize.height !== newHeight) {
              parentSize.setSize(newWidth, newHeight);
              return true;
            } else {
              return false;
            }
          },
          lockOrientation: function(orientation) {
            var lock = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;
            if (lock) {
              return lock.call(screen, orientation);
            }
            return false;
          },
          setParentSize: function(width, height) {
            this.parentSize.setSize(width, height);
            return this.refresh();
          },
          setGameSize: function(width, height) {
            var autoRound = this.autoRound;
            if (autoRound) {
              width = Math.floor(width);
              height = Math.floor(height);
            }
            var previousWidth = this.width;
            var previousHeight = this.height;
            this.gameSize.resize(width, height);
            this.baseSize.resize(width, height);
            if (autoRound) {
              this.baseSize.width = Math.floor(this.baseSize.width);
              this.baseSize.height = Math.floor(this.baseSize.height);
            }
            this.displaySize.setAspectRatio(width / height);
            this.canvas.width = this.baseSize.width;
            this.canvas.height = this.baseSize.height;
            return this.refresh(previousWidth, previousHeight);
          },
          resize: function(width, height) {
            var zoom = this.zoom;
            var autoRound = this.autoRound;
            if (autoRound) {
              width = Math.floor(width);
              height = Math.floor(height);
            }
            var previousWidth = this.width;
            var previousHeight = this.height;
            this.gameSize.resize(width, height);
            this.baseSize.resize(width, height);
            if (autoRound) {
              this.baseSize.width = Math.floor(this.baseSize.width);
              this.baseSize.height = Math.floor(this.baseSize.height);
            }
            this.displaySize.setSize(width * zoom, height * zoom);
            this.canvas.width = this.baseSize.width;
            this.canvas.height = this.baseSize.height;
            var style = this.canvas.style;
            var styleWidth = width * zoom;
            var styleHeight = height * zoom;
            if (autoRound) {
              styleWidth = Math.floor(styleWidth);
              styleHeight = Math.floor(styleHeight);
            }
            if (styleWidth !== width || styleHeight !== height) {
              style.width = styleWidth + "px";
              style.height = styleHeight + "px";
            }
            return this.refresh(previousWidth, previousHeight);
          },
          setZoom: function(value) {
            this.zoom = value;
            this._resetZoom = true;
            return this.refresh();
          },
          setMaxZoom: function() {
            this.zoom = this.getMaxZoom();
            this._resetZoom = true;
            return this.refresh();
          },
          refresh: function(previousWidth, previousHeight) {
            if (previousWidth === void 0) {
              previousWidth = this.width;
            }
            if (previousHeight === void 0) {
              previousHeight = this.height;
            }
            this.updateScale();
            this.updateBounds();
            this.updateOrientation();
            this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);
            var domContainer = this.game.domContainer;
            if (domContainer) {
              this.baseSize.setCSS(domContainer);
              var canvasStyle = this.canvas.style;
              var domStyle = domContainer.style;
              domStyle.transform = "scale(" + this.displaySize.width / this.baseSize.width + "," + this.displaySize.height / this.baseSize.height + ")";
              domStyle.marginLeft = canvasStyle.marginLeft;
              domStyle.marginTop = canvasStyle.marginTop;
            }
            this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, previousWidth, previousHeight);
            return this;
          },
          updateOrientation: function() {
            if (this._checkOrientation) {
              this._checkOrientation = false;
              var newOrientation = GetScreenOrientation(this.width, this.height);
              if (newOrientation !== this.orientation) {
                this.orientation = newOrientation;
                this.emit(Events.ORIENTATION_CHANGE, newOrientation);
              }
            }
          },
          updateScale: function() {
            var style = this.canvas.style;
            var width = this.gameSize.width;
            var height = this.gameSize.height;
            var styleWidth;
            var styleHeight;
            var zoom = this.zoom;
            var autoRound = this.autoRound;
            if (this.scaleMode === CONST.SCALE_MODE.NONE) {
              this.displaySize.setSize(width * zoom, height * zoom);
              styleWidth = this.displaySize.width;
              styleHeight = this.displaySize.height;
              if (autoRound) {
                styleWidth = Math.floor(styleWidth);
                styleHeight = Math.floor(styleHeight);
              }
              if (this._resetZoom) {
                style.width = styleWidth + "px";
                style.height = styleHeight + "px";
                this._resetZoom = false;
              }
            } else if (this.scaleMode === CONST.SCALE_MODE.RESIZE) {
              this.displaySize.setSize(this.parentSize.width, this.parentSize.height);
              this.gameSize.setSize(this.displaySize.width, this.displaySize.height);
              this.baseSize.setSize(this.displaySize.width, this.displaySize.height);
              styleWidth = this.displaySize.width;
              styleHeight = this.displaySize.height;
              if (autoRound) {
                styleWidth = Math.floor(styleWidth);
                styleHeight = Math.floor(styleHeight);
              }
              this.canvas.width = styleWidth;
              this.canvas.height = styleHeight;
            } else {
              this.displaySize.setSize(this.parentSize.width, this.parentSize.height);
              styleWidth = this.displaySize.width;
              styleHeight = this.displaySize.height;
              if (autoRound) {
                styleWidth = Math.floor(styleWidth);
                styleHeight = Math.floor(styleHeight);
              }
              style.width = styleWidth + "px";
              style.height = styleHeight + "px";
            }
            this.getParentBounds();
            this.updateCenter();
          },
          getMaxZoom: function() {
            var zoomH = SnapFloor(this.parentSize.width, this.gameSize.width, 0, true);
            var zoomV = SnapFloor(this.parentSize.height, this.gameSize.height, 0, true);
            return Math.max(Math.min(zoomH, zoomV), 1);
          },
          updateCenter: function() {
            var autoCenter = this.autoCenter;
            if (autoCenter === CONST.CENTER.NO_CENTER) {
              return;
            }
            var canvas = this.canvas;
            var style = canvas.style;
            var bounds = canvas.getBoundingClientRect();
            var width = bounds.width;
            var height = bounds.height;
            var offsetX = Math.floor((this.parentSize.width - width) / 2);
            var offsetY = Math.floor((this.parentSize.height - height) / 2);
            if (autoCenter === CONST.CENTER.CENTER_HORIZONTALLY) {
              offsetY = 0;
            } else if (autoCenter === CONST.CENTER.CENTER_VERTICALLY) {
              offsetX = 0;
            }
            style.marginLeft = offsetX + "px";
            style.marginTop = offsetY + "px";
          },
          updateBounds: function() {
            var bounds = this.canvasBounds;
            var clientRect = this.canvas.getBoundingClientRect();
            bounds.x = clientRect.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0);
            bounds.y = clientRect.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0);
            bounds.width = clientRect.width;
            bounds.height = clientRect.height;
          },
          transformX: function(pageX) {
            return (pageX - this.canvasBounds.left) * this.displayScale.x;
          },
          transformY: function(pageY) {
            return (pageY - this.canvasBounds.top) * this.displayScale.y;
          },
          startFullscreen: function(fullscreenOptions) {
            if (fullscreenOptions === void 0) {
              fullscreenOptions = { navigationUI: "hide" };
            }
            var fullscreen = this.fullscreen;
            if (!fullscreen.available) {
              this.emit(Events.FULLSCREEN_UNSUPPORTED);
              return;
            }
            if (!fullscreen.active) {
              var fsTarget = this.getFullscreenTarget();
              if (fullscreen.keyboard) {
                fsTarget[fullscreen.request](Element.ALLOW_KEYBOARD_INPUT);
              } else {
                fsTarget[fullscreen.request](fullscreenOptions);
              }
            }
          },
          fullscreenSuccessHandler: function() {
            this.getParentBounds();
            this.refresh();
            this.emit(Events.ENTER_FULLSCREEN);
          },
          fullscreenErrorHandler: function(error) {
            this.removeFullscreenTarget();
            this.emit(Events.FULLSCREEN_FAILED, error);
          },
          getFullscreenTarget: function() {
            if (!this.fullscreenTarget) {
              var fsTarget = document.createElement("div");
              fsTarget.style.margin = "0";
              fsTarget.style.padding = "0";
              fsTarget.style.width = "100%";
              fsTarget.style.height = "100%";
              this.fullscreenTarget = fsTarget;
              this._createdFullscreenTarget = true;
            }
            if (this._createdFullscreenTarget) {
              var canvasParent = this.canvas.parentNode;
              canvasParent.insertBefore(this.fullscreenTarget, this.canvas);
              this.fullscreenTarget.appendChild(this.canvas);
            }
            return this.fullscreenTarget;
          },
          removeFullscreenTarget: function() {
            if (this._createdFullscreenTarget) {
              var fsTarget = this.fullscreenTarget;
              if (fsTarget && fsTarget.parentNode) {
                var parent = fsTarget.parentNode;
                parent.insertBefore(this.canvas, fsTarget);
                parent.removeChild(fsTarget);
              }
            }
          },
          stopFullscreen: function() {
            var fullscreen = this.fullscreen;
            if (!fullscreen.available) {
              this.emit(Events.FULLSCREEN_UNSUPPORTED);
              return false;
            }
            if (fullscreen.active) {
              document[fullscreen.cancel]();
            }
            this.removeFullscreenTarget();
            this.getParentBounds();
            this.emit(Events.LEAVE_FULLSCREEN);
            this.refresh();
          },
          toggleFullscreen: function(fullscreenOptions) {
            if (this.fullscreen.active) {
              this.stopFullscreen();
            } else {
              this.startFullscreen(fullscreenOptions);
            }
          },
          startListeners: function() {
            var _this = this;
            var listeners = this.listeners;
            listeners.orientationChange = function() {
              _this.updateBounds();
              _this._checkOrientation = true;
              _this.dirty = true;
            };
            listeners.windowResize = function() {
              _this.updateBounds();
              _this.dirty = true;
            };
            window.addEventListener("orientationchange", listeners.orientationChange, false);
            window.addEventListener("resize", listeners.windowResize, false);
            if (this.fullscreen.available) {
              listeners.fullScreenChange = function(event) {
                return _this.onFullScreenChange(event);
              };
              listeners.fullScreenError = function(event) {
                return _this.onFullScreenError(event);
              };
              var vendors = ["webkit", "moz", ""];
              vendors.forEach(function(prefix) {
                document.addEventListener(prefix + "fullscreenchange", listeners.fullScreenChange, false);
                document.addEventListener(prefix + "fullscreenerror", listeners.fullScreenError, false);
              });
              document.addEventListener("MSFullscreenChange", listeners.fullScreenChange, false);
              document.addEventListener("MSFullscreenError", listeners.fullScreenError, false);
            }
          },
          onFullScreenChange: function() {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement) {
              this.fullscreenSuccessHandler();
            } else {
              this.stopFullscreen();
            }
          },
          onFullScreenError: function() {
            this.removeFullscreenTarget();
          },
          step: function(time, delta) {
            if (!this.parent) {
              return;
            }
            this._lastCheck += delta;
            if (this.dirty || this._lastCheck > this.resizeInterval) {
              if (this.getParentBounds()) {
                this.refresh();
              }
              this.dirty = false;
              this._lastCheck = 0;
            }
          },
          stopListeners: function() {
            var listeners = this.listeners;
            window.removeEventListener("orientationchange", listeners.orientationChange, false);
            window.removeEventListener("resize", listeners.windowResize, false);
            var vendors = ["webkit", "moz", ""];
            vendors.forEach(function(prefix) {
              document.removeEventListener(prefix + "fullscreenchange", listeners.fullScreenChange, false);
              document.removeEventListener(prefix + "fullscreenerror", listeners.fullScreenError, false);
            });
            document.removeEventListener("MSFullscreenChange", listeners.fullScreenChange, false);
            document.removeEventListener("MSFullscreenError", listeners.fullScreenError, false);
          },
          destroy: function() {
            this.removeAllListeners();
            this.stopListeners();
            this.game = null;
            this.canvas = null;
            this.canvasBounds = null;
            this.parent = null;
            this.fullscreenTarget = null;
            this.parentSize.destroy();
            this.gameSize.destroy();
            this.baseSize.destroy();
            this.displaySize.destroy();
          },
          isFullscreen: {
            get: function() {
              return this.fullscreen.active;
            }
          },
          width: {
            get: function() {
              return this.gameSize.width;
            }
          },
          height: {
            get: function() {
              return this.gameSize.height;
            }
          },
          isPortrait: {
            get: function() {
              return this.orientation === CONST.ORIENTATION.PORTRAIT;
            }
          },
          isLandscape: {
            get: function() {
              return this.orientation === CONST.ORIENTATION.LANDSCAPE;
            }
          },
          isGamePortrait: {
            get: function() {
              return this.height > this.width;
            }
          },
          isGameLandscape: {
            get: function() {
              return this.width > this.height;
            }
          }
        });
        module2.exports = ScaleManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clamp = __webpack_require__(18);
        var Class = __webpack_require__(0);
        var SnapFloor = __webpack_require__(76);
        var Vector2 = __webpack_require__(3);
        var Size = new Class({
          initialize: function Size2(width, height, aspectMode, parent) {
            if (width === void 0) {
              width = 0;
            }
            if (height === void 0) {
              height = width;
            }
            if (aspectMode === void 0) {
              aspectMode = 0;
            }
            if (parent === void 0) {
              parent = null;
            }
            this._width = width;
            this._height = height;
            this._parent = parent;
            this.aspectMode = aspectMode;
            this.aspectRatio = height === 0 ? 1 : width / height;
            this.minWidth = 0;
            this.minHeight = 0;
            this.maxWidth = Number.MAX_VALUE;
            this.maxHeight = Number.MAX_VALUE;
            this.snapTo = new Vector2();
          },
          setAspectMode: function(value) {
            if (value === void 0) {
              value = 0;
            }
            this.aspectMode = value;
            return this.setSize(this._width, this._height);
          },
          setSnap: function(snapWidth, snapHeight) {
            if (snapWidth === void 0) {
              snapWidth = 0;
            }
            if (snapHeight === void 0) {
              snapHeight = snapWidth;
            }
            this.snapTo.set(snapWidth, snapHeight);
            return this.setSize(this._width, this._height);
          },
          setParent: function(parent) {
            this._parent = parent;
            return this.setSize(this._width, this._height);
          },
          setMin: function(width, height) {
            if (width === void 0) {
              width = 0;
            }
            if (height === void 0) {
              height = width;
            }
            this.minWidth = Clamp(width, 0, this.maxWidth);
            this.minHeight = Clamp(height, 0, this.maxHeight);
            return this.setSize(this._width, this._height);
          },
          setMax: function(width, height) {
            if (width === void 0) {
              width = Number.MAX_VALUE;
            }
            if (height === void 0) {
              height = width;
            }
            this.maxWidth = Clamp(width, this.minWidth, Number.MAX_VALUE);
            this.maxHeight = Clamp(height, this.minHeight, Number.MAX_VALUE);
            return this.setSize(this._width, this._height);
          },
          setSize: function(width, height) {
            if (width === void 0) {
              width = 0;
            }
            if (height === void 0) {
              height = width;
            }
            switch (this.aspectMode) {
              case Size.NONE:
                this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
                this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
                this.aspectRatio = this._height === 0 ? 1 : this._width / this._height;
                break;
              case Size.WIDTH_CONTROLS_HEIGHT:
                this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
                this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), false);
                break;
              case Size.HEIGHT_CONTROLS_WIDTH:
                this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
                this._width = this.getNewWidth(this._height * this.aspectRatio, false);
                break;
              case Size.FIT:
                this.constrain(width, height, true);
                break;
              case Size.ENVELOP:
                this.constrain(width, height, false);
                break;
            }
            return this;
          },
          setAspectRatio: function(ratio) {
            this.aspectRatio = ratio;
            return this.setSize(this._width, this._height);
          },
          resize: function(width, height) {
            this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
            this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
            this.aspectRatio = this._height === 0 ? 1 : this._width / this._height;
            return this;
          },
          getNewWidth: function(value, checkParent) {
            if (checkParent === void 0) {
              checkParent = true;
            }
            value = Clamp(value, this.minWidth, this.maxWidth);
            if (checkParent && this._parent && value > this._parent.width) {
              value = Math.max(this.minWidth, this._parent.width);
            }
            return value;
          },
          getNewHeight: function(value, checkParent) {
            if (checkParent === void 0) {
              checkParent = true;
            }
            value = Clamp(value, this.minHeight, this.maxHeight);
            if (checkParent && this._parent && value > this._parent.height) {
              value = Math.max(this.minHeight, this._parent.height);
            }
            return value;
          },
          constrain: function(width, height, fit) {
            if (width === void 0) {
              width = 0;
            }
            if (height === void 0) {
              height = width;
            }
            if (fit === void 0) {
              fit = true;
            }
            width = this.getNewWidth(width);
            height = this.getNewHeight(height);
            var snap = this.snapTo;
            var newRatio = height === 0 ? 1 : width / height;
            if (fit && this.aspectRatio > newRatio || !fit && this.aspectRatio < newRatio) {
              width = SnapFloor(width, snap.x);
              height = width / this.aspectRatio;
              if (snap.y > 0) {
                height = SnapFloor(height, snap.y);
                width = height * this.aspectRatio;
              }
            } else if (fit && this.aspectRatio < newRatio || !fit && this.aspectRatio > newRatio) {
              height = SnapFloor(height, snap.y);
              width = height * this.aspectRatio;
              if (snap.x > 0) {
                width = SnapFloor(width, snap.x);
                height = width * (1 / this.aspectRatio);
              }
            }
            this._width = width;
            this._height = height;
            return this;
          },
          fitTo: function(width, height) {
            return this.constrain(width, height, true);
          },
          envelop: function(width, height) {
            return this.constrain(width, height, false);
          },
          setWidth: function(value) {
            return this.setSize(value, this._height);
          },
          setHeight: function(value) {
            return this.setSize(this._width, value);
          },
          toString: function() {
            return "[{ Size (width=" + this._width + " height=" + this._height + " aspectRatio=" + this.aspectRatio + " aspectMode=" + this.aspectMode + ") }]";
          },
          setCSS: function(element) {
            if (element && element.style) {
              element.style.width = this._width + "px";
              element.style.height = this._height + "px";
            }
          },
          copy: function(destination) {
            destination.setAspectMode(this.aspectMode);
            destination.aspectRatio = this.aspectRatio;
            return destination.setSize(this.width, this.height);
          },
          destroy: function() {
            this._parent = null;
            this.snapTo = null;
          },
          width: {
            get: function() {
              return this._width;
            },
            set: function(value) {
              this.setSize(value, this._height);
            }
          },
          height: {
            get: function() {
              return this._height;
            },
            set: function(value) {
              this.setSize(this._width, value);
            }
          }
        });
        Size.NONE = 0;
        Size.WIDTH_CONTROLS_HEIGHT = 1;
        Size.HEIGHT_CONTROLS_WIDTH = 2;
        Size.FIT = 3;
        Size.ENVELOP = 4;
        module2.exports = Size;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(144);
        var Events = __webpack_require__(20);
        var GameEvents = __webpack_require__(22);
        var GetValue = __webpack_require__(6);
        var LoaderEvents = __webpack_require__(95);
        var NOOP = __webpack_require__(1);
        var Scene = __webpack_require__(418);
        var Systems = __webpack_require__(204);
        var SceneManager = new Class({
          initialize: function SceneManager2(game, sceneConfig) {
            this.game = game;
            this.keys = {};
            this.scenes = [];
            this._pending = [];
            this._start = [];
            this._queue = [];
            this._data = {};
            this.isProcessing = false;
            this.isBooted = false;
            this.customViewports = 0;
            if (sceneConfig) {
              if (!Array.isArray(sceneConfig)) {
                sceneConfig = [sceneConfig];
              }
              for (var i2 = 0; i2 < sceneConfig.length; i2++) {
                this._pending.push({
                  key: "default",
                  scene: sceneConfig[i2],
                  autoStart: i2 === 0,
                  data: {}
                });
              }
            }
            game.events.once(GameEvents.READY, this.bootQueue, this);
          },
          bootQueue: function() {
            if (this.isBooted) {
              return;
            }
            var i2;
            var entry;
            var key;
            var sceneConfig;
            for (i2 = 0; i2 < this._pending.length; i2++) {
              entry = this._pending[i2];
              key = entry.key;
              sceneConfig = entry.scene;
              var newScene;
              if (sceneConfig instanceof Scene) {
                newScene = this.createSceneFromInstance(key, sceneConfig);
              } else if (typeof sceneConfig === "object") {
                newScene = this.createSceneFromObject(key, sceneConfig);
              } else if (typeof sceneConfig === "function") {
                newScene = this.createSceneFromFunction(key, sceneConfig);
              }
              key = newScene.sys.settings.key;
              this.keys[key] = newScene;
              this.scenes.push(newScene);
              if (this._data[key]) {
                newScene.sys.settings.data = this._data[key].data;
                if (this._data[key].autoStart) {
                  entry.autoStart = true;
                }
              }
              if (entry.autoStart || newScene.sys.settings.active) {
                this._start.push(key);
              }
            }
            this._pending.length = 0;
            this._data = {};
            this.isBooted = true;
            for (i2 = 0; i2 < this._start.length; i2++) {
              entry = this._start[i2];
              this.start(entry);
            }
            this._start.length = 0;
          },
          processQueue: function() {
            var pendingLength = this._pending.length;
            var queueLength = this._queue.length;
            if (pendingLength === 0 && queueLength === 0) {
              return;
            }
            var i2;
            var entry;
            if (pendingLength) {
              for (i2 = 0; i2 < pendingLength; i2++) {
                entry = this._pending[i2];
                this.add(entry.key, entry.scene, entry.autoStart, entry.data);
              }
              for (i2 = 0; i2 < this._start.length; i2++) {
                entry = this._start[i2];
                this.start(entry);
              }
              this._start.length = 0;
              this._pending.length = 0;
              return;
            }
            for (i2 = 0; i2 < this._queue.length; i2++) {
              entry = this._queue[i2];
              this[entry.op](entry.keyA, entry.keyB);
            }
            this._queue.length = 0;
          },
          add: function(key, sceneConfig, autoStart, data) {
            if (autoStart === void 0) {
              autoStart = false;
            }
            if (data === void 0) {
              data = {};
            }
            if (this.isProcessing || !this.isBooted) {
              this._pending.push({
                key,
                scene: sceneConfig,
                autoStart,
                data
              });
              if (!this.isBooted) {
                this._data[key] = { data };
              }
              return null;
            }
            key = this.getKey(key, sceneConfig);
            var newScene;
            if (sceneConfig instanceof Scene) {
              newScene = this.createSceneFromInstance(key, sceneConfig);
            } else if (typeof sceneConfig === "object") {
              sceneConfig.key = key;
              newScene = this.createSceneFromObject(key, sceneConfig);
            } else if (typeof sceneConfig === "function") {
              newScene = this.createSceneFromFunction(key, sceneConfig);
            }
            newScene.sys.settings.data = data;
            key = newScene.sys.settings.key;
            this.keys[key] = newScene;
            this.scenes.push(newScene);
            if (autoStart || newScene.sys.settings.active) {
              if (this._pending.length) {
                this._start.push(key);
              } else {
                this.start(key);
              }
            }
            return newScene;
          },
          remove: function(key) {
            if (this.isProcessing) {
              this._queue.push({ op: "remove", keyA: key, keyB: null });
            } else {
              var sceneToRemove = this.getScene(key);
              if (!sceneToRemove || sceneToRemove.sys.isTransitioning()) {
                return this;
              }
              var index2 = this.scenes.indexOf(sceneToRemove);
              var sceneKey = sceneToRemove.sys.settings.key;
              if (index2 > -1) {
                delete this.keys[sceneKey];
                this.scenes.splice(index2, 1);
                if (this._start.indexOf(sceneKey) > -1) {
                  index2 = this._start.indexOf(sceneKey);
                  this._start.splice(index2, 1);
                }
                sceneToRemove.sys.destroy();
              }
            }
            return this;
          },
          bootScene: function(scene) {
            var sys = scene.sys;
            var settings = sys.settings;
            sys.sceneUpdate = NOOP;
            if (scene.init) {
              scene.init.call(scene, settings.data);
              settings.status = CONST.INIT;
              if (settings.isTransition) {
                sys.events.emit(Events.TRANSITION_INIT, settings.transitionFrom, settings.transitionDuration);
              }
            }
            var loader;
            if (sys.load) {
              loader = sys.load;
              loader.reset();
            }
            if (loader && scene.preload) {
              scene.preload.call(scene);
              if (loader.list.size === 0) {
                this.create(scene);
              } else {
                settings.status = CONST.LOADING;
                loader.once(LoaderEvents.COMPLETE, this.loadComplete, this);
                loader.start();
              }
            } else {
              this.create(scene);
            }
          },
          loadComplete: function(loader) {
            this.create(loader.scene);
          },
          payloadComplete: function(loader) {
            this.bootScene(loader.scene);
          },
          update: function(time, delta) {
            this.processQueue();
            this.isProcessing = true;
            for (var i2 = this.scenes.length - 1; i2 >= 0; i2--) {
              var sys = this.scenes[i2].sys;
              if (sys.settings.status > CONST.START && sys.settings.status <= CONST.RUNNING) {
                sys.step(time, delta);
              }
            }
          },
          render: function(renderer) {
            for (var i2 = 0; i2 < this.scenes.length; i2++) {
              var sys = this.scenes[i2].sys;
              if (sys.settings.visible && sys.settings.status >= CONST.LOADING && sys.settings.status < CONST.SLEEPING) {
                sys.render(renderer);
              }
            }
            this.isProcessing = false;
          },
          create: function(scene) {
            var sys = scene.sys;
            var settings = sys.settings;
            if (scene.create) {
              settings.status = CONST.CREATING;
              scene.create.call(scene, settings.data);
              if (settings.status === CONST.DESTROYED) {
                return;
              }
            }
            if (settings.isTransition) {
              sys.events.emit(Events.TRANSITION_START, settings.transitionFrom, settings.transitionDuration);
            }
            if (scene.update) {
              sys.sceneUpdate = scene.update;
            }
            settings.status = CONST.RUNNING;
            sys.events.emit(Events.CREATE, scene);
          },
          createSceneFromFunction: function(key, scene) {
            var newScene = new scene();
            if (newScene instanceof Scene) {
              var configKey = newScene.sys.settings.key;
              if (configKey !== "") {
                key = configKey;
              }
              if (this.keys.hasOwnProperty(key)) {
                throw new Error("Cannot add a Scene with duplicate key: " + key);
              }
              return this.createSceneFromInstance(key, newScene);
            } else {
              newScene.sys = new Systems(newScene);
              newScene.sys.settings.key = key;
              newScene.sys.init(this.game);
              return newScene;
            }
          },
          createSceneFromInstance: function(key, newScene) {
            var configKey = newScene.sys.settings.key;
            if (configKey === "") {
              newScene.sys.settings.key = key;
            }
            newScene.sys.init(this.game);
            return newScene;
          },
          createSceneFromObject: function(key, sceneConfig) {
            var newScene = new Scene(sceneConfig);
            var configKey = newScene.sys.settings.key;
            if (configKey !== "") {
              key = configKey;
            } else {
              newScene.sys.settings.key = key;
            }
            newScene.sys.init(this.game);
            var defaults = ["init", "preload", "create", "update", "render"];
            for (var i2 = 0; i2 < defaults.length; i2++) {
              var sceneCallback = GetValue(sceneConfig, defaults[i2], null);
              if (sceneCallback) {
                newScene[defaults[i2]] = sceneCallback;
              }
            }
            if (sceneConfig.hasOwnProperty("extend")) {
              for (var propertyKey in sceneConfig.extend) {
                if (!sceneConfig.extend.hasOwnProperty(propertyKey)) {
                  continue;
                }
                var value = sceneConfig.extend[propertyKey];
                if (propertyKey === "data" && newScene.hasOwnProperty("data") && typeof value === "object") {
                  newScene.data.merge(value);
                } else if (propertyKey !== "sys") {
                  newScene[propertyKey] = value;
                }
              }
            }
            return newScene;
          },
          getKey: function(key, sceneConfig) {
            if (!key) {
              key = "default";
            }
            if (typeof sceneConfig === "function") {
              return key;
            } else if (sceneConfig instanceof Scene) {
              key = sceneConfig.sys.settings.key;
            } else if (typeof sceneConfig === "object" && sceneConfig.hasOwnProperty("key")) {
              key = sceneConfig.key;
            }
            if (this.keys.hasOwnProperty(key)) {
              throw new Error("Cannot add a Scene with duplicate key: " + key);
            } else {
              return key;
            }
          },
          getScenes: function(isActive, inReverse) {
            if (isActive === void 0) {
              isActive = true;
            }
            if (inReverse === void 0) {
              inReverse = false;
            }
            var out = [];
            var scenes = this.scenes;
            for (var i2 = 0; i2 < scenes.length; i2++) {
              var scene = scenes[i2];
              if (scene && (!isActive || isActive && scene.sys.isActive())) {
                out.push(scene);
              }
            }
            return inReverse ? out.reverse() : out;
          },
          getScene: function(key) {
            if (typeof key === "string") {
              if (this.keys[key]) {
                return this.keys[key];
              }
            } else {
              for (var i2 = 0; i2 < this.scenes.length; i2++) {
                if (key === this.scenes[i2]) {
                  return key;
                }
              }
            }
            return null;
          },
          isActive: function(key) {
            var scene = this.getScene(key);
            if (scene) {
              return scene.sys.isActive();
            }
            return null;
          },
          isPaused: function(key) {
            var scene = this.getScene(key);
            if (scene) {
              return scene.sys.isPaused();
            }
            return null;
          },
          isVisible: function(key) {
            var scene = this.getScene(key);
            if (scene) {
              return scene.sys.isVisible();
            }
            return null;
          },
          isSleeping: function(key) {
            var scene = this.getScene(key);
            if (scene) {
              return scene.sys.isSleeping();
            }
            return null;
          },
          pause: function(key, data) {
            var scene = this.getScene(key);
            if (scene) {
              scene.sys.pause(data);
            }
            return this;
          },
          resume: function(key, data) {
            var scene = this.getScene(key);
            if (scene) {
              scene.sys.resume(data);
            }
            return this;
          },
          sleep: function(key, data) {
            var scene = this.getScene(key);
            if (scene && !scene.sys.isTransitioning()) {
              scene.sys.sleep(data);
            }
            return this;
          },
          wake: function(key, data) {
            var scene = this.getScene(key);
            if (scene) {
              scene.sys.wake(data);
            }
            return this;
          },
          run: function(key, data) {
            var scene = this.getScene(key);
            if (!scene) {
              for (var i2 = 0; i2 < this._pending.length; i2++) {
                if (this._pending[i2].key === key) {
                  this.queueOp("start", key, data);
                  break;
                }
              }
              return this;
            }
            if (scene.sys.isSleeping()) {
              scene.sys.wake(data);
            } else if (scene.sys.isPaused()) {
              scene.sys.resume(data);
            } else {
              this.start(key, data);
            }
          },
          start: function(key, data) {
            if (!this.isBooted) {
              this._data[key] = {
                autoStart: true,
                data
              };
              return this;
            }
            var scene = this.getScene(key);
            if (scene) {
              var sys = scene.sys;
              if (sys.isActive() || sys.isPaused()) {
                sys.shutdown();
                sys.sceneUpdate = NOOP;
                sys.start(data);
              } else {
                sys.sceneUpdate = NOOP;
                sys.start(data);
                var loader;
                if (sys.load) {
                  loader = sys.load;
                }
                if (loader && sys.settings.hasOwnProperty("pack")) {
                  loader.reset();
                  if (loader.addPack({ payload: sys.settings.pack })) {
                    sys.settings.status = CONST.LOADING;
                    loader.once(LoaderEvents.COMPLETE, this.payloadComplete, this);
                    loader.start();
                    return this;
                  }
                }
              }
              this.bootScene(scene);
            }
            return this;
          },
          stop: function(key, data) {
            var scene = this.getScene(key);
            if (scene && !scene.sys.isTransitioning()) {
              scene.sys.shutdown(data);
            }
            return this;
          },
          switch: function(from, to) {
            var sceneA = this.getScene(from);
            var sceneB = this.getScene(to);
            if (sceneA && sceneB && sceneA !== sceneB) {
              this.sleep(from);
              if (this.isSleeping(to)) {
                this.wake(to);
              } else {
                this.start(to);
              }
            }
            return this;
          },
          getAt: function(index2) {
            return this.scenes[index2];
          },
          getIndex: function(key) {
            var scene = this.getScene(key);
            return this.scenes.indexOf(scene);
          },
          bringToTop: function(key) {
            if (this.isProcessing) {
              this._queue.push({ op: "bringToTop", keyA: key, keyB: null });
            } else {
              var index2 = this.getIndex(key);
              if (index2 !== -1 && index2 < this.scenes.length) {
                var scene = this.getScene(key);
                this.scenes.splice(index2, 1);
                this.scenes.push(scene);
              }
            }
            return this;
          },
          sendToBack: function(key) {
            if (this.isProcessing) {
              this._queue.push({ op: "sendToBack", keyA: key, keyB: null });
            } else {
              var index2 = this.getIndex(key);
              if (index2 !== -1 && index2 > 0) {
                var scene = this.getScene(key);
                this.scenes.splice(index2, 1);
                this.scenes.unshift(scene);
              }
            }
            return this;
          },
          moveDown: function(key) {
            if (this.isProcessing) {
              this._queue.push({ op: "moveDown", keyA: key, keyB: null });
            } else {
              var indexA = this.getIndex(key);
              if (indexA > 0) {
                var indexB = indexA - 1;
                var sceneA = this.getScene(key);
                var sceneB = this.getAt(indexB);
                this.scenes[indexA] = sceneB;
                this.scenes[indexB] = sceneA;
              }
            }
            return this;
          },
          moveUp: function(key) {
            if (this.isProcessing) {
              this._queue.push({ op: "moveUp", keyA: key, keyB: null });
            } else {
              var indexA = this.getIndex(key);
              if (indexA < this.scenes.length - 1) {
                var indexB = indexA + 1;
                var sceneA = this.getScene(key);
                var sceneB = this.getAt(indexB);
                this.scenes[indexA] = sceneB;
                this.scenes[indexB] = sceneA;
              }
            }
            return this;
          },
          moveAbove: function(keyA, keyB) {
            if (keyA === keyB) {
              return this;
            }
            if (this.isProcessing) {
              this._queue.push({ op: "moveAbove", keyA, keyB });
            } else {
              var indexA = this.getIndex(keyA);
              var indexB = this.getIndex(keyB);
              if (indexA !== -1 && indexB !== -1) {
                var tempScene = this.getAt(indexB);
                this.scenes.splice(indexB, 1);
                this.scenes.splice(indexA + 1, 0, tempScene);
              }
            }
            return this;
          },
          moveBelow: function(keyA, keyB) {
            if (keyA === keyB) {
              return this;
            }
            if (this.isProcessing) {
              this._queue.push({ op: "moveBelow", keyA, keyB });
            } else {
              var indexA = this.getIndex(keyA);
              var indexB = this.getIndex(keyB);
              if (indexA !== -1 && indexB !== -1) {
                var tempScene = this.getAt(indexB);
                this.scenes.splice(indexB, 1);
                if (indexA === 0) {
                  this.scenes.unshift(tempScene);
                } else {
                  this.scenes.splice(indexA, 0, tempScene);
                }
              }
            }
            return this;
          },
          queueOp: function(op, keyA, keyB) {
            this._queue.push({ op, keyA, keyB });
            return this;
          },
          swapPosition: function(keyA, keyB) {
            if (keyA === keyB) {
              return this;
            }
            if (this.isProcessing) {
              this._queue.push({ op: "swapPosition", keyA, keyB });
            } else {
              var indexA = this.getIndex(keyA);
              var indexB = this.getIndex(keyB);
              if (indexA !== indexB && indexA !== -1 && indexB !== -1) {
                var tempScene = this.getAt(indexA);
                this.scenes[indexA] = this.scenes[indexB];
                this.scenes[indexB] = tempScene;
              }
            }
            return this;
          },
          dump: function() {
            var out = [];
            var map = ["pending", "init", "start", "loading", "creating", "running", "paused", "sleeping", "shutdown", "destroyed"];
            for (var i2 = 0; i2 < this.scenes.length; i2++) {
              var sys = this.scenes[i2].sys;
              var key = sys.settings.visible && (sys.settings.status === CONST.RUNNING || sys.settings.status === CONST.PAUSED) ? "[*] " : "[-] ";
              key += sys.settings.key + " (" + map[sys.settings.status] + ")";
              out.push(key);
            }
            console.log(out.join("\n"));
          },
          destroy: function() {
            for (var i2 = 0; i2 < this.scenes.length; i2++) {
              var sys = this.scenes[i2].sys;
              sys.destroy();
            }
            this.update = NOOP;
            this.scenes = [];
            this._pending = [];
            this._start = [];
            this._queue = [];
            this.game = null;
          }
        });
        module2.exports = SceneManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Systems = __webpack_require__(204);
        var Scene = new Class({
          initialize: function Scene2(config) {
            this.sys = new Systems(this, config);
            this.game;
            this.anims;
            this.cache;
            this.registry;
            this.sound;
            this.textures;
            this.events;
            this.cameras;
            this.add;
            this.make;
            this.scene;
            this.children;
            this.lights;
            this.data;
            this.input;
            this.load;
            this.time;
            this.tweens;
            this.physics;
            this.matter;
            this.scale;
            this.plugins;
            this.renderer;
          },
          update: function() {
          }
        });
        module2.exports = Scene;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetFastValue = __webpack_require__(2);
        var UppercaseFirst = __webpack_require__(205);
        var GetPhysicsPlugins = function(sys) {
          var defaultSystem = sys.game.config.defaultPhysicsSystem;
          var sceneSystems = GetFastValue(sys.settings, "physics", false);
          if (!defaultSystem && !sceneSystems) {
            return;
          }
          var output = [];
          if (defaultSystem) {
            output.push(UppercaseFirst(defaultSystem + "Physics"));
          }
          if (sceneSystems) {
            for (var key in sceneSystems) {
              key = UppercaseFirst(key.concat("Physics"));
              if (output.indexOf(key) === -1) {
                output.push(key);
              }
            }
          }
          return output;
        };
        module2.exports = GetPhysicsPlugins;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetFastValue = __webpack_require__(2);
        var GetScenePlugins = function(sys) {
          var defaultPlugins = sys.plugins.getDefaultScenePlugins();
          var scenePlugins = GetFastValue(sys.settings, "plugins", false);
          if (Array.isArray(scenePlugins)) {
            return scenePlugins;
          } else if (defaultPlugins) {
            return defaultPlugins;
          } else {
            return [];
          }
        };
        module2.exports = GetScenePlugins;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(144);
        var GetValue = __webpack_require__(6);
        var Merge = __webpack_require__(127);
        var InjectionMap = __webpack_require__(978);
        var Settings = {
          create: function(config) {
            if (typeof config === "string") {
              config = { key: config };
            } else if (config === void 0) {
              config = {};
            }
            return {
              status: CONST.PENDING,
              key: GetValue(config, "key", ""),
              active: GetValue(config, "active", false),
              visible: GetValue(config, "visible", true),
              isBooted: false,
              isTransition: false,
              transitionFrom: null,
              transitionDuration: 0,
              transitionAllowInput: true,
              data: {},
              pack: GetValue(config, "pack", false),
              cameras: GetValue(config, "cameras", null),
              map: GetValue(config, "map", Merge(InjectionMap, GetValue(config, "mapAdd", {}))),
              physics: GetValue(config, "physics", {}),
              loader: GetValue(config, "loader", {}),
              plugins: GetValue(config, "plugins", false),
              input: GetValue(config, "input", {})
            };
          }
        };
        module2.exports = Settings;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CanvasPool = __webpack_require__(31);
        var CanvasTexture = __webpack_require__(423);
        var Class = __webpack_require__(0);
        var Color = __webpack_require__(38);
        var CONST = __webpack_require__(33);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(106);
        var GameEvents = __webpack_require__(22);
        var GenerateTexture = __webpack_require__(388);
        var GetValue = __webpack_require__(6);
        var Parser = __webpack_require__(425);
        var Texture = __webpack_require__(206);
        var TextureManager = new Class({
          Extends: EventEmitter,
          initialize: function TextureManager2(game) {
            EventEmitter.call(this);
            this.game = game;
            this.name = "TextureManager";
            this.list = {};
            this._tempCanvas = CanvasPool.create2D(this, 1, 1);
            this._tempContext = this._tempCanvas.getContext("2d");
            this._pending = 0;
            game.events.once(GameEvents.BOOT, this.boot, this);
          },
          boot: function() {
            this._pending = 3;
            this.on(Events.LOAD, this.updatePending, this);
            this.on(Events.ERROR, this.updatePending, this);
            var config = this.game.config;
            this.addBase64("__DEFAULT", config.defaultImage);
            this.addBase64("__MISSING", config.missingImage);
            this.addBase64("__WHITE", config.whiteImage);
            this.game.events.once(GameEvents.DESTROY, this.destroy, this);
          },
          updatePending: function() {
            this._pending--;
            if (this._pending === 0) {
              this.off(Events.LOAD);
              this.off(Events.ERROR);
              this.emit(Events.READY);
            }
          },
          checkKey: function(key) {
            if (this.exists(key)) {
              console.error("Texture key already in use: " + key);
              return false;
            }
            return true;
          },
          remove: function(key) {
            if (typeof key === "string") {
              if (this.exists(key)) {
                key = this.get(key);
              } else {
                console.warn("No texture found matching key: " + key);
                return this;
              }
            }
            if (this.list.hasOwnProperty(key.key)) {
              key.destroy();
              this.emit(Events.REMOVE, key.key);
            }
            return this;
          },
          removeKey: function(key) {
            if (this.list.hasOwnProperty(key)) {
              delete this.list[key];
            }
            return this;
          },
          addBase64: function(key, data) {
            if (this.checkKey(key)) {
              var _this = this;
              var image = new Image();
              image.onerror = function() {
                _this.emit(Events.ERROR, key);
              };
              image.onload = function() {
                var texture = _this.create(key, image);
                Parser.Image(texture, 0);
                _this.emit(Events.ADD, key, texture);
                _this.emit(Events.LOAD, key, texture);
              };
              image.src = data;
            }
            return this;
          },
          getBase64: function(key, frame, type, encoderOptions) {
            if (type === void 0) {
              type = "image/png";
            }
            if (encoderOptions === void 0) {
              encoderOptions = 0.92;
            }
            var data = "";
            var textureFrame = this.getFrame(key, frame);
            if (textureFrame && (textureFrame.source.isRenderTexture || textureFrame.source.isGLTexture)) {
              console.warn("Cannot getBase64 from WebGL Texture");
            } else if (textureFrame) {
              var cd2 = textureFrame.canvasData;
              var canvas = CanvasPool.create2D(this, cd2.width, cd2.height);
              var ctx = canvas.getContext("2d");
              ctx.drawImage(textureFrame.source.image, cd2.x, cd2.y, cd2.width, cd2.height, 0, 0, cd2.width, cd2.height);
              data = canvas.toDataURL(type, encoderOptions);
              CanvasPool.remove(canvas);
            }
            return data;
          },
          addImage: function(key, source, dataSource) {
            var texture = null;
            if (this.checkKey(key)) {
              texture = this.create(key, source);
              Parser.Image(texture, 0);
              if (dataSource) {
                texture.setDataSource(dataSource);
              }
              this.emit(Events.ADD, key, texture);
            }
            return texture;
          },
          addGLTexture: function(key, glTexture, width, height) {
            var texture = null;
            if (this.checkKey(key)) {
              if (width === void 0) {
                width = glTexture.width;
              }
              if (height === void 0) {
                height = glTexture.height;
              }
              texture = this.create(key, glTexture, width, height);
              texture.add("__BASE", 0, 0, 0, width, height);
              this.emit(Events.ADD, key, texture);
            }
            return texture;
          },
          addRenderTexture: function(key, renderTexture) {
            var texture = null;
            if (this.checkKey(key)) {
              texture = this.create(key, renderTexture);
              texture.add("__BASE", 0, 0, 0, renderTexture.width, renderTexture.height);
              this.emit(Events.ADD, key, texture);
            }
            return texture;
          },
          generate: function(key, config) {
            if (this.checkKey(key)) {
              var canvas = CanvasPool.create(this, 1, 1);
              config.canvas = canvas;
              GenerateTexture(config);
              return this.addCanvas(key, canvas);
            } else {
              return null;
            }
          },
          createCanvas: function(key, width, height) {
            if (width === void 0) {
              width = 256;
            }
            if (height === void 0) {
              height = 256;
            }
            if (this.checkKey(key)) {
              var canvas = CanvasPool.create(this, width, height, CONST.CANVAS, true);
              return this.addCanvas(key, canvas);
            }
            return null;
          },
          addCanvas: function(key, source, skipCache) {
            if (skipCache === void 0) {
              skipCache = false;
            }
            var texture = null;
            if (skipCache) {
              texture = new CanvasTexture(this, key, source, source.width, source.height);
            } else if (this.checkKey(key)) {
              texture = new CanvasTexture(this, key, source, source.width, source.height);
              this.list[key] = texture;
              this.emit(Events.ADD, key, texture);
            }
            return texture;
          },
          addAtlas: function(key, source, data, dataSource) {
            if (Array.isArray(data.textures) || Array.isArray(data.frames)) {
              return this.addAtlasJSONArray(key, source, data, dataSource);
            } else {
              return this.addAtlasJSONHash(key, source, data, dataSource);
            }
          },
          addAtlasJSONArray: function(key, source, data, dataSource) {
            var texture = null;
            if (this.checkKey(key)) {
              texture = this.create(key, source);
              if (Array.isArray(data)) {
                var singleAtlasFile = data.length === 1;
                for (var i2 = 0; i2 < texture.source.length; i2++) {
                  var atlasData = singleAtlasFile ? data[0] : data[i2];
                  Parser.JSONArray(texture, i2, atlasData);
                }
              } else {
                Parser.JSONArray(texture, 0, data);
              }
              if (dataSource) {
                texture.setDataSource(dataSource);
              }
              this.emit(Events.ADD, key, texture);
            }
            return texture;
          },
          addAtlasJSONHash: function(key, source, data, dataSource) {
            var texture = null;
            if (this.checkKey(key)) {
              texture = this.create(key, source);
              if (Array.isArray(data)) {
                for (var i2 = 0; i2 < data.length; i2++) {
                  Parser.JSONHash(texture, i2, data[i2]);
                }
              } else {
                Parser.JSONHash(texture, 0, data);
              }
              if (dataSource) {
                texture.setDataSource(dataSource);
              }
              this.emit(Events.ADD, key, texture);
            }
            return texture;
          },
          addAtlasXML: function(key, source, data, dataSource) {
            var texture = null;
            if (this.checkKey(key)) {
              texture = this.create(key, source);
              Parser.AtlasXML(texture, 0, data);
              if (dataSource) {
                texture.setDataSource(dataSource);
              }
              this.emit(Events.ADD, key, texture);
            }
            return texture;
          },
          addUnityAtlas: function(key, source, data, dataSource) {
            var texture = null;
            if (this.checkKey(key)) {
              texture = this.create(key, source);
              Parser.UnityYAML(texture, 0, data);
              if (dataSource) {
                texture.setDataSource(dataSource);
              }
              this.emit(Events.ADD, key, texture);
            }
            return texture;
          },
          addSpriteSheet: function(key, source, config) {
            var texture = null;
            if (this.checkKey(key)) {
              texture = this.create(key, source);
              var width = texture.source[0].width;
              var height = texture.source[0].height;
              Parser.SpriteSheet(texture, 0, 0, 0, width, height, config);
              this.emit(Events.ADD, key, texture);
            }
            return texture;
          },
          addSpriteSheetFromAtlas: function(key, config) {
            if (!this.checkKey(key)) {
              return null;
            }
            var atlasKey = GetValue(config, "atlas", null);
            var atlasFrame = GetValue(config, "frame", null);
            if (!atlasKey || !atlasFrame) {
              return;
            }
            var atlas = this.get(atlasKey);
            var sheet = atlas.get(atlasFrame);
            if (sheet) {
              var texture = this.create(key, sheet.source.image);
              if (sheet.trimmed) {
                Parser.SpriteSheetFromAtlas(texture, sheet, config);
              } else {
                Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config);
              }
              this.emit(Events.ADD, key, texture);
              return texture;
            }
          },
          create: function(key, source, width, height) {
            var texture = null;
            if (this.checkKey(key)) {
              texture = new Texture(this, key, source, width, height);
              this.list[key] = texture;
            }
            return texture;
          },
          exists: function(key) {
            return this.list.hasOwnProperty(key);
          },
          get: function(key) {
            if (key === void 0) {
              key = "__DEFAULT";
            }
            if (this.list[key]) {
              return this.list[key];
            } else if (key instanceof Texture) {
              return key;
            } else {
              return this.list["__MISSING"];
            }
          },
          cloneFrame: function(key, frame) {
            if (this.list[key]) {
              return this.list[key].get(frame).clone();
            }
          },
          getFrame: function(key, frame) {
            if (this.list[key]) {
              return this.list[key].get(frame);
            }
          },
          getTextureKeys: function() {
            var output = [];
            for (var key in this.list) {
              if (key !== "__DEFAULT" && key !== "__MISSING") {
                output.push(key);
              }
            }
            return output;
          },
          getPixel: function(x2, y2, key, frame) {
            var textureFrame = this.getFrame(key, frame);
            if (textureFrame) {
              x2 -= textureFrame.x;
              y2 -= textureFrame.y;
              var data = textureFrame.data.cut;
              x2 += data.x;
              y2 += data.y;
              if (x2 >= data.x && x2 < data.r && y2 >= data.y && y2 < data.b) {
                var ctx = this._tempContext;
                ctx.clearRect(0, 0, 1, 1);
                ctx.drawImage(textureFrame.source.image, x2, y2, 1, 1, 0, 0, 1, 1);
                var rgb = ctx.getImageData(0, 0, 1, 1);
                return new Color(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
              }
            }
            return null;
          },
          getPixelAlpha: function(x2, y2, key, frame) {
            var textureFrame = this.getFrame(key, frame);
            if (textureFrame) {
              x2 -= textureFrame.x;
              y2 -= textureFrame.y;
              var data = textureFrame.data.cut;
              x2 += data.x;
              y2 += data.y;
              if (x2 >= data.x && x2 < data.r && y2 >= data.y && y2 < data.b) {
                var ctx = this._tempContext;
                ctx.clearRect(0, 0, 1, 1);
                ctx.drawImage(textureFrame.source.image, x2, y2, 1, 1, 0, 0, 1, 1);
                var rgb = ctx.getImageData(0, 0, 1, 1);
                return rgb.data[3];
              }
            }
            return null;
          },
          setTexture: function(gameObject, key, frame) {
            if (this.list[key]) {
              gameObject.texture = this.list[key];
              gameObject.frame = gameObject.texture.get(frame);
            }
            return gameObject;
          },
          renameTexture: function(currentKey, newKey) {
            var texture = this.get(currentKey);
            if (texture && currentKey !== newKey) {
              texture.key = newKey;
              this.list[newKey] = texture;
              delete this.list[currentKey];
              return true;
            }
            return false;
          },
          each: function(callback, scope) {
            var args = [null];
            for (var i2 = 1; i2 < arguments.length; i2++) {
              args.push(arguments[i2]);
            }
            for (var texture in this.list) {
              args[0] = this.list[texture];
              callback.apply(scope, args);
            }
          },
          destroy: function() {
            for (var texture in this.list) {
              this.list[texture].destroy();
            }
            this.list = {};
            this.game = null;
            CanvasPool.remove(this._tempCanvas);
          }
        });
        module2.exports = TextureManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Clamp = __webpack_require__(18);
        var Color = __webpack_require__(38);
        var CONST = __webpack_require__(33);
        var IsSizePowerOfTwo = __webpack_require__(138);
        var Texture = __webpack_require__(206);
        var CanvasTexture = new Class({
          Extends: Texture,
          initialize: function CanvasTexture2(manager, key, source, width, height) {
            Texture.call(this, manager, key, source, width, height);
            this.add("__BASE", 0, 0, 0, width, height);
            this._source = this.frames["__BASE"].source;
            this.canvas = this._source.image;
            this.context = this.canvas.getContext("2d");
            this.width = width;
            this.height = height;
            this.imageData = this.context.getImageData(0, 0, width, height);
            this.data = null;
            if (this.imageData) {
              this.data = this.imageData.data;
            }
            this.pixels = null;
            this.buffer;
            if (this.data) {
              if (this.imageData.data.buffer) {
                this.buffer = this.imageData.data.buffer;
                this.pixels = new Uint32Array(this.buffer);
              } else if (window.ArrayBuffer) {
                this.buffer = new ArrayBuffer(this.imageData.data.length);
                this.pixels = new Uint32Array(this.buffer);
              } else {
                this.pixels = this.imageData.data;
              }
            }
          },
          update: function() {
            this.imageData = this.context.getImageData(0, 0, this.width, this.height);
            this.data = this.imageData.data;
            if (this.imageData.data.buffer) {
              this.buffer = this.imageData.data.buffer;
              this.pixels = new Uint32Array(this.buffer);
            } else if (window.ArrayBuffer) {
              this.buffer = new ArrayBuffer(this.imageData.data.length);
              this.pixels = new Uint32Array(this.buffer);
            } else {
              this.pixels = this.imageData.data;
            }
            if (this.manager.game.config.renderType === CONST.WEBGL) {
              this.refresh();
            }
            return this;
          },
          draw: function(x2, y2, source) {
            this.context.drawImage(source, x2, y2);
            return this.update();
          },
          drawFrame: function(key, frame, x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            var textureFrame = this.manager.getFrame(key, frame);
            if (textureFrame) {
              var cd2 = textureFrame.canvasData;
              var width = textureFrame.cutWidth;
              var height = textureFrame.cutHeight;
              var res = textureFrame.source.resolution;
              this.context.drawImage(textureFrame.source.image, cd2.x, cd2.y, width, height, x2, y2, width / res, height / res);
              return this.update();
            } else {
              return this;
            }
          },
          setPixel: function(x2, y2, red, green, blue, alpha) {
            if (alpha === void 0) {
              alpha = 255;
            }
            x2 = Math.abs(Math.floor(x2));
            y2 = Math.abs(Math.floor(y2));
            var index2 = this.getIndex(x2, y2);
            if (index2 > -1) {
              var imageData = this.context.getImageData(x2, y2, 1, 1);
              imageData.data[0] = red;
              imageData.data[1] = green;
              imageData.data[2] = blue;
              imageData.data[3] = alpha;
              this.context.putImageData(imageData, x2, y2);
            }
            return this;
          },
          putData: function(imageData, x2, y2, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
            if (dirtyX === void 0) {
              dirtyX = 0;
            }
            if (dirtyY === void 0) {
              dirtyY = 0;
            }
            if (dirtyWidth === void 0) {
              dirtyWidth = imageData.width;
            }
            if (dirtyHeight === void 0) {
              dirtyHeight = imageData.height;
            }
            this.context.putImageData(imageData, x2, y2, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
            return this;
          },
          getData: function(x2, y2, width, height) {
            x2 = Clamp(Math.floor(x2), 0, this.width - 1);
            y2 = Clamp(Math.floor(y2), 0, this.height - 1);
            width = Clamp(width, 1, this.width - x2);
            height = Clamp(height, 1, this.height - y2);
            var imageData = this.context.getImageData(x2, y2, width, height);
            return imageData;
          },
          getPixel: function(x2, y2, out) {
            if (!out) {
              out = new Color();
            }
            var index2 = this.getIndex(x2, y2);
            if (index2 > -1) {
              var data = this.data;
              var r2 = data[index2 + 0];
              var g2 = data[index2 + 1];
              var b2 = data[index2 + 2];
              var a = data[index2 + 3];
              out.setTo(r2, g2, b2, a);
            }
            return out;
          },
          getPixels: function(x2, y2, width, height) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = this.width;
            }
            if (height === void 0) {
              height = width;
            }
            x2 = Math.abs(Math.round(x2));
            y2 = Math.abs(Math.round(y2));
            var left = Clamp(x2, 0, this.width);
            var right = Clamp(x2 + width, 0, this.width);
            var top = Clamp(y2, 0, this.height);
            var bottom = Clamp(y2 + height, 0, this.height);
            var pixel = new Color();
            var out = [];
            for (var py = top; py < bottom; py++) {
              var row = [];
              for (var px = left; px < right; px++) {
                pixel = this.getPixel(px, py, pixel);
                row.push({ x: px, y: py, color: pixel.color, alpha: pixel.alphaGL });
              }
              out.push(row);
            }
            return out;
          },
          getIndex: function(x2, y2) {
            x2 = Math.abs(Math.round(x2));
            y2 = Math.abs(Math.round(y2));
            if (x2 < this.width && y2 < this.height) {
              return (x2 + y2 * this.width) * 4;
            } else {
              return -1;
            }
          },
          refresh: function() {
            this._source.update();
            return this;
          },
          getCanvas: function() {
            return this.canvas;
          },
          getContext: function() {
            return this.context;
          },
          clear: function(x2, y2, width, height) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = this.width;
            }
            if (height === void 0) {
              height = this.height;
            }
            this.context.clearRect(x2, y2, width, height);
            return this.update();
          },
          setSize: function(width, height) {
            if (height === void 0) {
              height = width;
            }
            if (width !== this.width || height !== this.height) {
              this.canvas.width = width;
              this.canvas.height = height;
              this._source.width = width;
              this._source.height = height;
              this._source.isPowerOf2 = IsSizePowerOfTwo(width, height);
              this.frames["__BASE"].setSize(width, height, 0, 0);
              this.width = width;
              this.height = height;
              this.refresh();
            }
            return this;
          },
          destroy: function() {
            Texture.prototype.destroy.call(this);
            this._source = null;
            this.canvas = null;
            this.context = null;
            this.imageData = null;
            this.data = null;
            this.pixels = null;
            this.buffer = null;
          }
        });
        module2.exports = CanvasTexture;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CanvasPool = __webpack_require__(31);
        var Class = __webpack_require__(0);
        var IsSizePowerOfTwo = __webpack_require__(138);
        var ScaleModes = __webpack_require__(168);
        var TextureSource = new Class({
          initialize: function TextureSource2(texture, source, width, height, flipY) {
            if (flipY === void 0) {
              flipY = false;
            }
            var game = texture.manager.game;
            this.renderer = game.renderer;
            this.texture = texture;
            this.source = source;
            this.image = source;
            this.compressionAlgorithm = null;
            this.resolution = 1;
            this.width = width || source.naturalWidth || source.videoWidth || source.width || 0;
            this.height = height || source.naturalHeight || source.videoHeight || source.height || 0;
            this.scaleMode = ScaleModes.DEFAULT;
            this.isCanvas = source instanceof HTMLCanvasElement;
            this.isVideo = window.hasOwnProperty("HTMLVideoElement") && source instanceof HTMLVideoElement;
            this.isRenderTexture = source.type === "RenderTexture";
            this.isGLTexture = window.hasOwnProperty("WebGLTexture") && source instanceof WebGLTexture;
            this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);
            this.glTexture = null;
            this.glIndex = 0;
            this.glIndexCounter = -1;
            this.flipY = flipY;
            this.init(game);
          },
          init: function(game) {
            var renderer = this.renderer;
            if (renderer) {
              if (renderer.gl) {
                if (this.isCanvas) {
                  this.glTexture = renderer.createCanvasTexture(this.image, false, this.flipY);
                } else if (this.isVideo) {
                  this.glTexture = renderer.createVideoTexture(this.image, false, this.flipY);
                } else if (this.isRenderTexture) {
                  this.image = this.source.canvas;
                  this.glTexture = renderer.createTextureFromSource(null, this.width, this.height, this.scaleMode);
                } else if (this.isGLTexture) {
                  this.glTexture = this.source;
                } else {
                  this.glTexture = renderer.createTextureFromSource(this.image, this.width, this.height, this.scaleMode);
                }
              } else if (this.isRenderTexture) {
                this.image = this.source.canvas;
              }
            }
            if (!game.config.antialias) {
              this.setFilter(1);
            }
          },
          setFilter: function(filterMode) {
            if (this.renderer.gl) {
              this.renderer.setTextureFilter(this.glTexture, filterMode);
            }
            this.scaleMode = filterMode;
          },
          setFlipY: function(value) {
            if (value === void 0) {
              value = true;
            }
            this.flipY = value;
            return this;
          },
          update: function() {
            var gl2 = this.renderer.gl;
            if (gl2 && this.isCanvas) {
              this.glTexture = this.renderer.updateCanvasTexture(this.image, this.glTexture, this.flipY);
            } else if (gl2 && this.isVideo) {
              this.glTexture = this.renderer.updateVideoTexture(this.image, this.glTexture, this.flipY);
            }
          },
          destroy: function() {
            if (this.glTexture) {
              this.renderer.deleteTexture(this.glTexture, true);
            }
            if (this.isCanvas) {
              CanvasPool.remove(this.image);
            }
            this.renderer = null;
            this.texture = null;
            this.source = null;
            this.image = null;
            this.glTexture = null;
          }
        });
        module2.exports = TextureSource;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          AtlasXML: __webpack_require__(979),
          Canvas: __webpack_require__(980),
          Image: __webpack_require__(981),
          JSONArray: __webpack_require__(982),
          JSONHash: __webpack_require__(983),
          SpriteSheet: __webpack_require__(984),
          SpriteSheetFromAtlas: __webpack_require__(985),
          UnityYAML: __webpack_require__(986)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var HTML5AudioSoundManager = __webpack_require__(427);
        var NoAudioSoundManager = __webpack_require__(430);
        var WebAudioSoundManager = __webpack_require__(432);
        var SoundManagerCreator = {
          create: function(game) {
            var audioConfig = game.config.audio;
            var deviceAudio = game.device.audio;
            if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
              return new NoAudioSoundManager(game);
            }
            if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
              return new WebAudioSoundManager(game);
            }
            return new HTML5AudioSoundManager(game);
          }
        };
        module2.exports = SoundManagerCreator;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BaseSoundManager = __webpack_require__(145);
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(70);
        var HTML5AudioSound = __webpack_require__(429);
        var HTML5AudioSoundManager = new Class({
          Extends: BaseSoundManager,
          initialize: function HTML5AudioSoundManager2(game) {
            this.override = true;
            this.audioPlayDelay = 0.1;
            this.loopEndOffset = 0.05;
            this.onBlurPausedSounds = [];
            this.locked = "ontouchstart" in window;
            this.lockedActionsQueue = this.locked ? [] : null;
            this._mute = false;
            this._volume = 1;
            BaseSoundManager.call(this, game);
          },
          add: function(key, config) {
            var sound = new HTML5AudioSound(this, key, config);
            this.sounds.push(sound);
            return sound;
          },
          unlock: function() {
            this.locked = false;
            var _this = this;
            this.game.cache.audio.entries.each(function(key, tags) {
              for (var i2 = 0; i2 < tags.length; i2++) {
                if (tags[i2].dataset.locked === "true") {
                  _this.locked = true;
                  return false;
                }
              }
              return true;
            });
            if (!this.locked) {
              return;
            }
            var moved = false;
            var detectMove = function() {
              moved = true;
            };
            var unlock = function() {
              if (moved) {
                moved = false;
                return;
              }
              document.body.removeEventListener("touchmove", detectMove);
              document.body.removeEventListener("touchend", unlock);
              var lockedTags = [];
              _this.game.cache.audio.entries.each(function(key, tags) {
                for (var i2 = 0; i2 < tags.length; i2++) {
                  var tag = tags[i2];
                  if (tag.dataset.locked === "true") {
                    lockedTags.push(tag);
                  }
                }
                return true;
              });
              if (lockedTags.length === 0) {
                return;
              }
              var lastTag = lockedTags[lockedTags.length - 1];
              lastTag.oncanplaythrough = function() {
                lastTag.oncanplaythrough = null;
                lockedTags.forEach(function(tag) {
                  tag.dataset.locked = "false";
                });
                _this.unlocked = true;
              };
              lockedTags.forEach(function(tag) {
                tag.load();
              });
            };
            this.once(Events.UNLOCKED, function() {
              this.forEachActiveSound(function(sound) {
                if (sound.currentMarker === null && sound.duration === 0) {
                  sound.duration = sound.tags[0].duration;
                }
                sound.totalDuration = sound.tags[0].duration;
              });
              while (this.lockedActionsQueue.length) {
                var lockedAction = this.lockedActionsQueue.shift();
                if (lockedAction.sound[lockedAction.prop].apply) {
                  lockedAction.sound[lockedAction.prop].apply(lockedAction.sound, lockedAction.value || []);
                } else {
                  lockedAction.sound[lockedAction.prop] = lockedAction.value;
                }
              }
            }, this);
            document.body.addEventListener("touchmove", detectMove, false);
            document.body.addEventListener("touchend", unlock, false);
          },
          onBlur: function() {
            this.forEachActiveSound(function(sound) {
              if (sound.isPlaying) {
                this.onBlurPausedSounds.push(sound);
                sound.onBlur();
              }
            });
          },
          onFocus: function() {
            this.onBlurPausedSounds.forEach(function(sound) {
              sound.onFocus();
            });
            this.onBlurPausedSounds.length = 0;
          },
          destroy: function() {
            BaseSoundManager.prototype.destroy.call(this);
            this.onBlurPausedSounds.length = 0;
            this.onBlurPausedSounds = null;
          },
          isLocked: function(sound, prop, value) {
            if (sound.tags[0].dataset.locked === "true") {
              this.lockedActionsQueue.push({
                sound,
                prop,
                value
              });
              return true;
            }
            return false;
          },
          setMute: function(value) {
            this.mute = value;
            return this;
          },
          mute: {
            get: function() {
              return this._mute;
            },
            set: function(value) {
              this._mute = value;
              this.forEachActiveSound(function(sound) {
                sound.updateMute();
              });
              this.emit(Events.GLOBAL_MUTE, this, value);
            }
          },
          setVolume: function(value) {
            this.volume = value;
            return this;
          },
          volume: {
            get: function() {
              return this._volume;
            },
            set: function(value) {
              this._volume = value;
              this.forEachActiveSound(function(sound) {
                sound.updateVolume();
              });
              this.emit(Events.GLOBAL_VOLUME, this, value);
            }
          }
        });
        module2.exports = HTML5AudioSoundManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SafeRange = __webpack_require__(78);
        var GetFirst = function(array, property, value, startIndex, endIndex) {
          if (startIndex === void 0) {
            startIndex = 0;
          }
          if (endIndex === void 0) {
            endIndex = array.length;
          }
          if (SafeRange(array, startIndex, endIndex)) {
            for (var i2 = startIndex; i2 < endIndex; i2++) {
              var child = array[i2];
              if (!property || property && value === void 0 && child.hasOwnProperty(property) || property && value !== void 0 && child[property] === value) {
                return child;
              }
            }
          }
          return null;
        };
        module2.exports = GetFirst;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BaseSound = __webpack_require__(146);
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(70);
        var Clamp = __webpack_require__(18);
        var HTML5AudioSound = new Class({
          Extends: BaseSound,
          initialize: function HTML5AudioSound2(manager, key, config) {
            if (config === void 0) {
              config = {};
            }
            this.tags = manager.game.cache.audio.get(key);
            if (!this.tags) {
              throw new Error('There is no audio asset with key "' + key + '" in the audio cache');
            }
            this.audio = null;
            this.startTime = 0;
            this.previousTime = 0;
            this.duration = this.tags[0].duration;
            this.totalDuration = this.tags[0].duration;
            BaseSound.call(this, manager, key, config);
          },
          play: function(markerName, config) {
            if (this.manager.isLocked(this, "play", [markerName, config])) {
              return false;
            }
            if (!BaseSound.prototype.play.call(this, markerName, config)) {
              return false;
            }
            if (!this.pickAndPlayAudioTag()) {
              return false;
            }
            this.emit(Events.PLAY, this);
            return true;
          },
          pause: function() {
            if (this.manager.isLocked(this, "pause")) {
              return false;
            }
            if (this.startTime > 0) {
              return false;
            }
            if (!BaseSound.prototype.pause.call(this)) {
              return false;
            }
            this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
            this.stopAndReleaseAudioTag();
            this.emit(Events.PAUSE, this);
            return true;
          },
          resume: function() {
            if (this.manager.isLocked(this, "resume")) {
              return false;
            }
            if (this.startTime > 0) {
              return false;
            }
            if (!BaseSound.prototype.resume.call(this)) {
              return false;
            }
            if (!this.pickAndPlayAudioTag()) {
              return false;
            }
            this.emit(Events.RESUME, this);
            return true;
          },
          stop: function() {
            if (this.manager.isLocked(this, "stop")) {
              return false;
            }
            if (!BaseSound.prototype.stop.call(this)) {
              return false;
            }
            this.stopAndReleaseAudioTag();
            this.emit(Events.STOP, this);
            return true;
          },
          pickAndPlayAudioTag: function() {
            if (!this.pickAudioTag()) {
              this.reset();
              return false;
            }
            var seek = this.currentConfig.seek;
            var delay = this.currentConfig.delay;
            var offset = (this.currentMarker ? this.currentMarker.start : 0) + seek;
            this.previousTime = offset;
            this.audio.currentTime = offset;
            this.applyConfig();
            if (delay === 0) {
              this.startTime = 0;
              if (this.audio.paused) {
                this.playCatchPromise();
              }
            } else {
              this.startTime = window.performance.now() + delay * 1e3;
              if (!this.audio.paused) {
                this.audio.pause();
              }
            }
            this.resetConfig();
            return true;
          },
          pickAudioTag: function() {
            if (this.audio) {
              return true;
            }
            for (var i2 = 0; i2 < this.tags.length; i2++) {
              var audio = this.tags[i2];
              if (audio.dataset.used === "false") {
                audio.dataset.used = "true";
                this.audio = audio;
                return true;
              }
            }
            if (!this.manager.override) {
              return false;
            }
            var otherSounds = [];
            this.manager.forEachActiveSound(function(sound) {
              if (sound.key === this.key && sound.audio) {
                otherSounds.push(sound);
              }
            }, this);
            otherSounds.sort(function(a1, a2) {
              if (a1.loop === a2.loop) {
                return a2.seek / a2.duration - a1.seek / a1.duration;
              }
              return a1.loop ? 1 : -1;
            });
            var selectedSound = otherSounds[0];
            this.audio = selectedSound.audio;
            selectedSound.reset();
            selectedSound.audio = null;
            selectedSound.startTime = 0;
            selectedSound.previousTime = 0;
            return true;
          },
          playCatchPromise: function() {
            var playPromise = this.audio.play();
            if (playPromise) {
              playPromise.catch(function(reason) {
                console.warn(reason);
              });
            }
          },
          stopAndReleaseAudioTag: function() {
            this.startTime = 0;
            this.previousTime = 0;
            if (this.audio) {
              this.audio.pause();
              this.audio.dataset.used = "false";
              this.audio = null;
            }
          },
          reset: function() {
            BaseSound.prototype.stop.call(this);
          },
          onBlur: function() {
            this.isPlaying = false;
            this.isPaused = true;
            this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
            this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3);
            this.stopAndReleaseAudioTag();
          },
          onFocus: function() {
            this.isPlaying = true;
            this.isPaused = false;
            this.pickAndPlayAudioTag();
          },
          update: function(time) {
            if (!this.isPlaying) {
              return;
            }
            if (this.startTime > 0) {
              if (this.startTime < time - this.manager.audioPlayDelay) {
                this.audio.currentTime += Math.max(0, time - this.startTime) / 1e3;
                this.startTime = 0;
                this.previousTime = this.audio.currentTime;
                this.playCatchPromise();
              }
              return;
            }
            var startTime = this.currentMarker ? this.currentMarker.start : 0;
            var endTime = startTime + this.duration;
            var currentTime = this.audio.currentTime;
            if (this.currentConfig.loop) {
              if (currentTime >= endTime - this.manager.loopEndOffset) {
                this.audio.currentTime = startTime + Math.max(0, currentTime - endTime);
                currentTime = this.audio.currentTime;
              } else if (currentTime < startTime) {
                this.audio.currentTime += startTime;
                currentTime = this.audio.currentTime;
              }
              if (currentTime < this.previousTime) {
                this.emit(Events.LOOPED, this);
              }
            } else if (currentTime >= endTime) {
              this.reset();
              this.stopAndReleaseAudioTag();
              this.emit(Events.COMPLETE, this);
              return;
            }
            this.previousTime = currentTime;
          },
          destroy: function() {
            BaseSound.prototype.destroy.call(this);
            this.tags = null;
            if (this.audio) {
              this.stopAndReleaseAudioTag();
            }
          },
          updateMute: function() {
            if (this.audio) {
              this.audio.muted = this.currentConfig.mute || this.manager.mute;
            }
          },
          updateVolume: function() {
            if (this.audio) {
              this.audio.volume = Clamp(this.currentConfig.volume * this.manager.volume, 0, 1);
            }
          },
          calculateRate: function() {
            BaseSound.prototype.calculateRate.call(this);
            if (this.audio) {
              this.audio.playbackRate = this.totalRate;
            }
          },
          mute: {
            get: function() {
              return this.currentConfig.mute;
            },
            set: function(value) {
              this.currentConfig.mute = value;
              if (this.manager.isLocked(this, "mute", value)) {
                return;
              }
              this.updateMute();
              this.emit(Events.MUTE, this, value);
            }
          },
          setMute: function(value) {
            this.mute = value;
            return this;
          },
          volume: {
            get: function() {
              return this.currentConfig.volume;
            },
            set: function(value) {
              this.currentConfig.volume = value;
              if (this.manager.isLocked(this, "volume", value)) {
                return;
              }
              this.updateVolume();
              this.emit(Events.VOLUME, this, value);
            }
          },
          setVolume: function(value) {
            this.volume = value;
            return this;
          },
          rate: {
            get: function() {
              return this.currentConfig.rate;
            },
            set: function(value) {
              this.currentConfig.rate = value;
              if (this.manager.isLocked(this, Events.RATE, value)) {
                return;
              } else {
                this.calculateRate();
                this.emit(Events.RATE, this, value);
              }
            }
          },
          setRate: function(value) {
            this.rate = value;
            return this;
          },
          detune: {
            get: function() {
              return this.currentConfig.detune;
            },
            set: function(value) {
              this.currentConfig.detune = value;
              if (this.manager.isLocked(this, Events.DETUNE, value)) {
                return;
              } else {
                this.calculateRate();
                this.emit(Events.DETUNE, this, value);
              }
            }
          },
          setDetune: function(value) {
            this.detune = value;
            return this;
          },
          seek: {
            get: function() {
              if (this.isPlaying) {
                return this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
              } else if (this.isPaused) {
                return this.currentConfig.seek;
              } else {
                return 0;
              }
            },
            set: function(value) {
              if (this.manager.isLocked(this, "seek", value)) {
                return;
              }
              if (this.startTime > 0) {
                return;
              }
              if (this.isPlaying || this.isPaused) {
                value = Math.min(Math.max(0, value), this.duration);
                if (this.isPlaying) {
                  this.previousTime = value;
                  this.audio.currentTime = value;
                } else if (this.isPaused) {
                  this.currentConfig.seek = value;
                }
                this.emit(Events.SEEK, this, value);
              }
            }
          },
          setSeek: function(value) {
            this.seek = value;
            return this;
          },
          loop: {
            get: function() {
              return this.currentConfig.loop;
            },
            set: function(value) {
              this.currentConfig.loop = value;
              if (this.manager.isLocked(this, "loop", value)) {
                return;
              }
              if (this.audio) {
                this.audio.loop = value;
              }
              this.emit(Events.LOOP, this, value);
            }
          },
          setLoop: function(value) {
            this.loop = value;
            return this;
          },
          pan: {
            get: function() {
              return this.currentConfig.pan;
            },
            set: function(value) {
              this.currentConfig.pan = value;
              this.emit(Events.PAN, this, value);
            }
          },
          setPan: function(value) {
            this.pan = value;
            return this;
          }
        });
        module2.exports = HTML5AudioSound;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BaseSoundManager = __webpack_require__(145);
        var Class = __webpack_require__(0);
        var EventEmitter = __webpack_require__(9);
        var NoAudioSound = __webpack_require__(431);
        var NOOP = __webpack_require__(1);
        var NoAudioSoundManager = new Class({
          Extends: EventEmitter,
          initialize: function NoAudioSoundManager2(game) {
            EventEmitter.call(this);
            this.game = game;
            this.sounds = [];
            this.mute = false;
            this.volume = 1;
            this.rate = 1;
            this.detune = 0;
            this.pauseOnBlur = true;
            this.locked = false;
          },
          add: function(key, config) {
            var sound = new NoAudioSound(this, key, config);
            this.sounds.push(sound);
            return sound;
          },
          addAudioSprite: function(key, config) {
            var sound = this.add(key, config);
            sound.spritemap = {};
            return sound;
          },
          play: function(key, extra) {
            return false;
          },
          playAudioSprite: function(key, spriteName, config) {
            return false;
          },
          remove: function(sound) {
            return BaseSoundManager.prototype.remove.call(this, sound);
          },
          removeByKey: function(key) {
            return BaseSoundManager.prototype.removeByKey.call(this, key);
          },
          pauseAll: NOOP,
          resumeAll: NOOP,
          stopAll: NOOP,
          update: NOOP,
          setRate: NOOP,
          setDetune: NOOP,
          setMute: NOOP,
          setVolume: NOOP,
          forEachActiveSound: function(callbackfn, scope) {
            BaseSoundManager.prototype.forEachActiveSound.call(this, callbackfn, scope);
          },
          destroy: function() {
            BaseSoundManager.prototype.destroy.call(this);
          }
        });
        module2.exports = NoAudioSoundManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BaseSound = __webpack_require__(146);
        var Class = __webpack_require__(0);
        var EventEmitter = __webpack_require__(9);
        var Extend = __webpack_require__(17);
        var returnFalse = function() {
          return false;
        };
        var returnNull = function() {
          return null;
        };
        var returnThis = function() {
          return this;
        };
        var NoAudioSound = new Class({
          Extends: EventEmitter,
          initialize: function NoAudioSound2(manager, key, config) {
            if (config === void 0) {
              config = {};
            }
            EventEmitter.call(this);
            this.manager = manager;
            this.key = key;
            this.isPlaying = false;
            this.isPaused = false;
            this.totalRate = 1;
            this.duration = 0;
            this.totalDuration = 0;
            this.config = Extend({
              mute: false,
              volume: 1,
              rate: 1,
              detune: 0,
              seek: 0,
              loop: false,
              delay: 0,
              pan: 0
            }, config);
            this.currentConfig = this.config;
            this.mute = false;
            this.volume = 1;
            this.rate = 1;
            this.detune = 0;
            this.seek = 0;
            this.loop = false;
            this.pan = 0;
            this.markers = {};
            this.currentMarker = null;
            this.pendingRemove = false;
          },
          addMarker: returnFalse,
          updateMarker: returnFalse,
          removeMarker: returnNull,
          play: returnFalse,
          pause: returnFalse,
          resume: returnFalse,
          stop: returnFalse,
          destroy: function() {
            BaseSound.prototype.destroy.call(this);
          },
          setMute: returnThis,
          setVolume: returnThis,
          setRate: returnThis,
          setDetune: returnThis,
          setSeek: returnThis,
          setLoop: returnThis,
          setPan: returnThis
        });
        module2.exports = NoAudioSound;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Base64ToArrayBuffer = __webpack_require__(433);
        var BaseSoundManager = __webpack_require__(145);
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(70);
        var GameEvents = __webpack_require__(22);
        var WebAudioSound = __webpack_require__(434);
        var WebAudioSoundManager = new Class({
          Extends: BaseSoundManager,
          initialize: function WebAudioSoundManager2(game) {
            this.context = this.createAudioContext(game);
            this.masterMuteNode = this.context.createGain();
            this.masterVolumeNode = this.context.createGain();
            this.masterMuteNode.connect(this.masterVolumeNode);
            this.masterVolumeNode.connect(this.context.destination);
            this.destination = this.masterMuteNode;
            this.locked = this.context.state === "suspended" && ("ontouchstart" in window || "onclick" in window);
            BaseSoundManager.call(this, game);
            if (this.locked && game.isBooted) {
              this.unlock();
            } else {
              game.events.once(GameEvents.BOOT, this.unlock, this);
            }
          },
          createAudioContext: function(game) {
            var audioConfig = game.config.audio;
            if (audioConfig.context) {
              audioConfig.context.resume();
              return audioConfig.context;
            }
            if (window.hasOwnProperty("AudioContext")) {
              return new AudioContext();
            } else if (window.hasOwnProperty("webkitAudioContext")) {
              return new window.webkitAudioContext();
            }
          },
          setAudioContext: function(context) {
            if (this.context) {
              this.context.close();
            }
            if (this.masterMuteNode) {
              this.masterMuteNode.disconnect();
            }
            if (this.masterVolumeNode) {
              this.masterVolumeNode.disconnect();
            }
            this.context = context;
            this.masterMuteNode = context.createGain();
            this.masterVolumeNode = context.createGain();
            this.masterMuteNode.connect(this.masterVolumeNode);
            this.masterVolumeNode.connect(context.destination);
            this.destination = this.masterMuteNode;
            return this;
          },
          add: function(key, config) {
            var sound = new WebAudioSound(this, key, config);
            this.sounds.push(sound);
            return sound;
          },
          decodeAudio: function(audioKey, audioData) {
            var audioFiles;
            if (!Array.isArray(audioKey)) {
              audioFiles = [{ key: audioKey, data: audioData }];
            } else {
              audioFiles = audioKey;
            }
            var cache = this.game.cache.audio;
            var remaining = audioFiles.length;
            for (var i2 = 0; i2 < audioFiles.length; i2++) {
              var entry = audioFiles[i2];
              var key = entry.key;
              var data = entry.data;
              if (typeof data === "string") {
                data = Base64ToArrayBuffer(data);
              }
              var success = function(key2, audioBuffer) {
                cache.add(key2, audioBuffer);
                this.emit(Events.DECODED, key2);
                remaining--;
                if (remaining === 0) {
                  this.emit(Events.DECODED_ALL);
                }
              }.bind(this, key);
              var failure = function(key2, error) {
                console.error("Error decoding audio: " + key2 + " - ", error ? error.message : "");
                remaining--;
                if (remaining === 0) {
                  this.emit(Events.DECODED_ALL);
                }
              }.bind(this, key);
              this.context.decodeAudioData(data, success, failure);
            }
          },
          unlock: function() {
            var _this = this;
            var body = document.body;
            var unlockHandler = function unlockHandler2() {
              if (_this.context && body) {
                var bodyRemove = body.removeEventListener;
                _this.context.resume().then(function() {
                  bodyRemove("touchstart", unlockHandler2);
                  bodyRemove("touchend", unlockHandler2);
                  bodyRemove("click", unlockHandler2);
                  bodyRemove("keydown", unlockHandler2);
                  _this.unlocked = true;
                }, function() {
                  bodyRemove("touchstart", unlockHandler2);
                  bodyRemove("touchend", unlockHandler2);
                  bodyRemove("click", unlockHandler2);
                  bodyRemove("keydown", unlockHandler2);
                });
              }
            };
            if (body) {
              body.addEventListener("touchstart", unlockHandler, false);
              body.addEventListener("touchend", unlockHandler, false);
              body.addEventListener("click", unlockHandler, false);
              body.addEventListener("keydown", unlockHandler, false);
            }
          },
          onBlur: function() {
            if (!this.locked) {
              this.context.suspend();
            }
          },
          onFocus: function() {
            var context = this.context;
            if ((context.state === "suspended" || context.state === "interrupted") && !this.locked) {
              context.resume();
            }
          },
          update: function(time, delta) {
            BaseSoundManager.prototype.update.call(this, time, delta);
            var context = this.context;
            if (context && context.state === "interrupted") {
              context.resume();
            }
          },
          destroy: function() {
            this.destination = null;
            this.masterVolumeNode.disconnect();
            this.masterVolumeNode = null;
            this.masterMuteNode.disconnect();
            this.masterMuteNode = null;
            if (this.game.config.audio.context) {
              this.context.suspend();
            } else {
              var _this = this;
              this.context.close().then(function() {
                _this.context = null;
              });
            }
            BaseSoundManager.prototype.destroy.call(this);
          },
          setMute: function(value) {
            this.mute = value;
            return this;
          },
          mute: {
            get: function() {
              return this.masterMuteNode.gain.value === 0;
            },
            set: function(value) {
              this.masterMuteNode.gain.setValueAtTime(value ? 0 : 1, 0);
              this.emit(Events.GLOBAL_MUTE, this, value);
            }
          },
          setVolume: function(value) {
            this.volume = value;
            return this;
          },
          volume: {
            get: function() {
              return this.masterVolumeNode.gain.value;
            },
            set: function(value) {
              this.masterVolumeNode.gain.setValueAtTime(value, 0);
              this.emit(Events.GLOBAL_VOLUME, this, value);
            }
          }
        });
        module2.exports = WebAudioSoundManager;
      },
      function(module2, exports2) {
        /**
         * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup = new Uint8Array(256);
        for (var i2 = 0; i2 < chars.length; i2++) {
          lookup[chars.charCodeAt(i2)] = i2;
        }
        var Base64ToArrayBuffer = function(base64) {
          base64 = base64.substr(base64.indexOf(",") + 1);
          var len = base64.length;
          var bufferLength = len * 0.75;
          var p2 = 0;
          var encoded1;
          var encoded2;
          var encoded3;
          var encoded4;
          if (base64[len - 1] === "=") {
            bufferLength--;
            if (base64[len - 2] === "=") {
              bufferLength--;
            }
          }
          var arrayBuffer = new ArrayBuffer(bufferLength);
          var bytes = new Uint8Array(arrayBuffer);
          for (var i3 = 0; i3 < len; i3 += 4) {
            encoded1 = lookup[base64.charCodeAt(i3)];
            encoded2 = lookup[base64.charCodeAt(i3 + 1)];
            encoded3 = lookup[base64.charCodeAt(i3 + 2)];
            encoded4 = lookup[base64.charCodeAt(i3 + 3)];
            bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return arrayBuffer;
        };
        module2.exports = Base64ToArrayBuffer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BaseSound = __webpack_require__(146);
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(70);
        var WebAudioSound = new Class({
          Extends: BaseSound,
          initialize: function WebAudioSound2(manager, key, config) {
            if (config === void 0) {
              config = {};
            }
            this.audioBuffer = manager.game.cache.audio.get(key);
            if (!this.audioBuffer) {
              throw new Error('Audio key "' + key + '" missing from cache');
            }
            this.source = null;
            this.loopSource = null;
            this.muteNode = manager.context.createGain();
            this.volumeNode = manager.context.createGain();
            this.pannerNode = null;
            this.playTime = 0;
            this.startTime = 0;
            this.loopTime = 0;
            this.rateUpdates = [];
            this.hasEnded = false;
            this.hasLooped = false;
            this.muteNode.connect(this.volumeNode);
            if (manager.context.createStereoPanner) {
              this.pannerNode = manager.context.createStereoPanner();
              this.volumeNode.connect(this.pannerNode);
              this.pannerNode.connect(manager.destination);
            } else {
              this.volumeNode.connect(manager.destination);
            }
            this.duration = this.audioBuffer.duration;
            this.totalDuration = this.audioBuffer.duration;
            BaseSound.call(this, manager, key, config);
          },
          play: function(markerName, config) {
            if (!BaseSound.prototype.play.call(this, markerName, config)) {
              return false;
            }
            this.stopAndRemoveBufferSource();
            this.createAndStartBufferSource();
            this.emit(Events.PLAY, this);
            return true;
          },
          pause: function() {
            if (this.manager.context.currentTime < this.startTime) {
              return false;
            }
            if (!BaseSound.prototype.pause.call(this)) {
              return false;
            }
            this.currentConfig.seek = this.getCurrentTime();
            this.stopAndRemoveBufferSource();
            this.emit(Events.PAUSE, this);
            return true;
          },
          resume: function() {
            if (this.manager.context.currentTime < this.startTime) {
              return false;
            }
            if (!BaseSound.prototype.resume.call(this)) {
              return false;
            }
            this.createAndStartBufferSource();
            this.emit(Events.RESUME, this);
            return true;
          },
          stop: function() {
            if (!BaseSound.prototype.stop.call(this)) {
              return false;
            }
            this.stopAndRemoveBufferSource();
            this.emit(Events.STOP, this);
            return true;
          },
          createAndStartBufferSource: function() {
            var seek = this.currentConfig.seek;
            var delay = this.currentConfig.delay;
            var when = this.manager.context.currentTime + delay;
            var offset = (this.currentMarker ? this.currentMarker.start : 0) + seek;
            var duration = this.duration - seek;
            this.playTime = when - seek;
            this.startTime = when;
            this.source = this.createBufferSource();
            this.applyConfig();
            this.source.start(Math.max(0, when), Math.max(0, offset), Math.max(0, duration));
            this.resetConfig();
          },
          createAndStartLoopBufferSource: function() {
            var when = this.getLoopTime();
            var offset = this.currentMarker ? this.currentMarker.start : 0;
            var duration = this.duration;
            this.loopTime = when;
            this.loopSource = this.createBufferSource();
            this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0);
            this.loopSource.start(Math.max(0, when), Math.max(0, offset), Math.max(0, duration));
          },
          createBufferSource: function() {
            var _this = this;
            var source = this.manager.context.createBufferSource();
            source.buffer = this.audioBuffer;
            source.connect(this.muteNode);
            source.onended = function(ev) {
              if (ev.target === _this.source) {
                if (_this.currentConfig.loop) {
                  _this.hasLooped = true;
                } else {
                  _this.hasEnded = true;
                }
              }
            };
            return source;
          },
          stopAndRemoveBufferSource: function() {
            if (this.source) {
              this.source.stop();
              this.source.disconnect();
              this.source = null;
            }
            this.playTime = 0;
            this.startTime = 0;
            this.stopAndRemoveLoopBufferSource();
          },
          stopAndRemoveLoopBufferSource: function() {
            if (this.loopSource) {
              this.loopSource.stop();
              this.loopSource.disconnect();
              this.loopSource = null;
            }
            this.loopTime = 0;
          },
          applyConfig: function() {
            this.rateUpdates.length = 0;
            this.rateUpdates.push({
              time: 0,
              rate: 1
            });
            BaseSound.prototype.applyConfig.call(this);
          },
          update: function() {
            if (this.hasEnded) {
              this.hasEnded = false;
              BaseSound.prototype.stop.call(this);
              this.stopAndRemoveBufferSource();
              this.emit(Events.COMPLETE, this);
            } else if (this.hasLooped) {
              this.hasLooped = false;
              this.source = this.loopSource;
              this.loopSource = null;
              this.playTime = this.startTime = this.loopTime;
              this.rateUpdates.length = 0;
              this.rateUpdates.push({
                time: 0,
                rate: this.totalRate
              });
              this.createAndStartLoopBufferSource();
              this.emit(Events.LOOPED, this);
            }
          },
          destroy: function() {
            BaseSound.prototype.destroy.call(this);
            this.audioBuffer = null;
            this.stopAndRemoveBufferSource();
            this.muteNode.disconnect();
            this.muteNode = null;
            this.volumeNode.disconnect();
            this.volumeNode = null;
            if (this.pannerNode) {
              this.pannerNode.disconnect();
              this.pannerNode = null;
            }
            this.rateUpdates.length = 0;
            this.rateUpdates = null;
          },
          calculateRate: function() {
            BaseSound.prototype.calculateRate.call(this);
            var now = this.manager.context.currentTime;
            if (this.source && typeof this.totalRate === "number") {
              this.source.playbackRate.setValueAtTime(this.totalRate, now);
            }
            if (this.isPlaying) {
              this.rateUpdates.push({
                time: Math.max(this.startTime, now) - this.playTime,
                rate: this.totalRate
              });
              if (this.loopSource) {
                this.stopAndRemoveLoopBufferSource();
                this.createAndStartLoopBufferSource();
              }
            }
          },
          getCurrentTime: function() {
            var currentTime = 0;
            for (var i2 = 0; i2 < this.rateUpdates.length; i2++) {
              var nextTime = 0;
              if (i2 < this.rateUpdates.length - 1) {
                nextTime = this.rateUpdates[i2 + 1].time;
              } else {
                nextTime = this.manager.context.currentTime - this.playTime;
              }
              currentTime += (nextTime - this.rateUpdates[i2].time) * this.rateUpdates[i2].rate;
            }
            return currentTime;
          },
          getLoopTime: function() {
            var lastRateUpdateCurrentTime = 0;
            for (var i2 = 0; i2 < this.rateUpdates.length - 1; i2++) {
              lastRateUpdateCurrentTime += (this.rateUpdates[i2 + 1].time - this.rateUpdates[i2].time) * this.rateUpdates[i2].rate;
            }
            var lastRateUpdate = this.rateUpdates[this.rateUpdates.length - 1];
            return this.playTime + lastRateUpdate.time + (this.duration - lastRateUpdateCurrentTime) / lastRateUpdate.rate;
          },
          rate: {
            get: function() {
              return this.currentConfig.rate;
            },
            set: function(value) {
              this.currentConfig.rate = value;
              this.calculateRate();
              this.emit(Events.RATE, this, value);
            }
          },
          setRate: function(value) {
            this.rate = value;
            return this;
          },
          detune: {
            get: function() {
              return this.currentConfig.detune;
            },
            set: function(value) {
              this.currentConfig.detune = value;
              this.calculateRate();
              this.emit(Events.DETUNE, this, value);
            }
          },
          setDetune: function(value) {
            this.detune = value;
            return this;
          },
          mute: {
            get: function() {
              return this.muteNode.gain.value === 0;
            },
            set: function(value) {
              this.currentConfig.mute = value;
              this.muteNode.gain.setValueAtTime(value ? 0 : 1, 0);
              this.emit(Events.MUTE, this, value);
            }
          },
          setMute: function(value) {
            this.mute = value;
            return this;
          },
          volume: {
            get: function() {
              return this.volumeNode.gain.value;
            },
            set: function(value) {
              this.currentConfig.volume = value;
              this.volumeNode.gain.setValueAtTime(value, 0);
              this.emit(Events.VOLUME, this, value);
            }
          },
          setVolume: function(value) {
            this.volume = value;
            return this;
          },
          seek: {
            get: function() {
              if (this.isPlaying) {
                if (this.manager.context.currentTime < this.startTime) {
                  return this.startTime - this.playTime;
                }
                return this.getCurrentTime();
              } else if (this.isPaused) {
                return this.currentConfig.seek;
              } else {
                return 0;
              }
            },
            set: function(value) {
              if (this.manager.context.currentTime < this.startTime) {
                return;
              }
              if (this.isPlaying || this.isPaused) {
                value = Math.min(Math.max(0, value), this.duration);
                this.currentConfig.seek = value;
                if (this.isPlaying) {
                  this.stopAndRemoveBufferSource();
                  this.createAndStartBufferSource();
                }
                this.emit(Events.SEEK, this, value);
              }
            }
          },
          setSeek: function(value) {
            this.seek = value;
            return this;
          },
          loop: {
            get: function() {
              return this.currentConfig.loop;
            },
            set: function(value) {
              this.currentConfig.loop = value;
              if (this.isPlaying) {
                this.stopAndRemoveLoopBufferSource();
                if (value) {
                  this.createAndStartLoopBufferSource();
                }
              }
              this.emit(Events.LOOP, this, value);
            }
          },
          setLoop: function(value) {
            this.loop = value;
            return this;
          },
          pan: {
            get: function() {
              if (this.pannerNode) {
                return this.pannerNode.pan.value;
              } else {
                return 0;
              }
            },
            set: function(value) {
              this.currentConfig.pan = value;
              if (this.pannerNode) {
                this.pannerNode.pan.setValueAtTime(value, this.manager.context.currentTime);
              }
              this.emit(Events.PAN, this, value);
            }
          },
          setPan: function(value) {
            this.pan = value;
            return this;
          }
        });
        module2.exports = WebAudioSound;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TransposeMatrix = function(array) {
          var sourceRowCount = array.length;
          var sourceColCount = array[0].length;
          var result = new Array(sourceColCount);
          for (var i2 = 0; i2 < sourceColCount; i2++) {
            result[i2] = new Array(sourceRowCount);
            for (var j = sourceRowCount - 1; j > -1; j--) {
              result[i2][j] = array[j][i2];
            }
          }
          return result;
        };
        module2.exports = TransposeMatrix;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        function swap(arr, i2, j) {
          var tmp = arr[i2];
          arr[i2] = arr[j];
          arr[j] = tmp;
        }
        function defaultCompare(a, b2) {
          return a < b2 ? -1 : a > b2 ? 1 : 0;
        }
        var QuickSelect = function(arr, k2, left, right, compare) {
          if (left === void 0) {
            left = 0;
          }
          if (right === void 0) {
            right = arr.length - 1;
          }
          if (compare === void 0) {
            compare = defaultCompare;
          }
          while (right > left) {
            if (right - left > 600) {
              var n2 = right - left + 1;
              var m2 = k2 - left + 1;
              var z2 = Math.log(n2);
              var s = 0.5 * Math.exp(2 * z2 / 3);
              var sd2 = 0.5 * Math.sqrt(z2 * s * (n2 - s) / n2) * (m2 - n2 / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k2 - m2 * s / n2 + sd2));
              var newRight = Math.min(right, Math.floor(k2 + (n2 - m2) * s / n2 + sd2));
              QuickSelect(arr, k2, newLeft, newRight, compare);
            }
            var t2 = arr[k2];
            var i2 = left;
            var j = right;
            swap(arr, left, k2);
            if (compare(arr[right], t2) > 0) {
              swap(arr, left, right);
            }
            while (i2 < j) {
              swap(arr, i2, j);
              i2++;
              j--;
              while (compare(arr[i2], t2) < 0) {
                i2++;
              }
              while (compare(arr[j], t2) > 0) {
                j--;
              }
            }
            if (compare(arr[left], t2) === 0) {
              swap(arr, left, j);
            } else {
              j++;
              swap(arr, j, right);
            }
            if (j <= k2) {
              left = j + 1;
            }
            if (k2 <= j) {
              right = j - 1;
            }
          }
        };
        module2.exports = QuickSelect;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetValue = __webpack_require__(6);
        var Shuffle = __webpack_require__(131);
        var BuildChunk = function(a, b2, qty) {
          var out = [];
          for (var aIndex = 0; aIndex < a.length; aIndex++) {
            for (var bIndex = 0; bIndex < b2.length; bIndex++) {
              for (var i2 = 0; i2 < qty; i2++) {
                out.push({ a: a[aIndex], b: b2[bIndex] });
              }
            }
          }
          return out;
        };
        var Range = function(a, b2, options) {
          var max = GetValue(options, "max", 0);
          var qty = GetValue(options, "qty", 1);
          var random = GetValue(options, "random", false);
          var randomB = GetValue(options, "randomB", false);
          var repeat = GetValue(options, "repeat", 0);
          var yoyo = GetValue(options, "yoyo", false);
          var out = [];
          if (randomB) {
            Shuffle(b2);
          }
          if (repeat === -1) {
            if (max === 0) {
              repeat = 0;
            } else {
              var total = a.length * b2.length * qty;
              if (yoyo) {
                total *= 2;
              }
              repeat = Math.ceil(max / total);
            }
          }
          for (var i2 = 0; i2 <= repeat; i2++) {
            var chunk = BuildChunk(a, b2, qty);
            if (random) {
              Shuffle(chunk);
            }
            out = out.concat(chunk);
            if (yoyo) {
              chunk.reverse();
              out = out.concat(chunk);
            }
          }
          if (max) {
            out.splice(max);
          }
          return out;
        };
        module2.exports = Range;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          PROCESS_QUEUE_ADD: __webpack_require__(1041),
          PROCESS_QUEUE_REMOVE: __webpack_require__(1042)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetAdvancedValue = __webpack_require__(13);
        var BuildGameObjectAnimation = function(sprite, config) {
          var animConfig = GetAdvancedValue(config, "anims", null);
          if (animConfig === null) {
            return sprite;
          }
          if (typeof animConfig === "string") {
            sprite.anims.play(animConfig);
          } else if (typeof animConfig === "object") {
            var anims = sprite.anims;
            var key = GetAdvancedValue(animConfig, "key", void 0);
            if (key) {
              var startFrame = GetAdvancedValue(animConfig, "startFrame", void 0);
              var delay = GetAdvancedValue(animConfig, "delay", 0);
              var repeat = GetAdvancedValue(animConfig, "repeat", 0);
              var repeatDelay = GetAdvancedValue(animConfig, "repeatDelay", 0);
              var yoyo = GetAdvancedValue(animConfig, "yoyo", false);
              var play = GetAdvancedValue(animConfig, "play", false);
              var delayedPlay = GetAdvancedValue(animConfig, "delayedPlay", 0);
              var playConfig = {
                key,
                delay,
                repeat,
                repeatDelay,
                yoyo,
                startFrame
              };
              if (play) {
                anims.play(playConfig);
              } else if (delayedPlay > 0) {
                anims.playAfterDelay(playConfig, delayedPlay);
              } else {
                anims.load(playConfig);
              }
            }
          }
          return sprite;
        };
        module2.exports = BuildGameObjectAnimation;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Frame = __webpack_require__(109);
        var Bob = new Class({
          initialize: function Bob2(blitter, x2, y2, frame, visible) {
            this.parent = blitter;
            this.x = x2;
            this.y = y2;
            this.frame = frame;
            this.data = {};
            this.tint = 16777215;
            this._visible = visible;
            this._alpha = 1;
            this.flipX = false;
            this.flipY = false;
          },
          setFrame: function(frame) {
            if (frame === void 0) {
              this.frame = this.parent.frame;
            } else if (frame instanceof Frame && frame.texture === this.parent.texture) {
              this.frame = frame;
            } else {
              this.frame = this.parent.texture.get(frame);
            }
            return this;
          },
          resetFlip: function() {
            this.flipX = false;
            this.flipY = false;
            return this;
          },
          reset: function(x2, y2, frame) {
            this.x = x2;
            this.y = y2;
            this.flipX = false;
            this.flipY = false;
            this._alpha = 1;
            this._visible = true;
            this.parent.dirty = true;
            if (frame) {
              this.setFrame(frame);
            }
            return this;
          },
          setPosition: function(x2, y2) {
            this.x = x2;
            this.y = y2;
            return this;
          },
          setFlipX: function(value) {
            this.flipX = value;
            return this;
          },
          setFlipY: function(value) {
            this.flipY = value;
            return this;
          },
          setFlip: function(x2, y2) {
            this.flipX = x2;
            this.flipY = y2;
            return this;
          },
          setVisible: function(value) {
            this.visible = value;
            return this;
          },
          setAlpha: function(value) {
            this.alpha = value;
            return this;
          },
          setTint: function(value) {
            this.tint = value;
            return this;
          },
          destroy: function() {
            this.parent.dirty = true;
            this.parent.children.remove(this);
            this.parent = void 0;
            this.frame = void 0;
            this.data = void 0;
          },
          visible: {
            get: function() {
              return this._visible;
            },
            set: function(value) {
              this.parent.dirty |= this._visible !== value;
              this._visible = value;
            }
          },
          alpha: {
            get: function() {
              return this._alpha;
            },
            set: function(value) {
              this.parent.dirty |= this._alpha > 0 !== value > 0;
              this._alpha = value;
            }
          }
        });
        module2.exports = Bob;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rectangle = __webpack_require__(10);
        var Union = function(rectA, rectB, out) {
          if (out === void 0) {
            out = new Rectangle();
          }
          var x2 = Math.min(rectA.x, rectB.x);
          var y2 = Math.min(rectA.y, rectB.y);
          var w2 = Math.max(rectA.right, rectB.right) - x2;
          var h2 = Math.max(rectA.bottom, rectB.bottom) - y2;
          return out.setTo(x2, y2, w2, h2);
        };
        module2.exports = Union;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var DOMElementRender = __webpack_require__(1055);
        var GameObject = __webpack_require__(15);
        var IsPlainObject2 = __webpack_require__(7);
        var RemoveFromDOM = __webpack_require__(202);
        var SCENE_EVENTS = __webpack_require__(20);
        var Vector4 = __webpack_require__(140);
        var DOMElement = new Class({
          Extends: GameObject,
          Mixins: [
            Components.AlphaSingle,
            Components.BlendMode,
            Components.Depth,
            Components.Origin,
            Components.ScrollFactor,
            Components.Transform,
            Components.Visible,
            DOMElementRender
          ],
          initialize: function DOMElement2(scene, x2, y2, element, style, innerText) {
            GameObject.call(this, scene, "DOMElement");
            this.parent = scene.sys.game.domContainer;
            this.cache = scene.sys.cache.html;
            this.node;
            this.transformOnly = false;
            this.skewX = 0;
            this.skewY = 0;
            this.rotate3d = new Vector4();
            this.rotate3dAngle = "deg";
            this.pointerEvents = "auto";
            this.width = 0;
            this.height = 0;
            this.displayWidth = 0;
            this.displayHeight = 0;
            this.handler = this.dispatchNativeEvent.bind(this);
            this.setPosition(x2, y2);
            if (typeof element === "string") {
              if (element[0] === "#") {
                this.setElement(element.substr(1), style, innerText);
              } else {
                this.createElement(element, style, innerText);
              }
            } else if (element) {
              this.setElement(element, style, innerText);
            }
            scene.sys.events.on(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);
            scene.sys.events.on(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);
          },
          addedToScene: function() {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function() {
            this.scene.sys.updateList.remove(this);
          },
          handleSceneEvent: function(sys) {
            var node = this.node;
            var style = node.style;
            if (node) {
              style.display = sys.settings.visible ? "block" : "none";
            }
          },
          setSkew: function(x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = x2;
            }
            this.skewX = x2;
            this.skewY = y2;
            return this;
          },
          setPerspective: function(value) {
            this.parent.style.perspective = value + "px";
            return this;
          },
          perspective: {
            get: function() {
              return parseFloat(this.parent.style.perspective);
            },
            set: function(value) {
              this.parent.style.perspective = value + "px";
            }
          },
          addListener: function(events) {
            if (this.node) {
              events = events.split(" ");
              for (var i2 = 0; i2 < events.length; i2++) {
                this.node.addEventListener(events[i2], this.handler, false);
              }
            }
            return this;
          },
          removeListener: function(events) {
            if (this.node) {
              events = events.split(" ");
              for (var i2 = 0; i2 < events.length; i2++) {
                this.node.removeEventListener(events[i2], this.handler);
              }
            }
            return this;
          },
          dispatchNativeEvent: function(event) {
            this.emit(event.type, event);
          },
          createElement: function(tagName, style, innerText) {
            return this.setElement(document.createElement(tagName), style, innerText);
          },
          setElement: function(element, style, innerText) {
            this.removeElement();
            var target;
            if (typeof element === "string") {
              if (element[0] === "#") {
                element = element.substr(1);
              }
              target = document.getElementById(element);
            } else if (typeof element === "object" && element.nodeType === 1) {
              target = element;
            }
            if (!target) {
              return this;
            }
            this.node = target;
            if (style && IsPlainObject2(style)) {
              for (var key in style) {
                target.style[key] = style[key];
              }
            } else if (typeof style === "string") {
              target.style = style;
            }
            target.style.zIndex = "0";
            target.style.display = "inline";
            target.style.position = "absolute";
            target.phaser = this;
            if (this.parent) {
              this.parent.appendChild(target);
            }
            if (innerText) {
              target.innerText = innerText;
            }
            return this.updateSize();
          },
          createFromCache: function(key, tagName) {
            var html = this.cache.get(key);
            if (html) {
              this.createFromHTML(html, tagName);
            }
            return this;
          },
          createFromHTML: function(html, tagName) {
            if (tagName === void 0) {
              tagName = "div";
            }
            this.removeElement();
            var element = document.createElement(tagName);
            this.node = element;
            element.style.zIndex = "0";
            element.style.display = "inline";
            element.style.position = "absolute";
            element.phaser = this;
            if (this.parent) {
              this.parent.appendChild(element);
            }
            element.innerHTML = html;
            return this.updateSize();
          },
          removeElement: function() {
            if (this.node) {
              RemoveFromDOM(this.node);
              this.node = null;
            }
            return this;
          },
          updateSize: function() {
            var node = this.node;
            var nodeBounds = node.getBoundingClientRect();
            this.width = node.clientWidth;
            this.height = node.clientHeight;
            this.displayWidth = nodeBounds.width || 0;
            this.displayHeight = nodeBounds.height || 0;
            return this;
          },
          getChildByProperty: function(property, value) {
            if (this.node) {
              var children = this.node.querySelectorAll("*");
              for (var i2 = 0; i2 < children.length; i2++) {
                if (children[i2][property] === value) {
                  return children[i2];
                }
              }
            }
            return null;
          },
          getChildByID: function(id2) {
            return this.getChildByProperty("id", id2);
          },
          getChildByName: function(name) {
            return this.getChildByProperty("name", name);
          },
          setClassName: function(className) {
            if (this.node) {
              this.node.className = className;
              this.updateSize();
            }
            return this;
          },
          setText: function(text) {
            if (this.node) {
              this.node.innerText = text;
              this.updateSize();
            }
            return this;
          },
          setHTML: function(html) {
            if (this.node) {
              this.node.innerHTML = html;
              this.updateSize();
            }
            return this;
          },
          preUpdate: function() {
            var parent = this.parentContainer;
            var node = this.node;
            if (node && parent && !parent.willRender()) {
              node.style.display = "none";
            }
          },
          willRender: function() {
            return true;
          },
          preDestroy: function() {
            this.removeElement();
            this.scene.sys.events.off(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);
            this.scene.sys.events.off(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);
          }
        });
        module2.exports = DOMElement;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CSSBlendModes = __webpack_require__(1056);
        var GameObject = __webpack_require__(15);
        var TransformMatrix = __webpack_require__(25);
        var tempMatrix1 = new TransformMatrix();
        var tempMatrix2 = new TransformMatrix();
        var tempMatrix3 = new TransformMatrix();
        var DOMElementCSSRenderer = function(renderer, src, camera, parentMatrix) {
          if (!src.node) {
            return;
          }
          var style = src.node.style;
          var settings = src.scene.sys.settings;
          if (!style || !settings.visible || GameObject.RENDER_MASK !== src.renderFlags || src.cameraFilter !== 0 && src.cameraFilter & camera.id || src.parentContainer && !src.parentContainer.willRender()) {
            style.display = "none";
            return;
          }
          var parent = src.parentContainer;
          var alpha = camera.alpha * src.alpha;
          if (parent) {
            alpha *= parent.alpha;
          }
          var camMatrix = tempMatrix1;
          var srcMatrix = tempMatrix2;
          var calcMatrix = tempMatrix3;
          var dx = 0;
          var dy = 0;
          var tx = "0%";
          var ty = "0%";
          if (parentMatrix) {
            dx = src.width * src.scaleX * src.originX;
            dy = src.height * src.scaleY * src.originY;
            srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);
            camMatrix.copyFrom(camera.matrix);
            camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
            srcMatrix.e = src.x - dx;
            srcMatrix.f = src.y - dy;
            camMatrix.multiply(srcMatrix, calcMatrix);
          } else {
            dx = src.width * src.originX;
            dy = src.height * src.originY;
            srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);
            camMatrix.copyFrom(camera.matrix);
            tx = 100 * src.originX + "%";
            ty = 100 * src.originY + "%";
            srcMatrix.e -= camera.scrollX * src.scrollFactorX;
            srcMatrix.f -= camera.scrollY * src.scrollFactorY;
            camMatrix.multiply(srcMatrix, calcMatrix);
          }
          if (!src.transformOnly) {
            style.display = "block";
            style.opacity = alpha;
            style.zIndex = src._depth;
            style.pointerEvents = src.pointerEvents;
            style.mixBlendMode = CSSBlendModes[src._blendMode];
          }
          style.transform = calcMatrix.getCSSMatrix() + " skew(" + src.skewX + "rad, " + src.skewY + "rad) rotate3d(" + src.rotate3d.x + "," + src.rotate3d.y + "," + src.rotate3d.z + "," + src.rotate3d.w + src.rotate3dAngle + ")";
          style.transformOrigin = tx + " " + ty;
        };
        module2.exports = DOMElementCSSRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var GameObject = __webpack_require__(15);
        var ExternRender = __webpack_require__(1060);
        var Extern = new Class({
          Extends: GameObject,
          Mixins: [
            Components.Alpha,
            Components.BlendMode,
            Components.Depth,
            Components.Flip,
            Components.Origin,
            Components.ScrollFactor,
            Components.Size,
            Components.Texture,
            Components.Tint,
            Components.Transform,
            Components.Visible,
            ExternRender
          ],
          initialize: function Extern2(scene) {
            GameObject.call(this, scene, "Extern");
          },
          addedToScene: function() {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function() {
            this.scene.sys.updateList.remove(this);
          },
          preUpdate: function() {
          },
          render: function() {
          }
        });
        module2.exports = Extern;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CircumferencePoint = __webpack_require__(218);
        var FromPercent = __webpack_require__(98);
        var MATH_CONST = __webpack_require__(14);
        var Point = __webpack_require__(4);
        var GetPoint = function(ellipse, position, out) {
          if (out === void 0) {
            out = new Point();
          }
          var angle = FromPercent(position, 0, MATH_CONST.PI2);
          return CircumferencePoint(ellipse, angle, out);
        };
        module2.exports = GetPoint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Circumference = __webpack_require__(447);
        var CircumferencePoint = __webpack_require__(218);
        var FromPercent = __webpack_require__(98);
        var MATH_CONST = __webpack_require__(14);
        var GetPoints = function(ellipse, quantity, stepRate, out) {
          if (out === void 0) {
            out = [];
          }
          if (!quantity && stepRate > 0) {
            quantity = Circumference(ellipse) / stepRate;
          }
          for (var i2 = 0; i2 < quantity; i2++) {
            var angle = FromPercent(i2 / quantity, 0, MATH_CONST.PI2);
            out.push(CircumferencePoint(ellipse, angle));
          }
          return out;
        };
        module2.exports = GetPoints;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Circumference = function(ellipse) {
          var rx = ellipse.width / 2;
          var ry = ellipse.height / 2;
          var h2 = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
          return Math.PI * (rx + ry) * (1 + 3 * h2 / (10 + Math.sqrt(4 - 3 * h2)));
        };
        module2.exports = Circumference;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Commands = __webpack_require__(217);
        var SetTransform = __webpack_require__(30);
        var GraphicsCanvasRenderer = function(renderer, src, camera, parentMatrix, renderTargetCtx, allowClip) {
          var commandBuffer = src.commandBuffer;
          var commandBufferLength = commandBuffer.length;
          var ctx = renderTargetCtx || renderer.currentContext;
          if (commandBufferLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
            return;
          }
          camera.addToRenderList(src);
          var lineAlpha = 1;
          var fillAlpha = 1;
          var lineColor = 0;
          var fillColor = 0;
          var lineWidth = 1;
          var red = 0;
          var green = 0;
          var blue = 0;
          ctx.beginPath();
          for (var index2 = 0; index2 < commandBufferLength; ++index2) {
            var commandID = commandBuffer[index2];
            switch (commandID) {
              case Commands.ARC:
                ctx.arc(commandBuffer[index2 + 1], commandBuffer[index2 + 2], commandBuffer[index2 + 3], commandBuffer[index2 + 4], commandBuffer[index2 + 5], commandBuffer[index2 + 6]);
                index2 += 7;
                break;
              case Commands.LINE_STYLE:
                lineWidth = commandBuffer[index2 + 1];
                lineColor = commandBuffer[index2 + 2];
                lineAlpha = commandBuffer[index2 + 3];
                red = (lineColor & 16711680) >>> 16;
                green = (lineColor & 65280) >>> 8;
                blue = lineColor & 255;
                ctx.strokeStyle = "rgba(" + red + "," + green + "," + blue + "," + lineAlpha + ")";
                ctx.lineWidth = lineWidth;
                index2 += 3;
                break;
              case Commands.FILL_STYLE:
                fillColor = commandBuffer[index2 + 1];
                fillAlpha = commandBuffer[index2 + 2];
                red = (fillColor & 16711680) >>> 16;
                green = (fillColor & 65280) >>> 8;
                blue = fillColor & 255;
                ctx.fillStyle = "rgba(" + red + "," + green + "," + blue + "," + fillAlpha + ")";
                index2 += 2;
                break;
              case Commands.BEGIN_PATH:
                ctx.beginPath();
                break;
              case Commands.CLOSE_PATH:
                ctx.closePath();
                break;
              case Commands.FILL_PATH:
                if (!allowClip) {
                  ctx.fill();
                }
                break;
              case Commands.STROKE_PATH:
                if (!allowClip) {
                  ctx.stroke();
                }
                break;
              case Commands.FILL_RECT:
                if (!allowClip) {
                  ctx.fillRect(commandBuffer[index2 + 1], commandBuffer[index2 + 2], commandBuffer[index2 + 3], commandBuffer[index2 + 4]);
                } else {
                  ctx.rect(commandBuffer[index2 + 1], commandBuffer[index2 + 2], commandBuffer[index2 + 3], commandBuffer[index2 + 4]);
                }
                index2 += 4;
                break;
              case Commands.FILL_TRIANGLE:
                ctx.beginPath();
                ctx.moveTo(commandBuffer[index2 + 1], commandBuffer[index2 + 2]);
                ctx.lineTo(commandBuffer[index2 + 3], commandBuffer[index2 + 4]);
                ctx.lineTo(commandBuffer[index2 + 5], commandBuffer[index2 + 6]);
                ctx.closePath();
                if (!allowClip) {
                  ctx.fill();
                }
                index2 += 6;
                break;
              case Commands.STROKE_TRIANGLE:
                ctx.beginPath();
                ctx.moveTo(commandBuffer[index2 + 1], commandBuffer[index2 + 2]);
                ctx.lineTo(commandBuffer[index2 + 3], commandBuffer[index2 + 4]);
                ctx.lineTo(commandBuffer[index2 + 5], commandBuffer[index2 + 6]);
                ctx.closePath();
                if (!allowClip) {
                  ctx.stroke();
                }
                index2 += 6;
                break;
              case Commands.LINE_TO:
                ctx.lineTo(commandBuffer[index2 + 1], commandBuffer[index2 + 2]);
                index2 += 2;
                break;
              case Commands.MOVE_TO:
                ctx.moveTo(commandBuffer[index2 + 1], commandBuffer[index2 + 2]);
                index2 += 2;
                break;
              case Commands.LINE_FX_TO:
                ctx.lineTo(commandBuffer[index2 + 1], commandBuffer[index2 + 2]);
                index2 += 5;
                break;
              case Commands.MOVE_FX_TO:
                ctx.moveTo(commandBuffer[index2 + 1], commandBuffer[index2 + 2]);
                index2 += 5;
                break;
              case Commands.SAVE:
                ctx.save();
                break;
              case Commands.RESTORE:
                ctx.restore();
                break;
              case Commands.TRANSLATE:
                ctx.translate(commandBuffer[index2 + 1], commandBuffer[index2 + 2]);
                index2 += 2;
                break;
              case Commands.SCALE:
                ctx.scale(commandBuffer[index2 + 1], commandBuffer[index2 + 2]);
                index2 += 2;
                break;
              case Commands.ROTATE:
                ctx.rotate(commandBuffer[index2 + 1]);
                index2 += 1;
                break;
              case Commands.GRADIENT_FILL_STYLE:
                index2 += 5;
                break;
              case Commands.GRADIENT_LINE_STYLE:
                index2 += 6;
                break;
            }
          }
          ctx.restore();
        };
        module2.exports = GraphicsCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FloatBetween = __webpack_require__(137);
        var GetEaseFunction = __webpack_require__(80);
        var GetFastValue = __webpack_require__(2);
        var Wrap = __webpack_require__(68);
        var EmitterOp = new Class({
          initialize: function EmitterOp2(config, key, defaultValue, emitOnly) {
            if (emitOnly === void 0) {
              emitOnly = false;
            }
            this.propertyKey = key;
            this.propertyValue = defaultValue;
            this.defaultValue = defaultValue;
            this.steps = 0;
            this.counter = 0;
            this.start = 0;
            this.end = 0;
            this.ease;
            this.emitOnly = emitOnly;
            this.onEmit = this.defaultEmit;
            this.onUpdate = this.defaultUpdate;
            this.loadConfig(config);
          },
          loadConfig: function(config, newKey) {
            if (config === void 0) {
              config = {};
            }
            if (newKey) {
              this.propertyKey = newKey;
            }
            this.propertyValue = GetFastValue(config, this.propertyKey, this.defaultValue);
            this.setMethods();
            if (this.emitOnly) {
              this.onUpdate = this.defaultUpdate;
            }
          },
          toJSON: function() {
            return this.propertyValue;
          },
          onChange: function(value) {
            this.propertyValue = value;
            return this.setMethods();
          },
          setMethods: function() {
            var value = this.propertyValue;
            var t2 = typeof value;
            this.onEmit = this.defaultEmit;
            this.onUpdate = this.defaultUpdate;
            if (t2 === "number") {
              this.onEmit = this.staticValueEmit;
              this.onUpdate = this.staticValueUpdate;
            } else if (Array.isArray(value)) {
              this.onEmit = this.randomStaticValueEmit;
            } else if (t2 === "function") {
              if (this.emitOnly) {
                this.onEmit = value;
              } else {
                this.onUpdate = value;
              }
            } else if (t2 === "object" && this.hasBoth(value, "start", "end")) {
              this.start = value.start;
              this.end = value.end;
              var isRandom = this.has(value, "random");
              if (isRandom) {
                this.onEmit = this.randomRangedValueEmit;
              }
              if (this.has(value, "steps")) {
                this.steps = value.steps;
                this.counter = this.start;
                this.onEmit = this.steppedEmit;
              } else {
                var easeType = this.has(value, "ease") ? value.ease : "Linear";
                this.ease = GetEaseFunction(easeType, value.easeParams);
                if (!isRandom) {
                  this.onEmit = this.easedValueEmit;
                }
                this.onUpdate = this.easeValueUpdate;
              }
            } else if (t2 === "object" && this.hasBoth(value, "min", "max")) {
              this.start = value.min;
              this.end = value.max;
              this.onEmit = this.randomRangedValueEmit;
            } else if (t2 === "object" && this.has(value, "random")) {
              var rnd = value.random;
              if (Array.isArray(rnd)) {
                this.start = rnd[0];
                this.end = rnd[1];
              }
              this.onEmit = this.randomRangedValueEmit;
            } else if (t2 === "object" && this.hasEither(value, "onEmit", "onUpdate")) {
              if (this.has(value, "onEmit")) {
                this.onEmit = value.onEmit;
              }
              if (this.has(value, "onUpdate")) {
                this.onUpdate = value.onUpdate;
              }
            }
            return this;
          },
          has: function(object, key) {
            return object.hasOwnProperty(key);
          },
          hasBoth: function(object, key1, key2) {
            return object.hasOwnProperty(key1) && object.hasOwnProperty(key2);
          },
          hasEither: function(object, key1, key2) {
            return object.hasOwnProperty(key1) || object.hasOwnProperty(key2);
          },
          defaultEmit: function(particle, key, value) {
            return value;
          },
          defaultUpdate: function(particle, key, t2, value) {
            return value;
          },
          staticValueEmit: function() {
            return this.propertyValue;
          },
          staticValueUpdate: function() {
            return this.propertyValue;
          },
          randomStaticValueEmit: function() {
            var randomIndex = Math.floor(Math.random() * this.propertyValue.length);
            return this.propertyValue[randomIndex];
          },
          randomRangedValueEmit: function(particle, key) {
            var value = FloatBetween(this.start, this.end);
            if (particle && particle.data[key]) {
              particle.data[key].min = value;
            }
            return value;
          },
          steppedEmit: function() {
            var current = this.counter;
            var next = this.counter + (this.end - this.start) / this.steps;
            this.counter = Wrap(next, this.start, this.end);
            return current;
          },
          easedValueEmit: function(particle, key) {
            if (particle && particle.data[key]) {
              var data = particle.data[key];
              data.min = this.start;
              data.max = this.end;
            }
            return this.start;
          },
          easeValueUpdate: function(particle, key, t2) {
            var data = particle.data[key];
            return (data.max - data.min) * this.ease(t2) + data.min;
          }
        });
        module2.exports = EmitterOp;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetFastValue = __webpack_require__(2);
        var GravityWell = new Class({
          initialize: function GravityWell2(x2, y2, power, epsilon, gravity) {
            if (typeof x2 === "object") {
              var config = x2;
              x2 = GetFastValue(config, "x", 0);
              y2 = GetFastValue(config, "y", 0);
              power = GetFastValue(config, "power", 0);
              epsilon = GetFastValue(config, "epsilon", 100);
              gravity = GetFastValue(config, "gravity", 50);
            } else {
              if (x2 === void 0) {
                x2 = 0;
              }
              if (y2 === void 0) {
                y2 = 0;
              }
              if (power === void 0) {
                power = 0;
              }
              if (epsilon === void 0) {
                epsilon = 100;
              }
              if (gravity === void 0) {
                gravity = 50;
              }
            }
            this.x = x2;
            this.y = y2;
            this.active = true;
            this._gravity = gravity;
            this._power = 0;
            this._epsilon = 0;
            this.power = power;
            this.epsilon = epsilon;
          },
          update: function(particle, delta) {
            var x2 = this.x - particle.x;
            var y2 = this.y - particle.y;
            var dSq = x2 * x2 + y2 * y2;
            if (dSq === 0) {
              return;
            }
            var d = Math.sqrt(dSq);
            if (dSq < this._epsilon) {
              dSq = this._epsilon;
            }
            var factor = this._power * delta / (dSq * d) * 100;
            particle.velocityX += x2 * factor;
            particle.velocityY += y2 * factor;
          },
          epsilon: {
            get: function() {
              return Math.sqrt(this._epsilon);
            },
            set: function(value) {
              this._epsilon = value * value;
            }
          },
          power: {
            get: function() {
              return this._power / this._gravity;
            },
            set: function(value) {
              this._power = value * this._gravity;
            }
          },
          gravity: {
            get: function() {
              return this._gravity;
            },
            set: function(value) {
              var pwr = this.power;
              this._gravity = value;
              this.power = pwr;
            }
          }
        });
        module2.exports = GravityWell;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var DegToRad = __webpack_require__(36);
        var DistanceBetween = __webpack_require__(50);
        var Particle = new Class({
          initialize: function Particle2(emitter) {
            this.emitter = emitter;
            this.frame = null;
            this.x = 0;
            this.y = 0;
            this.velocityX = 0;
            this.velocityY = 0;
            this.accelerationX = 0;
            this.accelerationY = 0;
            this.maxVelocityX = 1e4;
            this.maxVelocityY = 1e4;
            this.bounce = 0;
            this.scaleX = 1;
            this.scaleY = 1;
            this.alpha = 1;
            this.angle = 0;
            this.rotation = 0;
            this.tint = 16777215;
            this.life = 1e3;
            this.lifeCurrent = 1e3;
            this.delayCurrent = 0;
            this.lifeT = 0;
            this.data = {
              tint: { min: 16777215, max: 16777215, current: 16777215 },
              alpha: { min: 1, max: 1 },
              rotate: { min: 0, max: 0 },
              scaleX: { min: 1, max: 1 },
              scaleY: { min: 1, max: 1 }
            };
          },
          isAlive: function() {
            return this.lifeCurrent > 0;
          },
          resetPosition: function() {
            this.x = 0;
            this.y = 0;
          },
          fire: function(x2, y2) {
            var emitter = this.emitter;
            this.frame = emitter.getFrame();
            if (emitter.emitZone) {
              emitter.emitZone.getPoint(this);
            }
            if (x2 === void 0) {
              this.x += emitter.x.onEmit(this, "x");
            } else {
              this.x += x2;
            }
            if (y2 === void 0) {
              this.y += emitter.y.onEmit(this, "y");
            } else {
              this.y += y2;
            }
            this.life = emitter.lifespan.onEmit(this, "lifespan");
            this.lifeCurrent = this.life;
            this.lifeT = 0;
            var sx = emitter.speedX.onEmit(this, "speedX");
            var sy = emitter.speedY ? emitter.speedY.onEmit(this, "speedY") : sx;
            if (emitter.radial) {
              var rad = DegToRad(emitter.angle.onEmit(this, "angle"));
              this.velocityX = Math.cos(rad) * Math.abs(sx);
              this.velocityY = Math.sin(rad) * Math.abs(sy);
            } else if (emitter.moveTo) {
              var mx = emitter.moveToX.onEmit(this, "moveToX");
              var my = emitter.moveToY ? emitter.moveToY.onEmit(this, "moveToY") : mx;
              var angle = Math.atan2(my - this.y, mx - this.x);
              var speed = DistanceBetween(this.x, this.y, mx, my) / (this.life / 1e3);
              this.velocityX = Math.cos(angle) * speed;
              this.velocityY = Math.sin(angle) * speed;
            } else {
              this.velocityX = sx;
              this.velocityY = sy;
            }
            if (emitter.acceleration) {
              this.accelerationX = emitter.accelerationX.onEmit(this, "accelerationX");
              this.accelerationY = emitter.accelerationY.onEmit(this, "accelerationY");
            }
            this.maxVelocityX = emitter.maxVelocityX.onEmit(this, "maxVelocityX");
            this.maxVelocityY = emitter.maxVelocityY.onEmit(this, "maxVelocityY");
            this.delayCurrent = emitter.delay.onEmit(this, "delay");
            this.scaleX = emitter.scaleX.onEmit(this, "scaleX");
            this.scaleY = emitter.scaleY ? emitter.scaleY.onEmit(this, "scaleY") : this.scaleX;
            this.angle = emitter.rotate.onEmit(this, "rotate");
            this.rotation = DegToRad(this.angle);
            this.bounce = emitter.bounce.onEmit(this, "bounce");
            this.alpha = emitter.alpha.onEmit(this, "alpha");
            this.tint = emitter.tint.onEmit(this, "tint");
          },
          computeVelocity: function(emitter, delta, step, processors) {
            var vx = this.velocityX;
            var vy = this.velocityY;
            var ax = this.accelerationX;
            var ay = this.accelerationY;
            var mx = this.maxVelocityX;
            var my = this.maxVelocityY;
            vx += emitter.gravityX * step;
            vy += emitter.gravityY * step;
            if (ax) {
              vx += ax * step;
            }
            if (ay) {
              vy += ay * step;
            }
            if (vx > mx) {
              vx = mx;
            } else if (vx < -mx) {
              vx = -mx;
            }
            if (vy > my) {
              vy = my;
            } else if (vy < -my) {
              vy = -my;
            }
            this.velocityX = vx;
            this.velocityY = vy;
            for (var i2 = 0; i2 < processors.length; i2++) {
              processors[i2].update(this, delta, step);
            }
          },
          checkBounds: function(emitter) {
            var bounds = emitter.bounds;
            var bounce = -this.bounce;
            if (this.x < bounds.x && emitter.collideLeft) {
              this.x = bounds.x;
              this.velocityX *= bounce;
            } else if (this.x > bounds.right && emitter.collideRight) {
              this.x = bounds.right;
              this.velocityX *= bounce;
            }
            if (this.y < bounds.y && emitter.collideTop) {
              this.y = bounds.y;
              this.velocityY *= bounce;
            } else if (this.y > bounds.bottom && emitter.collideBottom) {
              this.y = bounds.bottom;
              this.velocityY *= bounce;
            }
          },
          update: function(delta, step, processors) {
            if (this.delayCurrent > 0) {
              this.delayCurrent -= delta;
              return false;
            }
            var emitter = this.emitter;
            var t2 = 1 - this.lifeCurrent / this.life;
            this.lifeT = t2;
            this.computeVelocity(emitter, delta, step, processors);
            this.x += this.velocityX * step;
            this.y += this.velocityY * step;
            if (emitter.bounds) {
              this.checkBounds(emitter);
            }
            if (emitter.deathZone && emitter.deathZone.willKill(this)) {
              this.lifeCurrent = 0;
              return true;
            }
            this.scaleX = emitter.scaleX.onUpdate(this, "scaleX", t2, this.scaleX);
            if (emitter.scaleY) {
              this.scaleY = emitter.scaleY.onUpdate(this, "scaleY", t2, this.scaleY);
            } else {
              this.scaleY = this.scaleX;
            }
            this.angle = emitter.rotate.onUpdate(this, "rotate", t2, this.angle);
            this.rotation = DegToRad(this.angle);
            this.alpha = emitter.alpha.onUpdate(this, "alpha", t2, this.alpha);
            this.tint = emitter.tint.onUpdate(this, "tint", t2, this.tint);
            this.lifeCurrent -= delta;
            return this.lifeCurrent <= 0;
          }
        });
        module2.exports = Particle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BlendModes = __webpack_require__(35);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var DeathZone = __webpack_require__(453);
        var EdgeZone = __webpack_require__(454);
        var EmitterOp = __webpack_require__(449);
        var GetFastValue = __webpack_require__(2);
        var GetRandom = __webpack_require__(210);
        var HasAny = __webpack_require__(455);
        var HasValue = __webpack_require__(126);
        var Particle = __webpack_require__(451);
        var RandomZone = __webpack_require__(456);
        var Rectangle = __webpack_require__(10);
        var StableSort = __webpack_require__(79);
        var Vector2 = __webpack_require__(3);
        var Wrap = __webpack_require__(68);
        var ParticleEmitter = new Class({
          Mixins: [
            Components.BlendMode,
            Components.Mask,
            Components.ScrollFactor,
            Components.Visible
          ],
          initialize: function ParticleEmitter2(manager, config) {
            this.manager = manager;
            this.texture = manager.texture;
            this.frames = [manager.defaultFrame];
            this.defaultFrame = manager.defaultFrame;
            this.configFastMap = [
              "active",
              "blendMode",
              "collideBottom",
              "collideLeft",
              "collideRight",
              "collideTop",
              "deathCallback",
              "deathCallbackScope",
              "emitCallback",
              "emitCallbackScope",
              "follow",
              "frequency",
              "gravityX",
              "gravityY",
              "maxParticles",
              "name",
              "on",
              "particleBringToTop",
              "particleClass",
              "radial",
              "timeScale",
              "trackVisible",
              "visible"
            ];
            this.configOpMap = [
              "accelerationX",
              "accelerationY",
              "angle",
              "alpha",
              "bounce",
              "delay",
              "lifespan",
              "maxVelocityX",
              "maxVelocityY",
              "moveToX",
              "moveToY",
              "quantity",
              "rotate",
              "scaleX",
              "scaleY",
              "speedX",
              "speedY",
              "tint",
              "x",
              "y"
            ];
            this.name = "";
            this.particleClass = Particle;
            this.x = new EmitterOp(config, "x", 0, true);
            this.y = new EmitterOp(config, "y", 0, true);
            this.radial = true;
            this.gravityX = 0;
            this.gravityY = 0;
            this.acceleration = false;
            this.accelerationX = new EmitterOp(config, "accelerationX", 0, true);
            this.accelerationY = new EmitterOp(config, "accelerationY", 0, true);
            this.maxVelocityX = new EmitterOp(config, "maxVelocityX", 1e4, true);
            this.maxVelocityY = new EmitterOp(config, "maxVelocityY", 1e4, true);
            this.speedX = new EmitterOp(config, "speedX", 0, true);
            this.speedY = new EmitterOp(config, "speedY", 0, true);
            this.moveTo = false;
            this.moveToX = new EmitterOp(config, "moveToX", 0, true);
            this.moveToY = new EmitterOp(config, "moveToY", 0, true);
            this.bounce = new EmitterOp(config, "bounce", 0, true);
            this.scaleX = new EmitterOp(config, "scaleX", 1);
            this.scaleY = new EmitterOp(config, "scaleY", 1);
            this.tint = new EmitterOp(config, "tint", 16777215);
            this.alpha = new EmitterOp(config, "alpha", 1);
            this.lifespan = new EmitterOp(config, "lifespan", 1e3, true);
            this.angle = new EmitterOp(config, "angle", { min: 0, max: 360 }, true);
            this.rotate = new EmitterOp(config, "rotate", 0);
            this.emitCallback = null;
            this.emitCallbackScope = null;
            this.deathCallback = null;
            this.deathCallbackScope = null;
            this.maxParticles = 0;
            this.quantity = new EmitterOp(config, "quantity", 1, true);
            this.delay = new EmitterOp(config, "delay", 0, true);
            this.frequency = 0;
            this.on = true;
            this.particleBringToTop = true;
            this.timeScale = 1;
            this.emitZone = null;
            this.deathZone = null;
            this.bounds = null;
            this.collideLeft = true;
            this.collideRight = true;
            this.collideTop = true;
            this.collideBottom = true;
            this.active = true;
            this.visible = true;
            this.blendMode = BlendModes.NORMAL;
            this.follow = null;
            this.followOffset = new Vector2();
            this.trackVisible = false;
            this.currentFrame = 0;
            this.randomFrame = true;
            this.frameQuantity = 1;
            this.dead = [];
            this.alive = [];
            this._counter = 0;
            this._frameCounter = 0;
            if (config) {
              this.fromJSON(config);
            }
          },
          fromJSON: function(config) {
            if (!config) {
              return this;
            }
            var i2 = 0;
            var key = "";
            for (i2 = 0; i2 < this.configFastMap.length; i2++) {
              key = this.configFastMap[i2];
              if (HasValue(config, key)) {
                this[key] = GetFastValue(config, key);
              }
            }
            for (i2 = 0; i2 < this.configOpMap.length; i2++) {
              key = this.configOpMap[i2];
              if (HasValue(config, key)) {
                this[key].loadConfig(config);
              }
            }
            this.acceleration = this.accelerationX.propertyValue !== 0 || this.accelerationY.propertyValue !== 0;
            this.moveTo = this.moveToX.propertyValue !== 0 || this.moveToY.propertyValue !== 0;
            if (HasValue(config, "speed")) {
              this.speedX.loadConfig(config, "speed");
              this.speedY = null;
            }
            if (HasAny(config, ["speedX", "speedY"]) || this.moveTo) {
              this.radial = false;
            }
            if (HasValue(config, "scale")) {
              this.scaleX.loadConfig(config, "scale");
              this.scaleY = null;
            }
            if (HasValue(config, "callbackScope")) {
              var callbackScope = GetFastValue(config, "callbackScope", null);
              this.emitCallbackScope = callbackScope;
              this.deathCallbackScope = callbackScope;
            }
            if (HasValue(config, "emitZone")) {
              this.setEmitZone(config.emitZone);
            }
            if (HasValue(config, "deathZone")) {
              this.setDeathZone(config.deathZone);
            }
            if (HasValue(config, "bounds")) {
              this.setBounds(config.bounds);
            }
            if (HasValue(config, "followOffset")) {
              this.followOffset.setFromObject(GetFastValue(config, "followOffset", 0));
            }
            if (HasValue(config, "frame")) {
              this.setFrame(config.frame);
            }
            if (HasValue(config, "reserve")) {
              this.reserve(config.reserve);
            }
            return this;
          },
          toJSON: function(output) {
            if (output === void 0) {
              output = {};
            }
            var i2 = 0;
            var key = "";
            for (i2 = 0; i2 < this.configFastMap.length; i2++) {
              key = this.configFastMap[i2];
              output[key] = this[key];
            }
            for (i2 = 0; i2 < this.configOpMap.length; i2++) {
              key = this.configOpMap[i2];
              if (this[key]) {
                output[key] = this[key].toJSON();
              }
            }
            if (!this.speedY) {
              delete output.speedX;
              output.speed = this.speedX.toJSON();
            }
            if (!this.scaleY) {
              delete output.scaleX;
              output.scale = this.scaleX.toJSON();
            }
            return output;
          },
          startFollow: function(target, offsetX, offsetY, trackVisible) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            if (trackVisible === void 0) {
              trackVisible = false;
            }
            this.follow = target;
            this.followOffset.set(offsetX, offsetY);
            this.trackVisible = trackVisible;
            return this;
          },
          stopFollow: function() {
            this.follow = null;
            this.followOffset.set(0, 0);
            this.trackVisible = false;
            return this;
          },
          getFrame: function() {
            if (this.frames.length === 1) {
              return this.defaultFrame;
            } else if (this.randomFrame) {
              return GetRandom(this.frames);
            } else {
              var frame = this.frames[this.currentFrame];
              this._frameCounter++;
              if (this._frameCounter === this.frameQuantity) {
                this._frameCounter = 0;
                this.currentFrame = Wrap(this.currentFrame + 1, 0, this._frameLength);
              }
              return frame;
            }
          },
          setFrame: function(frames, pickRandom, quantity) {
            if (pickRandom === void 0) {
              pickRandom = true;
            }
            if (quantity === void 0) {
              quantity = 1;
            }
            this.randomFrame = pickRandom;
            this.frameQuantity = quantity;
            this.currentFrame = 0;
            this._frameCounter = 0;
            var t2 = typeof frames;
            if (Array.isArray(frames) || t2 === "string" || t2 === "number") {
              this.manager.setEmitterFrames(frames, this);
            } else if (t2 === "object") {
              var frameConfig = frames;
              frames = GetFastValue(frameConfig, "frames", null);
              if (frames) {
                this.manager.setEmitterFrames(frames, this);
              }
              var isCycle = GetFastValue(frameConfig, "cycle", false);
              this.randomFrame = isCycle ? false : true;
              this.frameQuantity = GetFastValue(frameConfig, "quantity", quantity);
            }
            this._frameLength = this.frames.length;
            if (this._frameLength === 1) {
              this.frameQuantity = 1;
              this.randomFrame = false;
            }
            return this;
          },
          setRadial: function(value) {
            if (value === void 0) {
              value = true;
            }
            this.radial = value;
            return this;
          },
          setPosition: function(x2, y2) {
            this.x.onChange(x2);
            this.y.onChange(y2);
            return this;
          },
          setBounds: function(x2, y2, width, height) {
            if (typeof x2 === "object") {
              var obj = x2;
              x2 = obj.x;
              y2 = obj.y;
              width = HasValue(obj, "w") ? obj.w : obj.width;
              height = HasValue(obj, "h") ? obj.h : obj.height;
            }
            if (this.bounds) {
              this.bounds.setTo(x2, y2, width, height);
            } else {
              this.bounds = new Rectangle(x2, y2, width, height);
            }
            return this;
          },
          setSpeedX: function(value) {
            this.speedX.onChange(value);
            this.radial = false;
            return this;
          },
          setSpeedY: function(value) {
            if (this.speedY) {
              this.speedY.onChange(value);
              this.radial = false;
            }
            return this;
          },
          setSpeed: function(value) {
            this.speedX.onChange(value);
            this.speedY = null;
            this.radial = true;
            return this;
          },
          setScaleX: function(value) {
            this.scaleX.onChange(value);
            return this;
          },
          setScaleY: function(value) {
            this.scaleY.onChange(value);
            return this;
          },
          setScale: function(value) {
            this.scaleX.onChange(value);
            this.scaleY = null;
            return this;
          },
          setGravityX: function(value) {
            this.gravityX = value;
            return this;
          },
          setGravityY: function(value) {
            this.gravityY = value;
            return this;
          },
          setGravity: function(x2, y2) {
            this.gravityX = x2;
            this.gravityY = y2;
            return this;
          },
          setAlpha: function(value) {
            this.alpha.onChange(value);
            return this;
          },
          setTint: function(value) {
            this.tint.onChange(value);
            return this;
          },
          setEmitterAngle: function(value) {
            this.angle.onChange(value);
            return this;
          },
          setAngle: function(value) {
            this.angle.onChange(value);
            return this;
          },
          setLifespan: function(value) {
            this.lifespan.onChange(value);
            return this;
          },
          setQuantity: function(quantity) {
            this.quantity.onChange(quantity);
            return this;
          },
          setFrequency: function(frequency, quantity) {
            this.frequency = frequency;
            this._counter = 0;
            if (quantity) {
              this.quantity.onChange(quantity);
            }
            return this;
          },
          setEmitZone: function(zoneConfig) {
            if (zoneConfig === void 0) {
              this.emitZone = null;
            } else {
              var type = GetFastValue(zoneConfig, "type", "random");
              var source = GetFastValue(zoneConfig, "source", null);
              switch (type) {
                case "random":
                  this.emitZone = new RandomZone(source);
                  break;
                case "edge":
                  var quantity = GetFastValue(zoneConfig, "quantity", 1);
                  var stepRate = GetFastValue(zoneConfig, "stepRate", 0);
                  var yoyo = GetFastValue(zoneConfig, "yoyo", false);
                  var seamless = GetFastValue(zoneConfig, "seamless", true);
                  this.emitZone = new EdgeZone(source, quantity, stepRate, yoyo, seamless);
                  break;
              }
            }
            return this;
          },
          setDeathZone: function(zoneConfig) {
            if (zoneConfig === void 0) {
              this.deathZone = null;
            } else {
              var type = GetFastValue(zoneConfig, "type", "onEnter");
              var source = GetFastValue(zoneConfig, "source", null);
              if (source && typeof source.contains === "function") {
                var killOnEnter = type === "onEnter" ? true : false;
                this.deathZone = new DeathZone(source, killOnEnter);
              }
            }
            return this;
          },
          reserve: function(particleCount) {
            var dead = this.dead;
            for (var i2 = 0; i2 < particleCount; i2++) {
              dead.push(new this.particleClass(this));
            }
            return this;
          },
          getAliveParticleCount: function() {
            return this.alive.length;
          },
          getDeadParticleCount: function() {
            return this.dead.length;
          },
          getParticleCount: function() {
            return this.getAliveParticleCount() + this.getDeadParticleCount();
          },
          atLimit: function() {
            return this.maxParticles > 0 && this.getParticleCount() === this.maxParticles;
          },
          onParticleEmit: function(callback, context) {
            if (callback === void 0) {
              this.emitCallback = null;
              this.emitCallbackScope = null;
            } else if (typeof callback === "function") {
              this.emitCallback = callback;
              if (context) {
                this.emitCallbackScope = context;
              }
            }
            return this;
          },
          onParticleDeath: function(callback, context) {
            if (callback === void 0) {
              this.deathCallback = null;
              this.deathCallbackScope = null;
            } else if (typeof callback === "function") {
              this.deathCallback = callback;
              if (context) {
                this.deathCallbackScope = context;
              }
            }
            return this;
          },
          killAll: function() {
            var dead = this.dead;
            var alive = this.alive;
            while (alive.length > 0) {
              dead.push(alive.pop());
            }
            return this;
          },
          forEachAlive: function(callback, context) {
            var alive = this.alive;
            var length = alive.length;
            for (var index2 = 0; index2 < length; ++index2) {
              callback.call(context, alive[index2], this);
            }
            return this;
          },
          forEachDead: function(callback, context) {
            var dead = this.dead;
            var length = dead.length;
            for (var index2 = 0; index2 < length; ++index2) {
              callback.call(context, dead[index2], this);
            }
            return this;
          },
          start: function() {
            this.on = true;
            this._counter = 0;
            return this;
          },
          stop: function() {
            this.on = false;
            return this;
          },
          pause: function() {
            this.active = false;
            return this;
          },
          resume: function() {
            this.active = true;
            return this;
          },
          remove: function() {
            this.manager.removeEmitter(this);
            return this;
          },
          depthSort: function() {
            StableSort(this.alive, this.depthSortCallback);
            return this;
          },
          flow: function(frequency, count) {
            if (count === void 0) {
              count = 1;
            }
            this.frequency = frequency;
            this.quantity.onChange(count);
            return this.start();
          },
          explode: function(count, x2, y2) {
            this.frequency = -1;
            return this.emitParticle(count, x2, y2);
          },
          emitParticleAt: function(x2, y2, count) {
            return this.emitParticle(count, x2, y2);
          },
          emitParticle: function(count, x2, y2) {
            if (this.atLimit()) {
              return;
            }
            if (count === void 0) {
              count = this.quantity.onEmit();
            }
            var dead = this.dead;
            var followX = this.follow ? this.follow.x + this.followOffset.x : x2;
            var followY = this.follow ? this.follow.y + this.followOffset.y : y2;
            for (var i2 = 0; i2 < count; i2++) {
              var particle = dead.pop();
              if (!particle) {
                particle = new this.particleClass(this);
              }
              particle.fire(followX, followY);
              if (this.particleBringToTop) {
                this.alive.push(particle);
              } else {
                this.alive.unshift(particle);
              }
              if (this.emitCallback) {
                this.emitCallback.call(this.emitCallbackScope, particle, this);
              }
              if (this.atLimit()) {
                break;
              }
            }
            return particle;
          },
          preUpdate: function(time, delta) {
            delta *= this.timeScale;
            var step = delta / 1e3;
            if (this.trackVisible) {
              this.visible = this.follow.visible;
            }
            var processors = this.manager.getProcessors();
            var particles = this.alive;
            var dead = this.dead;
            var i2 = 0;
            var rip = [];
            var length = particles.length;
            for (i2 = 0; i2 < length; i2++) {
              var particle = particles[i2];
              if (particle.update(delta, step, processors)) {
                rip.push({ index: i2, particle });
              }
            }
            length = rip.length;
            if (length > 0) {
              var deathCallback = this.deathCallback;
              var deathCallbackScope = this.deathCallbackScope;
              for (i2 = length - 1; i2 >= 0; i2--) {
                var entry = rip[i2];
                particles.splice(entry.index, 1);
                dead.push(entry.particle);
                if (deathCallback) {
                  deathCallback.call(deathCallbackScope, entry.particle);
                }
                entry.particle.resetPosition();
              }
            }
            if (!this.on) {
              return;
            }
            if (this.frequency === 0) {
              this.emitParticle();
            } else if (this.frequency > 0) {
              this._counter -= delta;
              if (this._counter <= 0) {
                this.emitParticle();
                this._counter = this.frequency - Math.abs(this._counter);
              }
            }
          },
          depthSortCallback: function(a, b2) {
            return a.y - b2.y;
          }
        });
        module2.exports = ParticleEmitter;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var DeathZone = new Class({
          initialize: function DeathZone2(source, killOnEnter) {
            this.source = source;
            this.killOnEnter = killOnEnter;
          },
          willKill: function(particle) {
            var withinZone = this.source.contains(particle.x, particle.y);
            return withinZone && this.killOnEnter || !withinZone && !this.killOnEnter;
          }
        });
        module2.exports = DeathZone;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var EdgeZone = new Class({
          initialize: function EdgeZone2(source, quantity, stepRate, yoyo, seamless) {
            if (yoyo === void 0) {
              yoyo = false;
            }
            if (seamless === void 0) {
              seamless = true;
            }
            this.source = source;
            this.points = [];
            this.quantity = quantity;
            this.stepRate = stepRate;
            this.yoyo = yoyo;
            this.counter = -1;
            this.seamless = seamless;
            this._length = 0;
            this._direction = 0;
            this.updateSource();
          },
          updateSource: function() {
            this.points = this.source.getPoints(this.quantity, this.stepRate);
            if (this.seamless) {
              var a = this.points[0];
              var b2 = this.points[this.points.length - 1];
              if (a.x === b2.x && a.y === b2.y) {
                this.points.pop();
              }
            }
            var oldLength = this._length;
            this._length = this.points.length;
            if (this._length < oldLength && this.counter > this._length) {
              this.counter = this._length - 1;
            }
            return this;
          },
          changeSource: function(source) {
            this.source = source;
            return this.updateSource();
          },
          getPoint: function(particle) {
            if (this._direction === 0) {
              this.counter++;
              if (this.counter >= this._length) {
                if (this.yoyo) {
                  this._direction = 1;
                  this.counter = this._length - 1;
                } else {
                  this.counter = 0;
                }
              }
            } else {
              this.counter--;
              if (this.counter === -1) {
                if (this.yoyo) {
                  this._direction = 0;
                  this.counter = 0;
                } else {
                  this.counter = this._length - 1;
                }
              }
            }
            var point = this.points[this.counter];
            if (point) {
              particle.x = point.x;
              particle.y = point.y;
            }
          }
        });
        module2.exports = EdgeZone;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var HasAny = function(source, keys) {
          for (var i2 = 0; i2 < keys.length; i2++) {
            if (source.hasOwnProperty(keys[i2])) {
              return true;
            }
          }
          return false;
        };
        module2.exports = HasAny;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Vector2 = __webpack_require__(3);
        var RandomZone = new Class({
          initialize: function RandomZone2(source) {
            this.source = source;
            this._tempVec = new Vector2();
          },
          getPoint: function(particle) {
            var vec = this._tempVec;
            this.source.getRandomPoint(vec);
            particle.x = vec.x;
            particle.y = vec.y;
          }
        });
        module2.exports = RandomZone;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var Sprite = __webpack_require__(73);
        var PathFollower = new Class({
          Extends: Sprite,
          Mixins: [
            Components.PathFollower
          ],
          initialize: function PathFollower2(scene, path, x2, y2, texture, frame) {
            Sprite.call(this, scene, x2, y2, texture, frame);
            this.path = path;
          },
          preUpdate: function(time, delta) {
            this.anims.update(time, delta);
            this.pathUpdate(time);
          }
        });
        module2.exports = PathFollower;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTextSize = function(text, size, lines) {
          var canvas = text.canvas;
          var context = text.context;
          var style = text.style;
          var lineWidths = [];
          var maxLineWidth = 0;
          var drawnLines = lines.length;
          if (style.maxLines > 0 && style.maxLines < lines.length) {
            drawnLines = style.maxLines;
          }
          style.syncFont(canvas, context);
          for (var i2 = 0; i2 < drawnLines; i2++) {
            var lineWidth = style.strokeThickness;
            lineWidth += context.measureText(lines[i2]).width;
            if (style.wordWrap) {
              lineWidth -= context.measureText(" ").width;
            }
            lineWidths[i2] = Math.ceil(lineWidth);
            maxLineWidth = Math.max(maxLineWidth, lineWidths[i2]);
          }
          var lineHeight = size.fontSize + style.strokeThickness;
          var height = lineHeight * drawnLines;
          var lineSpacing = text.lineSpacing;
          if (drawnLines > 1) {
            height += lineSpacing * (drawnLines - 1);
          }
          return {
            width: maxLineWidth,
            height,
            lines: drawnLines,
            lineWidths,
            lineSpacing,
            lineHeight
          };
        };
        module2.exports = GetTextSize;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetAdvancedValue = __webpack_require__(13);
        var GetValue = __webpack_require__(6);
        var MeasureText = __webpack_require__(460);
        var propertyMap = {
          fontFamily: ["fontFamily", "Courier"],
          fontSize: ["fontSize", "16px"],
          fontStyle: ["fontStyle", ""],
          backgroundColor: ["backgroundColor", null],
          color: ["color", "#fff"],
          stroke: ["stroke", "#fff"],
          strokeThickness: ["strokeThickness", 0],
          shadowOffsetX: ["shadow.offsetX", 0],
          shadowOffsetY: ["shadow.offsetY", 0],
          shadowColor: ["shadow.color", "#000"],
          shadowBlur: ["shadow.blur", 0],
          shadowStroke: ["shadow.stroke", false],
          shadowFill: ["shadow.fill", false],
          align: ["align", "left"],
          maxLines: ["maxLines", 0],
          fixedWidth: ["fixedWidth", 0],
          fixedHeight: ["fixedHeight", 0],
          resolution: ["resolution", 0],
          rtl: ["rtl", false],
          testString: ["testString", "|M\xC3\u2030qgy"],
          baselineX: ["baselineX", 1.2],
          baselineY: ["baselineY", 1.4],
          wordWrapWidth: ["wordWrap.width", null],
          wordWrapCallback: ["wordWrap.callback", null],
          wordWrapCallbackScope: ["wordWrap.callbackScope", null],
          wordWrapUseAdvanced: ["wordWrap.useAdvancedWrap", false]
        };
        var TextStyle = new Class({
          initialize: function TextStyle2(text, style) {
            this.parent = text;
            this.fontFamily;
            this.fontSize;
            this.fontStyle;
            this.backgroundColor;
            this.color;
            this.stroke;
            this.strokeThickness;
            this.shadowOffsetX;
            this.shadowOffsetY;
            this.shadowColor;
            this.shadowBlur;
            this.shadowStroke;
            this.shadowFill;
            this.align;
            this.maxLines;
            this.fixedWidth;
            this.fixedHeight;
            this.resolution;
            this.rtl;
            this.testString;
            this.baselineX;
            this.baselineY;
            this.wordWrapWidth;
            this.wordWrapCallback;
            this.wordWrapCallbackScope;
            this.wordWrapUseAdvanced;
            this._font;
            this.setStyle(style, false, true);
            var metrics = GetValue(style, "metrics", false);
            if (metrics) {
              this.metrics = {
                ascent: GetValue(metrics, "ascent", 0),
                descent: GetValue(metrics, "descent", 0),
                fontSize: GetValue(metrics, "fontSize", 0)
              };
            } else {
              this.metrics = MeasureText(this);
            }
          },
          setStyle: function(style, updateText, setDefaults) {
            if (updateText === void 0) {
              updateText = true;
            }
            if (setDefaults === void 0) {
              setDefaults = false;
            }
            if (style && style.hasOwnProperty("fontSize") && typeof style.fontSize === "number") {
              style.fontSize = style.fontSize.toString() + "px";
            }
            for (var key in propertyMap) {
              var value = setDefaults ? propertyMap[key][1] : this[key];
              if (key === "wordWrapCallback" || key === "wordWrapCallbackScope") {
                this[key] = GetValue(style, propertyMap[key][0], value);
              } else {
                this[key] = GetAdvancedValue(style, propertyMap[key][0], value);
              }
            }
            var font = GetValue(style, "font", null);
            if (font !== null) {
              this.setFont(font, false);
            }
            this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
            var fill = GetValue(style, "fill", null);
            if (fill !== null) {
              this.color = fill;
            }
            if (updateText) {
              return this.update(true);
            } else {
              return this.parent;
            }
          },
          syncFont: function(canvas, context) {
            context.font = this._font;
          },
          syncStyle: function(canvas, context) {
            context.textBaseline = "alphabetic";
            context.fillStyle = this.color;
            context.strokeStyle = this.stroke;
            context.lineWidth = this.strokeThickness;
            context.lineCap = "round";
            context.lineJoin = "round";
          },
          syncShadow: function(context, enabled) {
            if (enabled) {
              context.shadowOffsetX = this.shadowOffsetX;
              context.shadowOffsetY = this.shadowOffsetY;
              context.shadowColor = this.shadowColor;
              context.shadowBlur = this.shadowBlur;
            } else {
              context.shadowOffsetX = 0;
              context.shadowOffsetY = 0;
              context.shadowColor = 0;
              context.shadowBlur = 0;
            }
          },
          update: function(recalculateMetrics) {
            if (recalculateMetrics) {
              this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
              this.metrics = MeasureText(this);
            }
            return this.parent.updateText();
          },
          setFont: function(font, updateText) {
            if (updateText === void 0) {
              updateText = true;
            }
            var fontFamily = font;
            var fontSize = "";
            var fontStyle = "";
            if (typeof font !== "string") {
              fontFamily = GetValue(font, "fontFamily", "Courier");
              fontSize = GetValue(font, "fontSize", "16px");
              fontStyle = GetValue(font, "fontStyle", "");
            } else {
              var fontSplit = font.split(" ");
              var i2 = 0;
              fontStyle = fontSplit.length > 2 ? fontSplit[i2++] : "";
              fontSize = fontSplit[i2++] || "16px";
              fontFamily = fontSplit[i2++] || "Courier";
            }
            if (fontFamily !== this.fontFamily || fontSize !== this.fontSize || fontStyle !== this.fontStyle) {
              this.fontFamily = fontFamily;
              this.fontSize = fontSize;
              this.fontStyle = fontStyle;
              if (updateText) {
                this.update(true);
              }
            }
            return this.parent;
          },
          setFontFamily: function(family) {
            if (this.fontFamily !== family) {
              this.fontFamily = family;
              this.update(true);
            }
            return this.parent;
          },
          setFontStyle: function(style) {
            if (this.fontStyle !== style) {
              this.fontStyle = style;
              this.update(true);
            }
            return this.parent;
          },
          setFontSize: function(size) {
            if (typeof size === "number") {
              size = size.toString() + "px";
            }
            if (this.fontSize !== size) {
              this.fontSize = size;
              this.update(true);
            }
            return this.parent;
          },
          setTestString: function(string) {
            this.testString = string;
            return this.update(true);
          },
          setFixedSize: function(width, height) {
            this.fixedWidth = width;
            this.fixedHeight = height;
            if (width) {
              this.parent.width = width;
            }
            if (height) {
              this.parent.height = height;
            }
            return this.update(false);
          },
          setBackgroundColor: function(color) {
            this.backgroundColor = color;
            return this.update(false);
          },
          setFill: function(color) {
            this.color = color;
            return this.update(false);
          },
          setColor: function(color) {
            this.color = color;
            return this.update(false);
          },
          setResolution: function(value) {
            this.resolution = value;
            return this.update(false);
          },
          setStroke: function(color, thickness) {
            if (thickness === void 0) {
              thickness = this.strokeThickness;
            }
            if (color === void 0 && this.strokeThickness !== 0) {
              this.strokeThickness = 0;
              this.update(true);
            } else if (this.stroke !== color || this.strokeThickness !== thickness) {
              this.stroke = color;
              this.strokeThickness = thickness;
              this.update(true);
            }
            return this.parent;
          },
          setShadow: function(x2, y2, color, blur, shadowStroke, shadowFill) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (color === void 0) {
              color = "#000";
            }
            if (blur === void 0) {
              blur = 0;
            }
            if (shadowStroke === void 0) {
              shadowStroke = false;
            }
            if (shadowFill === void 0) {
              shadowFill = true;
            }
            this.shadowOffsetX = x2;
            this.shadowOffsetY = y2;
            this.shadowColor = color;
            this.shadowBlur = blur;
            this.shadowStroke = shadowStroke;
            this.shadowFill = shadowFill;
            return this.update(false);
          },
          setShadowOffset: function(x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = x2;
            }
            this.shadowOffsetX = x2;
            this.shadowOffsetY = y2;
            return this.update(false);
          },
          setShadowColor: function(color) {
            if (color === void 0) {
              color = "#000";
            }
            this.shadowColor = color;
            return this.update(false);
          },
          setShadowBlur: function(blur) {
            if (blur === void 0) {
              blur = 0;
            }
            this.shadowBlur = blur;
            return this.update(false);
          },
          setShadowStroke: function(enabled) {
            this.shadowStroke = enabled;
            return this.update(false);
          },
          setShadowFill: function(enabled) {
            this.shadowFill = enabled;
            return this.update(false);
          },
          setWordWrapWidth: function(width, useAdvancedWrap) {
            if (useAdvancedWrap === void 0) {
              useAdvancedWrap = false;
            }
            this.wordWrapWidth = width;
            this.wordWrapUseAdvanced = useAdvancedWrap;
            return this.update(false);
          },
          setWordWrapCallback: function(callback, scope) {
            if (scope === void 0) {
              scope = null;
            }
            this.wordWrapCallback = callback;
            this.wordWrapCallbackScope = scope;
            return this.update(false);
          },
          setAlign: function(align) {
            if (align === void 0) {
              align = "left";
            }
            this.align = align;
            return this.update(false);
          },
          setMaxLines: function(max) {
            if (max === void 0) {
              max = 0;
            }
            this.maxLines = max;
            return this.update(false);
          },
          getTextMetrics: function() {
            var metrics = this.metrics;
            return {
              ascent: metrics.ascent,
              descent: metrics.descent,
              fontSize: metrics.fontSize
            };
          },
          toJSON: function() {
            var output = {};
            for (var key in propertyMap) {
              output[key] = this[key];
            }
            output.metrics = this.getTextMetrics();
            return output;
          },
          destroy: function() {
            this.parent = void 0;
          }
        });
        module2.exports = TextStyle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CanvasPool = __webpack_require__(31);
        var MeasureText = function(textStyle) {
          var canvas = CanvasPool.create(this);
          var context = canvas.getContext("2d");
          textStyle.syncFont(canvas, context);
          var metrics = context.measureText(textStyle.testString);
          if ("actualBoundingBoxAscent" in metrics) {
            var ascent = metrics.actualBoundingBoxAscent;
            var descent = metrics.actualBoundingBoxDescent;
            CanvasPool.remove(canvas);
            return {
              ascent,
              descent,
              fontSize: ascent + descent
            };
          }
          var width = Math.ceil(metrics.width * textStyle.baselineX);
          var baseline = width;
          var height = 2 * baseline;
          baseline = baseline * textStyle.baselineY | 0;
          canvas.width = width;
          canvas.height = height;
          context.fillStyle = "#f00";
          context.fillRect(0, 0, width, height);
          context.font = textStyle._font;
          context.textBaseline = "alphabetic";
          context.fillStyle = "#000";
          context.fillText(textStyle.testString, 0, baseline);
          var output = {
            ascent: 0,
            descent: 0,
            fontSize: 0
          };
          var imagedata = context.getImageData(0, 0, width, height);
          if (!imagedata) {
            output.ascent = baseline;
            output.descent = baseline + 6;
            output.fontSize = output.ascent + output.descent;
            CanvasPool.remove(canvas);
            return output;
          }
          var pixels = imagedata.data;
          var numPixels = pixels.length;
          var line = width * 4;
          var i2;
          var j;
          var idx = 0;
          var stop = false;
          for (i2 = 0; i2 < baseline; i2++) {
            for (j = 0; j < line; j += 4) {
              if (pixels[idx + j] !== 255) {
                stop = true;
                break;
              }
            }
            if (!stop) {
              idx += line;
            } else {
              break;
            }
          }
          output.ascent = baseline - i2;
          idx = numPixels - line;
          stop = false;
          for (i2 = height; i2 > baseline; i2--) {
            for (j = 0; j < line; j += 4) {
              if (pixels[idx + j] !== 255) {
                stop = true;
                break;
              }
            }
            if (!stop) {
              idx -= line;
            } else {
              break;
            }
          }
          output.descent = i2 - baseline;
          output.fontSize = output.ascent + output.descent;
          CanvasPool.remove(canvas);
          return output;
        };
        module2.exports = MeasureText;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ArcRender = __webpack_require__(1097);
        var Class = __webpack_require__(0);
        var DegToRad = __webpack_require__(36);
        var Earcut = __webpack_require__(59);
        var GeomCircle = __webpack_require__(65);
        var MATH_CONST = __webpack_require__(14);
        var Shape = __webpack_require__(34);
        var Arc = new Class({
          Extends: Shape,
          Mixins: [
            ArcRender
          ],
          initialize: function Arc2(scene, x2, y2, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (radius === void 0) {
              radius = 128;
            }
            if (startAngle === void 0) {
              startAngle = 0;
            }
            if (endAngle === void 0) {
              endAngle = 360;
            }
            if (anticlockwise === void 0) {
              anticlockwise = false;
            }
            Shape.call(this, scene, "Arc", new GeomCircle(0, 0, radius));
            this._startAngle = startAngle;
            this._endAngle = endAngle;
            this._anticlockwise = anticlockwise;
            this._iterations = 0.01;
            this.setPosition(x2, y2);
            var diameter = this.geom.radius * 2;
            this.setSize(diameter, diameter);
            if (fillColor !== void 0) {
              this.setFillStyle(fillColor, fillAlpha);
            }
            this.updateDisplayOrigin();
            this.updateData();
          },
          iterations: {
            get: function() {
              return this._iterations;
            },
            set: function(value) {
              this._iterations = value;
              this.updateData();
            }
          },
          radius: {
            get: function() {
              return this.geom.radius;
            },
            set: function(value) {
              this.geom.radius = value;
              var diameter = value * 2;
              this.setSize(diameter, diameter);
              this.updateDisplayOrigin();
              this.updateData();
            }
          },
          startAngle: {
            get: function() {
              return this._startAngle;
            },
            set: function(value) {
              this._startAngle = value;
              this.updateData();
            }
          },
          endAngle: {
            get: function() {
              return this._endAngle;
            },
            set: function(value) {
              this._endAngle = value;
              this.updateData();
            }
          },
          anticlockwise: {
            get: function() {
              return this._anticlockwise;
            },
            set: function(value) {
              this._anticlockwise = value;
              this.updateData();
            }
          },
          setRadius: function(value) {
            this.radius = value;
            return this;
          },
          setIterations: function(value) {
            if (value === void 0) {
              value = 0.01;
            }
            this.iterations = value;
            return this;
          },
          setStartAngle: function(angle, anticlockwise) {
            this._startAngle = angle;
            if (anticlockwise !== void 0) {
              this._anticlockwise = anticlockwise;
            }
            return this.updateData();
          },
          setEndAngle: function(angle, anticlockwise) {
            this._endAngle = angle;
            if (anticlockwise !== void 0) {
              this._anticlockwise = anticlockwise;
            }
            return this.updateData();
          },
          updateData: function() {
            var step = this._iterations;
            var iteration = step;
            var radius = this.geom.radius;
            var startAngle = DegToRad(this._startAngle);
            var endAngle = DegToRad(this._endAngle);
            var anticlockwise = this._anticlockwise;
            var x2 = radius;
            var y2 = radius;
            endAngle -= startAngle;
            if (anticlockwise) {
              if (endAngle < -MATH_CONST.PI2) {
                endAngle = -MATH_CONST.PI2;
              } else if (endAngle > 0) {
                endAngle = -MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;
              }
            } else if (endAngle > MATH_CONST.PI2) {
              endAngle = MATH_CONST.PI2;
            } else if (endAngle < 0) {
              endAngle = MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;
            }
            var path = [x2 + Math.cos(startAngle) * radius, y2 + Math.sin(startAngle) * radius];
            var ta2;
            while (iteration < 1) {
              ta2 = endAngle * iteration + startAngle;
              path.push(x2 + Math.cos(ta2) * radius, y2 + Math.sin(ta2) * radius);
              iteration += step;
            }
            ta2 = endAngle + startAngle;
            path.push(x2 + Math.cos(ta2) * radius, y2 + Math.sin(ta2) * radius);
            path.push(x2 + Math.cos(startAngle) * radius, y2 + Math.sin(startAngle) * radius);
            this.pathIndexes = Earcut(path);
            this.pathData = path;
            return this;
          }
        });
        module2.exports = Arc;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CurveRender = __webpack_require__(1100);
        var Earcut = __webpack_require__(59);
        var Rectangle = __webpack_require__(10);
        var Shape = __webpack_require__(34);
        var Curve = new Class({
          Extends: Shape,
          Mixins: [
            CurveRender
          ],
          initialize: function Curve2(scene, x2, y2, curve, fillColor, fillAlpha) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            Shape.call(this, scene, "Curve", curve);
            this._smoothness = 32;
            this._curveBounds = new Rectangle();
            this.closePath = false;
            this.setPosition(x2, y2);
            if (fillColor !== void 0) {
              this.setFillStyle(fillColor, fillAlpha);
            }
            this.updateData();
          },
          smoothness: {
            get: function() {
              return this._smoothness;
            },
            set: function(value) {
              this._smoothness = value;
              this.updateData();
            }
          },
          setSmoothness: function(value) {
            this._smoothness = value;
            return this.updateData();
          },
          updateData: function() {
            var bounds = this._curveBounds;
            var smoothness = this._smoothness;
            this.geom.getBounds(bounds, smoothness);
            this.setSize(bounds.width, bounds.height);
            this.updateDisplayOrigin();
            var path = [];
            var points = this.geom.getPoints(smoothness);
            for (var i2 = 0; i2 < points.length; i2++) {
              path.push(points[i2].x, points[i2].y);
            }
            path.push(points[0].x, points[0].y);
            this.pathIndexes = Earcut(path);
            this.pathData = path;
            return this;
          }
        });
        module2.exports = Curve;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Earcut = __webpack_require__(59);
        var EllipseRender = __webpack_require__(1103);
        var GeomEllipse = __webpack_require__(111);
        var Shape = __webpack_require__(34);
        var Ellipse = new Class({
          Extends: Shape,
          Mixins: [
            EllipseRender
          ],
          initialize: function Ellipse2(scene, x2, y2, width, height, fillColor, fillAlpha) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = 128;
            }
            if (height === void 0) {
              height = 128;
            }
            Shape.call(this, scene, "Ellipse", new GeomEllipse(width / 2, height / 2, width, height));
            this._smoothness = 64;
            this.setPosition(x2, y2);
            this.width = width;
            this.height = height;
            if (fillColor !== void 0) {
              this.setFillStyle(fillColor, fillAlpha);
            }
            this.updateDisplayOrigin();
            this.updateData();
          },
          smoothness: {
            get: function() {
              return this._smoothness;
            },
            set: function(value) {
              this._smoothness = value;
              this.updateData();
            }
          },
          setSize: function(width, height) {
            this.width = width;
            this.height = height;
            this.geom.setPosition(width / 2, height / 2);
            this.geom.setSize(width, height);
            return this.updateData();
          },
          setSmoothness: function(value) {
            this._smoothness = value;
            return this.updateData();
          },
          updateData: function() {
            var path = [];
            var points = this.geom.getPoints(this._smoothness);
            for (var i2 = 0; i2 < points.length; i2++) {
              path.push(points[i2].x, points[i2].y);
            }
            path.push(points[0].x, points[0].y);
            this.pathIndexes = Earcut(path);
            this.pathData = path;
            return this;
          }
        });
        module2.exports = Ellipse;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Shape = __webpack_require__(34);
        var GridRender = __webpack_require__(1106);
        var Grid = new Class({
          Extends: Shape,
          Mixins: [
            GridRender
          ],
          initialize: function Grid2(scene, x2, y2, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = 128;
            }
            if (height === void 0) {
              height = 128;
            }
            if (cellWidth === void 0) {
              cellWidth = 32;
            }
            if (cellHeight === void 0) {
              cellHeight = 32;
            }
            Shape.call(this, scene, "Grid", null);
            this.cellWidth = cellWidth;
            this.cellHeight = cellHeight;
            this.showCells = true;
            this.outlineFillColor = 0;
            this.outlineFillAlpha = 0;
            this.showOutline = true;
            this.showAltCells = false;
            this.altFillColor;
            this.altFillAlpha;
            this.setPosition(x2, y2);
            this.setSize(width, height);
            this.setFillStyle(fillColor, fillAlpha);
            if (outlineFillColor !== void 0) {
              this.setOutlineStyle(outlineFillColor, outlineFillAlpha);
            }
            this.updateDisplayOrigin();
          },
          setFillStyle: function(fillColor, fillAlpha) {
            if (fillAlpha === void 0) {
              fillAlpha = 1;
            }
            if (fillColor === void 0) {
              this.showCells = false;
            } else {
              this.fillColor = fillColor;
              this.fillAlpha = fillAlpha;
              this.showCells = true;
            }
            return this;
          },
          setAltFillStyle: function(fillColor, fillAlpha) {
            if (fillAlpha === void 0) {
              fillAlpha = 1;
            }
            if (fillColor === void 0) {
              this.showAltCells = false;
            } else {
              this.altFillColor = fillColor;
              this.altFillAlpha = fillAlpha;
              this.showAltCells = true;
            }
            return this;
          },
          setOutlineStyle: function(fillColor, fillAlpha) {
            if (fillAlpha === void 0) {
              fillAlpha = 1;
            }
            if (fillColor === void 0) {
              this.showOutline = false;
            } else {
              this.outlineFillColor = fillColor;
              this.outlineFillAlpha = fillAlpha;
              this.showOutline = true;
            }
            return this;
          }
        });
        module2.exports = Grid;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var IsoBoxRender = __webpack_require__(1109);
        var Class = __webpack_require__(0);
        var Shape = __webpack_require__(34);
        var IsoBox = new Class({
          Extends: Shape,
          Mixins: [
            IsoBoxRender
          ],
          initialize: function IsoBox2(scene, x2, y2, size, height, fillTop, fillLeft, fillRight) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (size === void 0) {
              size = 48;
            }
            if (height === void 0) {
              height = 32;
            }
            if (fillTop === void 0) {
              fillTop = 15658734;
            }
            if (fillLeft === void 0) {
              fillLeft = 10066329;
            }
            if (fillRight === void 0) {
              fillRight = 13421772;
            }
            Shape.call(this, scene, "IsoBox", null);
            this.projection = 4;
            this.fillTop = fillTop;
            this.fillLeft = fillLeft;
            this.fillRight = fillRight;
            this.showTop = true;
            this.showLeft = true;
            this.showRight = true;
            this.isFilled = true;
            this.setPosition(x2, y2);
            this.setSize(size, height);
            this.updateDisplayOrigin();
          },
          setProjection: function(value) {
            this.projection = value;
            return this;
          },
          setFaces: function(showTop, showLeft, showRight) {
            if (showTop === void 0) {
              showTop = true;
            }
            if (showLeft === void 0) {
              showLeft = true;
            }
            if (showRight === void 0) {
              showRight = true;
            }
            this.showTop = showTop;
            this.showLeft = showLeft;
            this.showRight = showRight;
            return this;
          },
          setFillStyle: function(fillTop, fillLeft, fillRight) {
            this.fillTop = fillTop;
            this.fillLeft = fillLeft;
            this.fillRight = fillRight;
            this.isFilled = true;
            return this;
          }
        });
        module2.exports = IsoBox;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var IsoTriangleRender = __webpack_require__(1112);
        var Shape = __webpack_require__(34);
        var IsoTriangle = new Class({
          Extends: Shape,
          Mixins: [
            IsoTriangleRender
          ],
          initialize: function IsoTriangle2(scene, x2, y2, size, height, reversed, fillTop, fillLeft, fillRight) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (size === void 0) {
              size = 48;
            }
            if (height === void 0) {
              height = 32;
            }
            if (reversed === void 0) {
              reversed = false;
            }
            if (fillTop === void 0) {
              fillTop = 15658734;
            }
            if (fillLeft === void 0) {
              fillLeft = 10066329;
            }
            if (fillRight === void 0) {
              fillRight = 13421772;
            }
            Shape.call(this, scene, "IsoTriangle", null);
            this.projection = 4;
            this.fillTop = fillTop;
            this.fillLeft = fillLeft;
            this.fillRight = fillRight;
            this.showTop = true;
            this.showLeft = true;
            this.showRight = true;
            this.isReversed = reversed;
            this.isFilled = true;
            this.setPosition(x2, y2);
            this.setSize(size, height);
            this.updateDisplayOrigin();
          },
          setProjection: function(value) {
            this.projection = value;
            return this;
          },
          setReversed: function(reversed) {
            this.isReversed = reversed;
            return this;
          },
          setFaces: function(showTop, showLeft, showRight) {
            if (showTop === void 0) {
              showTop = true;
            }
            if (showLeft === void 0) {
              showLeft = true;
            }
            if (showRight === void 0) {
              showRight = true;
            }
            this.showTop = showTop;
            this.showLeft = showLeft;
            this.showRight = showRight;
            return this;
          },
          setFillStyle: function(fillTop, fillLeft, fillRight) {
            this.fillTop = fillTop;
            this.fillLeft = fillLeft;
            this.fillRight = fillRight;
            this.isFilled = true;
            return this;
          }
        });
        module2.exports = IsoTriangle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Shape = __webpack_require__(34);
        var GeomLine = __webpack_require__(47);
        var LineRender = __webpack_require__(1115);
        var Line = new Class({
          Extends: Shape,
          Mixins: [
            LineRender
          ],
          initialize: function Line2(scene, x2, y2, x1, y1, x22, y22, strokeColor, strokeAlpha) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (x1 === void 0) {
              x1 = 0;
            }
            if (y1 === void 0) {
              y1 = 0;
            }
            if (x22 === void 0) {
              x22 = 128;
            }
            if (y22 === void 0) {
              y22 = 0;
            }
            Shape.call(this, scene, "Line", new GeomLine(x1, y1, x22, y22));
            var width = Math.max(1, this.geom.right - this.geom.left);
            var height = Math.max(1, this.geom.bottom - this.geom.top);
            this.lineWidth = 1;
            this._startWidth = 1;
            this._endWidth = 1;
            this.setPosition(x2, y2);
            this.setSize(width, height);
            if (strokeColor !== void 0) {
              this.setStrokeStyle(1, strokeColor, strokeAlpha);
            }
            this.updateDisplayOrigin();
          },
          setLineWidth: function(startWidth, endWidth) {
            if (endWidth === void 0) {
              endWidth = startWidth;
            }
            this._startWidth = startWidth;
            this._endWidth = endWidth;
            this.lineWidth = startWidth;
            return this;
          },
          setTo: function(x1, y1, x2, y2) {
            this.geom.setTo(x1, y1, x2, y2);
            return this;
          }
        });
        module2.exports = Line;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PolygonRender = __webpack_require__(1118);
        var Class = __webpack_require__(0);
        var Earcut = __webpack_require__(59);
        var GetAABB = __webpack_require__(469);
        var GeomPolygon = __webpack_require__(227);
        var Shape = __webpack_require__(34);
        var Smooth = __webpack_require__(472);
        var Polygon = new Class({
          Extends: Shape,
          Mixins: [
            PolygonRender
          ],
          initialize: function Polygon2(scene, x2, y2, points, fillColor, fillAlpha) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            Shape.call(this, scene, "Polygon", new GeomPolygon(points));
            var bounds = GetAABB(this.geom);
            this.setPosition(x2, y2);
            this.setSize(bounds.width, bounds.height);
            if (fillColor !== void 0) {
              this.setFillStyle(fillColor, fillAlpha);
            }
            this.updateDisplayOrigin();
            this.updateData();
          },
          smooth: function(iterations) {
            if (iterations === void 0) {
              iterations = 1;
            }
            for (var i2 = 0; i2 < iterations; i2++) {
              Smooth(this.geom);
            }
            return this.updateData();
          },
          updateData: function() {
            var path = [];
            var points = this.geom.points;
            for (var i2 = 0; i2 < points.length; i2++) {
              path.push(points[i2].x, points[i2].y);
            }
            path.push(points[0].x, points[0].y);
            this.pathIndexes = Earcut(path);
            this.pathData = path;
            return this;
          }
        });
        module2.exports = Polygon;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rectangle = __webpack_require__(10);
        var GetAABB = function(polygon, out) {
          if (out === void 0) {
            out = new Rectangle();
          }
          var minX = Infinity;
          var minY = Infinity;
          var maxX = -minX;
          var maxY = -minY;
          var p2;
          for (var i2 = 0; i2 < polygon.points.length; i2++) {
            p2 = polygon.points[i2];
            minX = Math.min(minX, p2.x);
            minY = Math.min(minY, p2.y);
            maxX = Math.max(maxX, p2.x);
            maxY = Math.max(maxY, p2.y);
          }
          out.x = minX;
          out.y = minY;
          out.width = maxX - minX;
          out.height = maxY - minY;
          return out;
        };
        module2.exports = GetAABB;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Length = __webpack_require__(67);
        var Line = __webpack_require__(47);
        var Perimeter = __webpack_require__(471);
        var GetPoints = function(polygon, quantity, stepRate, out) {
          if (out === void 0) {
            out = [];
          }
          var points = polygon.points;
          var perimeter = Perimeter(polygon);
          if (!quantity && stepRate > 0) {
            quantity = perimeter / stepRate;
          }
          for (var i2 = 0; i2 < quantity; i2++) {
            var position = perimeter * (i2 / quantity);
            var accumulatedPerimeter = 0;
            for (var j = 0; j < points.length; j++) {
              var pointA = points[j];
              var pointB = points[(j + 1) % points.length];
              var line = new Line(pointA.x, pointA.y, pointB.x, pointB.y);
              var length = Length(line);
              if (position < accumulatedPerimeter || position > accumulatedPerimeter + length) {
                accumulatedPerimeter += length;
                continue;
              }
              var point = line.getPoint((position - accumulatedPerimeter) / length);
              out.push(point);
              break;
            }
          }
          return out;
        };
        module2.exports = GetPoints;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Length = __webpack_require__(67);
        var Line = __webpack_require__(47);
        var Perimeter = function(polygon) {
          var points = polygon.points;
          var perimeter = 0;
          for (var i2 = 0; i2 < points.length; i2++) {
            var pointA = points[i2];
            var pointB = points[(i2 + 1) % points.length];
            var line = new Line(pointA.x, pointA.y, pointB.x, pointB.y);
            perimeter += Length(line);
          }
          return perimeter;
        };
        module2.exports = Perimeter;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Igor Ognichenko <ognichenko.igor@gmail.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var copy = function(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          return out;
        };
        var Smooth = function(polygon) {
          var i2;
          var points = [];
          var data = polygon.points;
          for (i2 = 0; i2 < data.length; i2++) {
            points.push([data[i2].x, data[i2].y]);
          }
          var output = [];
          if (points.length > 0) {
            output.push(copy([0, 0], points[0]));
          }
          for (i2 = 0; i2 < points.length - 1; i2++) {
            var p0 = points[i2];
            var p1 = points[i2 + 1];
            var p0x = p0[0];
            var p0y = p0[1];
            var p1x = p1[0];
            var p1y = p1[1];
            output.push([0.85 * p0x + 0.15 * p1x, 0.85 * p0y + 0.15 * p1y]);
            output.push([0.15 * p0x + 0.85 * p1x, 0.15 * p0y + 0.85 * p1y]);
          }
          if (points.length > 1) {
            output.push(copy([0, 0], points[points.length - 1]));
          }
          return polygon.setTo(output);
        };
        module2.exports = Smooth;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GeomRectangle = __webpack_require__(10);
        var Shape = __webpack_require__(34);
        var RectangleRender = __webpack_require__(1121);
        var Rectangle = new Class({
          Extends: Shape,
          Mixins: [
            RectangleRender
          ],
          initialize: function Rectangle2(scene, x2, y2, width, height, fillColor, fillAlpha) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = 128;
            }
            if (height === void 0) {
              height = 128;
            }
            Shape.call(this, scene, "Rectangle", new GeomRectangle(0, 0, width, height));
            this.setPosition(x2, y2);
            this.setSize(width, height);
            if (fillColor !== void 0) {
              this.setFillStyle(fillColor, fillAlpha);
            }
            this.updateDisplayOrigin();
            this.updateData();
          },
          setSize: function(width, height) {
            this.width = width;
            this.height = height;
            this.geom.setSize(width, height);
            this.updateData();
            return this;
          },
          updateData: function() {
            var path = [];
            var rect = this.geom;
            var line = this._tempLine;
            rect.getLineA(line);
            path.push(line.x1, line.y1, line.x2, line.y2);
            rect.getLineB(line);
            path.push(line.x2, line.y2);
            rect.getLineC(line);
            path.push(line.x2, line.y2);
            rect.getLineD(line);
            path.push(line.x2, line.y2);
            this.pathData = path;
            return this;
          }
        });
        module2.exports = Rectangle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var StarRender = __webpack_require__(1124);
        var Class = __webpack_require__(0);
        var Earcut = __webpack_require__(59);
        var Shape = __webpack_require__(34);
        var Star = new Class({
          Extends: Shape,
          Mixins: [
            StarRender
          ],
          initialize: function Star2(scene, x2, y2, points, innerRadius, outerRadius, fillColor, fillAlpha) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (points === void 0) {
              points = 5;
            }
            if (innerRadius === void 0) {
              innerRadius = 32;
            }
            if (outerRadius === void 0) {
              outerRadius = 64;
            }
            Shape.call(this, scene, "Star", null);
            this._points = points;
            this._innerRadius = innerRadius;
            this._outerRadius = outerRadius;
            this.setPosition(x2, y2);
            this.setSize(outerRadius * 2, outerRadius * 2);
            if (fillColor !== void 0) {
              this.setFillStyle(fillColor, fillAlpha);
            }
            this.updateDisplayOrigin();
            this.updateData();
          },
          setPoints: function(value) {
            this._points = value;
            return this.updateData();
          },
          setInnerRadius: function(value) {
            this._innerRadius = value;
            return this.updateData();
          },
          setOuterRadius: function(value) {
            this._outerRadius = value;
            return this.updateData();
          },
          points: {
            get: function() {
              return this._points;
            },
            set: function(value) {
              this._points = value;
              this.updateData();
            }
          },
          innerRadius: {
            get: function() {
              return this._innerRadius;
            },
            set: function(value) {
              this._innerRadius = value;
              this.updateData();
            }
          },
          outerRadius: {
            get: function() {
              return this._outerRadius;
            },
            set: function(value) {
              this._outerRadius = value;
              this.updateData();
            }
          },
          updateData: function() {
            var path = [];
            var points = this._points;
            var innerRadius = this._innerRadius;
            var outerRadius = this._outerRadius;
            var rot = Math.PI / 2 * 3;
            var step = Math.PI / points;
            var x2 = outerRadius;
            var y2 = outerRadius;
            path.push(x2, y2 + -outerRadius);
            for (var i2 = 0; i2 < points; i2++) {
              path.push(x2 + Math.cos(rot) * outerRadius, y2 + Math.sin(rot) * outerRadius);
              rot += step;
              path.push(x2 + Math.cos(rot) * innerRadius, y2 + Math.sin(rot) * innerRadius);
              rot += step;
            }
            path.push(x2, y2 + -outerRadius);
            this.pathIndexes = Earcut(path);
            this.pathData = path;
            return this;
          }
        });
        module2.exports = Star;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Shape = __webpack_require__(34);
        var GeomTriangle = __webpack_require__(82);
        var TriangleRender = __webpack_require__(1127);
        var Triangle = new Class({
          Extends: Shape,
          Mixins: [
            TriangleRender
          ],
          initialize: function Triangle2(scene, x2, y2, x1, y1, x22, y22, x3, y3, fillColor, fillAlpha) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (x1 === void 0) {
              x1 = 0;
            }
            if (y1 === void 0) {
              y1 = 128;
            }
            if (x22 === void 0) {
              x22 = 64;
            }
            if (y22 === void 0) {
              y22 = 0;
            }
            if (x3 === void 0) {
              x3 = 128;
            }
            if (y3 === void 0) {
              y3 = 128;
            }
            Shape.call(this, scene, "Triangle", new GeomTriangle(x1, y1, x22, y22, x3, y3));
            var width = this.geom.right - this.geom.left;
            var height = this.geom.bottom - this.geom.top;
            this.setPosition(x2, y2);
            this.setSize(width, height);
            if (fillColor !== void 0) {
              this.setFillStyle(fillColor, fillAlpha);
            }
            this.updateDisplayOrigin();
            this.updateData();
          },
          setTo: function(x1, y1, x2, y2, x3, y3) {
            this.geom.setTo(x1, y1, x2, y2, x3, y3);
            return this.updateData();
          },
          updateData: function() {
            var path = [];
            var tri = this.geom;
            var line = this._tempLine;
            tri.getLineA(line);
            path.push(line.x1, line.y1, line.x2, line.y2);
            tri.getLineB(line);
            path.push(line.x2, line.y2);
            tri.getLineC(line);
            path.push(line.x2, line.y2);
            this.pathData = path;
            return this;
          }
        });
        module2.exports = Triangle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var Length = __webpack_require__(67);
        var GetPoint = function(triangle, position, out) {
          if (out === void 0) {
            out = new Point();
          }
          var line1 = triangle.getLineA();
          var line2 = triangle.getLineB();
          var line3 = triangle.getLineC();
          if (position <= 0 || position >= 1) {
            out.x = line1.x1;
            out.y = line1.y1;
            return out;
          }
          var length1 = Length(line1);
          var length2 = Length(line2);
          var length3 = Length(line3);
          var perimeter = length1 + length2 + length3;
          var p2 = perimeter * position;
          var localPosition = 0;
          if (p2 < length1) {
            localPosition = p2 / length1;
            out.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;
            out.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;
          } else if (p2 > length1 + length2) {
            p2 -= length1 + length2;
            localPosition = p2 / length3;
            out.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;
            out.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;
          } else {
            p2 -= length1;
            localPosition = p2 / length2;
            out.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;
            out.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;
          }
          return out;
        };
        module2.exports = GetPoint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Length = __webpack_require__(67);
        var Point = __webpack_require__(4);
        var GetPoints = function(triangle, quantity, stepRate, out) {
          if (out === void 0) {
            out = [];
          }
          var line1 = triangle.getLineA();
          var line2 = triangle.getLineB();
          var line3 = triangle.getLineC();
          var length1 = Length(line1);
          var length2 = Length(line2);
          var length3 = Length(line3);
          var perimeter = length1 + length2 + length3;
          if (!quantity && stepRate > 0) {
            quantity = perimeter / stepRate;
          }
          for (var i2 = 0; i2 < quantity; i2++) {
            var p2 = perimeter * (i2 / quantity);
            var localPosition = 0;
            var point = new Point();
            if (p2 < length1) {
              localPosition = p2 / length1;
              point.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;
              point.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;
            } else if (p2 > length1 + length2) {
              p2 -= length1 + length2;
              localPosition = p2 / length3;
              point.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;
              point.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;
            } else {
              p2 -= length1;
              localPosition = p2 / length2;
              point.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;
              point.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;
            }
            out.push(point);
          }
          return out;
        };
        module2.exports = GetPoints;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetValue = function(source, key, value) {
          if (!source || typeof source === "number") {
            return false;
          } else if (source.hasOwnProperty(key)) {
            source[key] = value;
            return true;
          } else if (key.indexOf(".") !== -1) {
            var keys = key.split(".");
            var parent = source;
            var prev = source;
            for (var i2 = 0; i2 < keys.length; i2++) {
              if (parent.hasOwnProperty(keys[i2])) {
                prev = parent;
                parent = parent[keys[i2]];
              } else {
                return false;
              }
            }
            prev[keys[keys.length - 1]] = value;
            return true;
          }
          return false;
        };
        module2.exports = SetValue;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Face = __webpack_require__(116);
        var Vertex = __webpack_require__(117);
        var GenerateVerts = function(vertices, uvs, indicies, containsZ, normals, colors, alphas) {
          if (containsZ === void 0) {
            containsZ = false;
          }
          if (colors === void 0) {
            colors = 16777215;
          }
          if (alphas === void 0) {
            alphas = 1;
          }
          if (vertices.length !== uvs.length) {
            console.warn("GenerateVerts: vertices and uvs count not equal");
            return;
          }
          var result = {
            faces: [],
            vertices: []
          };
          var i2;
          var x2;
          var y2;
          var z2;
          var u2;
          var v2;
          var color;
          var alpha;
          var normalX;
          var normalY;
          var normalZ;
          var iInc = containsZ ? 3 : 2;
          var isColorArray = Array.isArray(colors);
          var isAlphaArray = Array.isArray(alphas);
          if (Array.isArray(indicies) && indicies.length > 0) {
            for (i2 = 0; i2 < indicies.length; i2++) {
              var index1 = indicies[i2];
              var index2 = indicies[i2] * 2;
              var index3 = indicies[i2] * iInc;
              x2 = vertices[index3];
              y2 = vertices[index3 + 1];
              z2 = containsZ ? vertices[index3 + 2] : 0;
              u2 = uvs[index2];
              v2 = uvs[index2 + 1];
              color = isColorArray ? colors[index1] : colors;
              alpha = isAlphaArray ? alphas[index1] : alphas;
              normalX = 0;
              normalY = 0;
              normalZ = 0;
              if (normals) {
                normalX = normals[index3];
                normalY = normals[index3 + 1];
                normalZ = containsZ ? normals[index3 + 2] : 0;
              }
              result.vertices.push(new Vertex(x2, y2, z2, u2, v2, color, alpha, normalX, normalY, normalZ));
            }
          } else {
            var uvIndex = 0;
            var colorIndex = 0;
            for (i2 = 0; i2 < vertices.length; i2 += iInc) {
              x2 = vertices[i2];
              y2 = vertices[i2 + 1];
              z2 = containsZ ? vertices[i2 + 2] : 0;
              u2 = uvs[uvIndex];
              v2 = uvs[uvIndex + 1];
              color = isColorArray ? colors[colorIndex] : colors;
              alpha = isAlphaArray ? alphas[colorIndex] : alphas;
              normalX = 0;
              normalY = 0;
              normalZ = 0;
              if (normals) {
                normalX = normals[i2];
                normalY = normals[i2 + 1];
                normalZ = containsZ ? normals[i2 + 2] : 0;
              }
              result.vertices.push(new Vertex(x2, y2, z2, u2, v2, color, alpha, normalX, normalY, normalZ));
              uvIndex += 2;
              colorIndex++;
            }
          }
          for (i2 = 0; i2 < result.vertices.length; i2 += 3) {
            var vert1 = result.vertices[i2];
            var vert2 = result.vertices[i2 + 1];
            var vert3 = result.vertices[i2 + 2];
            result.faces.push(new Face(vert1, vert2, vert3));
          }
          return result;
        };
        module2.exports = GenerateVerts;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Face = __webpack_require__(116);
        var Matrix4 = __webpack_require__(69);
        var Vector3 = __webpack_require__(39);
        var Vertex = __webpack_require__(117);
        var tempPosition = new Vector3();
        var tempRotation = new Vector3();
        var tempMatrix = new Matrix4();
        var GenerateObjVerts = function(data, mesh, scale, x2, y2, z2, rotateX, rotateY, rotateZ, zIsUp) {
          if (scale === void 0) {
            scale = 1;
          }
          if (x2 === void 0) {
            x2 = 0;
          }
          if (y2 === void 0) {
            y2 = 0;
          }
          if (z2 === void 0) {
            z2 = 0;
          }
          if (rotateX === void 0) {
            rotateX = 0;
          }
          if (rotateY === void 0) {
            rotateY = 0;
          }
          if (rotateZ === void 0) {
            rotateZ = 0;
          }
          if (zIsUp === void 0) {
            zIsUp = true;
          }
          var result = {
            faces: [],
            verts: []
          };
          var materials = data.materials;
          tempPosition.set(x2, y2, z2);
          tempRotation.set(rotateX, rotateY, rotateZ);
          tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);
          for (var m2 = 0; m2 < data.models.length; m2++) {
            var model = data.models[m2];
            var vertices = model.vertices;
            var textureCoords = model.textureCoords;
            var faces = model.faces;
            for (var i2 = 0; i2 < faces.length; i2++) {
              var face = faces[i2];
              var v1 = face.vertices[0];
              var v2 = face.vertices[1];
              var v3 = face.vertices[2];
              var m1 = vertices[v1.vertexIndex];
              var m22 = vertices[v2.vertexIndex];
              var m3 = vertices[v3.vertexIndex];
              var t1 = v1.textureCoordsIndex;
              var t2 = v2.textureCoordsIndex;
              var t3 = v3.textureCoordsIndex;
              var uv1 = t1 === -1 ? { u: 0, v: 1 } : textureCoords[t1];
              var uv2 = t2 === -1 ? { u: 0, v: 0 } : textureCoords[t2];
              var uv3 = t3 === -1 ? { u: 1, v: 1 } : textureCoords[t3];
              var color = 16777215;
              if (face.material !== "" && materials[face.material]) {
                color = materials[face.material];
              }
              var vert1 = new Vertex(m1.x * scale, m1.y * scale, m1.z * scale, uv1.u, uv1.v, color).transformMat4(tempMatrix);
              var vert2 = new Vertex(m22.x * scale, m22.y * scale, m22.z * scale, uv2.u, uv2.v, color).transformMat4(tempMatrix);
              var vert3 = new Vertex(m3.x * scale, m3.y * scale, m3.z * scale, uv3.u, uv3.v, color).transformMat4(tempMatrix);
              result.verts.push(vert1, vert2, vert3);
              result.faces.push(new Face(vert1, vert2, vert3));
            }
          }
          if (mesh) {
            mesh.faces = mesh.faces.concat(result.faces);
            mesh.vertices = mesh.vertices.concat(result.verts);
          }
          return result;
        };
        module2.exports = GenerateObjVerts;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Circle = __webpack_require__(65);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var RGB = __webpack_require__(200);
        var Utils = __webpack_require__(12);
        var Light = new Class({
          Extends: Circle,
          Mixins: [
            Components.ScrollFactor,
            Components.Visible
          ],
          initialize: function Light2(x2, y2, radius, r2, g2, b2, intensity) {
            Circle.call(this, x2, y2, radius);
            this.color = new RGB(r2, g2, b2);
            this.intensity = intensity;
            this.renderFlags = 15;
            this.cameraFilter = 0;
            this.setScrollFactor(1, 1);
          },
          willRender: function(camera) {
            return !(Light.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
          },
          setColor: function(rgb) {
            var color = Utils.getFloatsFromUintRGB(rgb);
            this.color.set(color[0], color[1], color[2]);
            return this;
          },
          setIntensity: function(intensity) {
            this.intensity = intensity;
            return this;
          },
          setRadius: function(radius) {
            this.radius = radius;
            return this;
          }
        });
        Light.RENDER_MASK = 15;
        module2.exports = Light;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CircleToRectangle = __webpack_require__(151);
        var Class = __webpack_require__(0);
        var DistanceBetween = __webpack_require__(50);
        var Light = __webpack_require__(481);
        var PointLight = __webpack_require__(150);
        var RGB = __webpack_require__(200);
        var SpliceOne = __webpack_require__(74);
        var StableSort = __webpack_require__(79);
        var Utils = __webpack_require__(12);
        var LightsManager = new Class({
          initialize: function LightsManager2() {
            this.lights = [];
            this.ambientColor = new RGB(0.1, 0.1, 0.1);
            this.active = false;
            this.maxLights = -1;
            this.visibleLights = 0;
          },
          addPointLight: function(x2, y2, color, radius, intensity, attenuation) {
            return this.systems.displayList.add(new PointLight(this.scene, x2, y2, color, radius, intensity, attenuation));
          },
          enable: function() {
            if (this.maxLights === -1) {
              this.maxLights = this.systems.renderer.config.maxLights;
            }
            this.active = true;
            return this;
          },
          disable: function() {
            this.active = false;
            return this;
          },
          getLights: function(camera) {
            var lights = this.lights;
            var worldView = camera.worldView;
            var visibleLights = [];
            for (var i2 = 0; i2 < lights.length; i2++) {
              var light = lights[i2];
              if (light.willRender(camera) && CircleToRectangle(light, worldView)) {
                visibleLights.push({
                  light,
                  distance: DistanceBetween(light.x, light.y, worldView.centerX, worldView.centerY)
                });
              }
            }
            if (visibleLights.length > this.maxLights) {
              StableSort(visibleLights, this.sortByDistance);
              visibleLights = visibleLights.slice(0, this.maxLights);
            }
            this.visibleLights = visibleLights.length;
            return visibleLights;
          },
          sortByDistance: function(a, b2) {
            return a.distance >= b2.distance;
          },
          setAmbientColor: function(rgb) {
            var color = Utils.getFloatsFromUintRGB(rgb);
            this.ambientColor.set(color[0], color[1], color[2]);
            return this;
          },
          getMaxVisibleLights: function() {
            return this.maxLights;
          },
          getLightCount: function() {
            return this.lights.length;
          },
          addLight: function(x2, y2, radius, rgb, intensity) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (radius === void 0) {
              radius = 128;
            }
            if (rgb === void 0) {
              rgb = 16777215;
            }
            if (intensity === void 0) {
              intensity = 1;
            }
            var color = Utils.getFloatsFromUintRGB(rgb);
            var light = new Light(x2, y2, radius, color[0], color[1], color[2], intensity);
            this.lights.push(light);
            return light;
          },
          removeLight: function(light) {
            var index2 = this.lights.indexOf(light);
            if (index2 >= 0) {
              SpliceOne(this.lights, index2);
            }
            return this;
          },
          shutdown: function() {
            this.lights.length = 0;
          },
          destroy: function() {
            this.shutdown();
          }
        });
        module2.exports = LightsManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(56);
        var Extend = __webpack_require__(17);
        var Geom = {
          Circle: __webpack_require__(1191),
          Ellipse: __webpack_require__(1201),
          Intersects: __webpack_require__(484),
          Line: __webpack_require__(1221),
          Mesh: __webpack_require__(1243),
          Point: __webpack_require__(1246),
          Polygon: __webpack_require__(1260),
          Rectangle: __webpack_require__(502),
          Triangle: __webpack_require__(1293)
        };
        Geom = Extend(false, Geom, CONST);
        module2.exports = Geom;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          CircleToCircle: __webpack_require__(231),
          CircleToRectangle: __webpack_require__(151),
          GetCircleToCircle: __webpack_require__(1211),
          GetCircleToRectangle: __webpack_require__(1212),
          GetLineToCircle: __webpack_require__(232),
          GetLineToLine: __webpack_require__(485),
          GetLineToPoints: __webpack_require__(486),
          GetLineToPolygon: __webpack_require__(487),
          GetLineToRectangle: __webpack_require__(234),
          GetRaysFromPointToPolygon: __webpack_require__(1213),
          GetRectangleIntersection: __webpack_require__(1214),
          GetRectangleToRectangle: __webpack_require__(1215),
          GetRectangleToTriangle: __webpack_require__(1216),
          GetTriangleToCircle: __webpack_require__(1217),
          GetTriangleToLine: __webpack_require__(492),
          GetTriangleToTriangle: __webpack_require__(1218),
          LineToCircle: __webpack_require__(233),
          LineToLine: __webpack_require__(96),
          LineToRectangle: __webpack_require__(488),
          PointToLine: __webpack_require__(496),
          PointToLineSegment: __webpack_require__(1219),
          RectangleToRectangle: __webpack_require__(152),
          RectangleToTriangle: __webpack_require__(489),
          RectangleToValues: __webpack_require__(1220),
          TriangleToCircle: __webpack_require__(491),
          TriangleToLine: __webpack_require__(493),
          TriangleToTriangle: __webpack_require__(494)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector3 = __webpack_require__(39);
        var GetLineToLine = function(line1, line2, out) {
          var x1 = line1.x1;
          var y1 = line1.y1;
          var x2 = line1.x2;
          var y2 = line1.y2;
          var x3 = line2.x1;
          var y3 = line2.y1;
          var x4 = line2.x2;
          var y4 = line2.y2;
          var dx1 = x2 - x1;
          var dy1 = y2 - y1;
          var dx2 = x4 - x3;
          var dy2 = y4 - y3;
          var denom = dy2 * dx1 - dx2 * dy1;
          if (dx1 === 0 || denom === 0) {
            return false;
          }
          var T2 = (dx1 * (y3 - y1) + dy1 * (x1 - x3)) / (dx2 * dy1 - dy2 * dx1);
          var T1 = (x3 + dx2 * T2 - x1) / dx1;
          if (T1 < 0 || T2 < 0 || T2 > 1) {
            return null;
          }
          if (out === void 0) {
            out = new Vector3();
          }
          return out.set(x1 + dx1 * T1, y1 + dy1 * T1, T1);
        };
        module2.exports = GetLineToLine;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector3 = __webpack_require__(39);
        var GetLineToLine = __webpack_require__(485);
        var Line = __webpack_require__(47);
        var segment = new Line();
        var tempIntersect = new Vector3();
        var GetLineToPoints = function(line, points, out) {
          if (out === void 0) {
            out = new Vector3();
          }
          var closestIntersect = false;
          out.set();
          tempIntersect.set();
          var prev = points[0];
          for (var i2 = 1; i2 < points.length; i2++) {
            var current = points[i2];
            segment.setTo(prev.x, prev.y, current.x, current.y);
            prev = current;
            if (GetLineToLine(line, segment, tempIntersect)) {
              if (!closestIntersect || tempIntersect.z < out.z) {
                out.copy(tempIntersect);
                closestIntersect = true;
              }
            }
          }
          return closestIntersect ? out : null;
        };
        module2.exports = GetLineToPoints;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector3 = __webpack_require__(39);
        var Vector4 = __webpack_require__(140);
        var GetLineToPoints = __webpack_require__(486);
        var tempIntersect = new Vector3();
        var GetLineToPolygon = function(line, polygons, out) {
          if (out === void 0) {
            out = new Vector4();
          }
          if (!Array.isArray(polygons)) {
            polygons = [polygons];
          }
          var closestIntersect = false;
          out.set();
          tempIntersect.set();
          for (var i2 = 0; i2 < polygons.length; i2++) {
            if (GetLineToPoints(line, polygons[i2].points, tempIntersect)) {
              if (!closestIntersect || tempIntersect.z < out.z) {
                out.set(tempIntersect.x, tempIntersect.y, tempIntersect.z, i2);
                closestIntersect = true;
              }
            }
          }
          return closestIntersect ? out : null;
        };
        module2.exports = GetLineToPolygon;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var LineToRectangle = function(line, rect) {
          var x1 = line.x1;
          var y1 = line.y1;
          var x2 = line.x2;
          var y2 = line.y2;
          var bx1 = rect.x;
          var by1 = rect.y;
          var bx2 = rect.right;
          var by2 = rect.bottom;
          var t2 = 0;
          if (x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2 || x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2) {
            return true;
          }
          if (x1 < bx1 && x2 >= bx1) {
            t2 = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);
            if (t2 > by1 && t2 <= by2) {
              return true;
            }
          } else if (x1 > bx2 && x2 <= bx2) {
            t2 = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);
            if (t2 >= by1 && t2 <= by2) {
              return true;
            }
          }
          if (y1 < by1 && y2 >= by1) {
            t2 = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);
            if (t2 >= bx1 && t2 <= bx2) {
              return true;
            }
          } else if (y1 > by2 && y2 <= by2) {
            t2 = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);
            if (t2 >= bx1 && t2 <= bx2) {
              return true;
            }
          }
          return false;
        };
        module2.exports = LineToRectangle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var LineToLine = __webpack_require__(96);
        var Contains = __webpack_require__(57);
        var ContainsArray = __webpack_require__(235);
        var Decompose = __webpack_require__(490);
        var RectangleToTriangle = function(rect, triangle) {
          if (triangle.left > rect.right || triangle.right < rect.left || triangle.top > rect.bottom || triangle.bottom < rect.top) {
            return false;
          }
          var triA = triangle.getLineA();
          var triB = triangle.getLineB();
          var triC = triangle.getLineC();
          if (Contains(rect, triA.x1, triA.y1) || Contains(rect, triA.x2, triA.y2)) {
            return true;
          }
          if (Contains(rect, triB.x1, triB.y1) || Contains(rect, triB.x2, triB.y2)) {
            return true;
          }
          if (Contains(rect, triC.x1, triC.y1) || Contains(rect, triC.x2, triC.y2)) {
            return true;
          }
          var rectA = rect.getLineA();
          var rectB = rect.getLineB();
          var rectC = rect.getLineC();
          var rectD = rect.getLineD();
          if (LineToLine(triA, rectA) || LineToLine(triA, rectB) || LineToLine(triA, rectC) || LineToLine(triA, rectD)) {
            return true;
          }
          if (LineToLine(triB, rectA) || LineToLine(triB, rectB) || LineToLine(triB, rectC) || LineToLine(triB, rectD)) {
            return true;
          }
          if (LineToLine(triC, rectA) || LineToLine(triC, rectB) || LineToLine(triC, rectC) || LineToLine(triC, rectD)) {
            return true;
          }
          var points = Decompose(rect);
          var within = ContainsArray(triangle, points, true);
          return within.length > 0;
        };
        module2.exports = RectangleToTriangle;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Decompose = function(rect, out) {
          if (out === void 0) {
            out = [];
          }
          out.push({ x: rect.x, y: rect.y });
          out.push({ x: rect.right, y: rect.y });
          out.push({ x: rect.right, y: rect.bottom });
          out.push({ x: rect.x, y: rect.bottom });
          return out;
        };
        module2.exports = Decompose;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var LineToCircle = __webpack_require__(233);
        var Contains = __webpack_require__(115);
        var TriangleToCircle = function(triangle, circle) {
          if (triangle.left > circle.right || triangle.right < circle.left || triangle.top > circle.bottom || triangle.bottom < circle.top) {
            return false;
          }
          if (Contains(triangle, circle.x, circle.y)) {
            return true;
          }
          if (LineToCircle(triangle.getLineA(), circle)) {
            return true;
          }
          if (LineToCircle(triangle.getLineB(), circle)) {
            return true;
          }
          if (LineToCircle(triangle.getLineC(), circle)) {
            return true;
          }
          return false;
        };
        module2.exports = TriangleToCircle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Florian Vazelle
         * @author       Geoffrey Glaive
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var TriangleToLine = __webpack_require__(493);
        var LineToLine = __webpack_require__(96);
        var GetTriangleToLine = function(triangle, line, out) {
          if (out === void 0) {
            out = [];
          }
          if (TriangleToLine(triangle, line)) {
            var lineA = triangle.getLineA();
            var lineB = triangle.getLineB();
            var lineC = triangle.getLineC();
            var output = [new Point(), new Point(), new Point()];
            var result = [
              LineToLine(lineA, line, output[0]),
              LineToLine(lineB, line, output[1]),
              LineToLine(lineC, line, output[2])
            ];
            for (var i2 = 0; i2 < 3; i2++) {
              if (result[i2]) {
                out.push(output[i2]);
              }
            }
          }
          return out;
        };
        module2.exports = GetTriangleToLine;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var LineToLine = __webpack_require__(96);
        var TriangleToLine = function(triangle, line) {
          if (triangle.contains(line.x1, line.y1) || triangle.contains(line.x2, line.y2)) {
            return true;
          }
          if (LineToLine(triangle.getLineA(), line)) {
            return true;
          }
          if (LineToLine(triangle.getLineB(), line)) {
            return true;
          }
          if (LineToLine(triangle.getLineC(), line)) {
            return true;
          }
          return false;
        };
        module2.exports = TriangleToLine;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ContainsArray = __webpack_require__(235);
        var Decompose = __webpack_require__(495);
        var LineToLine = __webpack_require__(96);
        var TriangleToTriangle = function(triangleA, triangleB) {
          if (triangleA.left > triangleB.right || triangleA.right < triangleB.left || triangleA.top > triangleB.bottom || triangleA.bottom < triangleB.top) {
            return false;
          }
          var lineAA = triangleA.getLineA();
          var lineAB = triangleA.getLineB();
          var lineAC = triangleA.getLineC();
          var lineBA = triangleB.getLineA();
          var lineBB = triangleB.getLineB();
          var lineBC = triangleB.getLineC();
          if (LineToLine(lineAA, lineBA) || LineToLine(lineAA, lineBB) || LineToLine(lineAA, lineBC)) {
            return true;
          }
          if (LineToLine(lineAB, lineBA) || LineToLine(lineAB, lineBB) || LineToLine(lineAB, lineBC)) {
            return true;
          }
          if (LineToLine(lineAC, lineBA) || LineToLine(lineAC, lineBB) || LineToLine(lineAC, lineBC)) {
            return true;
          }
          var points = Decompose(triangleA);
          var within = ContainsArray(triangleB, points, true);
          if (within.length > 0) {
            return true;
          }
          points = Decompose(triangleB);
          within = ContainsArray(triangleA, points, true);
          if (within.length > 0) {
            return true;
          }
          return false;
        };
        module2.exports = TriangleToTriangle;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Decompose = function(triangle, out) {
          if (out === void 0) {
            out = [];
          }
          out.push({ x: triangle.x1, y: triangle.y1 });
          out.push({ x: triangle.x2, y: triangle.y2 });
          out.push({ x: triangle.x3, y: triangle.y3 });
          return out;
        };
        module2.exports = Decompose;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Florian Mertens
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PointToLine = function(point, line, lineThickness) {
          if (lineThickness === void 0) {
            lineThickness = 1;
          }
          var x1 = line.x1;
          var y1 = line.y1;
          var x2 = line.x2;
          var y2 = line.y2;
          var px = point.x;
          var py = point.y;
          var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
          if (L2 === 0) {
            return false;
          }
          var r2 = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / L2;
          if (r2 < 0) {
            return Math.sqrt((x1 - px) * (x1 - px) + (y1 - py) * (y1 - py)) <= lineThickness;
          } else if (r2 >= 0 && r2 <= 1) {
            var s = ((y1 - py) * (x2 - x1) - (x1 - px) * (y2 - y1)) / L2;
            return Math.abs(s) * Math.sqrt(L2) <= lineThickness;
          } else {
            return Math.sqrt((x2 - px) * (x2 - px) + (y2 - py) * (y2 - py)) <= lineThickness;
          }
        };
        module2.exports = PointToLine;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MATH_CONST = __webpack_require__(14);
        var Wrap = __webpack_require__(68);
        var Angle = __webpack_require__(97);
        var NormalAngle = function(line) {
          var angle = Angle(line) - MATH_CONST.TAU;
          return Wrap(angle, -Math.PI, Math.PI);
        };
        module2.exports = NormalAngle;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var flip = true;
        var defaultModelName = "untitled";
        var currentGroup = "";
        var currentMaterial = "";
        function stripComments(line) {
          var idx = line.indexOf("#");
          return idx > -1 ? line.substring(0, idx) : line;
        }
        function currentModel(result) {
          if (result.models.length === 0) {
            result.models.push({
              faces: [],
              name: defaultModelName,
              textureCoords: [],
              vertexNormals: [],
              vertices: []
            });
          }
          currentGroup = "";
          return result.models[result.models.length - 1];
        }
        function parseObject(lineItems, result) {
          var modelName = lineItems.length >= 2 ? lineItems[1] : defaultModelName;
          result.models.push({
            faces: [],
            name: modelName,
            textureCoords: [],
            vertexNormals: [],
            vertices: []
          });
          currentGroup = "";
        }
        function parseGroup(lineItems) {
          if (lineItems.length === 2) {
            currentGroup = lineItems[1];
          }
        }
        function parseVertexCoords(lineItems, result) {
          var len = lineItems.length;
          var x2 = len >= 2 ? parseFloat(lineItems[1]) : 0;
          var y2 = len >= 3 ? parseFloat(lineItems[2]) : 0;
          var z2 = len >= 4 ? parseFloat(lineItems[3]) : 0;
          currentModel(result).vertices.push({ x: x2, y: y2, z: z2 });
        }
        function parseTextureCoords(lineItems, result) {
          var len = lineItems.length;
          var u2 = len >= 2 ? parseFloat(lineItems[1]) : 0;
          var v2 = len >= 3 ? parseFloat(lineItems[2]) : 0;
          var w2 = len >= 4 ? parseFloat(lineItems[3]) : 0;
          if (isNaN(u2)) {
            u2 = 0;
          }
          if (isNaN(v2)) {
            v2 = 0;
          }
          if (isNaN(w2)) {
            w2 = 0;
          }
          if (flip) {
            v2 = 1 - v2;
          }
          currentModel(result).textureCoords.push({ u: u2, v: v2, w: w2 });
        }
        function parseVertexNormal(lineItems, result) {
          var len = lineItems.length;
          var x2 = len >= 2 ? parseFloat(lineItems[1]) : 0;
          var y2 = len >= 3 ? parseFloat(lineItems[2]) : 0;
          var z2 = len >= 4 ? parseFloat(lineItems[3]) : 0;
          currentModel(result).vertexNormals.push({ x: x2, y: y2, z: z2 });
        }
        function parsePolygon(lineItems, result) {
          var totalVertices = lineItems.length - 1;
          if (totalVertices < 3) {
            return;
          }
          var face = {
            group: currentGroup,
            material: currentMaterial,
            vertices: []
          };
          for (var i2 = 0; i2 < totalVertices; i2++) {
            var vertexString = lineItems[i2 + 1];
            var vertexValues = vertexString.split("/");
            var vvLen = vertexValues.length;
            if (vvLen < 1 || vvLen > 3) {
              continue;
            }
            var vertexIndex = 0;
            var textureCoordsIndex = 0;
            var vertexNormalIndex = 0;
            vertexIndex = parseInt(vertexValues[0], 10);
            if (vvLen > 1 && vertexValues[1] !== "") {
              textureCoordsIndex = parseInt(vertexValues[1], 10);
            }
            if (vvLen > 2) {
              vertexNormalIndex = parseInt(vertexValues[2], 10);
            }
            if (vertexIndex !== 0) {
              if (vertexIndex < 0) {
                vertexIndex = currentModel(result).vertices.length + 1 + vertexIndex;
              }
              textureCoordsIndex -= 1;
              vertexIndex -= 1;
              vertexNormalIndex -= 1;
              face.vertices.push({
                textureCoordsIndex,
                vertexIndex,
                vertexNormalIndex
              });
            }
          }
          currentModel(result).faces.push(face);
        }
        function parseMtlLib(lineItems, result) {
          if (lineItems.length >= 2) {
            result.materialLibraries.push(lineItems[1]);
          }
        }
        function parseUseMtl(lineItems) {
          if (lineItems.length >= 2) {
            currentMaterial = lineItems[1];
          }
        }
        var ParseObj = function(data, flipUV) {
          if (flipUV === void 0) {
            flipUV = true;
          }
          flip = flipUV;
          var result = {
            materials: {},
            materialLibraries: [],
            models: []
          };
          currentGroup = "";
          currentMaterial = "";
          var lines = data.split("\n");
          for (var i2 = 0; i2 < lines.length; i2++) {
            var line = stripComments(lines[i2]);
            var lineItems = line.replace(/\s\s+/g, " ").trim().split(" ");
            switch (lineItems[0].toLowerCase()) {
              case "o":
                parseObject(lineItems, result);
                break;
              case "g":
                parseGroup(lineItems);
                break;
              case "v":
                parseVertexCoords(lineItems, result);
                break;
              case "vt":
                parseTextureCoords(lineItems, result);
                break;
              case "vn":
                parseVertexNormal(lineItems, result);
                break;
              case "f":
                parsePolygon(lineItems, result);
                break;
              case "mtllib":
                parseMtlLib(lineItems, result);
                break;
              case "usemtl":
                parseUseMtl(lineItems);
                break;
            }
          }
          return result;
        };
        module2.exports = ParseObj;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetColor = __webpack_require__(103);
        var ParseObjMaterial = function(mtl) {
          var output = {};
          var lines = mtl.split("\n");
          var currentMaterial = "";
          for (var i2 = 0; i2 < lines.length; i2++) {
            var line = lines[i2].trim();
            if (line.indexOf("#") === 0 || line === "") {
              continue;
            }
            var lineItems = line.replace(/\s\s+/g, " ").trim().split(" ");
            switch (lineItems[0].toLowerCase()) {
              case "newmtl": {
                currentMaterial = lineItems[1];
                break;
              }
              case "kd": {
                var r2 = Math.floor(lineItems[1] * 255);
                var g2 = lineItems.length >= 2 ? Math.floor(lineItems[2] * 255) : r2;
                var b2 = lineItems.length >= 3 ? Math.floor(lineItems[3] * 255) : r2;
                output[currentMaterial] = GetColor(r2, g2, b2);
                break;
              }
            }
          }
          return output;
        };
        module2.exports = ParseObjMaterial;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetMagnitude = function(point) {
          return Math.sqrt(point.x * point.x + point.y * point.y);
        };
        module2.exports = GetMagnitude;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetMagnitudeSq = function(point) {
          return point.x * point.x + point.y * point.y;
        };
        module2.exports = GetMagnitudeSq;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rectangle = __webpack_require__(10);
        Rectangle.Area = __webpack_require__(1267);
        Rectangle.Ceil = __webpack_require__(1268);
        Rectangle.CeilAll = __webpack_require__(1269);
        Rectangle.CenterOn = __webpack_require__(190);
        Rectangle.Clone = __webpack_require__(1270);
        Rectangle.Contains = __webpack_require__(57);
        Rectangle.ContainsPoint = __webpack_require__(1271);
        Rectangle.ContainsRect = __webpack_require__(503);
        Rectangle.CopyFrom = __webpack_require__(1272);
        Rectangle.Decompose = __webpack_require__(490);
        Rectangle.Equals = __webpack_require__(1273);
        Rectangle.FitInside = __webpack_require__(1274);
        Rectangle.FitOutside = __webpack_require__(1275);
        Rectangle.Floor = __webpack_require__(1276);
        Rectangle.FloorAll = __webpack_require__(1277);
        Rectangle.FromPoints = __webpack_require__(199);
        Rectangle.FromXY = __webpack_require__(1278);
        Rectangle.GetAspectRatio = __webpack_require__(237);
        Rectangle.GetCenter = __webpack_require__(1279);
        Rectangle.GetPoint = __webpack_require__(171);
        Rectangle.GetPoints = __webpack_require__(306);
        Rectangle.GetSize = __webpack_require__(1280);
        Rectangle.Inflate = __webpack_require__(1281);
        Rectangle.Intersection = __webpack_require__(1282);
        Rectangle.MarchingAnts = __webpack_require__(316);
        Rectangle.MergePoints = __webpack_require__(1283);
        Rectangle.MergeRect = __webpack_require__(1284);
        Rectangle.MergeXY = __webpack_require__(1285);
        Rectangle.Offset = __webpack_require__(1286);
        Rectangle.OffsetPoint = __webpack_require__(1287);
        Rectangle.Overlaps = __webpack_require__(1288);
        Rectangle.Perimeter = __webpack_require__(130);
        Rectangle.PerimeterPoint = __webpack_require__(1289);
        Rectangle.Random = __webpack_require__(174);
        Rectangle.RandomOutside = __webpack_require__(1290);
        Rectangle.SameDimensions = __webpack_require__(1291);
        Rectangle.Scale = __webpack_require__(1292);
        Rectangle.Union = __webpack_require__(441);
        module2.exports = Rectangle;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ContainsRect = function(rectA, rectB) {
          if (rectB.width * rectB.height > rectA.width * rectA.height) {
            return false;
          }
          return rectB.x > rectA.x && rectB.x < rectA.right && (rectB.right > rectA.x && rectB.right < rectA.right) && (rectB.y > rectA.y && rectB.y < rectA.bottom) && (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom);
        };
        module2.exports = ContainsRect;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var Centroid = function(triangle, out) {
          if (out === void 0) {
            out = new Point();
          }
          out.x = (triangle.x1 + triangle.x2 + triangle.x3) / 3;
          out.y = (triangle.y1 + triangle.y2 + triangle.y3) / 3;
          return out;
        };
        module2.exports = Centroid;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Offset = function(triangle, x2, y2) {
          triangle.x1 += x2;
          triangle.y1 += y2;
          triangle.x2 += x2;
          triangle.y2 += y2;
          triangle.x3 += x2;
          triangle.y3 += y2;
          return triangle;
        };
        module2.exports = Offset;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        function getLength(x1, y1, x2, y2) {
          var x3 = x1 - x2;
          var y3 = y1 - y2;
          var magnitude = x3 * x3 + y3 * y3;
          return Math.sqrt(magnitude);
        }
        var InCenter = function(triangle, out) {
          if (out === void 0) {
            out = new Point();
          }
          var x1 = triangle.x1;
          var y1 = triangle.y1;
          var x2 = triangle.x2;
          var y2 = triangle.y2;
          var x3 = triangle.x3;
          var y3 = triangle.y3;
          var d1 = getLength(x3, y3, x2, y2);
          var d2 = getLength(x1, y1, x3, y3);
          var d3 = getLength(x2, y2, x1, y1);
          var p2 = d1 + d2 + d3;
          out.x = (x1 * d1 + x2 * d2 + x3 * d3) / p2;
          out.y = (y1 * d1 + y2 * d2 + y3 * d3) / p2;
          return out;
        };
        module2.exports = InCenter;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CreatePixelPerfectHandler = function(textureManager, alphaTolerance) {
          return function(hitArea, x2, y2, gameObject) {
            var alpha = textureManager.getPixelAlpha(x2, y2, gameObject.texture.key, gameObject.frame.name);
            return alpha && alpha >= alphaTolerance;
          };
        };
        module2.exports = CreatePixelPerfectHandler;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CreateInteractiveObject = function(gameObject, hitArea, hitAreaCallback) {
          return {
            gameObject,
            enabled: true,
            alwaysEnabled: false,
            draggable: false,
            dropZone: false,
            cursor: false,
            target: null,
            camera: null,
            hitArea,
            hitAreaCallback,
            hitAreaDebug: null,
            customHitArea: false,
            localX: 0,
            localY: 0,
            dragState: 0,
            dragStartX: 0,
            dragStartY: 0,
            dragStartXGlobal: 0,
            dragStartYGlobal: 0,
            dragX: 0,
            dragY: 0
          };
        };
        module2.exports = CreateInteractiveObject;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Axis = new Class({
          initialize: function Axis2(pad, index2) {
            this.pad = pad;
            this.events = pad.events;
            this.index = index2;
            this.value = 0;
            this.threshold = 0.1;
          },
          update: function(value) {
            this.value = value;
          },
          getValue: function() {
            return Math.abs(this.value) < this.threshold ? 0 : this.value;
          },
          destroy: function() {
            this.pad = null;
            this.events = null;
          }
        });
        module2.exports = Axis;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(239);
        var Button = new Class({
          initialize: function Button2(pad, index2) {
            this.pad = pad;
            this.events = pad.manager;
            this.index = index2;
            this.value = 0;
            this.threshold = 1;
            this.pressed = false;
          },
          update: function(value) {
            this.value = value;
            var pad = this.pad;
            var index2 = this.index;
            if (value >= this.threshold) {
              if (!this.pressed) {
                this.pressed = true;
                this.events.emit(Events.BUTTON_DOWN, pad, this, value);
                this.pad.emit(Events.GAMEPAD_BUTTON_DOWN, index2, value, this);
              }
            } else if (this.pressed) {
              this.pressed = false;
              this.events.emit(Events.BUTTON_UP, pad, this, value);
              this.pad.emit(Events.GAMEPAD_BUTTON_UP, index2, value, this);
            }
          },
          destroy: function() {
            this.pad = null;
            this.events = null;
          }
        });
        module2.exports = Button;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Axis = __webpack_require__(509);
        var Button = __webpack_require__(510);
        var Class = __webpack_require__(0);
        var EventEmitter = __webpack_require__(9);
        var Vector2 = __webpack_require__(3);
        var Gamepad = new Class({
          Extends: EventEmitter,
          initialize: function Gamepad2(manager, pad) {
            EventEmitter.call(this);
            this.manager = manager;
            this.pad = pad;
            this.id = pad.id;
            this.index = pad.index;
            var buttons = [];
            for (var i2 = 0; i2 < pad.buttons.length; i2++) {
              buttons.push(new Button(this, i2));
            }
            this.buttons = buttons;
            var axes = [];
            for (i2 = 0; i2 < pad.axes.length; i2++) {
              axes.push(new Axis(this, i2));
            }
            this.axes = axes;
            this.vibration = pad.vibrationActuator;
            var _noButton = { value: 0, pressed: false };
            this._LCLeft = buttons[14] ? buttons[14] : _noButton;
            this._LCRight = buttons[15] ? buttons[15] : _noButton;
            this._LCTop = buttons[12] ? buttons[12] : _noButton;
            this._LCBottom = buttons[13] ? buttons[13] : _noButton;
            this._RCLeft = buttons[2] ? buttons[2] : _noButton;
            this._RCRight = buttons[1] ? buttons[1] : _noButton;
            this._RCTop = buttons[3] ? buttons[3] : _noButton;
            this._RCBottom = buttons[0] ? buttons[0] : _noButton;
            this._FBLeftTop = buttons[4] ? buttons[4] : _noButton;
            this._FBLeftBottom = buttons[6] ? buttons[6] : _noButton;
            this._FBRightTop = buttons[5] ? buttons[5] : _noButton;
            this._FBRightBottom = buttons[7] ? buttons[7] : _noButton;
            var _noAxis = { value: 0 };
            this._HAxisLeft = axes[0] ? axes[0] : _noAxis;
            this._VAxisLeft = axes[1] ? axes[1] : _noAxis;
            this._HAxisRight = axes[2] ? axes[2] : _noAxis;
            this._VAxisRight = axes[3] ? axes[3] : _noAxis;
            this.leftStick = new Vector2();
            this.rightStick = new Vector2();
            this._created = performance.now();
          },
          getAxisTotal: function() {
            return this.axes.length;
          },
          getAxisValue: function(index2) {
            return this.axes[index2].getValue();
          },
          setAxisThreshold: function(value) {
            for (var i2 = 0; i2 < this.axes.length; i2++) {
              this.axes[i2].threshold = value;
            }
          },
          getButtonTotal: function() {
            return this.buttons.length;
          },
          getButtonValue: function(index2) {
            return this.buttons[index2].value;
          },
          isButtonDown: function(index2) {
            return this.buttons[index2].pressed;
          },
          update: function(pad) {
            if (pad.timestamp < this._created) {
              return;
            }
            var i2;
            var localButtons = this.buttons;
            var gamepadButtons = pad.buttons;
            var len = localButtons.length;
            for (i2 = 0; i2 < len; i2++) {
              localButtons[i2].update(gamepadButtons[i2].value);
            }
            var localAxes = this.axes;
            var gamepadAxes = pad.axes;
            len = localAxes.length;
            for (i2 = 0; i2 < len; i2++) {
              localAxes[i2].update(gamepadAxes[i2]);
            }
            if (len >= 2) {
              this.leftStick.set(localAxes[0].getValue(), localAxes[1].getValue());
              if (len >= 4) {
                this.rightStick.set(localAxes[2].getValue(), localAxes[3].getValue());
              }
            }
          },
          destroy: function() {
            this.removeAllListeners();
            this.manager = null;
            this.pad = null;
            var i2;
            for (i2 = 0; i2 < this.buttons.length; i2++) {
              this.buttons[i2].destroy();
            }
            for (i2 = 0; i2 < this.axes.length; i2++) {
              this.axes[i2].destroy();
            }
            this.buttons = [];
            this.axes = [];
          },
          connected: {
            get: function() {
              return this.pad.connected;
            }
          },
          timestamp: {
            get: function() {
              return this.pad.timestamp;
            }
          },
          left: {
            get: function() {
              return this._LCLeft.pressed;
            }
          },
          right: {
            get: function() {
              return this._LCRight.pressed;
            }
          },
          up: {
            get: function() {
              return this._LCTop.pressed;
            }
          },
          down: {
            get: function() {
              return this._LCBottom.pressed;
            }
          },
          A: {
            get: function() {
              return this._RCBottom.pressed;
            }
          },
          Y: {
            get: function() {
              return this._RCTop.pressed;
            }
          },
          X: {
            get: function() {
              return this._RCLeft.pressed;
            }
          },
          B: {
            get: function() {
              return this._RCRight.pressed;
            }
          },
          L1: {
            get: function() {
              return this._FBLeftTop.value;
            }
          },
          L2: {
            get: function() {
              return this._FBLeftBottom.value;
            }
          },
          R1: {
            get: function() {
              return this._FBRightTop.value;
            }
          },
          R2: {
            get: function() {
              return this._FBRightBottom.value;
            }
          }
        });
        module2.exports = Gamepad;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(154);
        var Key = new Class({
          Extends: EventEmitter,
          initialize: function Key2(plugin, keyCode) {
            EventEmitter.call(this);
            this.plugin = plugin;
            this.keyCode = keyCode;
            this.originalEvent = void 0;
            this.enabled = true;
            this.isDown = false;
            this.isUp = true;
            this.altKey = false;
            this.ctrlKey = false;
            this.shiftKey = false;
            this.metaKey = false;
            this.location = 0;
            this.timeDown = 0;
            this.duration = 0;
            this.timeUp = 0;
            this.emitOnRepeat = false;
            this.repeats = 0;
            this._justDown = false;
            this._justUp = false;
            this._tick = -1;
          },
          setEmitOnRepeat: function(value) {
            this.emitOnRepeat = value;
            return this;
          },
          onDown: function(event) {
            this.originalEvent = event;
            if (!this.enabled) {
              return;
            }
            this.altKey = event.altKey;
            this.ctrlKey = event.ctrlKey;
            this.shiftKey = event.shiftKey;
            this.metaKey = event.metaKey;
            this.location = event.location;
            this.repeats++;
            if (!this.isDown) {
              this.isDown = true;
              this.isUp = false;
              this.timeDown = event.timeStamp;
              this.duration = 0;
              this._justDown = true;
              this._justUp = false;
              this.emit(Events.DOWN, this, event);
            } else if (this.emitOnRepeat) {
              this.emit(Events.DOWN, this, event);
            }
          },
          onUp: function(event) {
            this.originalEvent = event;
            if (!this.enabled) {
              return;
            }
            this.isDown = false;
            this.isUp = true;
            this.timeUp = event.timeStamp;
            this.duration = this.timeUp - this.timeDown;
            this.repeats = 0;
            this._justDown = false;
            this._justUp = true;
            this._tick = -1;
            this.emit(Events.UP, this, event);
          },
          reset: function() {
            this.preventDefault = true;
            this.enabled = true;
            this.isDown = false;
            this.isUp = true;
            this.altKey = false;
            this.ctrlKey = false;
            this.shiftKey = false;
            this.metaKey = false;
            this.timeDown = 0;
            this.duration = 0;
            this.timeUp = 0;
            this.repeats = 0;
            this._justDown = false;
            this._justUp = false;
            this._tick = -1;
            return this;
          },
          getDuration: function() {
            if (this.isDown) {
              return this.plugin.game.loop.time - this.timeDown;
            } else {
              return 0;
            }
          },
          destroy: function() {
            this.removeAllListeners();
            this.originalEvent = null;
            this.plugin = null;
          }
        });
        module2.exports = Key;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(154);
        var GetFastValue = __webpack_require__(2);
        var ProcessKeyCombo = __webpack_require__(514);
        var ResetKeyCombo = __webpack_require__(516);
        var KeyCombo = new Class({
          initialize: function KeyCombo2(keyboardPlugin, keys, config) {
            if (config === void 0) {
              config = {};
            }
            if (keys.length < 2) {
              return false;
            }
            this.manager = keyboardPlugin;
            this.enabled = true;
            this.keyCodes = [];
            for (var i2 = 0; i2 < keys.length; i2++) {
              var char = keys[i2];
              if (typeof char === "string") {
                this.keyCodes.push(char.toUpperCase().charCodeAt(0));
              } else if (typeof char === "number") {
                this.keyCodes.push(char);
              } else if (char.hasOwnProperty("keyCode")) {
                this.keyCodes.push(char.keyCode);
              }
            }
            this.current = this.keyCodes[0];
            this.index = 0;
            this.size = this.keyCodes.length;
            this.timeLastMatched = 0;
            this.matched = false;
            this.timeMatched = 0;
            this.resetOnWrongKey = GetFastValue(config, "resetOnWrongKey", true);
            this.maxKeyDelay = GetFastValue(config, "maxKeyDelay", 0);
            this.resetOnMatch = GetFastValue(config, "resetOnMatch", false);
            this.deleteOnMatch = GetFastValue(config, "deleteOnMatch", false);
            var _this = this;
            var onKeyDownHandler = function(event) {
              if (_this.matched || !_this.enabled) {
                return;
              }
              var matched = ProcessKeyCombo(event, _this);
              if (matched) {
                _this.manager.emit(Events.COMBO_MATCH, _this, event);
                if (_this.resetOnMatch) {
                  ResetKeyCombo(_this);
                } else if (_this.deleteOnMatch) {
                  _this.destroy();
                }
              }
            };
            this.onKeyDown = onKeyDownHandler;
            this.manager.on(Events.ANY_KEY_DOWN, this.onKeyDown);
          },
          progress: {
            get: function() {
              return this.index / this.size;
            }
          },
          destroy: function() {
            this.enabled = false;
            this.keyCodes = [];
            this.manager.off(Events.ANY_KEY_DOWN, this.onKeyDown);
            this.manager = null;
          }
        });
        module2.exports = KeyCombo;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AdvanceKeyCombo = __webpack_require__(515);
        var ProcessKeyCombo = function(event, combo) {
          if (combo.matched) {
            return true;
          }
          var comboMatched = false;
          var keyMatched = false;
          if (event.keyCode === combo.current) {
            if (combo.index > 0 && combo.maxKeyDelay > 0) {
              var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;
              if (event.timeStamp <= timeLimit) {
                keyMatched = true;
                comboMatched = AdvanceKeyCombo(event, combo);
              }
            } else {
              keyMatched = true;
              comboMatched = AdvanceKeyCombo(event, combo);
            }
          }
          if (!keyMatched && combo.resetOnWrongKey) {
            combo.index = 0;
            combo.current = combo.keyCodes[0];
          }
          if (comboMatched) {
            combo.timeLastMatched = event.timeStamp;
            combo.matched = true;
            combo.timeMatched = event.timeStamp;
          }
          return comboMatched;
        };
        module2.exports = ProcessKeyCombo;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AdvanceKeyCombo = function(event, combo) {
          combo.timeLastMatched = event.timeStamp;
          combo.index++;
          if (combo.index === combo.size) {
            return true;
          } else {
            combo.current = combo.keyCodes[combo.index];
            return false;
          }
        };
        module2.exports = AdvanceKeyCombo;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ResetKeyCombo = function(combo) {
          combo.current = combo.keyCodes[0];
          combo.index = 0;
          combo.timeLastMatched = 0;
          combo.matched = false;
          combo.timeMatched = 0;
          return combo;
        };
        module2.exports = ResetKeyCombo;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MergeXHRSettings = __webpack_require__(240);
        var XHRLoader = function(file, globalXHRSettings) {
          var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);
          var xhr = new XMLHttpRequest();
          xhr.open("GET", file.src, config.async, config.user, config.password);
          xhr.responseType = file.xhrSettings.responseType;
          xhr.timeout = config.timeout;
          if (config.headers) {
            for (var key in config.headers) {
              xhr.setRequestHeader(key, config.headers[key]);
            }
          }
          if (config.header && config.headerValue) {
            xhr.setRequestHeader(config.header, config.headerValue);
          }
          if (config.requestedWith) {
            xhr.setRequestHeader("X-Requested-With", config.requestedWith);
          }
          if (config.overrideMimeType) {
            xhr.overrideMimeType(config.overrideMimeType);
          }
          if (config.withCredentials) {
            xhr.withCredentials = true;
          }
          xhr.onload = file.onLoad.bind(file, xhr);
          xhr.onerror = file.onError.bind(file, xhr);
          xhr.onprogress = file.onProgress.bind(file);
          xhr.send();
          return xhr;
        };
        module2.exports = XHRLoader;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var HTML5AudioFile = __webpack_require__(519);
        var IsPlainObject2 = __webpack_require__(7);
        var AudioFile = new Class({
          Extends: File,
          initialize: function AudioFile2(loader, key, urlConfig, xhrSettings, audioContext) {
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              xhrSettings = GetFastValue(config, "xhrSettings");
              audioContext = GetFastValue(config, "context", audioContext);
            }
            var fileConfig = {
              type: "audio",
              cache: loader.cacheManager.audio,
              extension: urlConfig.type,
              responseType: "arraybuffer",
              key,
              url: urlConfig.url,
              xhrSettings,
              config: { context: audioContext }
            };
            File.call(this, loader, fileConfig);
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            var _this = this;
            this.config.context.decodeAudioData(this.xhrLoader.response, function(audioBuffer) {
              _this.data = audioBuffer;
              _this.onProcessComplete();
            }, function(e) {
              console.error("Error decoding audio: " + _this.key + " - ", e ? e.message : null);
              _this.onProcessError();
            });
            this.config.context = null;
          }
        });
        AudioFile.create = function(loader, key, urls, config, xhrSettings) {
          var game = loader.systems.game;
          var audioConfig = game.config.audio;
          var deviceAudio = game.device.audio;
          if (IsPlainObject2(key)) {
            urls = GetFastValue(key, "url", []);
            config = GetFastValue(key, "config", {});
          }
          var urlConfig = AudioFile.getAudioURL(game, urls);
          if (!urlConfig) {
            return null;
          }
          if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
            return new AudioFile(loader, key, urlConfig, xhrSettings, game.sound.context);
          } else {
            return new HTML5AudioFile(loader, key, urlConfig, config);
          }
        };
        AudioFile.getAudioURL = function(game, urls) {
          if (!Array.isArray(urls)) {
            urls = [urls];
          }
          for (var i2 = 0; i2 < urls.length; i2++) {
            var url = GetFastValue(urls[i2], "url", urls[i2]);
            if (url.indexOf("blob:") === 0 || url.indexOf("data:") === 0) {
              return {
                url,
                type: ""
              };
            }
            var audioType = url.match(/\.([a-zA-Z0-9]+)($|\?)/);
            audioType = GetFastValue(urls[i2], "type", audioType ? audioType[1] : "").toLowerCase();
            if (game.device.audio[audioType]) {
              return {
                url,
                type: audioType
              };
            }
          }
          return null;
        };
        FileTypesManager.register("audio", function(key, urls, config, xhrSettings) {
          var game = this.systems.game;
          var audioConfig = game.config.audio;
          var deviceAudio = game.device.audio;
          if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
            return this;
          }
          var audioFile;
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              audioFile = AudioFile.create(this, key[i2]);
              if (audioFile) {
                this.addFile(audioFile);
              }
            }
          } else {
            audioFile = AudioFile.create(this, key, urls, config, xhrSettings);
            if (audioFile) {
              this.addFile(audioFile);
            }
          }
          return this;
        });
        module2.exports = AudioFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(95);
        var File = __webpack_require__(23);
        var GetFastValue = __webpack_require__(2);
        var GetURL = __webpack_require__(155);
        var IsPlainObject2 = __webpack_require__(7);
        var HTML5AudioFile = new Class({
          Extends: File,
          initialize: function HTML5AudioFile2(loader, key, urlConfig, audioConfig) {
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              audioConfig = GetFastValue(config, "config", audioConfig);
            }
            var fileConfig = {
              type: "audio",
              cache: loader.cacheManager.audio,
              extension: urlConfig.type,
              key,
              url: urlConfig.url,
              config: audioConfig
            };
            File.call(this, loader, fileConfig);
            this.locked = "ontouchstart" in window;
            this.loaded = false;
            this.filesLoaded = 0;
            this.filesTotal = 0;
          },
          onLoad: function() {
            if (this.loaded) {
              return;
            }
            this.loaded = true;
            this.loader.nextFile(this, true);
          },
          onError: function() {
            for (var i2 = 0; i2 < this.data.length; i2++) {
              var audio = this.data[i2];
              audio.oncanplaythrough = null;
              audio.onerror = null;
            }
            this.loader.nextFile(this, false);
          },
          onProgress: function(event) {
            var audio = event.target;
            audio.oncanplaythrough = null;
            audio.onerror = null;
            this.filesLoaded++;
            this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1);
            this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);
            if (this.filesLoaded === this.filesTotal) {
              this.onLoad();
            }
          },
          load: function() {
            this.data = [];
            var instances = this.config && this.config.instances || 1;
            this.filesTotal = instances;
            this.filesLoaded = 0;
            this.percentComplete = 0;
            for (var i2 = 0; i2 < instances; i2++) {
              var audio = new Audio();
              if (!audio.dataset) {
                audio.dataset = {};
              }
              audio.dataset.name = this.key + ("0" + i2).slice(-2);
              audio.dataset.used = "false";
              if (this.locked) {
                audio.dataset.locked = "true";
              } else {
                audio.dataset.locked = "false";
                audio.preload = "auto";
                audio.oncanplaythrough = this.onProgress.bind(this);
                audio.onerror = this.onError.bind(this);
              }
              this.data.push(audio);
            }
            for (i2 = 0; i2 < this.data.length; i2++) {
              audio = this.data[i2];
              audio.src = GetURL(this, this.loader.baseURL);
              if (!this.locked) {
                audio.load();
              }
            }
            if (this.locked) {
              setTimeout(this.onLoad.bind(this));
            }
          }
        });
        module2.exports = HTML5AudioFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var ScriptFile = new Class({
          Extends: File,
          initialize: function ScriptFile2(loader, key, url, xhrSettings) {
            var extension = "js";
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
            }
            var fileConfig = {
              type: "script",
              cache: false,
              extension,
              responseType: "text",
              key,
              url,
              xhrSettings
            };
            File.call(this, loader, fileConfig);
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            this.data = document.createElement("script");
            this.data.language = "javascript";
            this.data.type = "text/javascript";
            this.data.defer = false;
            this.data.text = this.xhrLoader.responseText;
            document.head.appendChild(this.data);
            this.onProcessComplete();
          }
        });
        FileTypesManager.register("script", function(key, url, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new ScriptFile(this, key[i2]));
            }
          } else {
            this.addFile(new ScriptFile(this, key, url, xhrSettings));
          }
          return this;
        });
        module2.exports = ScriptFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ArcadeImage = __webpack_require__(522);
        var ArcadeSprite = __webpack_require__(157);
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(62);
        var PhysicsGroup = __webpack_require__(524);
        var StaticPhysicsGroup = __webpack_require__(525);
        var Factory = new Class({
          initialize: function Factory2(world) {
            this.world = world;
            this.scene = world.scene;
            this.sys = world.scene.sys;
          },
          collider: function(object1, object2, collideCallback, processCallback, callbackContext) {
            return this.world.addCollider(object1, object2, collideCallback, processCallback, callbackContext);
          },
          overlap: function(object1, object2, collideCallback, processCallback, callbackContext) {
            return this.world.addOverlap(object1, object2, collideCallback, processCallback, callbackContext);
          },
          existing: function(gameObject, isStatic) {
            var type = isStatic ? CONST.STATIC_BODY : CONST.DYNAMIC_BODY;
            this.world.enableBody(gameObject, type);
            return gameObject;
          },
          staticImage: function(x2, y2, key, frame) {
            var image = new ArcadeImage(this.scene, x2, y2, key, frame);
            this.sys.displayList.add(image);
            this.world.enableBody(image, CONST.STATIC_BODY);
            return image;
          },
          image: function(x2, y2, key, frame) {
            var image = new ArcadeImage(this.scene, x2, y2, key, frame);
            this.sys.displayList.add(image);
            this.world.enableBody(image, CONST.DYNAMIC_BODY);
            return image;
          },
          staticSprite: function(x2, y2, key, frame) {
            var sprite = new ArcadeSprite(this.scene, x2, y2, key, frame);
            this.sys.displayList.add(sprite);
            this.sys.updateList.add(sprite);
            this.world.enableBody(sprite, CONST.STATIC_BODY);
            return sprite;
          },
          sprite: function(x2, y2, key, frame) {
            var sprite = new ArcadeSprite(this.scene, x2, y2, key, frame);
            this.sys.displayList.add(sprite);
            this.sys.updateList.add(sprite);
            this.world.enableBody(sprite, CONST.DYNAMIC_BODY);
            return sprite;
          },
          staticGroup: function(children, config) {
            return this.sys.updateList.add(new StaticPhysicsGroup(this.world, this.world.scene, children, config));
          },
          group: function(children, config) {
            return this.sys.updateList.add(new PhysicsGroup(this.world, this.world.scene, children, config));
          },
          destroy: function() {
            this.world = null;
            this.scene = null;
            this.sys = null;
          }
        });
        module2.exports = Factory;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(243);
        var Image2 = __webpack_require__(125);
        var ArcadeImage = new Class({
          Extends: Image2,
          Mixins: [
            Components.Acceleration,
            Components.Angular,
            Components.Bounce,
            Components.Debug,
            Components.Drag,
            Components.Enable,
            Components.Friction,
            Components.Gravity,
            Components.Immovable,
            Components.Mass,
            Components.Pushable,
            Components.Size,
            Components.Velocity
          ],
          initialize: function ArcadeImage2(scene, x2, y2, texture, frame) {
            Image2.call(this, scene, x2, y2, texture, frame);
            this.body = null;
          }
        });
        module2.exports = ArcadeImage;
      },
      function(module2, exports2, __webpack_require__) {
        var OverlapRect = __webpack_require__(244);
        var Circle = __webpack_require__(65);
        var CircleToCircle = __webpack_require__(231);
        var CircleToRectangle = __webpack_require__(151);
        var OverlapCirc = function(world, x2, y2, radius, includeDynamic, includeStatic) {
          var bodiesInRect = OverlapRect(world, x2 - radius, y2 - radius, 2 * radius, 2 * radius, includeDynamic, includeStatic);
          if (bodiesInRect.length === 0) {
            return bodiesInRect;
          }
          var area = new Circle(x2, y2, radius);
          var circFromBody = new Circle();
          var bodiesInArea = [];
          for (var i2 = 0; i2 < bodiesInRect.length; i2++) {
            var body = bodiesInRect[i2];
            if (body.isCircle) {
              circFromBody.setTo(body.center.x, body.center.y, body.halfWidth);
              if (CircleToCircle(area, circFromBody)) {
                bodiesInArea.push(body);
              }
            } else if (CircleToRectangle(area, body)) {
              bodiesInArea.push(body);
            }
          }
          return bodiesInArea;
        };
        module2.exports = OverlapCirc;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ArcadeSprite = __webpack_require__(157);
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(62);
        var GetFastValue = __webpack_require__(2);
        var Group = __webpack_require__(113);
        var IsPlainObject2 = __webpack_require__(7);
        var PhysicsGroup = new Class({
          Extends: Group,
          initialize: function PhysicsGroup2(world, scene, children, config) {
            if (!children && !config) {
              config = {
                internalCreateCallback: this.createCallbackHandler,
                internalRemoveCallback: this.removeCallbackHandler
              };
            } else if (IsPlainObject2(children)) {
              config = children;
              children = null;
              config.internalCreateCallback = this.createCallbackHandler;
              config.internalRemoveCallback = this.removeCallbackHandler;
            } else if (Array.isArray(children) && IsPlainObject2(children[0])) {
              config = children[0];
              var _this = this;
              children.forEach(function(singleConfig) {
                singleConfig.internalCreateCallback = _this.createCallbackHandler;
                singleConfig.internalRemoveCallback = _this.removeCallbackHandler;
              });
              children = null;
            } else {
              config = {
                internalCreateCallback: this.createCallbackHandler,
                internalRemoveCallback: this.removeCallbackHandler
              };
            }
            this.world = world;
            config.classType = GetFastValue(config, "classType", ArcadeSprite);
            this.physicsType = CONST.DYNAMIC_BODY;
            this.defaults = {
              setCollideWorldBounds: GetFastValue(config, "collideWorldBounds", false),
              setBoundsRectangle: GetFastValue(config, "customBoundsRectangle", null),
              setAccelerationX: GetFastValue(config, "accelerationX", 0),
              setAccelerationY: GetFastValue(config, "accelerationY", 0),
              setAllowDrag: GetFastValue(config, "allowDrag", true),
              setAllowGravity: GetFastValue(config, "allowGravity", true),
              setAllowRotation: GetFastValue(config, "allowRotation", true),
              setBounceX: GetFastValue(config, "bounceX", 0),
              setBounceY: GetFastValue(config, "bounceY", 0),
              setDragX: GetFastValue(config, "dragX", 0),
              setDragY: GetFastValue(config, "dragY", 0),
              setEnable: GetFastValue(config, "enable", true),
              setGravityX: GetFastValue(config, "gravityX", 0),
              setGravityY: GetFastValue(config, "gravityY", 0),
              setFrictionX: GetFastValue(config, "frictionX", 0),
              setFrictionY: GetFastValue(config, "frictionY", 0),
              setMaxVelocityX: GetFastValue(config, "maxVelocityX", 1e4),
              setMaxVelocityY: GetFastValue(config, "maxVelocityY", 1e4),
              setVelocityX: GetFastValue(config, "velocityX", 0),
              setVelocityY: GetFastValue(config, "velocityY", 0),
              setAngularVelocity: GetFastValue(config, "angularVelocity", 0),
              setAngularAcceleration: GetFastValue(config, "angularAcceleration", 0),
              setAngularDrag: GetFastValue(config, "angularDrag", 0),
              setMass: GetFastValue(config, "mass", 1),
              setImmovable: GetFastValue(config, "immovable", false)
            };
            Group.call(this, scene, children, config);
            this.type = "PhysicsGroup";
          },
          createCallbackHandler: function(child) {
            if (!child.body) {
              this.world.enableBody(child, CONST.DYNAMIC_BODY);
            }
            var body = child.body;
            for (var key in this.defaults) {
              body[key](this.defaults[key]);
            }
          },
          removeCallbackHandler: function(child) {
            if (child.body) {
              this.world.disableBody(child);
            }
          },
          setVelocity: function(x2, y2, step) {
            if (step === void 0) {
              step = 0;
            }
            var items = this.getChildren();
            for (var i2 = 0; i2 < items.length; i2++) {
              items[i2].body.velocity.set(x2 + i2 * step, y2 + i2 * step);
            }
            return this;
          },
          setVelocityX: function(value, step) {
            if (step === void 0) {
              step = 0;
            }
            var items = this.getChildren();
            for (var i2 = 0; i2 < items.length; i2++) {
              items[i2].body.velocity.x = value + i2 * step;
            }
            return this;
          },
          setVelocityY: function(value, step) {
            if (step === void 0) {
              step = 0;
            }
            var items = this.getChildren();
            for (var i2 = 0; i2 < items.length; i2++) {
              items[i2].body.velocity.y = value + i2 * step;
            }
            return this;
          }
        });
        module2.exports = PhysicsGroup;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ArcadeSprite = __webpack_require__(157);
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(62);
        var GetFastValue = __webpack_require__(2);
        var Group = __webpack_require__(113);
        var IsPlainObject2 = __webpack_require__(7);
        var StaticPhysicsGroup = new Class({
          Extends: Group,
          initialize: function StaticPhysicsGroup2(world, scene, children, config) {
            if (!children && !config) {
              config = {
                internalCreateCallback: this.createCallbackHandler,
                internalRemoveCallback: this.removeCallbackHandler,
                createMultipleCallback: this.createMultipleCallbackHandler,
                classType: ArcadeSprite
              };
            } else if (IsPlainObject2(children)) {
              config = children;
              children = null;
              config.internalCreateCallback = this.createCallbackHandler;
              config.internalRemoveCallback = this.removeCallbackHandler;
              config.createMultipleCallback = this.createMultipleCallbackHandler;
              config.classType = GetFastValue(config, "classType", ArcadeSprite);
            } else if (Array.isArray(children) && IsPlainObject2(children[0])) {
              config = children;
              children = null;
              config.forEach(function(singleConfig) {
                singleConfig.internalCreateCallback = this.createCallbackHandler;
                singleConfig.internalRemoveCallback = this.removeCallbackHandler;
                singleConfig.createMultipleCallback = this.createMultipleCallbackHandler;
                singleConfig.classType = GetFastValue(singleConfig, "classType", ArcadeSprite);
              });
            } else {
              config = {
                internalCreateCallback: this.createCallbackHandler,
                internalRemoveCallback: this.removeCallbackHandler
              };
            }
            this.world = world;
            this.physicsType = CONST.STATIC_BODY;
            Group.call(this, scene, children, config);
            this.type = "StaticPhysicsGroup";
          },
          createCallbackHandler: function(child) {
            if (!child.body) {
              this.world.enableBody(child, CONST.STATIC_BODY);
            }
          },
          removeCallbackHandler: function(child) {
            if (child.body) {
              this.world.disableBody(child);
            }
          },
          createMultipleCallbackHandler: function() {
            this.refresh();
          },
          refresh: function() {
            var children = this.children.entries;
            for (var i2 = 0; i2 < children.length; i2++) {
              children[i2].body.reset();
            }
            return this;
          }
        });
        module2.exports = StaticPhysicsGroup;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AngleBetweenPoints = __webpack_require__(350);
        var Body = __webpack_require__(527);
        var Clamp = __webpack_require__(18);
        var Class = __webpack_require__(0);
        var Collider = __webpack_require__(528);
        var CONST = __webpack_require__(62);
        var DistanceBetween = __webpack_require__(50);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(245);
        var FuzzyEqual = __webpack_require__(124);
        var FuzzyGreaterThan = __webpack_require__(354);
        var FuzzyLessThan = __webpack_require__(355);
        var GetOverlapX = __webpack_require__(246);
        var GetOverlapY = __webpack_require__(247);
        var GetTilesWithinWorldXY = __webpack_require__(529);
        var GetValue = __webpack_require__(6);
        var MATH_CONST = __webpack_require__(14);
        var ProcessQueue = __webpack_require__(211);
        var ProcessTileCallbacks = __webpack_require__(530);
        var Rectangle = __webpack_require__(10);
        var RTree = __webpack_require__(531);
        var SeparateTile = __webpack_require__(532);
        var SeparateX = __webpack_require__(537);
        var SeparateY = __webpack_require__(538);
        var Set2 = __webpack_require__(149);
        var StaticBody = __webpack_require__(539);
        var TileIntersectsBody = __webpack_require__(248);
        var TransformMatrix = __webpack_require__(25);
        var Vector2 = __webpack_require__(3);
        var Wrap = __webpack_require__(68);
        var World = new Class({
          Extends: EventEmitter,
          initialize: function World2(scene, config) {
            EventEmitter.call(this);
            this.scene = scene;
            this.bodies = new Set2();
            this.staticBodies = new Set2();
            this.pendingDestroy = new Set2();
            this.colliders = new ProcessQueue();
            this.gravity = new Vector2(GetValue(config, "gravity.x", 0), GetValue(config, "gravity.y", 0));
            this.bounds = new Rectangle(GetValue(config, "x", 0), GetValue(config, "y", 0), GetValue(config, "width", scene.sys.scale.width), GetValue(config, "height", scene.sys.scale.height));
            this.checkCollision = {
              up: GetValue(config, "checkCollision.up", true),
              down: GetValue(config, "checkCollision.down", true),
              left: GetValue(config, "checkCollision.left", true),
              right: GetValue(config, "checkCollision.right", true)
            };
            this.fps = GetValue(config, "fps", 60);
            this.fixedStep = GetValue(config, "fixedStep", true);
            this._elapsed = 0;
            this._frameTime = 1 / this.fps;
            this._frameTimeMS = 1e3 * this._frameTime;
            this.stepsLastFrame = 0;
            this.timeScale = GetValue(config, "timeScale", 1);
            this.OVERLAP_BIAS = GetValue(config, "overlapBias", 4);
            this.TILE_BIAS = GetValue(config, "tileBias", 16);
            this.forceX = GetValue(config, "forceX", false);
            this.isPaused = GetValue(config, "isPaused", false);
            this._total = 0;
            this.drawDebug = GetValue(config, "debug", false);
            this.debugGraphic;
            this.defaults = {
              debugShowBody: GetValue(config, "debugShowBody", true),
              debugShowStaticBody: GetValue(config, "debugShowStaticBody", true),
              debugShowVelocity: GetValue(config, "debugShowVelocity", true),
              bodyDebugColor: GetValue(config, "debugBodyColor", 16711935),
              staticBodyDebugColor: GetValue(config, "debugStaticBodyColor", 255),
              velocityDebugColor: GetValue(config, "debugVelocityColor", 65280)
            };
            this.maxEntries = GetValue(config, "maxEntries", 16);
            this.useTree = GetValue(config, "useTree", true);
            this.tree = new RTree(this.maxEntries);
            this.staticTree = new RTree(this.maxEntries);
            this.treeMinMax = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
            this._tempMatrix = new TransformMatrix();
            this._tempMatrix2 = new TransformMatrix();
            if (this.drawDebug) {
              this.createDebugGraphic();
            }
          },
          enable: function(object, bodyType) {
            if (bodyType === void 0) {
              bodyType = CONST.DYNAMIC_BODY;
            }
            if (!Array.isArray(object)) {
              object = [object];
            }
            for (var i2 = 0; i2 < object.length; i2++) {
              var entry = object[i2];
              if (entry.isParent) {
                var children = entry.getChildren();
                for (var c = 0; c < children.length; c++) {
                  var child = children[c];
                  if (child.isParent) {
                    this.enable(child, bodyType);
                  } else {
                    this.enableBody(child, bodyType);
                  }
                }
              } else {
                this.enableBody(entry, bodyType);
              }
            }
          },
          enableBody: function(object, bodyType) {
            if (bodyType === void 0) {
              bodyType = CONST.DYNAMIC_BODY;
            }
            if (!object.body) {
              if (bodyType === CONST.DYNAMIC_BODY) {
                object.body = new Body(this, object);
              } else if (bodyType === CONST.STATIC_BODY) {
                object.body = new StaticBody(this, object);
              }
            }
            this.add(object.body);
            return object;
          },
          add: function(body) {
            if (body.physicsType === CONST.DYNAMIC_BODY) {
              this.bodies.set(body);
            } else if (body.physicsType === CONST.STATIC_BODY) {
              this.staticBodies.set(body);
              this.staticTree.insert(body);
            }
            body.enable = true;
            return body;
          },
          disable: function(object) {
            if (!Array.isArray(object)) {
              object = [object];
            }
            for (var i2 = 0; i2 < object.length; i2++) {
              var entry = object[i2];
              if (entry.isParent) {
                var children = entry.getChildren();
                for (var c = 0; c < children.length; c++) {
                  var child = children[c];
                  if (child.isParent) {
                    this.disable(child);
                  } else {
                    this.disableBody(child.body);
                  }
                }
              } else {
                this.disableBody(entry.body);
              }
            }
          },
          disableBody: function(body) {
            this.remove(body);
            body.enable = false;
          },
          remove: function(body) {
            if (body.physicsType === CONST.DYNAMIC_BODY) {
              this.tree.remove(body);
              this.bodies.delete(body);
            } else if (body.physicsType === CONST.STATIC_BODY) {
              this.staticBodies.delete(body);
              this.staticTree.remove(body);
            }
          },
          createDebugGraphic: function() {
            var graphic = this.scene.sys.add.graphics({ x: 0, y: 0 });
            graphic.setDepth(Number.MAX_VALUE);
            this.debugGraphic = graphic;
            this.drawDebug = true;
            return graphic;
          },
          setBounds: function(x2, y2, width, height, checkLeft, checkRight, checkUp, checkDown) {
            this.bounds.setTo(x2, y2, width, height);
            if (checkLeft !== void 0) {
              this.setBoundsCollision(checkLeft, checkRight, checkUp, checkDown);
            }
            return this;
          },
          setBoundsCollision: function(left, right, up, down) {
            if (left === void 0) {
              left = true;
            }
            if (right === void 0) {
              right = true;
            }
            if (up === void 0) {
              up = true;
            }
            if (down === void 0) {
              down = true;
            }
            this.checkCollision.left = left;
            this.checkCollision.right = right;
            this.checkCollision.up = up;
            this.checkCollision.down = down;
            return this;
          },
          pause: function() {
            this.isPaused = true;
            this.emit(Events.PAUSE);
            return this;
          },
          resume: function() {
            this.isPaused = false;
            this.emit(Events.RESUME);
            return this;
          },
          addCollider: function(object1, object2, collideCallback, processCallback, callbackContext) {
            if (collideCallback === void 0) {
              collideCallback = null;
            }
            if (processCallback === void 0) {
              processCallback = null;
            }
            if (callbackContext === void 0) {
              callbackContext = collideCallback;
            }
            var collider = new Collider(this, false, object1, object2, collideCallback, processCallback, callbackContext);
            this.colliders.add(collider);
            return collider;
          },
          addOverlap: function(object1, object2, collideCallback, processCallback, callbackContext) {
            if (collideCallback === void 0) {
              collideCallback = null;
            }
            if (processCallback === void 0) {
              processCallback = null;
            }
            if (callbackContext === void 0) {
              callbackContext = collideCallback;
            }
            var collider = new Collider(this, true, object1, object2, collideCallback, processCallback, callbackContext);
            this.colliders.add(collider);
            return collider;
          },
          removeCollider: function(collider) {
            this.colliders.remove(collider);
            return this;
          },
          setFPS: function(framerate) {
            this.fps = framerate;
            this._frameTime = 1 / this.fps;
            this._frameTimeMS = 1e3 * this._frameTime;
            return this;
          },
          update: function(time, delta) {
            if (this.isPaused || this.bodies.size === 0) {
              return;
            }
            var i2;
            var fixedDelta = this._frameTime;
            var msPerFrame = this._frameTimeMS * this.timeScale;
            this._elapsed += delta;
            var body;
            var bodies = this.bodies.entries;
            var willStep = this._elapsed >= msPerFrame;
            if (!this.fixedStep) {
              fixedDelta = delta * 1e-3;
              willStep = true;
              this._elapsed = 0;
            }
            for (i2 = 0; i2 < bodies.length; i2++) {
              body = bodies[i2];
              if (body.enable) {
                body.preUpdate(willStep, fixedDelta);
              }
            }
            if (willStep) {
              this._elapsed -= msPerFrame;
              this.stepsLastFrame = 1;
              if (this.useTree) {
                this.tree.clear();
                this.tree.load(bodies);
              }
              var colliders = this.colliders.update();
              for (i2 = 0; i2 < colliders.length; i2++) {
                var collider = colliders[i2];
                if (collider.active) {
                  collider.update();
                }
              }
              this.emit(Events.WORLD_STEP, fixedDelta);
            }
            while (this._elapsed >= msPerFrame) {
              this._elapsed -= msPerFrame;
              this.step(fixedDelta);
            }
          },
          step: function(delta) {
            var i2;
            var body;
            var bodies = this.bodies.entries;
            var len = bodies.length;
            for (i2 = 0; i2 < len; i2++) {
              body = bodies[i2];
              if (body.enable) {
                body.update(delta);
              }
            }
            if (this.useTree) {
              this.tree.clear();
              this.tree.load(bodies);
            }
            var colliders = this.colliders.update();
            for (i2 = 0; i2 < colliders.length; i2++) {
              var collider = colliders[i2];
              if (collider.active) {
                collider.update();
              }
            }
            this.emit(Events.WORLD_STEP, delta);
            this.stepsLastFrame++;
          },
          postUpdate: function() {
            var i2;
            var body;
            var bodies = this.bodies.entries;
            var len = bodies.length;
            var dynamic = this.bodies;
            var staticBodies = this.staticBodies;
            if (this.stepsLastFrame) {
              this.stepsLastFrame = 0;
              for (i2 = 0; i2 < len; i2++) {
                body = bodies[i2];
                if (body.enable) {
                  body.postUpdate();
                }
              }
            }
            if (this.drawDebug) {
              var graphics = this.debugGraphic;
              graphics.clear();
              for (i2 = 0; i2 < len; i2++) {
                body = bodies[i2];
                if (body.willDrawDebug()) {
                  body.drawDebug(graphics);
                }
              }
              bodies = staticBodies.entries;
              len = bodies.length;
              for (i2 = 0; i2 < len; i2++) {
                body = bodies[i2];
                if (body.willDrawDebug()) {
                  body.drawDebug(graphics);
                }
              }
            }
            var pending = this.pendingDestroy;
            if (pending.size > 0) {
              var dynamicTree = this.tree;
              var staticTree = this.staticTree;
              bodies = pending.entries;
              len = bodies.length;
              for (i2 = 0; i2 < len; i2++) {
                body = bodies[i2];
                if (body.physicsType === CONST.DYNAMIC_BODY) {
                  dynamicTree.remove(body);
                  dynamic.delete(body);
                } else if (body.physicsType === CONST.STATIC_BODY) {
                  staticTree.remove(body);
                  staticBodies.delete(body);
                }
                body.world = void 0;
                body.gameObject = void 0;
              }
              pending.clear();
            }
          },
          updateMotion: function(body, delta) {
            if (body.allowRotation) {
              this.computeAngularVelocity(body, delta);
            }
            this.computeVelocity(body, delta);
          },
          computeAngularVelocity: function(body, delta) {
            var velocity = body.angularVelocity;
            var acceleration = body.angularAcceleration;
            var drag = body.angularDrag;
            var max = body.maxAngular;
            if (acceleration) {
              velocity += acceleration * delta;
            } else if (body.allowDrag && drag) {
              drag *= delta;
              if (FuzzyGreaterThan(velocity - drag, 0, 0.1)) {
                velocity -= drag;
              } else if (FuzzyLessThan(velocity + drag, 0, 0.1)) {
                velocity += drag;
              } else {
                velocity = 0;
              }
            }
            velocity = Clamp(velocity, -max, max);
            var velocityDelta = velocity - body.angularVelocity;
            body.angularVelocity += velocityDelta;
            body.rotation += body.angularVelocity * delta;
          },
          computeVelocity: function(body, delta) {
            var velocityX = body.velocity.x;
            var accelerationX = body.acceleration.x;
            var dragX = body.drag.x;
            var maxX = body.maxVelocity.x;
            var velocityY = body.velocity.y;
            var accelerationY = body.acceleration.y;
            var dragY = body.drag.y;
            var maxY = body.maxVelocity.y;
            var speed = body.speed;
            var maxSpeed = body.maxSpeed;
            var allowDrag = body.allowDrag;
            var useDamping = body.useDamping;
            if (body.allowGravity) {
              velocityX += (this.gravity.x + body.gravity.x) * delta;
              velocityY += (this.gravity.y + body.gravity.y) * delta;
            }
            if (accelerationX) {
              velocityX += accelerationX * delta;
            } else if (allowDrag && dragX) {
              if (useDamping) {
                dragX = Math.pow(dragX, delta);
                velocityX *= dragX;
                speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                if (FuzzyEqual(speed, 0, 1e-3)) {
                  velocityX = 0;
                }
              } else {
                dragX *= delta;
                if (FuzzyGreaterThan(velocityX - dragX, 0, 0.01)) {
                  velocityX -= dragX;
                } else if (FuzzyLessThan(velocityX + dragX, 0, 0.01)) {
                  velocityX += dragX;
                } else {
                  velocityX = 0;
                }
              }
            }
            if (accelerationY) {
              velocityY += accelerationY * delta;
            } else if (allowDrag && dragY) {
              if (useDamping) {
                dragY = Math.pow(dragY, delta);
                velocityY *= dragY;
                speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                if (FuzzyEqual(speed, 0, 1e-3)) {
                  velocityY = 0;
                }
              } else {
                dragY *= delta;
                if (FuzzyGreaterThan(velocityY - dragY, 0, 0.01)) {
                  velocityY -= dragY;
                } else if (FuzzyLessThan(velocityY + dragY, 0, 0.01)) {
                  velocityY += dragY;
                } else {
                  velocityY = 0;
                }
              }
            }
            velocityX = Clamp(velocityX, -maxX, maxX);
            velocityY = Clamp(velocityY, -maxY, maxY);
            body.velocity.set(velocityX, velocityY);
            if (maxSpeed > -1 && speed > maxSpeed) {
              body.velocity.normalize().scale(maxSpeed);
              speed = maxSpeed;
            }
            body.speed = speed;
          },
          separate: function(body1, body2, processCallback, callbackContext, overlapOnly, intersects) {
            if (!intersects && !body1.enable || !body2.enable || body1.checkCollision.none || body2.checkCollision.none || !this.intersects(body1, body2)) {
              return false;
            }
            if (processCallback && processCallback.call(callbackContext, body1.gameObject, body2.gameObject) === false) {
              return false;
            }
            if (body1.isCircle && body2.isCircle) {
              return this.separateCircle(body1, body2, overlapOnly);
            }
            if (body1.isCircle !== body2.isCircle) {
              var bodyRect = body1.isCircle ? body2 : body1;
              var bodyCircle = body1.isCircle ? body1 : body2;
              var rect = {
                x: bodyRect.x,
                y: bodyRect.y,
                right: bodyRect.right,
                bottom: bodyRect.bottom
              };
              var circle = bodyCircle.center;
              if (circle.y < rect.y || circle.y > rect.bottom) {
                if (circle.x < rect.x || circle.x > rect.right) {
                  return this.separateCircle(body1, body2, overlapOnly);
                }
              }
            }
            var resultX = false;
            var resultY = false;
            if (overlapOnly) {
              resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);
              resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);
            } else if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x)) {
              resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);
              if (this.intersects(body1, body2)) {
                resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);
              }
            } else {
              resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);
              if (this.intersects(body1, body2)) {
                resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);
              }
            }
            var result = resultX || resultY;
            if (result) {
              if (overlapOnly) {
                if (body1.onOverlap || body2.onOverlap) {
                  this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);
                }
              } else if (body1.onCollide || body2.onCollide) {
                this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);
              }
            }
            return result;
          },
          separateCircle: function(body1, body2, overlapOnly, bias) {
            GetOverlapX(body1, body2, false, bias);
            GetOverlapY(body1, body2, false, bias);
            var overlap = 0;
            if (body1.isCircle !== body2.isCircle) {
              var rect = {
                x: body2.isCircle ? body1.position.x : body2.position.x,
                y: body2.isCircle ? body1.position.y : body2.position.y,
                right: body2.isCircle ? body1.right : body2.right,
                bottom: body2.isCircle ? body1.bottom : body2.bottom
              };
              var circle = {
                x: body1.isCircle ? body1.center.x : body2.center.x,
                y: body1.isCircle ? body1.center.y : body2.center.y,
                radius: body1.isCircle ? body1.halfWidth : body2.halfWidth
              };
              if (circle.y < rect.y) {
                if (circle.x < rect.x) {
                  overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.y) - circle.radius;
                } else if (circle.x > rect.right) {
                  overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.y) - circle.radius;
                }
              } else if (circle.y > rect.bottom) {
                if (circle.x < rect.x) {
                  overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.bottom) - circle.radius;
                } else if (circle.x > rect.right) {
                  overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.bottom) - circle.radius;
                }
              }
              overlap *= -1;
            } else {
              overlap = body1.halfWidth + body2.halfWidth - DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y);
            }
            body1.overlapR = overlap;
            body2.overlapR = overlap;
            if (overlapOnly || overlap === 0 || body1.immovable && body2.immovable || body1.customSeparateX || body2.customSeparateX) {
              if (overlap !== 0 && (body1.onOverlap || body2.onOverlap)) {
                this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);
              }
              return overlap !== 0;
            }
            var dx = body1.center.x - body2.center.x;
            var dy = body1.center.y - body2.center.y;
            var d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
            var nx = (body2.center.x - body1.center.x) / d || 0;
            var ny = (body2.center.y - body1.center.y) / d || 0;
            var p2 = 2 * (body1.velocity.x * nx + body1.velocity.y * ny - body2.velocity.x * nx - body2.velocity.y * ny) / (body1.mass + body2.mass);
            if (body1.immovable || body2.immovable) {
              p2 *= 2;
            }
            if (!body1.immovable) {
              body1.velocity.x = body1.velocity.x - p2 / body1.mass * nx;
              body1.velocity.y = body1.velocity.y - p2 / body1.mass * ny;
            }
            if (!body2.immovable) {
              body2.velocity.x = body2.velocity.x + p2 / body2.mass * nx;
              body2.velocity.y = body2.velocity.y + p2 / body2.mass * ny;
            }
            if (!body1.immovable && !body2.immovable) {
              overlap /= 2;
            }
            var angle = AngleBetweenPoints(body1.center, body2.center);
            var overlapX = (overlap + MATH_CONST.EPSILON) * Math.cos(angle);
            var overlapY = (overlap + MATH_CONST.EPSILON) * Math.sin(angle);
            if (!body1.immovable) {
              body1.x -= overlapX;
              body1.y -= overlapY;
              body1.updateCenter();
            }
            if (!body2.immovable) {
              body2.x += overlapX;
              body2.y += overlapY;
              body2.updateCenter();
            }
            body1.velocity.x *= body1.bounce.x;
            body1.velocity.y *= body1.bounce.y;
            body2.velocity.x *= body2.bounce.x;
            body2.velocity.y *= body2.bounce.y;
            if (body1.onCollide || body2.onCollide) {
              this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);
            }
            return true;
          },
          intersects: function(body1, body2) {
            if (body1 === body2) {
              return false;
            }
            if (!body1.isCircle && !body2.isCircle) {
              return !(body1.right <= body2.position.x || body1.bottom <= body2.position.y || body1.position.x >= body2.right || body1.position.y >= body2.bottom);
            } else if (body1.isCircle) {
              if (body2.isCircle) {
                return DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y) <= body1.halfWidth + body2.halfWidth;
              } else {
                return this.circleBodyIntersects(body1, body2);
              }
            } else {
              return this.circleBodyIntersects(body2, body1);
            }
          },
          circleBodyIntersects: function(circle, body) {
            var x2 = Clamp(circle.center.x, body.left, body.right);
            var y2 = Clamp(circle.center.y, body.top, body.bottom);
            var dx = (circle.center.x - x2) * (circle.center.x - x2);
            var dy = (circle.center.y - y2) * (circle.center.y - y2);
            return dx + dy <= circle.halfWidth * circle.halfWidth;
          },
          overlap: function(object1, object2, overlapCallback, processCallback, callbackContext) {
            if (overlapCallback === void 0) {
              overlapCallback = null;
            }
            if (processCallback === void 0) {
              processCallback = null;
            }
            if (callbackContext === void 0) {
              callbackContext = overlapCallback;
            }
            return this.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);
          },
          collide: function(object1, object2, collideCallback, processCallback, callbackContext) {
            if (collideCallback === void 0) {
              collideCallback = null;
            }
            if (processCallback === void 0) {
              processCallback = null;
            }
            if (callbackContext === void 0) {
              callbackContext = collideCallback;
            }
            return this.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);
          },
          collideObjects: function(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
            var i2;
            var j;
            if (object1.isParent && object1.physicsType === void 0) {
              object1 = object1.children.entries;
            }
            if (object2 && object2.isParent && object2.physicsType === void 0) {
              object2 = object2.children.entries;
            }
            var object1isArray = Array.isArray(object1);
            var object2isArray = Array.isArray(object2);
            this._total = 0;
            if (!object1isArray && !object2isArray) {
              this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
            } else if (!object1isArray && object2isArray) {
              for (i2 = 0; i2 < object2.length; i2++) {
                this.collideHandler(object1, object2[i2], collideCallback, processCallback, callbackContext, overlapOnly);
              }
            } else if (object1isArray && !object2isArray) {
              if (!object2) {
                for (i2 = 0; i2 < object1.length; i2++) {
                  var child = object1[i2];
                  for (j = i2 + 1; j < object1.length; j++) {
                    if (i2 === j) {
                      continue;
                    }
                    this.collideHandler(child, object1[j], collideCallback, processCallback, callbackContext, overlapOnly);
                  }
                }
              } else {
                for (i2 = 0; i2 < object1.length; i2++) {
                  this.collideHandler(object1[i2], object2, collideCallback, processCallback, callbackContext, overlapOnly);
                }
              }
            } else {
              for (i2 = 0; i2 < object1.length; i2++) {
                for (j = 0; j < object2.length; j++) {
                  this.collideHandler(object1[i2], object2[j], collideCallback, processCallback, callbackContext, overlapOnly);
                }
              }
            }
            return this._total > 0;
          },
          collideHandler: function(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (object2 === void 0 && object1.isParent) {
              return this.collideGroupVsGroup(object1, object1, collideCallback, processCallback, callbackContext, overlapOnly);
            }
            if (!object1 || !object2) {
              return false;
            }
            if (object1.body) {
              if (object2.body) {
                return this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
              } else if (object2.isParent) {
                return this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
              } else if (object2.isTilemap) {
                return this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
              }
            } else if (object1.isParent) {
              if (object2.body) {
                return this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
              } else if (object2.isParent) {
                return this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
              } else if (object2.isTilemap) {
                return this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
              }
            } else if (object1.isTilemap) {
              if (object2.body) {
                return this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
              } else if (object2.isParent) {
                return this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
              }
            }
          },
          collideSpriteVsSprite: function(sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (!sprite1.body || !sprite2.body) {
              return false;
            }
            if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly)) {
              if (collideCallback) {
                collideCallback.call(callbackContext, sprite1, sprite2);
              }
              this._total++;
            }
            return true;
          },
          collideSpriteVsGroup: function(sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {
            var bodyA = sprite.body;
            if (group.length === 0 || !bodyA || !bodyA.enable || bodyA.checkCollision.none) {
              return;
            }
            var i2;
            var len;
            var bodyB;
            if (this.useTree || group.physicsType === CONST.STATIC_BODY) {
              var minMax = this.treeMinMax;
              minMax.minX = bodyA.left;
              minMax.minY = bodyA.top;
              minMax.maxX = bodyA.right;
              minMax.maxY = bodyA.bottom;
              var results = group.physicsType === CONST.DYNAMIC_BODY ? this.tree.search(minMax) : this.staticTree.search(minMax);
              len = results.length;
              for (i2 = 0; i2 < len; i2++) {
                bodyB = results[i2];
                if (bodyA === bodyB || !bodyB.enable || bodyB.checkCollision.none || !group.contains(bodyB.gameObject)) {
                  continue;
                }
                if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly, true)) {
                  if (collideCallback) {
                    collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);
                  }
                  this._total++;
                }
              }
            } else {
              var children = group.getChildren();
              var skipIndex = group.children.entries.indexOf(sprite);
              len = children.length;
              for (i2 = 0; i2 < len; i2++) {
                bodyB = children[i2].body;
                if (!bodyB || i2 === skipIndex || !bodyB.enable) {
                  continue;
                }
                if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly)) {
                  if (collideCallback) {
                    collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);
                  }
                  this._total++;
                }
              }
            }
          },
          collideGroupVsTilemapLayer: function(group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {
            var children = group.getChildren();
            if (children.length === 0) {
              return false;
            }
            var didCollide = false;
            for (var i2 = 0; i2 < children.length; i2++) {
              if (children[i2].body) {
                if (this.collideSpriteVsTilemapLayer(children[i2], tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)) {
                  didCollide = true;
                }
              }
            }
            return didCollide;
          },
          collideTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
            if (!sprite.body.enable || tiles.length === 0) {
              return false;
            } else {
              return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, false, false);
            }
          },
          overlapTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
            if (!sprite.body.enable || tiles.length === 0) {
              return false;
            } else {
              return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, true, false);
            }
          },
          collideSpriteVsTilemapLayer: function(sprite, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {
            var body = sprite.body;
            if (!body.enable || body.checkCollision.none) {
              return false;
            }
            var x2 = body.position.x;
            var y2 = body.position.y;
            var w2 = body.width;
            var h2 = body.height;
            var layerData = tilemapLayer.layer;
            if (layerData.tileWidth > layerData.baseTileWidth) {
              var xDiff = (layerData.tileWidth - layerData.baseTileWidth) * tilemapLayer.scaleX;
              x2 -= xDiff;
              w2 += xDiff;
            }
            if (layerData.tileHeight > layerData.baseTileHeight) {
              var yDiff = (layerData.tileHeight - layerData.baseTileHeight) * tilemapLayer.scaleY;
              h2 += yDiff;
            }
            var mapData = GetTilesWithinWorldXY(x2, y2, w2, h2, null, tilemapLayer.scene.cameras.main, tilemapLayer.layer);
            if (mapData.length === 0) {
              return false;
            } else {
              return this.collideSpriteVsTilesHandler(sprite, mapData, collideCallback, processCallback, callbackContext, overlapOnly, true);
            }
          },
          collideSpriteVsTilesHandler: function(sprite, tiles, collideCallback, processCallback, callbackContext, overlapOnly, isLayer) {
            var body = sprite.body;
            var tile;
            var tileWorldRect = { left: 0, right: 0, top: 0, bottom: 0 };
            var tilemapLayer;
            var collision = false;
            for (var i2 = 0; i2 < tiles.length; i2++) {
              tile = tiles[i2];
              tilemapLayer = tile.tilemapLayer;
              var point = tilemapLayer.tileToWorldXY(tile.x, tile.y);
              tileWorldRect.left = point.x;
              tileWorldRect.top = point.y;
              if (tile.baseHeight !== tile.height) {
                tileWorldRect.top -= (tile.height - tile.baseHeight) * tilemapLayer.scaleY;
              }
              tileWorldRect.right = tileWorldRect.left + tile.width * tilemapLayer.scaleX;
              tileWorldRect.bottom = tileWorldRect.top + tile.height * tilemapLayer.scaleY;
              if (TileIntersectsBody(tileWorldRect, body) && (!processCallback || processCallback.call(callbackContext, sprite, tile)) && ProcessTileCallbacks(tile, sprite) && (overlapOnly || SeparateTile(i2, body, tile, tileWorldRect, tilemapLayer, this.TILE_BIAS, isLayer))) {
                this._total++;
                collision = true;
                if (collideCallback) {
                  collideCallback.call(callbackContext, sprite, tile);
                }
                if (overlapOnly && body.onOverlap) {
                  this.emit(Events.TILE_OVERLAP, sprite, tile, body);
                } else if (body.onCollide) {
                  this.emit(Events.TILE_COLLIDE, sprite, tile, body);
                }
              }
            }
            return collision;
          },
          collideGroupVsGroup: function(group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (group1.length === 0 || group2.length === 0) {
              return;
            }
            var children = group1.getChildren();
            for (var i2 = 0; i2 < children.length; i2++) {
              this.collideSpriteVsGroup(children[i2], group2, collideCallback, processCallback, callbackContext, overlapOnly);
            }
          },
          wrap: function(object, padding) {
            if (object.body) {
              this.wrapObject(object, padding);
            } else if (object.getChildren) {
              this.wrapArray(object.getChildren(), padding);
            } else if (Array.isArray(object)) {
              this.wrapArray(object, padding);
            } else {
              this.wrapObject(object, padding);
            }
          },
          wrapArray: function(objects, padding) {
            for (var i2 = 0; i2 < objects.length; i2++) {
              this.wrapObject(objects[i2], padding);
            }
          },
          wrapObject: function(object, padding) {
            if (padding === void 0) {
              padding = 0;
            }
            object.x = Wrap(object.x, this.bounds.left - padding, this.bounds.right + padding);
            object.y = Wrap(object.y, this.bounds.top - padding, this.bounds.bottom + padding);
          },
          shutdown: function() {
            this.tree.clear();
            this.staticTree.clear();
            this.bodies.clear();
            this.staticBodies.clear();
            this.colliders.destroy();
            this.removeAllListeners();
          },
          destroy: function() {
            this.shutdown();
            this.scene = null;
          }
        });
        module2.exports = World;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Benjamin D. Richards <benjamindrichards@gmail.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(62);
        var Events = __webpack_require__(245);
        var RadToDeg = __webpack_require__(196);
        var Rectangle = __webpack_require__(10);
        var RectangleContains = __webpack_require__(57);
        var Vector2 = __webpack_require__(3);
        var Body = new Class({
          initialize: function Body2(world, gameObject) {
            var width = gameObject.displayWidth ? gameObject.displayWidth : 64;
            var height = gameObject.displayHeight ? gameObject.displayHeight : 64;
            this.world = world;
            this.gameObject = gameObject;
            this.transform = {
              x: gameObject.x,
              y: gameObject.y,
              rotation: gameObject.angle,
              scaleX: gameObject.scaleX,
              scaleY: gameObject.scaleY,
              displayOriginX: gameObject.displayOriginX,
              displayOriginY: gameObject.displayOriginY
            };
            this.debugShowBody = world.defaults.debugShowBody;
            this.debugShowVelocity = world.defaults.debugShowVelocity;
            this.debugBodyColor = world.defaults.bodyDebugColor;
            this.enable = true;
            this.isCircle = false;
            this.radius = 0;
            this.offset = new Vector2();
            this.position = new Vector2(gameObject.x - gameObject.scaleX * gameObject.displayOriginX, gameObject.y - gameObject.scaleY * gameObject.displayOriginY);
            this.prev = this.position.clone();
            this.prevFrame = this.position.clone();
            this.allowRotation = true;
            this.rotation = gameObject.angle;
            this.preRotation = gameObject.angle;
            this.width = width;
            this.height = height;
            this.sourceWidth = width;
            this.sourceHeight = height;
            if (gameObject.frame) {
              this.sourceWidth = gameObject.frame.realWidth;
              this.sourceHeight = gameObject.frame.realHeight;
            }
            this.halfWidth = Math.abs(width / 2);
            this.halfHeight = Math.abs(height / 2);
            this.center = new Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
            this.velocity = new Vector2();
            this.newVelocity = new Vector2();
            this.deltaMax = new Vector2();
            this.acceleration = new Vector2();
            this.allowDrag = true;
            this.drag = new Vector2();
            this.allowGravity = true;
            this.gravity = new Vector2();
            this.bounce = new Vector2();
            this.worldBounce = null;
            this.customBoundsRectangle = world.bounds;
            this.onWorldBounds = false;
            this.onCollide = false;
            this.onOverlap = false;
            this.maxVelocity = new Vector2(1e4, 1e4);
            this.maxSpeed = -1;
            this.friction = new Vector2(1, 0);
            this.useDamping = false;
            this.angularVelocity = 0;
            this.angularAcceleration = 0;
            this.angularDrag = 0;
            this.maxAngular = 1e3;
            this.mass = 1;
            this.angle = 0;
            this.speed = 0;
            this.facing = CONST.FACING_NONE;
            this.immovable = false;
            this.pushable = true;
            this.moves = true;
            this.customSeparateX = false;
            this.customSeparateY = false;
            this.overlapX = 0;
            this.overlapY = 0;
            this.overlapR = 0;
            this.embedded = false;
            this.collideWorldBounds = false;
            this.checkCollision = { none: false, up: true, down: true, left: true, right: true };
            this.touching = { none: true, up: false, down: false, left: false, right: false };
            this.wasTouching = { none: true, up: false, down: false, left: false, right: false };
            this.blocked = { none: true, up: false, down: false, left: false, right: false };
            this.syncBounds = false;
            this.physicsType = CONST.DYNAMIC_BODY;
            this._sx = gameObject.scaleX;
            this._sy = gameObject.scaleY;
            this._dx = 0;
            this._dy = 0;
            this._tx = 0;
            this._ty = 0;
            this._bounds = new Rectangle();
          },
          updateBounds: function() {
            var sprite = this.gameObject;
            var transform = this.transform;
            if (sprite.parentContainer) {
              var matrix = sprite.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);
              transform.x = matrix.tx;
              transform.y = matrix.ty;
              transform.rotation = RadToDeg(matrix.rotation);
              transform.scaleX = matrix.scaleX;
              transform.scaleY = matrix.scaleY;
              transform.displayOriginX = sprite.displayOriginX;
              transform.displayOriginY = sprite.displayOriginY;
            } else {
              transform.x = sprite.x;
              transform.y = sprite.y;
              transform.rotation = sprite.angle;
              transform.scaleX = sprite.scaleX;
              transform.scaleY = sprite.scaleY;
              transform.displayOriginX = sprite.displayOriginX;
              transform.displayOriginY = sprite.displayOriginY;
            }
            var recalc = false;
            if (this.syncBounds) {
              var b2 = sprite.getBounds(this._bounds);
              this.width = b2.width;
              this.height = b2.height;
              recalc = true;
            } else {
              var asx = Math.abs(transform.scaleX);
              var asy = Math.abs(transform.scaleY);
              if (this._sx !== asx || this._sy !== asy) {
                this.width = this.sourceWidth * asx;
                this.height = this.sourceHeight * asy;
                this._sx = asx;
                this._sy = asy;
                recalc = true;
              }
            }
            if (recalc) {
              this.halfWidth = Math.floor(this.width / 2);
              this.halfHeight = Math.floor(this.height / 2);
              this.updateCenter();
            }
          },
          updateCenter: function() {
            this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
          },
          updateFromGameObject: function() {
            this.updateBounds();
            var transform = this.transform;
            this.position.x = transform.x + transform.scaleX * (this.offset.x - transform.displayOriginX);
            this.position.y = transform.y + transform.scaleY * (this.offset.y - transform.displayOriginY);
            this.updateCenter();
          },
          resetFlags: function(clear) {
            if (clear === void 0) {
              clear = false;
            }
            var wasTouching = this.wasTouching;
            var touching = this.touching;
            var blocked = this.blocked;
            if (clear) {
              wasTouching.none = true;
              wasTouching.up = false;
              wasTouching.down = false;
              wasTouching.left = false;
              wasTouching.right = false;
            } else {
              wasTouching.none = touching.none;
              wasTouching.up = touching.up;
              wasTouching.down = touching.down;
              wasTouching.left = touching.left;
              wasTouching.right = touching.right;
            }
            touching.none = true;
            touching.up = false;
            touching.down = false;
            touching.left = false;
            touching.right = false;
            blocked.none = true;
            blocked.up = false;
            blocked.down = false;
            blocked.left = false;
            blocked.right = false;
            this.overlapR = 0;
            this.overlapX = 0;
            this.overlapY = 0;
            this.embedded = false;
          },
          preUpdate: function(willStep, delta) {
            if (willStep) {
              this.resetFlags();
            }
            this.updateFromGameObject();
            this.rotation = this.transform.rotation;
            this.preRotation = this.rotation;
            if (this.moves) {
              this.prev.x = this.position.x;
              this.prev.y = this.position.y;
              this.prevFrame.x = this.position.x;
              this.prevFrame.y = this.position.y;
            }
            if (willStep) {
              this.update(delta);
            }
          },
          update: function(delta) {
            this.prev.x = this.position.x;
            this.prev.y = this.position.y;
            if (this.moves) {
              this.world.updateMotion(this, delta);
              var vx = this.velocity.x;
              var vy = this.velocity.y;
              this.newVelocity.set(vx * delta, vy * delta);
              this.position.add(this.newVelocity);
              this.updateCenter();
              this.angle = Math.atan2(vy, vx);
              this.speed = Math.sqrt(vx * vx + vy * vy);
              if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds) {
                this.world.emit(Events.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right);
              }
            }
            this._dx = this.position.x - this.prev.x;
            this._dy = this.position.y - this.prev.y;
          },
          postUpdate: function() {
            var dx = this.position.x - this.prevFrame.x;
            var dy = this.position.y - this.prevFrame.y;
            if (this.moves) {
              var mx = this.deltaMax.x;
              var my = this.deltaMax.y;
              if (mx !== 0 && dx !== 0) {
                if (dx < 0 && dx < -mx) {
                  dx = -mx;
                } else if (dx > 0 && dx > mx) {
                  dx = mx;
                }
              }
              if (my !== 0 && dy !== 0) {
                if (dy < 0 && dy < -my) {
                  dy = -my;
                } else if (dy > 0 && dy > my) {
                  dy = my;
                }
              }
              this.gameObject.x += dx;
              this.gameObject.y += dy;
            }
            if (dx < 0) {
              this.facing = CONST.FACING_LEFT;
            } else if (dx > 0) {
              this.facing = CONST.FACING_RIGHT;
            }
            if (dy < 0) {
              this.facing = CONST.FACING_UP;
            } else if (dy > 0) {
              this.facing = CONST.FACING_DOWN;
            }
            if (this.allowRotation) {
              this.gameObject.angle += this.deltaZ();
            }
            this._tx = dx;
            this._ty = dy;
          },
          setBoundsRectangle: function(bounds) {
            this.customBoundsRectangle = !bounds ? this.world.bounds : bounds;
            return this;
          },
          checkWorldBounds: function() {
            var pos = this.position;
            var bounds = this.customBoundsRectangle;
            var check = this.world.checkCollision;
            var bx = this.worldBounce ? -this.worldBounce.x : -this.bounce.x;
            var by = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
            var wasSet = false;
            if (pos.x < bounds.x && check.left) {
              pos.x = bounds.x;
              this.velocity.x *= bx;
              this.blocked.left = true;
              wasSet = true;
            } else if (this.right > bounds.right && check.right) {
              pos.x = bounds.right - this.width;
              this.velocity.x *= bx;
              this.blocked.right = true;
              wasSet = true;
            }
            if (pos.y < bounds.y && check.up) {
              pos.y = bounds.y;
              this.velocity.y *= by;
              this.blocked.up = true;
              wasSet = true;
            } else if (this.bottom > bounds.bottom && check.down) {
              pos.y = bounds.bottom - this.height;
              this.velocity.y *= by;
              this.blocked.down = true;
              wasSet = true;
            }
            if (wasSet) {
              this.blocked.none = false;
              this.updateCenter();
            }
            return wasSet;
          },
          setOffset: function(x2, y2) {
            if (y2 === void 0) {
              y2 = x2;
            }
            this.offset.set(x2, y2);
            return this;
          },
          setSize: function(width, height, center) {
            if (center === void 0) {
              center = true;
            }
            var gameObject = this.gameObject;
            if (!width && gameObject.frame) {
              width = gameObject.frame.realWidth;
            }
            if (!height && gameObject.frame) {
              height = gameObject.frame.realHeight;
            }
            this.sourceWidth = width;
            this.sourceHeight = height;
            this.width = this.sourceWidth * this._sx;
            this.height = this.sourceHeight * this._sy;
            this.halfWidth = Math.floor(this.width / 2);
            this.halfHeight = Math.floor(this.height / 2);
            this.updateCenter();
            if (center && gameObject.getCenter) {
              var ox = (gameObject.width - width) / 2;
              var oy = (gameObject.height - height) / 2;
              this.offset.set(ox, oy);
            }
            this.isCircle = false;
            this.radius = 0;
            return this;
          },
          setCircle: function(radius, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = this.offset.x;
            }
            if (offsetY === void 0) {
              offsetY = this.offset.y;
            }
            if (radius > 0) {
              this.isCircle = true;
              this.radius = radius;
              this.sourceWidth = radius * 2;
              this.sourceHeight = radius * 2;
              this.width = this.sourceWidth * this._sx;
              this.height = this.sourceHeight * this._sy;
              this.halfWidth = Math.floor(this.width / 2);
              this.halfHeight = Math.floor(this.height / 2);
              this.offset.set(offsetX, offsetY);
              this.updateCenter();
            } else {
              this.isCircle = false;
            }
            return this;
          },
          reset: function(x2, y2) {
            this.stop();
            var gameObject = this.gameObject;
            gameObject.setPosition(x2, y2);
            if (gameObject.getTopLeft) {
              gameObject.getTopLeft(this.position);
            } else {
              this.position.set(x2, y2);
            }
            this.prev.copy(this.position);
            this.prevFrame.copy(this.position);
            this.rotation = gameObject.angle;
            this.preRotation = gameObject.angle;
            this.updateBounds();
            this.updateCenter();
            this.resetFlags(true);
          },
          stop: function() {
            this.velocity.set(0);
            this.acceleration.set(0);
            this.speed = 0;
            this.angularVelocity = 0;
            this.angularAcceleration = 0;
            return this;
          },
          getBounds: function(obj) {
            obj.x = this.x;
            obj.y = this.y;
            obj.right = this.right;
            obj.bottom = this.bottom;
            return obj;
          },
          hitTest: function(x2, y2) {
            if (!this.isCircle) {
              return RectangleContains(this, x2, y2);
            }
            if (this.radius > 0 && x2 >= this.left && x2 <= this.right && y2 >= this.top && y2 <= this.bottom) {
              var dx = (this.center.x - x2) * (this.center.x - x2);
              var dy = (this.center.y - y2) * (this.center.y - y2);
              return dx + dy <= this.radius * this.radius;
            }
            return false;
          },
          onFloor: function() {
            return this.blocked.down;
          },
          onCeiling: function() {
            return this.blocked.up;
          },
          onWall: function() {
            return this.blocked.left || this.blocked.right;
          },
          deltaAbsX: function() {
            return this._dx > 0 ? this._dx : -this._dx;
          },
          deltaAbsY: function() {
            return this._dy > 0 ? this._dy : -this._dy;
          },
          deltaX: function() {
            return this._dx;
          },
          deltaY: function() {
            return this._dy;
          },
          deltaXFinal: function() {
            return this._tx;
          },
          deltaYFinal: function() {
            return this._ty;
          },
          deltaZ: function() {
            return this.rotation - this.preRotation;
          },
          destroy: function() {
            this.enable = false;
            if (this.world) {
              this.world.pendingDestroy.set(this);
            }
          },
          drawDebug: function(graphic) {
            var pos = this.position;
            var x2 = pos.x + this.halfWidth;
            var y2 = pos.y + this.halfHeight;
            if (this.debugShowBody) {
              graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor);
              if (this.isCircle) {
                graphic.strokeCircle(x2, y2, this.width / 2);
              } else {
                if (this.checkCollision.up) {
                  graphic.lineBetween(pos.x, pos.y, pos.x + this.width, pos.y);
                }
                if (this.checkCollision.right) {
                  graphic.lineBetween(pos.x + this.width, pos.y, pos.x + this.width, pos.y + this.height);
                }
                if (this.checkCollision.down) {
                  graphic.lineBetween(pos.x, pos.y + this.height, pos.x + this.width, pos.y + this.height);
                }
                if (this.checkCollision.left) {
                  graphic.lineBetween(pos.x, pos.y, pos.x, pos.y + this.height);
                }
              }
            }
            if (this.debugShowVelocity) {
              graphic.lineStyle(graphic.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1);
              graphic.lineBetween(x2, y2, x2 + this.velocity.x / 2, y2 + this.velocity.y / 2);
            }
          },
          willDrawDebug: function() {
            return this.debugShowBody || this.debugShowVelocity;
          },
          setCollideWorldBounds: function(value, bounceX, bounceY, onWorldBounds) {
            if (value === void 0) {
              value = true;
            }
            this.collideWorldBounds = value;
            var setBounceX = bounceX !== void 0;
            var setBounceY = bounceY !== void 0;
            if (setBounceX || setBounceY) {
              if (!this.worldBounce) {
                this.worldBounce = new Vector2();
              }
              if (setBounceX) {
                this.worldBounce.x = bounceX;
              }
              if (setBounceY) {
                this.worldBounce.y = bounceY;
              }
            }
            if (onWorldBounds !== void 0) {
              this.onWorldBounds = onWorldBounds;
            }
            return this;
          },
          setVelocity: function(x2, y2) {
            this.velocity.set(x2, y2);
            x2 = this.velocity.x;
            y2 = this.velocity.y;
            this.speed = Math.sqrt(x2 * x2 + y2 * y2);
            return this;
          },
          setVelocityX: function(value) {
            this.velocity.x = value;
            var x2 = value;
            var y2 = this.velocity.y;
            this.speed = Math.sqrt(x2 * x2 + y2 * y2);
            return this;
          },
          setVelocityY: function(value) {
            this.velocity.y = value;
            var x2 = this.velocity.x;
            var y2 = value;
            this.speed = Math.sqrt(x2 * x2 + y2 * y2);
            return this;
          },
          setMaxVelocity: function(x2, y2) {
            this.maxVelocity.set(x2, y2);
            return this;
          },
          setMaxVelocityX: function(value) {
            this.maxVelocity.x = value;
            return this;
          },
          setMaxVelocityY: function(value) {
            this.maxVelocity.y = value;
            return this;
          },
          setMaxSpeed: function(value) {
            this.maxSpeed = value;
            return this;
          },
          setBounce: function(x2, y2) {
            this.bounce.set(x2, y2);
            return this;
          },
          setBounceX: function(value) {
            this.bounce.x = value;
            return this;
          },
          setBounceY: function(value) {
            this.bounce.y = value;
            return this;
          },
          setAcceleration: function(x2, y2) {
            this.acceleration.set(x2, y2);
            return this;
          },
          setAccelerationX: function(value) {
            this.acceleration.x = value;
            return this;
          },
          setAccelerationY: function(value) {
            this.acceleration.y = value;
            return this;
          },
          setAllowDrag: function(value) {
            if (value === void 0) {
              value = true;
            }
            this.allowDrag = value;
            return this;
          },
          setAllowGravity: function(value) {
            if (value === void 0) {
              value = true;
            }
            this.allowGravity = value;
            return this;
          },
          setAllowRotation: function(value) {
            if (value === void 0) {
              value = true;
            }
            this.allowRotation = value;
            return this;
          },
          setDrag: function(x2, y2) {
            this.drag.set(x2, y2);
            return this;
          },
          setDamping: function(value) {
            this.useDamping = value;
            return this;
          },
          setDragX: function(value) {
            this.drag.x = value;
            return this;
          },
          setDragY: function(value) {
            this.drag.y = value;
            return this;
          },
          setGravity: function(x2, y2) {
            this.gravity.set(x2, y2);
            return this;
          },
          setGravityX: function(value) {
            this.gravity.x = value;
            return this;
          },
          setGravityY: function(value) {
            this.gravity.y = value;
            return this;
          },
          setFriction: function(x2, y2) {
            this.friction.set(x2, y2);
            return this;
          },
          setFrictionX: function(value) {
            this.friction.x = value;
            return this;
          },
          setFrictionY: function(value) {
            this.friction.y = value;
            return this;
          },
          setAngularVelocity: function(value) {
            this.angularVelocity = value;
            return this;
          },
          setAngularAcceleration: function(value) {
            this.angularAcceleration = value;
            return this;
          },
          setAngularDrag: function(value) {
            this.angularDrag = value;
            return this;
          },
          setMass: function(value) {
            this.mass = value;
            return this;
          },
          setImmovable: function(value) {
            if (value === void 0) {
              value = true;
            }
            this.immovable = value;
            return this;
          },
          setEnable: function(value) {
            if (value === void 0) {
              value = true;
            }
            this.enable = value;
            return this;
          },
          processX: function(x2, vx, left, right) {
            this.x += x2;
            this.updateCenter();
            if (vx !== null) {
              this.velocity.x = vx;
            }
            var blocked = this.blocked;
            if (left) {
              blocked.left = true;
            }
            if (right) {
              blocked.right = true;
            }
          },
          processY: function(y2, vy, up, down) {
            this.y += y2;
            this.updateCenter();
            if (vy !== null) {
              this.velocity.y = vy;
            }
            var blocked = this.blocked;
            if (up) {
              blocked.up = true;
            }
            if (down) {
              blocked.down = true;
            }
          },
          x: {
            get: function() {
              return this.position.x;
            },
            set: function(value) {
              this.position.x = value;
            }
          },
          y: {
            get: function() {
              return this.position.y;
            },
            set: function(value) {
              this.position.y = value;
            }
          },
          left: {
            get: function() {
              return this.position.x;
            }
          },
          right: {
            get: function() {
              return this.position.x + this.width;
            }
          },
          top: {
            get: function() {
              return this.position.y;
            }
          },
          bottom: {
            get: function() {
              return this.position.y + this.height;
            }
          }
        });
        module2.exports = Body;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Collider = new Class({
          initialize: function Collider2(world, overlapOnly, object1, object2, collideCallback, processCallback, callbackContext) {
            this.world = world;
            this.name = "";
            this.active = true;
            this.overlapOnly = overlapOnly;
            this.object1 = object1;
            this.object2 = object2;
            this.collideCallback = collideCallback;
            this.processCallback = processCallback;
            this.callbackContext = callbackContext;
          },
          setName: function(name) {
            this.name = name;
            return this;
          },
          update: function() {
            this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly);
          },
          destroy: function() {
            this.world.removeCollider(this);
            this.active = false;
            this.world = null;
            this.object1 = null;
            this.object2 = null;
            this.collideCallback = null;
            this.processCallback = null;
            this.callbackContext = null;
          }
        });
        module2.exports = Collider;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTilesWithin = __webpack_require__(26);
        var Vector2 = __webpack_require__(3);
        var pointStart = new Vector2();
        var pointEnd = new Vector2();
        var GetTilesWithinWorldXY = function(worldX, worldY, width, height, filteringOptions, camera, layer) {
          var worldToTileXY = layer.tilemapLayer.tilemap._convert.WorldToTileXY;
          worldToTileXY(worldX, worldY, true, pointStart, camera, layer);
          var xStart = pointStart.x;
          var yStart = pointStart.y;
          worldToTileXY(worldX + width, worldY + height, false, pointEnd, camera, layer);
          var xEnd = Math.ceil(pointEnd.x);
          var yEnd = Math.ceil(pointEnd.y);
          return GetTilesWithin(xStart, yStart, xEnd - xStart, yEnd - yStart, filteringOptions, layer);
        };
        module2.exports = GetTilesWithinWorldXY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ProcessTileCallbacks = function(tile, sprite) {
          if (tile.collisionCallback) {
            return !tile.collisionCallback.call(tile.collisionCallbackContext, sprite, tile);
          } else if (tile.layer.callbacks[tile.index]) {
            return !tile.layer.callbacks[tile.index].callback.call(tile.layer.callbacks[tile.index].callbackContext, sprite, tile);
          }
          return true;
        };
        module2.exports = ProcessTileCallbacks;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Vladimir Agafonkin
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var quickselect = __webpack_require__(436);
        function rbush(maxEntries) {
          var format = [".left", ".top", ".right", ".bottom"];
          if (!(this instanceof rbush))
            return new rbush(maxEntries, format);
          this._maxEntries = Math.max(4, maxEntries || 9);
          this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
          this.clear();
        }
        rbush.prototype = {
          all: function() {
            return this._all(this.data, []);
          },
          search: function(bbox) {
            var node = this.data, result = [], toBBox = this.toBBox;
            if (!intersects(bbox, node))
              return result;
            var nodesToSearch = [], i2, len, child, childBBox;
            while (node) {
              for (i2 = 0, len = node.children.length; i2 < len; i2++) {
                child = node.children[i2];
                childBBox = node.leaf ? toBBox(child) : child;
                if (intersects(bbox, childBBox)) {
                  if (node.leaf)
                    result.push(child);
                  else if (contains(bbox, childBBox))
                    this._all(child, result);
                  else
                    nodesToSearch.push(child);
                }
              }
              node = nodesToSearch.pop();
            }
            return result;
          },
          collides: function(bbox) {
            var node = this.data, toBBox = this.toBBox;
            if (!intersects(bbox, node))
              return false;
            var nodesToSearch = [], i2, len, child, childBBox;
            while (node) {
              for (i2 = 0, len = node.children.length; i2 < len; i2++) {
                child = node.children[i2];
                childBBox = node.leaf ? toBBox(child) : child;
                if (intersects(bbox, childBBox)) {
                  if (node.leaf || contains(bbox, childBBox))
                    return true;
                  nodesToSearch.push(child);
                }
              }
              node = nodesToSearch.pop();
            }
            return false;
          },
          load: function(data) {
            if (!(data && data.length))
              return this;
            if (data.length < this._minEntries) {
              for (var i2 = 0, len = data.length; i2 < len; i2++) {
                this.insert(data[i2]);
              }
              return this;
            }
            var node = this._build(data.slice(), 0, data.length - 1, 0);
            if (!this.data.children.length) {
              this.data = node;
            } else if (this.data.height === node.height) {
              this._splitRoot(this.data, node);
            } else {
              if (this.data.height < node.height) {
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
              }
              this._insert(node, this.data.height - node.height - 1, true);
            }
            return this;
          },
          insert: function(item) {
            if (item)
              this._insert(item, this.data.height - 1);
            return this;
          },
          clear: function() {
            this.data = createNode([]);
            return this;
          },
          remove: function(item, equalsFn) {
            if (!item)
              return this;
            var node = this.data, bbox = this.toBBox(item), path = [], indexes = [], i2, parent, index2, goingUp;
            while (node || path.length) {
              if (!node) {
                node = path.pop();
                parent = path[path.length - 1];
                i2 = indexes.pop();
                goingUp = true;
              }
              if (node.leaf) {
                index2 = findItem(item, node.children, equalsFn);
                if (index2 !== -1) {
                  node.children.splice(index2, 1);
                  path.push(node);
                  this._condense(path);
                  return this;
                }
              }
              if (!goingUp && !node.leaf && contains(node, bbox)) {
                path.push(node);
                indexes.push(i2);
                i2 = 0;
                parent = node;
                node = node.children[0];
              } else if (parent) {
                i2++;
                node = parent.children[i2];
                goingUp = false;
              } else
                node = null;
            }
            return this;
          },
          toBBox: function(item) {
            return item;
          },
          compareMinX: compareNodeMinX,
          compareMinY: compareNodeMinY,
          toJSON: function() {
            return this.data;
          },
          fromJSON: function(data) {
            this.data = data;
            return this;
          },
          _all: function(node, result) {
            var nodesToSearch = [];
            while (node) {
              if (node.leaf)
                result.push.apply(result, node.children);
              else
                nodesToSearch.push.apply(nodesToSearch, node.children);
              node = nodesToSearch.pop();
            }
            return result;
          },
          _build: function(items, left, right, height) {
            var N2 = right - left + 1, M2 = this._maxEntries, node;
            if (N2 <= M2) {
              node = createNode(items.slice(left, right + 1));
              calcBBox(node, this.toBBox);
              return node;
            }
            if (!height) {
              height = Math.ceil(Math.log(N2) / Math.log(M2));
              M2 = Math.ceil(N2 / Math.pow(M2, height - 1));
            }
            node = createNode([]);
            node.leaf = false;
            node.height = height;
            var N22 = Math.ceil(N2 / M2), N1 = N22 * Math.ceil(Math.sqrt(M2)), i2, j, right2, right3;
            multiSelect(items, left, right, N1, this.compareMinX);
            for (i2 = left; i2 <= right; i2 += N1) {
              right2 = Math.min(i2 + N1 - 1, right);
              multiSelect(items, i2, right2, N22, this.compareMinY);
              for (j = i2; j <= right2; j += N22) {
                right3 = Math.min(j + N22 - 1, right2);
                node.children.push(this._build(items, j, right3, height - 1));
              }
            }
            calcBBox(node, this.toBBox);
            return node;
          },
          _chooseSubtree: function(bbox, node, level, path) {
            var i2, len, child, targetNode, area, enlargement, minArea, minEnlargement;
            while (true) {
              path.push(node);
              if (node.leaf || path.length - 1 === level)
                break;
              minArea = minEnlargement = Infinity;
              for (i2 = 0, len = node.children.length; i2 < len; i2++) {
                child = node.children[i2];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;
                if (enlargement < minEnlargement) {
                  minEnlargement = enlargement;
                  minArea = area < minArea ? area : minArea;
                  targetNode = child;
                } else if (enlargement === minEnlargement) {
                  if (area < minArea) {
                    minArea = area;
                    targetNode = child;
                  }
                }
              }
              node = targetNode || node.children[0];
            }
            return node;
          },
          _insert: function(item, level, isNode) {
            var toBBox = this.toBBox, bbox = isNode ? item : toBBox(item), insertPath = [];
            var node = this._chooseSubtree(bbox, this.data, level, insertPath);
            node.children.push(item);
            extend(node, bbox);
            while (level >= 0) {
              if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
              } else
                break;
            }
            this._adjustParentBBoxes(bbox, insertPath, level);
          },
          _split: function(insertPath, level) {
            var node = insertPath[level], M2 = node.children.length, m2 = this._minEntries;
            this._chooseSplitAxis(node, m2, M2);
            var splitIndex = this._chooseSplitIndex(node, m2, M2);
            var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
            newNode.height = node.height;
            newNode.leaf = node.leaf;
            calcBBox(node, this.toBBox);
            calcBBox(newNode, this.toBBox);
            if (level)
              insertPath[level - 1].children.push(newNode);
            else
              this._splitRoot(node, newNode);
          },
          _splitRoot: function(node, newNode) {
            this.data = createNode([node, newNode]);
            this.data.height = node.height + 1;
            this.data.leaf = false;
            calcBBox(this.data, this.toBBox);
          },
          _chooseSplitIndex: function(node, m2, M2) {
            var i2, bbox1, bbox2, overlap, area, minOverlap, minArea, index2;
            minOverlap = minArea = Infinity;
            for (i2 = m2; i2 <= M2 - m2; i2++) {
              bbox1 = distBBox(node, 0, i2, this.toBBox);
              bbox2 = distBBox(node, i2, M2, this.toBBox);
              overlap = intersectionArea(bbox1, bbox2);
              area = bboxArea(bbox1) + bboxArea(bbox2);
              if (overlap < minOverlap) {
                minOverlap = overlap;
                index2 = i2;
                minArea = area < minArea ? area : minArea;
              } else if (overlap === minOverlap) {
                if (area < minArea) {
                  minArea = area;
                  index2 = i2;
                }
              }
            }
            return index2;
          },
          _chooseSplitAxis: function(node, m2, M2) {
            var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m2, M2, compareMinX), yMargin = this._allDistMargin(node, m2, M2, compareMinY);
            if (xMargin < yMargin)
              node.children.sort(compareMinX);
          },
          _allDistMargin: function(node, m2, M2, compare) {
            node.children.sort(compare);
            var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m2, toBBox), rightBBox = distBBox(node, M2 - m2, M2, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i2, child;
            for (i2 = m2; i2 < M2 - m2; i2++) {
              child = node.children[i2];
              extend(leftBBox, node.leaf ? toBBox(child) : child);
              margin += bboxMargin(leftBBox);
            }
            for (i2 = M2 - m2 - 1; i2 >= m2; i2--) {
              child = node.children[i2];
              extend(rightBBox, node.leaf ? toBBox(child) : child);
              margin += bboxMargin(rightBBox);
            }
            return margin;
          },
          _adjustParentBBoxes: function(bbox, path, level) {
            for (var i2 = level; i2 >= 0; i2--) {
              extend(path[i2], bbox);
            }
          },
          _condense: function(path) {
            for (var i2 = path.length - 1, siblings; i2 >= 0; i2--) {
              if (path[i2].children.length === 0) {
                if (i2 > 0) {
                  siblings = path[i2 - 1].children;
                  siblings.splice(siblings.indexOf(path[i2]), 1);
                } else
                  this.clear();
              } else
                calcBBox(path[i2], this.toBBox);
            }
          },
          compareMinX: function(a, b2) {
            return a.left - b2.left;
          },
          compareMinY: function(a, b2) {
            return a.top - b2.top;
          },
          toBBox: function(a) {
            return {
              minX: a.left,
              minY: a.top,
              maxX: a.right,
              maxY: a.bottom
            };
          }
        };
        function findItem(item, items, equalsFn) {
          if (!equalsFn)
            return items.indexOf(item);
          for (var i2 = 0; i2 < items.length; i2++) {
            if (equalsFn(item, items[i2]))
              return i2;
          }
          return -1;
        }
        function calcBBox(node, toBBox) {
          distBBox(node, 0, node.children.length, toBBox, node);
        }
        function distBBox(node, k2, p2, toBBox, destNode) {
          if (!destNode)
            destNode = createNode(null);
          destNode.minX = Infinity;
          destNode.minY = Infinity;
          destNode.maxX = -Infinity;
          destNode.maxY = -Infinity;
          for (var i2 = k2, child; i2 < p2; i2++) {
            child = node.children[i2];
            extend(destNode, node.leaf ? toBBox(child) : child);
          }
          return destNode;
        }
        function extend(a, b2) {
          a.minX = Math.min(a.minX, b2.minX);
          a.minY = Math.min(a.minY, b2.minY);
          a.maxX = Math.max(a.maxX, b2.maxX);
          a.maxY = Math.max(a.maxY, b2.maxY);
          return a;
        }
        function compareNodeMinX(a, b2) {
          return a.minX - b2.minX;
        }
        function compareNodeMinY(a, b2) {
          return a.minY - b2.minY;
        }
        function bboxArea(a) {
          return (a.maxX - a.minX) * (a.maxY - a.minY);
        }
        function bboxMargin(a) {
          return a.maxX - a.minX + (a.maxY - a.minY);
        }
        function enlargedArea(a, b2) {
          return (Math.max(b2.maxX, a.maxX) - Math.min(b2.minX, a.minX)) * (Math.max(b2.maxY, a.maxY) - Math.min(b2.minY, a.minY));
        }
        function intersectionArea(a, b2) {
          var minX = Math.max(a.minX, b2.minX), minY = Math.max(a.minY, b2.minY), maxX = Math.min(a.maxX, b2.maxX), maxY = Math.min(a.maxY, b2.maxY);
          return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
        }
        function contains(a, b2) {
          return a.minX <= b2.minX && a.minY <= b2.minY && b2.maxX <= a.maxX && b2.maxY <= a.maxY;
        }
        function intersects(a, b2) {
          return b2.minX <= a.maxX && b2.minY <= a.maxY && b2.maxX >= a.minX && b2.maxY >= a.minY;
        }
        function createNode(children) {
          return {
            children,
            height: 1,
            leaf: true,
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
          };
        }
        function multiSelect(arr, left, right, n2, compare) {
          var stack = [left, right], mid;
          while (stack.length) {
            right = stack.pop();
            left = stack.pop();
            if (right - left <= n2)
              continue;
            mid = left + Math.ceil((right - left) / n2 / 2) * n2;
            quickselect(arr, mid, left, right, compare);
            stack.push(left, mid, mid, right);
          }
        }
        module2.exports = rbush;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TileCheckX = __webpack_require__(533);
        var TileCheckY = __webpack_require__(535);
        var TileIntersectsBody = __webpack_require__(248);
        var SeparateTile = function(i2, body, tile, tileWorldRect, tilemapLayer, tileBias, isLayer) {
          var tileLeft = tileWorldRect.left;
          var tileTop = tileWorldRect.top;
          var tileRight = tileWorldRect.right;
          var tileBottom = tileWorldRect.bottom;
          var faceHorizontal = tile.faceLeft || tile.faceRight;
          var faceVertical = tile.faceTop || tile.faceBottom;
          if (!isLayer) {
            faceHorizontal = true;
            faceVertical = true;
          }
          if (!faceHorizontal && !faceVertical) {
            return false;
          }
          var ox = 0;
          var oy = 0;
          var minX = 0;
          var minY = 1;
          if (body.deltaAbsX() > body.deltaAbsY()) {
            minX = -1;
          } else if (body.deltaAbsX() < body.deltaAbsY()) {
            minY = -1;
          }
          if (body.deltaX() !== 0 && body.deltaY() !== 0 && faceHorizontal && faceVertical) {
            minX = Math.min(Math.abs(body.position.x - tileRight), Math.abs(body.right - tileLeft));
            minY = Math.min(Math.abs(body.position.y - tileBottom), Math.abs(body.bottom - tileTop));
          }
          if (minX < minY) {
            if (faceHorizontal) {
              ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);
              if (ox !== 0 && !TileIntersectsBody(tileWorldRect, body)) {
                return true;
              }
            }
            if (faceVertical) {
              oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);
            }
          } else {
            if (faceVertical) {
              oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);
              if (oy !== 0 && !TileIntersectsBody(tileWorldRect, body)) {
                return true;
              }
            }
            if (faceHorizontal) {
              ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);
            }
          }
          return ox !== 0 || oy !== 0;
        };
        module2.exports = SeparateTile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ProcessTileSeparationX = __webpack_require__(534);
        var TileCheckX = function(body, tile, tileLeft, tileRight, tileBias, isLayer) {
          var ox = 0;
          var faceLeft = tile.faceLeft;
          var faceRight = tile.faceRight;
          var collideLeft = tile.collideLeft;
          var collideRight = tile.collideRight;
          if (!isLayer) {
            faceLeft = true;
            faceRight = true;
            collideLeft = true;
            collideRight = true;
          }
          if (body.deltaX() < 0 && collideRight && body.checkCollision.left) {
            if (faceRight && body.x < tileRight) {
              ox = body.x - tileRight;
              if (ox < -tileBias) {
                ox = 0;
              }
            }
          } else if (body.deltaX() > 0 && collideLeft && body.checkCollision.right) {
            if (faceLeft && body.right > tileLeft) {
              ox = body.right - tileLeft;
              if (ox > tileBias) {
                ox = 0;
              }
            }
          }
          if (ox !== 0) {
            if (body.customSeparateX) {
              body.overlapX = ox;
            } else {
              ProcessTileSeparationX(body, ox);
            }
          }
          return ox;
        };
        module2.exports = TileCheckX;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ProcessTileSeparationX = function(body, x2) {
          if (x2 < 0) {
            body.blocked.none = false;
            body.blocked.left = true;
          } else if (x2 > 0) {
            body.blocked.none = false;
            body.blocked.right = true;
          }
          body.position.x -= x2;
          if (body.bounce.x === 0) {
            body.velocity.x = 0;
          } else {
            body.velocity.x = -body.velocity.x * body.bounce.x;
          }
        };
        module2.exports = ProcessTileSeparationX;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ProcessTileSeparationY = __webpack_require__(536);
        var TileCheckY = function(body, tile, tileTop, tileBottom, tileBias, isLayer) {
          var oy = 0;
          var faceTop = tile.faceTop;
          var faceBottom = tile.faceBottom;
          var collideUp = tile.collideUp;
          var collideDown = tile.collideDown;
          if (!isLayer) {
            faceTop = true;
            faceBottom = true;
            collideUp = true;
            collideDown = true;
          }
          if (body.deltaY() < 0 && collideDown && body.checkCollision.up) {
            if (faceBottom && body.y < tileBottom) {
              oy = body.y - tileBottom;
              if (oy < -tileBias) {
                oy = 0;
              }
            }
          } else if (body.deltaY() > 0 && collideUp && body.checkCollision.down) {
            if (faceTop && body.bottom > tileTop) {
              oy = body.bottom - tileTop;
              if (oy > tileBias) {
                oy = 0;
              }
            }
          }
          if (oy !== 0) {
            if (body.customSeparateY) {
              body.overlapY = oy;
            } else {
              ProcessTileSeparationY(body, oy);
            }
          }
          return oy;
        };
        module2.exports = TileCheckY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ProcessTileSeparationY = function(body, y2) {
          if (y2 < 0) {
            body.blocked.none = false;
            body.blocked.up = true;
          } else if (y2 > 0) {
            body.blocked.none = false;
            body.blocked.down = true;
          }
          body.position.y -= y2;
          if (body.bounce.y === 0) {
            body.velocity.y = 0;
          } else {
            body.velocity.y = -body.velocity.y * body.bounce.y;
          }
        };
        module2.exports = ProcessTileSeparationY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetOverlapX = __webpack_require__(246);
        var ProcessX = __webpack_require__(1389);
        var SeparateX = function(body1, body2, overlapOnly, bias) {
          var overlap = GetOverlapX(body1, body2, overlapOnly, bias);
          var body1Immovable = body1.immovable;
          var body2Immovable = body2.immovable;
          if (overlapOnly || overlap === 0 || body1Immovable && body2Immovable || body1.customSeparateX || body2.customSeparateX) {
            return overlap !== 0 || body1.embedded && body2.embedded;
          }
          var blockedState = ProcessX.Set(body1, body2, overlap);
          if (!body1Immovable && !body2Immovable) {
            if (blockedState > 0) {
              return true;
            }
            return ProcessX.Check();
          } else if (body1Immovable) {
            ProcessX.RunImmovableBody1(blockedState);
          } else if (body2Immovable) {
            ProcessX.RunImmovableBody2(blockedState);
          }
          return true;
        };
        module2.exports = SeparateX;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetOverlapY = __webpack_require__(247);
        var ProcessY = __webpack_require__(1390);
        var SeparateY = function(body1, body2, overlapOnly, bias) {
          var overlap = GetOverlapY(body1, body2, overlapOnly, bias);
          var body1Immovable = body1.immovable;
          var body2Immovable = body2.immovable;
          if (overlapOnly || overlap === 0 || body1Immovable && body2Immovable || body1.customSeparateY || body2.customSeparateY) {
            return overlap !== 0 || body1.embedded && body2.embedded;
          }
          var blockedState = ProcessY.Set(body1, body2, overlap);
          if (!body1Immovable && !body2Immovable) {
            if (blockedState > 0) {
              return true;
            }
            return ProcessY.Check();
          } else if (body1Immovable) {
            ProcessY.RunImmovableBody1(blockedState);
          } else if (body2Immovable) {
            ProcessY.RunImmovableBody2(blockedState);
          }
          return true;
        };
        module2.exports = SeparateY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CircleContains = __webpack_require__(66);
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(62);
        var RectangleContains = __webpack_require__(57);
        var Vector2 = __webpack_require__(3);
        var StaticBody = new Class({
          initialize: function StaticBody2(world, gameObject) {
            var width = gameObject.displayWidth ? gameObject.displayWidth : 64;
            var height = gameObject.displayHeight ? gameObject.displayHeight : 64;
            this.world = world;
            this.gameObject = gameObject;
            this.debugShowBody = world.defaults.debugShowStaticBody;
            this.debugBodyColor = world.defaults.staticBodyDebugColor;
            this.enable = true;
            this.isCircle = false;
            this.radius = 0;
            this.offset = new Vector2();
            this.position = new Vector2(gameObject.x - width * gameObject.originX, gameObject.y - height * gameObject.originY);
            this.width = width;
            this.height = height;
            this.halfWidth = Math.abs(this.width / 2);
            this.halfHeight = Math.abs(this.height / 2);
            this.center = new Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
            this.velocity = Vector2.ZERO;
            this.allowGravity = false;
            this.gravity = Vector2.ZERO;
            this.bounce = Vector2.ZERO;
            this.onWorldBounds = false;
            this.onCollide = false;
            this.onOverlap = false;
            this.mass = 1;
            this.immovable = true;
            this.pushable = false;
            this.customSeparateX = false;
            this.customSeparateY = false;
            this.overlapX = 0;
            this.overlapY = 0;
            this.overlapR = 0;
            this.embedded = false;
            this.collideWorldBounds = false;
            this.checkCollision = { none: false, up: true, down: true, left: true, right: true };
            this.touching = { none: true, up: false, down: false, left: false, right: false };
            this.wasTouching = { none: true, up: false, down: false, left: false, right: false };
            this.blocked = { none: true, up: false, down: false, left: false, right: false };
            this.physicsType = CONST.STATIC_BODY;
            this._dx = 0;
            this._dy = 0;
          },
          setGameObject: function(gameObject, update) {
            if (gameObject && gameObject !== this.gameObject) {
              this.gameObject.body = null;
              gameObject.body = this;
              this.gameObject = gameObject;
            }
            if (update) {
              this.updateFromGameObject();
            }
            return this;
          },
          updateFromGameObject: function() {
            this.world.staticTree.remove(this);
            var gameObject = this.gameObject;
            gameObject.getTopLeft(this.position);
            this.width = gameObject.displayWidth;
            this.height = gameObject.displayHeight;
            this.halfWidth = Math.abs(this.width / 2);
            this.halfHeight = Math.abs(this.height / 2);
            this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
            this.world.staticTree.insert(this);
            return this;
          },
          setOffset: function(x2, y2) {
            if (y2 === void 0) {
              y2 = x2;
            }
            this.world.staticTree.remove(this);
            this.position.x -= this.offset.x;
            this.position.y -= this.offset.y;
            this.offset.set(x2, y2);
            this.position.x += this.offset.x;
            this.position.y += this.offset.y;
            this.updateCenter();
            this.world.staticTree.insert(this);
            return this;
          },
          setSize: function(width, height, center) {
            if (center === void 0) {
              center = true;
            }
            var gameObject = this.gameObject;
            if (!width && gameObject.frame) {
              width = gameObject.frame.realWidth;
            }
            if (!height && gameObject.frame) {
              height = gameObject.frame.realHeight;
            }
            this.world.staticTree.remove(this);
            this.width = width;
            this.height = height;
            this.halfWidth = Math.floor(width / 2);
            this.halfHeight = Math.floor(height / 2);
            if (center && gameObject.getCenter) {
              var ox = gameObject.displayWidth / 2;
              var oy = gameObject.displayHeight / 2;
              this.position.x -= this.offset.x;
              this.position.y -= this.offset.y;
              this.offset.set(ox - this.halfWidth, oy - this.halfHeight);
              this.position.x += this.offset.x;
              this.position.y += this.offset.y;
            }
            this.updateCenter();
            this.isCircle = false;
            this.radius = 0;
            this.world.staticTree.insert(this);
            return this;
          },
          setCircle: function(radius, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = this.offset.x;
            }
            if (offsetY === void 0) {
              offsetY = this.offset.y;
            }
            if (radius > 0) {
              this.world.staticTree.remove(this);
              this.isCircle = true;
              this.radius = radius;
              this.width = radius * 2;
              this.height = radius * 2;
              this.halfWidth = Math.floor(this.width / 2);
              this.halfHeight = Math.floor(this.height / 2);
              this.offset.set(offsetX, offsetY);
              this.updateCenter();
              this.world.staticTree.insert(this);
            } else {
              this.isCircle = false;
            }
            return this;
          },
          updateCenter: function() {
            this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
          },
          reset: function(x2, y2) {
            var gameObject = this.gameObject;
            if (x2 === void 0) {
              x2 = gameObject.x;
            }
            if (y2 === void 0) {
              y2 = gameObject.y;
            }
            this.world.staticTree.remove(this);
            gameObject.setPosition(x2, y2);
            gameObject.getTopLeft(this.position);
            this.updateCenter();
            this.world.staticTree.insert(this);
          },
          stop: function() {
            return this;
          },
          getBounds: function(obj) {
            obj.x = this.x;
            obj.y = this.y;
            obj.right = this.right;
            obj.bottom = this.bottom;
            return obj;
          },
          hitTest: function(x2, y2) {
            return this.isCircle ? CircleContains(this, x2, y2) : RectangleContains(this, x2, y2);
          },
          postUpdate: function() {
          },
          deltaAbsX: function() {
            return 0;
          },
          deltaAbsY: function() {
            return 0;
          },
          deltaX: function() {
            return 0;
          },
          deltaY: function() {
            return 0;
          },
          deltaZ: function() {
            return 0;
          },
          destroy: function() {
            this.enable = false;
            this.world.pendingDestroy.set(this);
          },
          drawDebug: function(graphic) {
            var pos = this.position;
            var x2 = pos.x + this.halfWidth;
            var y2 = pos.y + this.halfHeight;
            if (this.debugShowBody) {
              graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor, 1);
              if (this.isCircle) {
                graphic.strokeCircle(x2, y2, this.width / 2);
              } else {
                graphic.strokeRect(pos.x, pos.y, this.width, this.height);
              }
            }
          },
          willDrawDebug: function() {
            return this.debugShowBody;
          },
          setMass: function(value) {
            if (value <= 0) {
              value = 0.1;
            }
            this.mass = value;
            return this;
          },
          x: {
            get: function() {
              return this.position.x;
            },
            set: function(value) {
              this.world.staticTree.remove(this);
              this.position.x = value;
              this.world.staticTree.insert(this);
            }
          },
          y: {
            get: function() {
              return this.position.y;
            },
            set: function(value) {
              this.world.staticTree.remove(this);
              this.position.y = value;
              this.world.staticTree.insert(this);
            }
          },
          left: {
            get: function() {
              return this.position.x;
            }
          },
          right: {
            get: function() {
              return this.position.x + this.width;
            }
          },
          top: {
            get: function() {
              return this.position.y;
            }
          },
          bottom: {
            get: function() {
              return this.position.y + this.height;
            }
          }
        });
        module2.exports = StaticBody;
      },
      function(module2, exports2, __webpack_require__) {
        /**
        * @author       Richard Davey <rich@photonstorm.com>
        * @copyright    2020 Photon Storm Ltd.
        * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}
        */
        var Class = __webpack_require__(0);
        var BasePlugin = new Class({
          initialize: function BasePlugin2(pluginManager) {
            this.pluginManager = pluginManager;
            this.game = pluginManager.game;
          },
          init: function() {
          },
          start: function() {
          },
          stop: function() {
          },
          destroy: function() {
            this.pluginManager = null;
            this.game = null;
            this.scene = null;
            this.systems = null;
          }
        });
        module2.exports = BasePlugin;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector2 = __webpack_require__(3);
        var point = new Vector2();
        var CheckIsoBounds = function(tileX, tileY, layer, camera) {
          var tilemapLayer = layer.tilemapLayer;
          var cullPaddingX = tilemapLayer.cullPaddingX;
          var cullPaddingY = tilemapLayer.cullPaddingY;
          var pos = tilemapLayer.tilemap.tileToWorldXY(tileX, tileY, point, camera, tilemapLayer);
          return pos.x > camera.worldView.x + tilemapLayer.scaleX * layer.tileWidth * (-cullPaddingX - 0.5) && pos.x < camera.worldView.right + tilemapLayer.scaleX * layer.tileWidth * (cullPaddingX - 0.5) && pos.y > camera.worldView.y + tilemapLayer.scaleY * layer.tileHeight * (-cullPaddingY - 1) && pos.y < camera.worldView.bottom + tilemapLayer.scaleY * layer.tileHeight * (cullPaddingY - 0.5);
        };
        module2.exports = CheckIsoBounds;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTilesWithin = __webpack_require__(26);
        var ReplaceByIndex = function(findIndex, newIndex, tileX, tileY, width, height, layer) {
          var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
          for (var i2 = 0; i2 < tiles.length; i2++) {
            if (tiles[i2] && tiles[i2].index === findIndex) {
              tiles[i2].index = newIndex;
            }
          }
        };
        module2.exports = ReplaceByIndex;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rectangle = __webpack_require__(10);
        var SnapCeil = __webpack_require__(139);
        var SnapFloor = __webpack_require__(76);
        var bounds = new Rectangle();
        var CullBounds = function(layer, camera) {
          var tilemap = layer.tilemapLayer.tilemap;
          var tilemapLayer = layer.tilemapLayer;
          var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
          var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
          var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
          var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
          var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH, 0, true) - tilemapLayer.cullPaddingY;
          var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH, 0, true) + tilemapLayer.cullPaddingY;
          return bounds.setTo(boundsLeft, boundsTop, boundsRight - boundsLeft, boundsBottom - boundsTop);
        };
        module2.exports = CullBounds;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CullBounds = __webpack_require__(543);
        var RunCull = __webpack_require__(159);
        var CullTiles = function(layer, camera, outputArray, renderOrder) {
          if (outputArray === void 0) {
            outputArray = [];
          }
          if (renderOrder === void 0) {
            renderOrder = 0;
          }
          outputArray.length = 0;
          var tilemapLayer = layer.tilemapLayer;
          var bounds = CullBounds(layer, camera);
          if (tilemapLayer.skipCull || tilemapLayer.scrollFactorX !== 1 || tilemapLayer.scrollFactorY !== 1) {
            bounds.left = 0;
            bounds.right = layer.width;
            bounds.top = 0;
            bounds.bottom = layer.height;
          }
          RunCull(layer, bounds, renderOrder, outputArray);
          return outputArray;
        };
        module2.exports = CullTiles;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CullBounds = __webpack_require__(546);
        var RunCull = __webpack_require__(159);
        var HexagonalCullTiles = function(layer, camera, outputArray, renderOrder) {
          if (outputArray === void 0) {
            outputArray = [];
          }
          if (renderOrder === void 0) {
            renderOrder = 0;
          }
          outputArray.length = 0;
          var tilemapLayer = layer.tilemapLayer;
          if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1) {
            var bounds = CullBounds(layer, camera);
            RunCull(layer, bounds, renderOrder, outputArray);
          }
          return outputArray;
        };
        module2.exports = HexagonalCullTiles;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SnapCeil = __webpack_require__(139);
        var SnapFloor = __webpack_require__(76);
        var HexagonalCullBounds = function(layer, camera) {
          var tilemap = layer.tilemapLayer.tilemap;
          var tilemapLayer = layer.tilemapLayer;
          var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
          var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
          var len = layer.hexSideLength;
          var rowH = (tileH - len) / 2 + len;
          var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
          var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
          var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, rowH, 0, true) - tilemapLayer.cullPaddingY;
          var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, rowH, 0, true) + tilemapLayer.cullPaddingY;
          return {
            left: boundsLeft,
            right: boundsRight,
            top: boundsTop,
            bottom: boundsBottom
          };
        };
        module2.exports = HexagonalCullBounds;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CheckIsoBounds = __webpack_require__(541);
        var IsometricCullTiles = function(layer, camera, outputArray, renderOrder) {
          if (outputArray === void 0) {
            outputArray = [];
          }
          if (renderOrder === void 0) {
            renderOrder = 0;
          }
          outputArray.length = 0;
          var tilemapLayer = layer.tilemapLayer;
          var mapData = layer.data;
          var mapWidth = layer.width;
          var mapHeight = layer.height;
          var drawLeft = 0;
          var drawRight = mapWidth;
          var drawTop = 0;
          var drawBottom = mapHeight;
          if (!tilemapLayer.skipCull) {
            var x2;
            var y2;
            var tile;
            if (renderOrder === 0) {
              for (y2 = drawTop; y2 < drawBottom; y2++) {
                for (x2 = drawLeft; mapData[y2] && x2 < drawRight; x2++) {
                  if (CheckIsoBounds(x2, y2, layer, camera)) {
                    tile = mapData[y2][x2];
                    if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                      continue;
                    }
                    outputArray.push(tile);
                  }
                }
              }
            } else if (renderOrder === 1) {
              for (y2 = drawTop; y2 < drawBottom; y2++) {
                for (x2 = drawRight; mapData[y2] && x2 >= drawLeft; x2--) {
                  if (CheckIsoBounds(x2, y2, layer, camera)) {
                    tile = mapData[y2][x2];
                    if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                      continue;
                    }
                    outputArray.push(tile);
                  }
                }
              }
            } else if (renderOrder === 2) {
              for (y2 = drawBottom; y2 >= drawTop; y2--) {
                for (x2 = drawLeft; mapData[y2] && x2 < drawRight; x2++) {
                  if (CheckIsoBounds(x2, y2, layer, camera)) {
                    tile = mapData[y2][x2];
                    if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                      continue;
                    }
                    outputArray.push(tile);
                  }
                }
              }
            } else if (renderOrder === 3) {
              for (y2 = drawBottom; y2 >= drawTop; y2--) {
                for (x2 = drawRight; mapData[y2] && x2 >= drawLeft; x2--) {
                  if (CheckIsoBounds(x2, y2, layer, camera)) {
                    tile = mapData[y2][x2];
                    if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                      continue;
                    }
                    outputArray.push(tile);
                  }
                }
              }
            }
          }
          tilemapLayer.tilesDrawn = outputArray.length;
          tilemapLayer.tilesTotal = mapWidth * mapHeight;
          return outputArray;
        };
        module2.exports = IsometricCullTiles;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CullBounds = __webpack_require__(549);
        var RunCull = __webpack_require__(159);
        var StaggeredCullTiles = function(layer, camera, outputArray, renderOrder) {
          if (outputArray === void 0) {
            outputArray = [];
          }
          if (renderOrder === void 0) {
            renderOrder = 0;
          }
          outputArray.length = 0;
          var tilemapLayer = layer.tilemapLayer;
          if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1) {
            var bounds = CullBounds(layer, camera);
            RunCull(layer, bounds, renderOrder, outputArray);
          }
          return outputArray;
        };
        module2.exports = StaggeredCullTiles;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SnapCeil = __webpack_require__(139);
        var SnapFloor = __webpack_require__(76);
        var StaggeredCullBounds = function(layer, camera) {
          var tilemap = layer.tilemapLayer.tilemap;
          var tilemapLayer = layer.tilemapLayer;
          var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
          var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
          var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
          var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
          var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH / 2, 0, true) - tilemapLayer.cullPaddingY;
          var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH / 2, 0, true) + tilemapLayer.cullPaddingY;
          return {
            left: boundsLeft,
            right: boundsRight,
            top: boundsTop,
            bottom: boundsBottom
          };
        };
        module2.exports = StaggeredCullBounds;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector2 = __webpack_require__(3);
        var HexagonalTileToWorldXY = function(tileX, tileY, point, camera, layer) {
          if (!point) {
            point = new Vector2();
          }
          var tileWidth = layer.baseTileWidth;
          var tileHeight = layer.baseTileHeight;
          var tilemapLayer = layer.tilemapLayer;
          var layerWorldX = 0;
          var layerWorldY = 0;
          if (tilemapLayer) {
            if (!camera) {
              camera = tilemapLayer.scene.cameras.main;
            }
            layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
            tileWidth *= tilemapLayer.scaleX;
            layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
            tileHeight *= tilemapLayer.scaleY;
          }
          var len = layer.hexSideLength;
          var rowHeight = (tileHeight - len) / 2 + len;
          var x2 = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);
          var y2 = layerWorldY + tileY * rowHeight;
          return point.set(x2, y2);
        };
        module2.exports = HexagonalTileToWorldXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector2 = __webpack_require__(3);
        var IsometricTileToWorldXY = function(tileX, tileY, point, camera, layer) {
          if (!point) {
            point = new Vector2();
          }
          var tileWidth = layer.baseTileWidth;
          var tileHeight = layer.baseTileHeight;
          var tilemapLayer = layer.tilemapLayer;
          var layerWorldX = 0;
          var layerWorldY = 0;
          if (tilemapLayer) {
            if (!camera) {
              camera = tilemapLayer.scene.cameras.main;
            }
            layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
            tileWidth *= tilemapLayer.scaleX;
            layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
            tileHeight *= tilemapLayer.scaleY;
          }
          var x2 = layerWorldX + (tileX - tileY) * (tileWidth / 2);
          var y2 = layerWorldY + (tileX + tileY) * (tileHeight / 2);
          return point.set(x2, y2);
        };
        module2.exports = IsometricTileToWorldXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector2 = __webpack_require__(3);
        var StaggeredTileToWorldXY = function(tileX, tileY, point, camera, layer) {
          if (!point) {
            point = new Vector2();
          }
          var tileWidth = layer.baseTileWidth;
          var tileHeight = layer.baseTileHeight;
          var tilemapLayer = layer.tilemapLayer;
          var layerWorldX = 0;
          var layerWorldY = 0;
          if (tilemapLayer) {
            if (!camera) {
              camera = tilemapLayer.scene.cameras.main;
            }
            layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
            tileWidth *= tilemapLayer.scaleX;
            layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
            tileHeight *= tilemapLayer.scaleY;
          }
          var x2 = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);
          var y2 = layerWorldY + tileY * (tileHeight / 2);
          return point.set(x2, y2);
        };
        module2.exports = StaggeredTileToWorldXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TileToWorldX = __webpack_require__(253);
        var TileToWorldY = __webpack_require__(254);
        var Vector2 = __webpack_require__(3);
        var TileToWorldXY = function(tileX, tileY, point, camera, layer) {
          if (!point) {
            point = new Vector2(0, 0);
          }
          point.x = TileToWorldX(tileX, camera, layer);
          point.y = TileToWorldY(tileY, camera, layer);
          return point;
        };
        module2.exports = TileToWorldXY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var HexagonalTileToWorldY = function(tileY, camera, layer) {
          var tileHeight = layer.baseTileHeight;
          var tilemapLayer = layer.tilemapLayer;
          var layerWorldY = 0;
          if (tilemapLayer) {
            if (camera === void 0) {
              camera = tilemapLayer.scene.cameras.main;
            }
            layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
            tileHeight *= tilemapLayer.scaleY;
          }
          var len = tilemapLayer.tilemap.hexSideLength;
          var rowHeight = (tileHeight - len) / 2 + len;
          return layerWorldY + tileY * rowHeight;
        };
        module2.exports = HexagonalTileToWorldY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var StaggeredTileToWorldY = function(tileY, camera, layer) {
          var tileHeight = layer.baseTileHeight;
          var tilemapLayer = layer.tilemapLayer;
          var layerWorldY = 0;
          if (tilemapLayer) {
            if (camera === void 0) {
              camera = tilemapLayer.scene.cameras.main;
            }
            layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
            tileHeight *= tilemapLayer.scaleY;
          }
          return layerWorldY + tileY * (tileHeight / 2);
        };
        module2.exports = StaggeredTileToWorldY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector2 = __webpack_require__(3);
        var HexagonalWorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
          if (!point) {
            point = new Vector2();
          }
          var tileWidth = layer.baseTileWidth;
          var tileHeight = layer.baseTileHeight;
          var tilemapLayer = layer.tilemapLayer;
          if (tilemapLayer) {
            if (!camera) {
              camera = tilemapLayer.scene.cameras.main;
            }
            worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
            tileHeight *= tilemapLayer.scaleY;
            worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
            tileWidth *= tilemapLayer.scaleX;
          }
          var len = layer.hexSideLength;
          var rowHeight = (tileHeight - len) / 2 + len;
          var y2 = snapToFloor ? Math.floor(worldY / rowHeight) : worldY / rowHeight;
          var x2 = snapToFloor ? Math.floor((worldX - y2 % 2 * 0.5 * tileWidth) / tileWidth) : (worldX - y2 % 2 * 0.5 * tileWidth) / tileWidth;
          return point.set(x2, y2);
        };
        module2.exports = HexagonalWorldToTileXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector2 = __webpack_require__(3);
        var IsometricWorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
          if (!point) {
            point = new Vector2();
          }
          var tileWidth = layer.baseTileWidth;
          var tileHeight = layer.baseTileHeight;
          var tilemapLayer = layer.tilemapLayer;
          if (tilemapLayer) {
            if (!camera) {
              camera = tilemapLayer.scene.cameras.main;
            }
            worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
            tileHeight *= tilemapLayer.scaleY;
            worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
            tileWidth *= tilemapLayer.scaleX;
          }
          var x2 = snapToFloor ? Math.floor((worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2) : (worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2;
          var y2 = snapToFloor ? Math.floor((worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2) : (worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2;
          return point.set(x2, y2);
        };
        module2.exports = IsometricWorldToTileXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector2 = __webpack_require__(3);
        var StaggeredWorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
          if (!point) {
            point = new Vector2();
          }
          var tileWidth = layer.baseTileWidth;
          var tileHeight = layer.baseTileHeight;
          var tilemapLayer = layer.tilemapLayer;
          if (tilemapLayer) {
            if (!camera) {
              camera = tilemapLayer.scene.cameras.main;
            }
            worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
            tileHeight *= tilemapLayer.scaleY;
            worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
            tileWidth *= tilemapLayer.scaleX;
          }
          var y2 = snapToFloor ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);
          var x2 = snapToFloor ? Math.floor((worldX + y2 % 2 * 0.5 * tileWidth) / tileWidth) : (worldX + y2 % 2 * 0.5 * tileWidth) / tileWidth;
          return point.set(x2, y2);
        };
        module2.exports = StaggeredWorldToTileXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var WorldToTileX = __webpack_require__(255);
        var WorldToTileY = __webpack_require__(256);
        var Vector2 = __webpack_require__(3);
        var WorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
          if (snapToFloor === void 0) {
            snapToFloor = true;
          }
          if (!point) {
            point = new Vector2(0, 0);
          }
          point.x = WorldToTileX(worldX, snapToFloor, camera, layer);
          point.y = WorldToTileY(worldY, snapToFloor, camera, layer);
          return point;
        };
        module2.exports = WorldToTileXY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var HexagonalWorldToTileY = function(worldY, snapToFloor, camera, layer) {
          var tileHeight = layer.baseTileHeight;
          var tilemapLayer = layer.tilemapLayer;
          if (tilemapLayer) {
            if (!camera) {
              camera = tilemapLayer.scene.cameras.main;
            }
            worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
            tileHeight *= tilemapLayer.scaleY;
          }
          var len = layer.hexSideLength;
          var rowHeight = (tileHeight - len) / 2 + len;
          return snapToFloor ? Math.floor(worldY / rowHeight) : worldY / rowHeight;
        };
        module2.exports = HexagonalWorldToTileY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var StaggeredWorldToTileY = function(worldY, snapToFloor, camera, layer) {
          var tileHeight = layer.baseTileHeight;
          var tilemapLayer = layer.tilemapLayer;
          if (tilemapLayer) {
            if (!camera) {
              camera = tilemapLayer.scene.cameras.main;
            }
            worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
            tileHeight *= tilemapLayer.scaleY;
          }
          return snapToFloor ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);
        };
        module2.exports = StaggeredWorldToTileY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var IsInLayerBounds = __webpack_require__(119);
        var HasTileAt = function(tileX, tileY, layer) {
          if (IsInLayerBounds(tileX, tileY, layer)) {
            var tile = layer.data[tileY][tileX];
            return tile !== null && tile.index > -1;
          } else {
            return false;
          }
        };
        module2.exports = HasTileAt;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Tile = __webpack_require__(85);
        var IsInLayerBounds = __webpack_require__(119);
        var CalculateFacesAt = __webpack_require__(252);
        var RemoveTileAt = function(tileX, tileY, replaceWithNull, recalculateFaces, layer) {
          if (replaceWithNull === void 0) {
            replaceWithNull = true;
          }
          if (recalculateFaces === void 0) {
            recalculateFaces = true;
          }
          if (!IsInLayerBounds(tileX, tileY, layer)) {
            return null;
          }
          var tile = layer.data[tileY][tileX];
          if (!tile) {
            return null;
          } else {
            layer.data[tileY][tileX] = replaceWithNull ? null : new Tile(layer, -1, tileX, tileY, layer.tileWidth, layer.tileHeight);
          }
          if (recalculateFaces && tile && tile.collides) {
            CalculateFacesAt(tileX, tileY, layer);
          }
          return tile;
        };
        module2.exports = RemoveTileAt;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Formats = __webpack_require__(40);
        var Parse2DArray = __webpack_require__(259);
        var ParseCSV = __webpack_require__(565);
        var ParseJSONTiled = __webpack_require__(566);
        var ParseWeltmeister = __webpack_require__(577);
        var Parse = function(name, mapFormat, data, tileWidth, tileHeight, insertNull) {
          var newMap;
          switch (mapFormat) {
            case Formats.ARRAY_2D:
              newMap = Parse2DArray(name, data, tileWidth, tileHeight, insertNull);
              break;
            case Formats.CSV:
              newMap = ParseCSV(name, data, tileWidth, tileHeight, insertNull);
              break;
            case Formats.TILED_JSON:
              newMap = ParseJSONTiled(name, data, insertNull);
              break;
            case Formats.WELTMEISTER:
              newMap = ParseWeltmeister(name, data, insertNull);
              break;
            default:
              console.warn("Unrecognized tilemap data format: " + mapFormat);
              newMap = null;
          }
          return newMap;
        };
        module2.exports = Parse;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Formats = __webpack_require__(40);
        var Parse2DArray = __webpack_require__(259);
        var ParseCSV = function(name, data, tileWidth, tileHeight, insertNull) {
          var array2D = data.trim().split("\n").map(function(row) {
            return row.split(",");
          });
          var map = Parse2DArray(name, array2D, tileWidth, tileHeight, insertNull);
          map.format = Formats.CSV;
          return map;
        };
        module2.exports = ParseCSV;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AssignTileProperties = __webpack_require__(567);
        var BuildTilesetIndex = __webpack_require__(568);
        var CONST = __webpack_require__(29);
        var Formats = __webpack_require__(40);
        var FromOrientationString = __webpack_require__(258);
        var MapData = __webpack_require__(121);
        var ParseImageLayers = __webpack_require__(569);
        var ParseObjectLayers = __webpack_require__(570);
        var ParseTileLayers = __webpack_require__(573);
        var ParseTilesets = __webpack_require__(575);
        var ParseJSONTiled = function(name, json, insertNull) {
          var mapData = new MapData({
            width: json.width,
            height: json.height,
            name,
            tileWidth: json.tilewidth,
            tileHeight: json.tileheight,
            orientation: FromOrientationString(json.orientation),
            format: Formats.TILED_JSON,
            version: json.version,
            properties: json.properties,
            renderOrder: json.renderorder,
            infinite: json.infinite
          });
          if (mapData.orientation === CONST.HEXAGONAL) {
            mapData.hexSideLength = json.hexsidelength;
          }
          mapData.layers = ParseTileLayers(json, insertNull);
          mapData.images = ParseImageLayers(json);
          var sets = ParseTilesets(json);
          mapData.tilesets = sets.tilesets;
          mapData.imageCollections = sets.imageCollections;
          mapData.objects = ParseObjectLayers(json);
          mapData.tiles = BuildTilesetIndex(mapData);
          AssignTileProperties(mapData);
          return mapData;
        };
        module2.exports = ParseJSONTiled;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Extend = __webpack_require__(17);
        var AssignTileProperties = function(mapData) {
          var layerData;
          var tile;
          var sid;
          var set;
          var row;
          for (var i2 = 0; i2 < mapData.layers.length; i2++) {
            layerData = mapData.layers[i2];
            set = null;
            for (var j = 0; j < layerData.data.length; j++) {
              row = layerData.data[j];
              for (var k2 = 0; k2 < row.length; k2++) {
                tile = row[k2];
                if (tile === null || tile.index < 0) {
                  continue;
                }
                sid = mapData.tiles[tile.index][2];
                set = mapData.tilesets[sid];
                tile.width = set.tileWidth;
                tile.height = set.tileHeight;
                if (set.tileProperties && set.tileProperties[tile.index - set.firstgid]) {
                  tile.properties = Extend(tile.properties, set.tileProperties[tile.index - set.firstgid]);
                }
              }
            }
          }
        };
        module2.exports = AssignTileProperties;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Tileset = __webpack_require__(122);
        var BuildTilesetIndex = function(mapData) {
          var i2;
          var set;
          var tiles = [];
          for (i2 = 0; i2 < mapData.imageCollections.length; i2++) {
            var collection = mapData.imageCollections[i2];
            var images = collection.images;
            for (var j = 0; j < images.length; j++) {
              var image = images[j];
              set = new Tileset(image.image, image.gid, collection.imageWidth, collection.imageHeight, 0, 0);
              set.updateTileData(collection.imageWidth, collection.imageHeight);
              mapData.tilesets.push(set);
            }
          }
          for (i2 = 0; i2 < mapData.tilesets.length; i2++) {
            set = mapData.tilesets[i2];
            var x2 = set.tileMargin;
            var y2 = set.tileMargin;
            var count = 0;
            var countX = 0;
            var countY = 0;
            for (var t2 = set.firstgid; t2 < set.firstgid + set.total; t2++) {
              tiles[t2] = [x2, y2, i2];
              x2 += set.tileWidth + set.tileSpacing;
              count++;
              if (count === set.total) {
                break;
              }
              countX++;
              if (countX === set.columns) {
                x2 = set.tileMargin;
                y2 += set.tileHeight + set.tileSpacing;
                countX = 0;
                countY++;
                if (countY === set.rows) {
                  break;
                }
              }
            }
          }
          return tiles;
        };
        module2.exports = BuildTilesetIndex;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetFastValue = __webpack_require__(2);
        var CreateGroupLayer = __webpack_require__(161);
        var ParseImageLayers = function(json) {
          var images = [];
          var groupStack = [];
          var curGroupState = CreateGroupLayer(json);
          while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
            if (curGroupState.i >= curGroupState.layers.length) {
              if (groupStack.length < 1) {
                console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                break;
              }
              curGroupState = groupStack.pop();
              continue;
            }
            var curi = curGroupState.layers[curGroupState.i];
            curGroupState.i++;
            if (curi.type !== "imagelayer") {
              if (curi.type === "group") {
                var nextGroupState = CreateGroupLayer(json, curi, curGroupState);
                groupStack.push(curGroupState);
                curGroupState = nextGroupState;
              }
              continue;
            }
            var layerOffsetX = GetFastValue(curi, "offsetx", 0) + GetFastValue(curi, "startx", 0);
            var layerOffsetY = GetFastValue(curi, "offsety", 0) + GetFastValue(curi, "starty", 0);
            images.push({
              name: curGroupState.name + curi.name,
              image: curi.image,
              x: curGroupState.x + layerOffsetX + curi.x,
              y: curGroupState.y + layerOffsetY + curi.y,
              alpha: curGroupState.opacity * curi.opacity,
              visible: curGroupState.visible && curi.visible,
              properties: GetFastValue(curi, "properties", {})
            });
          }
          return images;
        };
        module2.exports = ParseImageLayers;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetFastValue = __webpack_require__(2);
        var ParseObject = __webpack_require__(260);
        var ObjectLayer = __webpack_require__(572);
        var CreateGroupLayer = __webpack_require__(161);
        var ParseObjectLayers = function(json) {
          var objectLayers = [];
          var groupStack = [];
          var curGroupState = CreateGroupLayer(json);
          while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
            if (curGroupState.i >= curGroupState.layers.length) {
              if (groupStack.length < 1) {
                console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                break;
              }
              curGroupState = groupStack.pop();
              continue;
            }
            var curo = curGroupState.layers[curGroupState.i];
            curGroupState.i++;
            curo.opacity *= curGroupState.opacity;
            curo.visible = curGroupState.visible && curo.visible;
            if (curo.type !== "objectgroup") {
              if (curo.type === "group") {
                var nextGroupState = CreateGroupLayer(json, curo, curGroupState);
                groupStack.push(curGroupState);
                curGroupState = nextGroupState;
              }
              continue;
            }
            curo.name = curGroupState.name + curo.name;
            var offsetX = curGroupState.x + GetFastValue(curo, "startx", 0) + GetFastValue(curo, "offsetx", 0);
            var offsetY = curGroupState.y + GetFastValue(curo, "starty", 0) + GetFastValue(curo, "offsety", 0);
            var objects = [];
            for (var j = 0; j < curo.objects.length; j++) {
              var parsedObject = ParseObject(curo.objects[j], offsetX, offsetY);
              objects.push(parsedObject);
            }
            var objectLayer = new ObjectLayer(curo);
            objectLayer.objects = objects;
            objectLayers.push(objectLayer);
          }
          return objectLayers;
        };
        module2.exports = ParseObjectLayers;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var HasValue = __webpack_require__(126);
        var Pick = function(object, keys) {
          var obj = {};
          for (var i2 = 0; i2 < keys.length; i2++) {
            var key = keys[i2];
            if (HasValue(object, key)) {
              obj[key] = object[key];
            }
          }
          return obj;
        };
        module2.exports = Pick;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetFastValue = __webpack_require__(2);
        var ObjectLayer = new Class({
          initialize: function ObjectLayer2(config) {
            if (config === void 0) {
              config = {};
            }
            this.name = GetFastValue(config, "name", "object layer");
            this.opacity = GetFastValue(config, "opacity", 1);
            this.properties = GetFastValue(config, "properties", {});
            this.propertyTypes = GetFastValue(config, "propertytypes", {});
            this.type = GetFastValue(config, "type", "objectgroup");
            this.visible = GetFastValue(config, "visible", true);
            this.objects = GetFastValue(config, "objects", []);
          }
        });
        module2.exports = ObjectLayer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Base64Decode = __webpack_require__(574);
        var CONST = __webpack_require__(29);
        var CreateGroupLayer = __webpack_require__(161);
        var FromOrientationString = __webpack_require__(258);
        var GetFastValue = __webpack_require__(2);
        var LayerData = __webpack_require__(120);
        var ParseGID = __webpack_require__(261);
        var Tile = __webpack_require__(85);
        var ParseTileLayers = function(json, insertNull) {
          var infiniteMap = GetFastValue(json, "infinite", false);
          var tileLayers = [];
          var groupStack = [];
          var curGroupState = CreateGroupLayer(json);
          while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
            if (curGroupState.i >= curGroupState.layers.length) {
              if (groupStack.length < 1) {
                console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                break;
              }
              curGroupState = groupStack.pop();
              continue;
            }
            var curl = curGroupState.layers[curGroupState.i];
            curGroupState.i++;
            if (curl.type !== "tilelayer") {
              if (curl.type === "group") {
                var nextGroupState = CreateGroupLayer(json, curl, curGroupState);
                groupStack.push(curGroupState);
                curGroupState = nextGroupState;
              }
              continue;
            }
            if (curl.compression) {
              console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + curl.name + "'");
              continue;
            } else if (curl.encoding && curl.encoding === "base64") {
              if (curl.chunks) {
                for (var i2 = 0; i2 < curl.chunks.length; i2++) {
                  curl.chunks[i2].data = Base64Decode(curl.chunks[i2].data);
                }
              }
              if (curl.data) {
                curl.data = Base64Decode(curl.data);
              }
              delete curl.encoding;
            }
            var layerData;
            var gidInfo;
            var tile;
            var blankTile;
            var output = [];
            var x2 = 0;
            if (infiniteMap) {
              var layerOffsetX = GetFastValue(curl, "startx", 0) + curl.x;
              var layerOffsetY = GetFastValue(curl, "starty", 0) + curl.y;
              layerData = new LayerData({
                name: curGroupState.name + curl.name,
                x: curGroupState.x + GetFastValue(curl, "offsetx", 0) + layerOffsetX * json.tilewidth,
                y: curGroupState.y + GetFastValue(curl, "offsety", 0) + layerOffsetY * json.tileheight,
                width: curl.width,
                height: curl.height,
                tileWidth: json.tilewidth,
                tileHeight: json.tileheight,
                alpha: curGroupState.opacity * curl.opacity,
                visible: curGroupState.visible && curl.visible,
                properties: GetFastValue(curl, "properties", []),
                orientation: FromOrientationString(json.orientation)
              });
              if (layerData.orientation === CONST.HEXAGONAL) {
                layerData.hexSideLength = json.hexsidelength;
              }
              for (var c = 0; c < curl.height; c++) {
                output.push([null]);
                for (var j = 0; j < curl.width; j++) {
                  output[c][j] = null;
                }
              }
              for (c = 0, len = curl.chunks.length; c < len; c++) {
                var chunk = curl.chunks[c];
                var offsetX = chunk.x - layerOffsetX;
                var offsetY = chunk.y - layerOffsetY;
                var y2 = 0;
                for (var t2 = 0, len2 = chunk.data.length; t2 < len2; t2++) {
                  var newOffsetX = x2 + offsetX;
                  var newOffsetY = y2 + offsetY;
                  gidInfo = ParseGID(chunk.data[t2]);
                  if (gidInfo.gid > 0) {
                    tile = new Tile(layerData, gidInfo.gid, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);
                    tile.rotation = gidInfo.rotation;
                    tile.flipX = gidInfo.flipped;
                    output[newOffsetY][newOffsetX] = tile;
                  } else {
                    blankTile = insertNull ? null : new Tile(layerData, -1, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);
                    output[newOffsetY][newOffsetX] = blankTile;
                  }
                  x2++;
                  if (x2 === chunk.width) {
                    y2++;
                    x2 = 0;
                  }
                }
              }
            } else {
              layerData = new LayerData({
                name: curGroupState.name + curl.name,
                x: curGroupState.x + GetFastValue(curl, "offsetx", 0) + curl.x,
                y: curGroupState.y + GetFastValue(curl, "offsety", 0) + curl.y,
                width: curl.width,
                height: curl.height,
                tileWidth: json.tilewidth,
                tileHeight: json.tileheight,
                alpha: curGroupState.opacity * curl.opacity,
                visible: curGroupState.visible && curl.visible,
                properties: GetFastValue(curl, "properties", []),
                orientation: FromOrientationString(json.orientation)
              });
              if (layerData.orientation === CONST.HEXAGONAL) {
                layerData.hexSideLength = json.hexsidelength;
              }
              var row = [];
              for (var k2 = 0, len = curl.data.length; k2 < len; k2++) {
                gidInfo = ParseGID(curl.data[k2]);
                if (gidInfo.gid > 0) {
                  tile = new Tile(layerData, gidInfo.gid, x2, output.length, json.tilewidth, json.tileheight);
                  tile.rotation = gidInfo.rotation;
                  tile.flipX = gidInfo.flipped;
                  row.push(tile);
                } else {
                  blankTile = insertNull ? null : new Tile(layerData, -1, x2, output.length, json.tilewidth, json.tileheight);
                  row.push(blankTile);
                }
                x2++;
                if (x2 === curl.width) {
                  output.push(row);
                  x2 = 0;
                  row = [];
                }
              }
            }
            layerData.data = output;
            tileLayers.push(layerData);
          }
          return tileLayers;
        };
        module2.exports = ParseTileLayers;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Base64Decode = function(data) {
          var binaryString = window.atob(data);
          var len = binaryString.length;
          var bytes = new Array(len / 4);
          for (var i2 = 0; i2 < len; i2 += 4) {
            bytes[i2 / 4] = (binaryString.charCodeAt(i2) | binaryString.charCodeAt(i2 + 1) << 8 | binaryString.charCodeAt(i2 + 2) << 16 | binaryString.charCodeAt(i2 + 3) << 24) >>> 0;
          }
          return bytes;
        };
        module2.exports = Base64Decode;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Tileset = __webpack_require__(122);
        var ImageCollection = __webpack_require__(576);
        var ParseObject = __webpack_require__(260);
        var ParseWangsets = __webpack_require__(1453);
        var ParseTilesets = function(json) {
          var tilesets = [];
          var imageCollections = [];
          var lastSet = null;
          var stringID;
          for (var i2 = 0; i2 < json.tilesets.length; i2++) {
            var set = json.tilesets[i2];
            if (set.source) {
              console.warn("External tilesets unsupported. Use Embed Tileset and re-export");
            } else if (set.image) {
              var newSet = new Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing);
              if (json.version > 1) {
                var datas = void 0;
                var props = void 0;
                if (Array.isArray(set.tiles)) {
                  datas = datas || {};
                  props = props || {};
                  for (var t2 = 0; t2 < set.tiles.length; t2++) {
                    var tile = set.tiles[t2];
                    if (tile.properties) {
                      var newPropData = {};
                      tile.properties.forEach(function(propData) {
                        newPropData[propData["name"]] = propData["value"];
                      });
                      props[tile.id] = newPropData;
                    }
                    if (tile.objectgroup) {
                      (datas[tile.id] || (datas[tile.id] = {})).objectgroup = tile.objectgroup;
                      if (tile.objectgroup.objects) {
                        var parsedObjects2 = tile.objectgroup.objects.map(function(obj) {
                          return ParseObject(obj);
                        });
                        datas[tile.id].objectgroup.objects = parsedObjects2;
                      }
                    }
                    if (tile.animation) {
                      (datas[tile.id] || (datas[tile.id] = {})).animation = tile.animation;
                    }
                    if (tile.type) {
                      (datas[tile.id] || (datas[tile.id] = {})).type = tile.type;
                    }
                  }
                }
                if (Array.isArray(set.wangsets)) {
                  datas = datas || {};
                  props = props || {};
                  ParseWangsets(set.wangsets, datas);
                }
                if (datas) {
                  newSet.tileData = datas;
                  newSet.tileProperties = props;
                }
              } else {
                if (set.tileproperties) {
                  newSet.tileProperties = set.tileproperties;
                }
                if (set.tiles) {
                  newSet.tileData = set.tiles;
                  for (stringID in newSet.tileData) {
                    var objectGroup = newSet.tileData[stringID].objectgroup;
                    if (objectGroup && objectGroup.objects) {
                      var parsedObjects1 = objectGroup.objects.map(function(obj) {
                        return ParseObject(obj);
                      });
                      newSet.tileData[stringID].objectgroup.objects = parsedObjects1;
                    }
                  }
                }
              }
              newSet.updateTileData(set.imagewidth, set.imageheight);
              tilesets.push(newSet);
            } else {
              var newCollection = new ImageCollection(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);
              var maxId = 0;
              for (t2 = 0; t2 < set.tiles.length; t2++) {
                tile = set.tiles[t2];
                var image = tile.image;
                var tileId = parseInt(tile.id, 10);
                var gid = set.firstgid + tileId;
                newCollection.addImage(gid, image);
                maxId = Math.max(tileId, maxId);
              }
              newCollection.maxId = maxId;
              imageCollections.push(newCollection);
            }
            if (lastSet) {
              lastSet.lastgid = set.firstgid - 1;
            }
            lastSet = set;
          }
          return { tilesets, imageCollections };
        };
        module2.exports = ParseTilesets;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var ImageCollection = new Class({
          initialize: function ImageCollection2(name, firstgid, width, height, margin, spacing, properties) {
            if (width === void 0 || width <= 0) {
              width = 32;
            }
            if (height === void 0 || height <= 0) {
              height = 32;
            }
            if (margin === void 0) {
              margin = 0;
            }
            if (spacing === void 0) {
              spacing = 0;
            }
            this.name = name;
            this.firstgid = firstgid | 0;
            this.imageWidth = width | 0;
            this.imageHeight = height | 0;
            this.imageMargin = margin | 0;
            this.imageSpacing = spacing | 0;
            this.properties = properties || {};
            this.images = [];
            this.total = 0;
          },
          containsImageIndex: function(imageIndex) {
            return imageIndex >= this.firstgid && imageIndex < this.firstgid + this.total;
          },
          addImage: function(gid, image) {
            this.images.push({ gid, image });
            this.total++;
            return this;
          }
        });
        module2.exports = ImageCollection;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Formats = __webpack_require__(40);
        var MapData = __webpack_require__(121);
        var ParseTileLayers = __webpack_require__(578);
        var ParseTilesets = __webpack_require__(579);
        var ParseWeltmeister = function(name, json, insertNull) {
          if (json.layer.length === 0) {
            console.warn("No layers found in the Weltmeister map: " + name);
            return null;
          }
          var width = 0;
          var height = 0;
          for (var i2 = 0; i2 < json.layer.length; i2++) {
            if (json.layer[i2].width > width) {
              width = json.layer[i2].width;
            }
            if (json.layer[i2].height > height) {
              height = json.layer[i2].height;
            }
          }
          var mapData = new MapData({
            width,
            height,
            name,
            tileWidth: json.layer[0].tilesize,
            tileHeight: json.layer[0].tilesize,
            format: Formats.WELTMEISTER
          });
          mapData.layers = ParseTileLayers(json, insertNull);
          mapData.tilesets = ParseTilesets(json);
          return mapData;
        };
        module2.exports = ParseWeltmeister;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var LayerData = __webpack_require__(120);
        var Tile = __webpack_require__(85);
        var ParseTileLayers = function(json, insertNull) {
          var tileLayers = [];
          for (var i2 = 0; i2 < json.layer.length; i2++) {
            var layer = json.layer[i2];
            var layerData = new LayerData({
              name: layer.name,
              width: layer.width,
              height: layer.height,
              tileWidth: layer.tilesize,
              tileHeight: layer.tilesize,
              visible: layer.visible === 1
            });
            var row = [];
            var tileGrid = [];
            for (var y2 = 0; y2 < layer.data.length; y2++) {
              for (var x2 = 0; x2 < layer.data[y2].length; x2++) {
                var index2 = layer.data[y2][x2] - 1;
                var tile;
                if (index2 > -1) {
                  tile = new Tile(layerData, index2, x2, y2, layer.tilesize, layer.tilesize);
                } else {
                  tile = insertNull ? null : new Tile(layerData, -1, x2, y2, layer.tilesize, layer.tilesize);
                }
                row.push(tile);
              }
              tileGrid.push(row);
              row = [];
            }
            layerData.data = tileGrid;
            tileLayers.push(layerData);
          }
          return tileLayers;
        };
        module2.exports = ParseTileLayers;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Tileset = __webpack_require__(122);
        var ParseTilesets = function(json) {
          var tilesets = [];
          var tilesetsNames = [];
          for (var i2 = 0; i2 < json.layer.length; i2++) {
            var layer = json.layer[i2];
            var tilesetName = layer.tilesetName;
            if (tilesetName !== "" && tilesetsNames.indexOf(tilesetName) === -1) {
              tilesetsNames.push(tilesetName);
              tilesets.push(new Tileset(tilesetName, 0, layer.tilesize, layer.tilesize, 0, 0));
            }
          }
          return tilesets;
        };
        module2.exports = ParseTilesets;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var DegToRad = __webpack_require__(36);
        var Formats = __webpack_require__(40);
        var GetFastValue = __webpack_require__(2);
        var LayerData = __webpack_require__(120);
        var ORIENTATION = __webpack_require__(29);
        var Rotate = __webpack_require__(362);
        var SpliceOne = __webpack_require__(74);
        var Sprite = __webpack_require__(73);
        var Tile = __webpack_require__(85);
        var TilemapComponents = __webpack_require__(251);
        var TilemapLayer = __webpack_require__(581);
        var Tileset = __webpack_require__(122);
        var Tilemap = new Class({
          initialize: function Tilemap2(scene, mapData) {
            this.scene = scene;
            this.tileWidth = mapData.tileWidth;
            this.tileHeight = mapData.tileHeight;
            this.width = mapData.width;
            this.height = mapData.height;
            this.orientation = mapData.orientation;
            this.renderOrder = mapData.renderOrder;
            this.format = mapData.format;
            this.version = mapData.version;
            this.properties = mapData.properties;
            this.widthInPixels = mapData.widthInPixels;
            this.heightInPixels = mapData.heightInPixels;
            this.imageCollections = mapData.imageCollections;
            this.images = mapData.images;
            this.layers = mapData.layers;
            this.tilesets = mapData.tilesets;
            this.objects = mapData.objects;
            this.currentLayerIndex = 0;
            this.hexSideLength = mapData.hexSideLength;
            var orientation = this.orientation;
            this._convert = {
              WorldToTileXY: TilemapComponents.GetWorldToTileXYFunction(orientation),
              WorldToTileX: TilemapComponents.GetWorldToTileXFunction(orientation),
              WorldToTileY: TilemapComponents.GetWorldToTileYFunction(orientation),
              TileToWorldXY: TilemapComponents.GetTileToWorldXYFunction(orientation),
              TileToWorldX: TilemapComponents.GetTileToWorldXFunction(orientation),
              TileToWorldY: TilemapComponents.GetTileToWorldYFunction(orientation)
            };
          },
          createBlankDynamicLayer: function(name, tileset, x2, y2, width, height, tileWidth, tileHeight) {
            console.warn("createBlankDynamicLayer is deprecated. Use createBlankLayer");
            return this.createBlankLayer(name, tileset, x2, y2, width, height, tileWidth, tileHeight);
          },
          createDynamicLayer: function(layerID, tileset, x2, y2) {
            console.warn("createDynamicLayer is deprecated. Use createLayer");
            return this.createLayer(layerID, tileset, x2, y2);
          },
          createStaticLayer: function(layerID, tileset, x2, y2) {
            console.warn("createStaticLayer is deprecated. Use createLayer");
            return this.createLayer(layerID, tileset, x2, y2);
          },
          setRenderOrder: function(renderOrder) {
            var orders = ["right-down", "left-down", "right-up", "left-up"];
            if (typeof renderOrder === "number") {
              renderOrder = orders[renderOrder];
            }
            if (orders.indexOf(renderOrder) > -1) {
              this.renderOrder = renderOrder;
            }
            return this;
          },
          addTilesetImage: function(tilesetName, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid) {
            if (tilesetName === void 0) {
              return null;
            }
            if (key === void 0 || key === null) {
              key = tilesetName;
            }
            if (!this.scene.sys.textures.exists(key)) {
              console.warn("Invalid Tileset Image: " + key);
              return null;
            }
            var texture = this.scene.sys.textures.get(key);
            var index2 = this.getTilesetIndex(tilesetName);
            if (index2 === null && this.format === Formats.TILED_JSON) {
              console.warn("No data found for Tileset: " + tilesetName);
              return null;
            }
            var tileset = this.tilesets[index2];
            if (tileset) {
              tileset.setTileSize(tileWidth, tileHeight);
              tileset.setSpacing(tileMargin, tileSpacing);
              tileset.setImage(texture);
              return tileset;
            }
            if (tileWidth === void 0) {
              tileWidth = this.tileWidth;
            }
            if (tileHeight === void 0) {
              tileHeight = this.tileHeight;
            }
            if (tileMargin === void 0) {
              tileMargin = 0;
            }
            if (tileSpacing === void 0) {
              tileSpacing = 0;
            }
            if (gid === void 0) {
              gid = 0;
            }
            tileset = new Tileset(tilesetName, gid, tileWidth, tileHeight, tileMargin, tileSpacing);
            tileset.setImage(texture);
            this.tilesets.push(tileset);
            return tileset;
          },
          copy: function(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer) {
            layer = this.getLayer(layer);
            if (layer !== null) {
              TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer);
              return this;
            } else {
              return null;
            }
          },
          createBlankLayer: function(name, tileset, x2, y2, width, height, tileWidth, tileHeight) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = this.width;
            }
            if (height === void 0) {
              height = this.height;
            }
            if (tileWidth === void 0) {
              tileWidth = this.tileWidth;
            }
            if (tileHeight === void 0) {
              tileHeight = this.tileHeight;
            }
            var index2 = this.getLayerIndex(name);
            if (index2 !== null) {
              console.warn("Invalid Tilemap Layer ID: " + name);
              return null;
            }
            var layerData = new LayerData({
              name,
              tileWidth,
              tileHeight,
              width,
              height,
              orientation: this.orientation
            });
            var row;
            for (var tileY = 0; tileY < height; tileY++) {
              row = [];
              for (var tileX = 0; tileX < width; tileX++) {
                row.push(new Tile(layerData, -1, tileX, tileY, tileWidth, tileHeight, this.tileWidth, this.tileHeight));
              }
              layerData.data.push(row);
            }
            this.layers.push(layerData);
            this.currentLayerIndex = this.layers.length - 1;
            var layer = new TilemapLayer(this.scene, this, this.currentLayerIndex, tileset, x2, y2);
            layer.setRenderOrder(this.renderOrder);
            this.scene.sys.displayList.add(layer);
            return layer;
          },
          createLayer: function(layerID, tileset, x2, y2) {
            var index2 = this.getLayerIndex(layerID);
            if (index2 === null) {
              console.warn("Invalid Tilemap Layer ID: " + layerID);
              if (typeof layerID === "string") {
                console.warn("Valid tilelayer names:\n	" + this.getTileLayerNames().join(",\n	"));
              }
              return null;
            }
            var layerData = this.layers[index2];
            if (layerData.tilemapLayer) {
              console.warn("Tilemap Layer ID already exists:" + layerID);
              return null;
            }
            this.currentLayerIndex = index2;
            if (x2 === void 0) {
              x2 = layerData.x;
            }
            if (y2 === void 0) {
              y2 = layerData.y;
            }
            var layer = new TilemapLayer(this.scene, this, index2, tileset, x2, y2);
            layer.setRenderOrder(this.renderOrder);
            this.scene.sys.displayList.add(layer);
            return layer;
          },
          createFromObjects: function(objectLayerName, config) {
            var results = [];
            var objectLayer = this.getObjectLayer(objectLayerName);
            if (!objectLayer) {
              console.warn("createFromObjects: Invalid objectLayerName given: " + objectLayerName);
              return results;
            }
            if (!Array.isArray(config)) {
              config = [config];
            }
            var objects = objectLayer.objects;
            for (var c = 0; c < config.length; c++) {
              var singleConfig = config[c];
              var id2 = GetFastValue(singleConfig, "id", null);
              var gid = GetFastValue(singleConfig, "gid", null);
              var name = GetFastValue(singleConfig, "name", null);
              var obj;
              var toConvert = [];
              for (var s = 0; s < objects.length; s++) {
                obj = objects[s];
                if (id2 === null && gid === null && name === null || id2 !== null && obj.id === id2 || gid !== null && obj.gid === gid || name !== null && obj.name === name) {
                  toConvert.push(obj);
                }
              }
              var classType = GetFastValue(singleConfig, "classType", Sprite);
              var scene = GetFastValue(singleConfig, "scene", this.scene);
              var container = GetFastValue(singleConfig, "container", null);
              var texture = GetFastValue(singleConfig, "key", null);
              var frame = GetFastValue(singleConfig, "frame", null);
              for (var i2 = 0; i2 < toConvert.length; i2++) {
                obj = toConvert[i2];
                var sprite = new classType(scene);
                sprite.setName(obj.name);
                sprite.setPosition(obj.x, obj.y);
                sprite.setTexture(texture, frame);
                if (obj.width) {
                  sprite.displayWidth = obj.width;
                }
                if (obj.height) {
                  sprite.displayHeight = obj.height;
                }
                var offset = {
                  x: sprite.originX * obj.width,
                  y: (sprite.originY - 1) * obj.height
                };
                if (obj.rotation) {
                  var angle = DegToRad(obj.rotation);
                  Rotate(offset, angle);
                  sprite.rotation = angle;
                }
                sprite.x += offset.x;
                sprite.y += offset.y;
                if (obj.flippedHorizontal !== void 0 || obj.flippedVertical !== void 0) {
                  sprite.setFlip(obj.flippedHorizontal, obj.flippedVertical);
                }
                if (!obj.visible) {
                  sprite.visible = false;
                }
                if (Array.isArray(obj.properties)) {
                  obj.properties.forEach(function(propData) {
                    var key2 = propData["name"];
                    if (sprite[key2] !== void 0) {
                      sprite[key2] = propData["value"];
                    } else {
                      sprite.setData(key2, propData["value"]);
                    }
                  });
                } else {
                  for (var key in obj.properties) {
                    if (sprite[key] !== void 0) {
                      sprite[key] = obj.properties[key];
                    } else {
                      sprite.setData(key, obj.properties[key]);
                    }
                  }
                }
                if (container) {
                  container.add(sprite);
                } else {
                  scene.add.existing(sprite);
                }
                results.push(sprite);
              }
            }
            return results;
          },
          createFromTiles: function(indexes, replacements, spriteConfig, scene, camera, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, layer);
          },
          fill: function(index2, tileX, tileY, width, height, recalculateFaces, layer) {
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.Fill(index2, tileX, tileY, width, height, recalculateFaces, layer);
            return this;
          },
          filterObjects: function(objectLayer, callback, context) {
            if (typeof objectLayer === "string") {
              var name = objectLayer;
              objectLayer = this.getObjectLayer(objectLayer);
              if (!objectLayer) {
                console.warn("No object layer found with the name: " + name);
                return null;
              }
            }
            return objectLayer.objects.filter(callback, context);
          },
          filterTiles: function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, layer);
          },
          findByIndex: function(findIndex, skip, reverse, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.FindByIndex(findIndex, skip, reverse, layer);
          },
          findObject: function(objectLayer, callback, context) {
            if (typeof objectLayer === "string") {
              var name = objectLayer;
              objectLayer = this.getObjectLayer(objectLayer);
              if (!objectLayer) {
                console.warn("No object layer found with the name: " + name);
                return null;
              }
            }
            return objectLayer.objects.find(callback, context) || null;
          },
          findTile: function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);
          },
          forEachTile: function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);
            return this;
          },
          getImageIndex: function(name) {
            return this.getIndex(this.images, name);
          },
          getImageLayerNames: function() {
            if (!this.images || !Array.isArray(this.images)) {
              return [];
            }
            return this.images.map(function(image) {
              return image.name;
            });
          },
          getIndex: function(location, name) {
            for (var i2 = 0; i2 < location.length; i2++) {
              if (location[i2].name === name) {
                return i2;
              }
            }
            return null;
          },
          getLayer: function(layer) {
            var index2 = this.getLayerIndex(layer);
            return index2 !== null ? this.layers[index2] : null;
          },
          getObjectLayer: function(name) {
            var index2 = this.getIndex(this.objects, name);
            return index2 !== null ? this.objects[index2] : null;
          },
          getObjectLayerNames: function() {
            if (!this.objects || !Array.isArray(this.objects)) {
              return [];
            }
            return this.objects.map(function(object) {
              return object.name;
            });
          },
          getLayerIndex: function(layer) {
            if (layer === void 0) {
              return this.currentLayerIndex;
            } else if (typeof layer === "string") {
              return this.getLayerIndexByName(layer);
            } else if (typeof layer === "number" && layer < this.layers.length) {
              return layer;
            } else if (layer instanceof TilemapLayer) {
              return layer.layerIndex;
            } else {
              return null;
            }
          },
          getLayerIndexByName: function(name) {
            return this.getIndex(this.layers, name);
          },
          getTileAt: function(tileX, tileY, nonNull, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.GetTileAt(tileX, tileY, nonNull, layer);
          },
          getTileAtWorldXY: function(worldX, worldY, nonNull, camera, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, layer);
          },
          getTileLayerNames: function() {
            if (!this.layers || !Array.isArray(this.layers)) {
              return [];
            }
            return this.layers.map(function(layer) {
              return layer.name;
            });
          },
          getTilesWithin: function(tileX, tileY, width, height, filteringOptions, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
          },
          getTilesWithinShape: function(shape, filteringOptions, camera, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, layer);
          },
          getTilesWithinWorldXY: function(worldX, worldY, width, height, filteringOptions, camera, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, layer);
          },
          getTileset: function(name) {
            var index2 = this.getIndex(this.tilesets, name);
            return index2 !== null ? this.tilesets[index2] : null;
          },
          getTilesetIndex: function(name) {
            return this.getIndex(this.tilesets, name);
          },
          hasTileAt: function(tileX, tileY, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.HasTileAt(tileX, tileY, layer);
          },
          hasTileAtWorldXY: function(worldX, worldY, camera, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, layer);
          },
          layer: {
            get: function() {
              return this.layers[this.currentLayerIndex];
            },
            set: function(layer) {
              this.setLayer(layer);
            }
          },
          putTileAt: function(tile, tileX, tileY, recalculateFaces, layer) {
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, layer);
          },
          putTileAtWorldXY: function(tile, worldX, worldY, recalculateFaces, camera, layer) {
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, layer);
          },
          putTilesAt: function(tilesArray, tileX, tileY, recalculateFaces, layer) {
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, layer);
            return this;
          },
          randomize: function(tileX, tileY, width, height, indexes, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.Randomize(tileX, tileY, width, height, indexes, layer);
            return this;
          },
          calculateFacesAt: function(tileX, tileY, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.CalculateFacesAt(tileX, tileY, layer);
            return this;
          },
          calculateFacesWithin: function(tileX, tileY, width, height, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, layer);
            return this;
          },
          removeLayer: function(layer) {
            var index2 = this.getLayerIndex(layer);
            if (index2 !== null) {
              SpliceOne(this.layers, index2);
              for (var i2 = index2; i2 < this.layers.length; i2++) {
                if (this.layers[i2].tilemapLayer) {
                  this.layers[i2].tilemapLayer.layerIndex--;
                }
              }
              if (this.currentLayerIndex === index2) {
                this.currentLayerIndex = 0;
              }
              return this;
            } else {
              return null;
            }
          },
          destroyLayer: function(layer) {
            var index2 = this.getLayerIndex(layer);
            if (index2 !== null) {
              layer = this.layers[index2];
              layer.destroy();
              SpliceOne(this.layers, index2);
              if (this.currentLayerIndex === index2) {
                this.currentLayerIndex = 0;
              }
              return this;
            } else {
              return null;
            }
          },
          removeAllLayers: function() {
            var layers = this.layers;
            for (var i2 = 0; i2 < layers.length; i2++) {
              if (layers[i2].tilemapLayer) {
                layers[i2].tilemapLayer.destroy(false);
              }
            }
            layers.length = 0;
            this.currentLayerIndex = 0;
            return this;
          },
          removeTile: function(tiles, replaceIndex, recalculateFaces) {
            if (replaceIndex === void 0) {
              replaceIndex = -1;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            var removed = [];
            if (!Array.isArray(tiles)) {
              tiles = [tiles];
            }
            for (var i2 = 0; i2 < tiles.length; i2++) {
              var tile = tiles[i2];
              removed.push(this.removeTileAt(tile.x, tile.y, true, recalculateFaces, tile.tilemapLayer));
              if (replaceIndex > -1) {
                this.putTileAt(replaceIndex, tile.x, tile.y, recalculateFaces, tile.tilemapLayer);
              }
            }
            return removed;
          },
          removeTileAt: function(tileX, tileY, replaceWithNull, recalculateFaces, layer) {
            if (replaceWithNull === void 0) {
              replaceWithNull = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, layer);
          },
          removeTileAtWorldXY: function(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer) {
            if (replaceWithNull === void 0) {
              replaceWithNull = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer);
          },
          renderDebug: function(graphics, styleConfig, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            if (this.orientation === ORIENTATION.ORTHOGONAL) {
              TilemapComponents.RenderDebug(graphics, styleConfig, layer);
            }
            return this;
          },
          renderDebugFull: function(graphics, styleConfig) {
            var layers = this.layers;
            for (var i2 = 0; i2 < layers.length; i2++) {
              TilemapComponents.RenderDebug(graphics, styleConfig, layers[i2]);
            }
            return this;
          },
          replaceByIndex: function(findIndex, newIndex, tileX, tileY, width, height, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, layer);
            return this;
          },
          setCollision: function(indexes, collides, recalculateFaces, layer, updateLayer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (updateLayer === void 0) {
              updateLayer = true;
            }
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.SetCollision(indexes, collides, recalculateFaces, layer, updateLayer);
            return this;
          },
          setCollisionBetween: function(start, stop, collides, recalculateFaces, layer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, layer);
            return this;
          },
          setCollisionByProperty: function(properties, collides, recalculateFaces, layer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, layer);
            return this;
          },
          setCollisionByExclusion: function(indexes, collides, recalculateFaces, layer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, layer);
            return this;
          },
          setCollisionFromCollisionGroup: function(collides, recalculateFaces, layer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, layer);
            return this;
          },
          setTileIndexCallback: function(indexes, callback, callbackContext, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, layer);
            return this;
          },
          setTileLocationCallback: function(tileX, tileY, width, height, callback, callbackContext, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, layer);
            return this;
          },
          setLayer: function(layer) {
            var index2 = this.getLayerIndex(layer);
            if (index2 !== null) {
              this.currentLayerIndex = index2;
            }
            return this;
          },
          setBaseTileSize: function(tileWidth, tileHeight) {
            this.tileWidth = tileWidth;
            this.tileHeight = tileHeight;
            this.widthInPixels = this.width * tileWidth;
            this.heightInPixels = this.height * tileHeight;
            for (var i2 = 0; i2 < this.layers.length; i2++) {
              this.layers[i2].baseTileWidth = tileWidth;
              this.layers[i2].baseTileHeight = tileHeight;
              var mapData = this.layers[i2].data;
              var mapWidth = this.layers[i2].width;
              var mapHeight = this.layers[i2].height;
              for (var row = 0; row < mapHeight; row++) {
                for (var col = 0; col < mapWidth; col++) {
                  var tile = mapData[row][col];
                  if (tile !== null) {
                    tile.setSize(void 0, void 0, tileWidth, tileHeight);
                  }
                }
              }
            }
            return this;
          },
          setLayerTileSize: function(tileWidth, tileHeight, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return this;
            }
            layer.tileWidth = tileWidth;
            layer.tileHeight = tileHeight;
            var mapData = layer.data;
            var mapWidth = layer.width;
            var mapHeight = layer.height;
            for (var row = 0; row < mapHeight; row++) {
              for (var col = 0; col < mapWidth; col++) {
                var tile = mapData[row][col];
                if (tile !== null) {
                  tile.setSize(tileWidth, tileHeight);
                }
              }
            }
            return this;
          },
          shuffle: function(tileX, tileY, width, height, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.Shuffle(tileX, tileY, width, height, layer);
            return this;
          },
          swapByIndex: function(indexA, indexB, tileX, tileY, width, height, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, layer);
            return this;
          },
          tileToWorldX: function(tileX, camera, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return this._convert.TileToWorldX(tileX, camera, layer);
          },
          tileToWorldY: function(tileX, camera, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return this._convert.TileToWorldY(tileX, camera, layer);
          },
          tileToWorldXY: function(tileX, tileY, vec2, camera, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return this._convert.TileToWorldXY(tileX, tileY, vec2, camera, layer);
          },
          weightedRandomize: function(weightedIndexes, tileX, tileY, width, height, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, layer);
            return this;
          },
          worldToTileX: function(worldX, snapToFloor, camera, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return this._convert.WorldToTileX(worldX, snapToFloor, camera, layer);
          },
          worldToTileY: function(worldY, snapToFloor, camera, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return this._convert.WorldToTileY(worldY, snapToFloor, camera, layer);
          },
          worldToTileXY: function(worldX, worldY, snapToFloor, vec2, camera, layer) {
            layer = this.getLayer(layer);
            if (layer === null) {
              return null;
            }
            return this._convert.WorldToTileXY(worldX, worldY, snapToFloor, vec2, camera, layer);
          },
          destroy: function() {
            this.removeAllLayers();
            this.tilesets.length = 0;
            this.objects.length = 0;
            this.scene = null;
          }
        });
        module2.exports = Tilemap;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(11);
        var GameObject = __webpack_require__(15);
        var TilemapComponents = __webpack_require__(251);
        var TilemapLayerRender = __webpack_require__(1456);
        var TilemapLayer = new Class({
          Extends: GameObject,
          Mixins: [
            Components.Alpha,
            Components.BlendMode,
            Components.ComputedSize,
            Components.Depth,
            Components.Flip,
            Components.GetBounds,
            Components.Origin,
            Components.Pipeline,
            Components.Transform,
            Components.Visible,
            Components.ScrollFactor,
            TilemapLayerRender
          ],
          initialize: function TilemapLayer2(scene, tilemap, layerIndex, tileset, x2, y2) {
            GameObject.call(this, scene, "TilemapLayer");
            this.isTilemap = true;
            this.tilemap = tilemap;
            this.layerIndex = layerIndex;
            this.layer = tilemap.layers[layerIndex];
            this.layer.tilemapLayer = this;
            this.tileset = [];
            this.tilesDrawn = 0;
            this.tilesTotal = this.layer.width * this.layer.height;
            this.culledTiles = [];
            this.skipCull = false;
            this.cullPaddingX = 1;
            this.cullPaddingY = 1;
            this.cullCallback = TilemapComponents.GetCullTilesFunction(this.layer.orientation);
            this._renderOrder = 0;
            this.gidMap = [];
            this.setTilesets(tileset);
            this.setAlpha(this.layer.alpha);
            this.setPosition(x2, y2);
            this.setOrigin();
            this.setSize(tilemap.tileWidth * this.layer.width, tilemap.tileHeight * this.layer.height);
            this.initPipeline();
          },
          setTilesets: function(tilesets) {
            var gidMap = [];
            var setList = [];
            var map = this.tilemap;
            if (!Array.isArray(tilesets)) {
              tilesets = [tilesets];
            }
            for (var i2 = 0; i2 < tilesets.length; i2++) {
              var tileset = tilesets[i2];
              if (typeof tileset === "string") {
                tileset = map.getTileset(tileset);
              }
              if (tileset) {
                setList.push(tileset);
                var s = tileset.firstgid;
                for (var t2 = 0; t2 < tileset.total; t2++) {
                  gidMap[s + t2] = tileset;
                }
              }
            }
            this.gidMap = gidMap;
            this.tileset = setList;
          },
          setRenderOrder: function(renderOrder) {
            var orders = ["right-down", "left-down", "right-up", "left-up"];
            if (typeof renderOrder === "string") {
              renderOrder = orders.indexOf(renderOrder);
            }
            if (renderOrder >= 0 && renderOrder < 4) {
              this._renderOrder = renderOrder;
            }
            return this;
          },
          calculateFacesAt: function(tileX, tileY) {
            TilemapComponents.CalculateFacesAt(tileX, tileY, this.layer);
            return this;
          },
          calculateFacesWithin: function(tileX, tileY, width, height) {
            TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, this.layer);
            return this;
          },
          createFromTiles: function(indexes, replacements, spriteConfig, scene, camera) {
            return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, this.layer);
          },
          cull: function(camera) {
            return this.cullCallback(this.layer, camera, this.culledTiles, this._renderOrder);
          },
          copy: function(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces) {
            TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, this.layer);
            return this;
          },
          fill: function(index2, tileX, tileY, width, height, recalculateFaces) {
            TilemapComponents.Fill(index2, tileX, tileY, width, height, recalculateFaces, this.layer);
            return this;
          },
          filterTiles: function(callback, context, tileX, tileY, width, height, filteringOptions) {
            return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
          },
          findByIndex: function(findIndex, skip, reverse) {
            return TilemapComponents.FindByIndex(findIndex, skip, reverse, this.layer);
          },
          findTile: function(callback, context, tileX, tileY, width, height, filteringOptions) {
            return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
          },
          forEachTile: function(callback, context, tileX, tileY, width, height, filteringOptions) {
            TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
            return this;
          },
          getTileAt: function(tileX, tileY, nonNull) {
            return TilemapComponents.GetTileAt(tileX, tileY, nonNull, this.layer);
          },
          getTileAtWorldXY: function(worldX, worldY, nonNull, camera) {
            return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, this.layer);
          },
          getTilesWithin: function(tileX, tileY, width, height, filteringOptions) {
            return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, this.layer);
          },
          getTilesWithinShape: function(shape, filteringOptions, camera) {
            return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, this.layer);
          },
          getTilesWithinWorldXY: function(worldX, worldY, width, height, filteringOptions, camera) {
            return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, this.layer);
          },
          hasTileAt: function(tileX, tileY) {
            return TilemapComponents.HasTileAt(tileX, tileY, this.layer);
          },
          hasTileAtWorldXY: function(worldX, worldY, camera) {
            return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, this.layer);
          },
          putTileAt: function(tile, tileX, tileY, recalculateFaces) {
            return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, this.layer);
          },
          putTileAtWorldXY: function(tile, worldX, worldY, recalculateFaces, camera) {
            return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, this.layer);
          },
          putTilesAt: function(tilesArray, tileX, tileY, recalculateFaces) {
            TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, this.layer);
            return this;
          },
          randomize: function(tileX, tileY, width, height, indexes) {
            TilemapComponents.Randomize(tileX, tileY, width, height, indexes, this.layer);
            return this;
          },
          removeTileAt: function(tileX, tileY, replaceWithNull, recalculateFaces) {
            return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, this.layer);
          },
          removeTileAtWorldXY: function(worldX, worldY, replaceWithNull, recalculateFaces, camera) {
            return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, this.layer);
          },
          renderDebug: function(graphics, styleConfig) {
            TilemapComponents.RenderDebug(graphics, styleConfig, this.layer);
            return this;
          },
          replaceByIndex: function(findIndex, newIndex, tileX, tileY, width, height) {
            TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, this.layer);
            return this;
          },
          setSkipCull: function(value) {
            if (value === void 0) {
              value = true;
            }
            this.skipCull = value;
            return this;
          },
          setCullPadding: function(paddingX, paddingY) {
            if (paddingX === void 0) {
              paddingX = 1;
            }
            if (paddingY === void 0) {
              paddingY = 1;
            }
            this.cullPaddingX = paddingX;
            this.cullPaddingY = paddingY;
            return this;
          },
          setCollision: function(indexes, collides, recalculateFaces, updateLayer) {
            TilemapComponents.SetCollision(indexes, collides, recalculateFaces, this.layer, updateLayer);
            return this;
          },
          setCollisionBetween: function(start, stop, collides, recalculateFaces) {
            TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, this.layer);
            return this;
          },
          setCollisionByProperty: function(properties, collides, recalculateFaces) {
            TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, this.layer);
            return this;
          },
          setCollisionByExclusion: function(indexes, collides, recalculateFaces) {
            TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, this.layer);
            return this;
          },
          setCollisionFromCollisionGroup: function(collides, recalculateFaces) {
            TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, this.layer);
            return this;
          },
          setTileIndexCallback: function(indexes, callback, callbackContext) {
            TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, this.layer);
            return this;
          },
          setTileLocationCallback: function(tileX, tileY, width, height, callback, callbackContext) {
            TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, this.layer);
            return this;
          },
          shuffle: function(tileX, tileY, width, height) {
            TilemapComponents.Shuffle(tileX, tileY, width, height, this.layer);
            return this;
          },
          swapByIndex: function(indexA, indexB, tileX, tileY, width, height) {
            TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, this.layer);
            return this;
          },
          tileToWorldX: function(tileX, camera) {
            return this.tilemap.tileToWorldX(tileX, camera, this);
          },
          tileToWorldY: function(tileY, camera) {
            return this.tilemap.tileToWorldY(tileY, camera, this);
          },
          tileToWorldXY: function(tileX, tileY, point, camera) {
            return this.tilemap.tileToWorldXY(tileX, tileY, point, camera, this);
          },
          weightedRandomize: function(weightedIndexes, tileX, tileY, width, height) {
            TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, this.layer);
            return this;
          },
          worldToTileX: function(worldX, snapToFloor, camera) {
            return this.tilemap.worldToTileX(worldX, snapToFloor, camera, this);
          },
          worldToTileY: function(worldY, snapToFloor, camera) {
            return this.tilemap.worldToTileY(worldY, snapToFloor, camera, this);
          },
          worldToTileXY: function(worldX, worldY, snapToFloor, point, camera) {
            return this.tilemap.worldToTileXY(worldX, worldY, snapToFloor, point, camera, this);
          },
          destroy: function(removeFromTilemap) {
            if (removeFromTilemap === void 0) {
              removeFromTilemap = true;
            }
            if (!this.tilemap) {
              return;
            }
            if (this.layer.tilemapLayer === this) {
              this.layer.tilemapLayer = void 0;
            }
            if (removeFromTilemap) {
              this.tilemap.removeLayer(this);
            }
            this.tilemap = void 0;
            this.layer = void 0;
            this.culledTiles.length = 0;
            this.cullCallback = null;
            this.gidMap = [];
            this.tileset = [];
            GameObject.prototype.destroy.call(this);
          }
        });
        module2.exports = TilemapLayer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetFastValue = __webpack_require__(2);
        var TimerEvent = new Class({
          initialize: function TimerEvent2(config) {
            this.delay = 0;
            this.repeat = 0;
            this.repeatCount = 0;
            this.loop = false;
            this.callback;
            this.callbackScope;
            this.args;
            this.timeScale = 1;
            this.startAt = 0;
            this.elapsed = 0;
            this.paused = false;
            this.hasDispatched = false;
            this.reset(config);
          },
          reset: function(config) {
            this.delay = GetFastValue(config, "delay", 0);
            this.repeat = GetFastValue(config, "repeat", 0);
            this.loop = GetFastValue(config, "loop", false);
            this.callback = GetFastValue(config, "callback", void 0);
            this.callbackScope = GetFastValue(config, "callbackScope", this.callback);
            this.args = GetFastValue(config, "args", []);
            this.timeScale = GetFastValue(config, "timeScale", 1);
            this.startAt = GetFastValue(config, "startAt", 0);
            this.paused = GetFastValue(config, "paused", false);
            this.elapsed = this.startAt;
            this.hasDispatched = false;
            this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 : this.repeat;
            return this;
          },
          getProgress: function() {
            return this.elapsed / this.delay;
          },
          getOverallProgress: function() {
            if (this.repeat > 0) {
              var totalDuration = this.delay + this.delay * this.repeat;
              var totalElapsed = this.elapsed + this.delay * (this.repeat - this.repeatCount);
              return totalElapsed / totalDuration;
            } else {
              return this.getProgress();
            }
          },
          getRepeatCount: function() {
            return this.repeatCount;
          },
          getElapsed: function() {
            return this.elapsed;
          },
          getElapsedSeconds: function() {
            return this.elapsed * 1e-3;
          },
          getRemaining: function() {
            return this.delay - this.elapsed;
          },
          getRemainingSeconds: function() {
            return this.getRemaining() * 1e-3;
          },
          getOverallRemaining: function() {
            return this.delay * (1 + this.repeatCount) - this.elapsed;
          },
          getOverallRemainingSeconds: function() {
            return this.getOverallRemaining() * 1e-3;
          },
          remove: function(dispatchCallback) {
            if (dispatchCallback === void 0) {
              dispatchCallback = false;
            }
            this.elapsed = this.delay;
            this.hasDispatched = !dispatchCallback;
            this.repeatCount = 0;
          },
          destroy: function() {
            this.callback = void 0;
            this.callbackScope = void 0;
            this.args = [];
          }
        });
        module2.exports = TimerEvent;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RESERVED = __webpack_require__(1465);
        var GetProps = function(config) {
          var key;
          var keys = [];
          if (config.hasOwnProperty("props")) {
            for (key in config.props) {
              if (key.substr(0, 1) !== "_") {
                keys.push({ key, value: config.props[key] });
              }
            }
          } else {
            for (key in config) {
              if (RESERVED.indexOf(key) === -1 && key.substr(0, 1) !== "_") {
                keys.push({ key, value: config[key] });
              }
            }
          }
          return keys;
        };
        module2.exports = GetProps;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetValue = __webpack_require__(6);
        var GetTweens = function(config) {
          var tweens = GetValue(config, "tweens", null);
          if (tweens === null) {
            return [];
          } else if (typeof tweens === "function") {
            tweens = tweens.call();
          }
          if (!Array.isArray(tweens)) {
            tweens = [tweens];
          }
          return tweens;
        };
        module2.exports = GetTweens;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Defaults = __webpack_require__(265);
        var GetAdvancedValue = __webpack_require__(13);
        var GetBoolean = __webpack_require__(99);
        var GetEaseFunction = __webpack_require__(80);
        var GetNewValue = __webpack_require__(162);
        var GetValue = __webpack_require__(6);
        var GetValueOp = __webpack_require__(264);
        var Tween = __webpack_require__(266);
        var TweenData = __webpack_require__(268);
        var NumberTweenBuilder = function(parent, config, defaults) {
          if (defaults === void 0) {
            defaults = Defaults;
          }
          var from = GetValue(config, "from", 0);
          var to = GetValue(config, "to", 1);
          var targets = [{ value: from }];
          var delay = GetNewValue(config, "delay", defaults.delay);
          var duration = GetNewValue(config, "duration", defaults.duration);
          var easeParams = GetValue(config, "easeParams", defaults.easeParams);
          var ease = GetEaseFunction(GetValue(config, "ease", defaults.ease), easeParams);
          var hold = GetNewValue(config, "hold", defaults.hold);
          var repeat = GetNewValue(config, "repeat", defaults.repeat);
          var repeatDelay = GetNewValue(config, "repeatDelay", defaults.repeatDelay);
          var yoyo = GetBoolean(config, "yoyo", defaults.yoyo);
          var data = [];
          var ops = GetValueOp("value", to);
          var tweenData = TweenData(targets[0], 0, "value", ops.getEnd, ops.getStart, ops.getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, false, false);
          tweenData.start = from;
          tweenData.current = from;
          tweenData.to = to;
          data.push(tweenData);
          var tween = new Tween(parent, data, targets);
          tween.offset = GetAdvancedValue(config, "offset", null);
          tween.completeDelay = GetAdvancedValue(config, "completeDelay", 0);
          tween.loop = Math.round(GetAdvancedValue(config, "loop", 0));
          tween.loopDelay = Math.round(GetAdvancedValue(config, "loopDelay", 0));
          tween.paused = GetBoolean(config, "paused", false);
          tween.useFrames = GetBoolean(config, "useFrames", false);
          var scope = GetValue(config, "callbackScope", tween);
          var tweenArray = [tween, null];
          var callbacks = Tween.TYPES;
          for (var i2 = 0; i2 < callbacks.length; i2++) {
            var type = callbacks[i2];
            var callback = GetValue(config, type, false);
            if (callback) {
              var callbackScope = GetValue(config, type + "Scope", scope);
              var callbackParams = GetValue(config, type + "Params", []);
              tween.setCallback(type, callback, tweenArray.concat(callbackParams), callbackScope);
            }
          }
          return tween;
        };
        module2.exports = NumberTweenBuilder;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetEaseFunction = __webpack_require__(80);
        var GetValue = __webpack_require__(6);
        var MATH_CONST = __webpack_require__(14);
        var StaggerBuilder = function(value, options) {
          if (options === void 0) {
            options = {};
          }
          var result;
          var start = GetValue(options, "start", 0);
          var ease = GetValue(options, "ease", null);
          var grid = GetValue(options, "grid", null);
          var from = GetValue(options, "from", 0);
          var fromFirst = from === "first";
          var fromCenter = from === "center";
          var fromLast = from === "last";
          var fromValue = typeof from === "number";
          var isRange = Array.isArray(value);
          var value1 = isRange ? parseFloat(value[0]) : parseFloat(value);
          var value2 = isRange ? parseFloat(value[1]) : 0;
          var maxValue = Math.max(value1, value2);
          if (isRange) {
            start += value1;
          }
          if (grid) {
            var gridWidth = grid[0];
            var gridHeight = grid[1];
            var fromX = 0;
            var fromY = 0;
            var distanceX = 0;
            var distanceY = 0;
            var gridValues = [];
            if (fromLast) {
              fromX = gridWidth - 1;
              fromY = gridHeight - 1;
            } else if (fromValue) {
              fromX = from % gridWidth;
              fromY = Math.floor(from / gridWidth);
            } else if (fromCenter) {
              fromX = (gridWidth - 1) / 2;
              fromY = (gridHeight - 1) / 2;
            }
            var gridMax = MATH_CONST.MIN_SAFE_INTEGER;
            for (var toY = 0; toY < gridHeight; toY++) {
              gridValues[toY] = [];
              for (var toX = 0; toX < gridWidth; toX++) {
                distanceX = fromX - toX;
                distanceY = fromY - toY;
                var dist = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                if (dist > gridMax) {
                  gridMax = dist;
                }
                gridValues[toY][toX] = dist;
              }
            }
          }
          var easeFunction = ease ? GetEaseFunction(ease) : null;
          if (grid) {
            result = function(target, key, value3, index2) {
              var gridSpace = 0;
              var toX2 = index2 % gridWidth;
              var toY2 = Math.floor(index2 / gridWidth);
              if (toX2 >= 0 && toX2 < gridWidth && toY2 >= 0 && toY2 < gridHeight) {
                gridSpace = gridValues[toY2][toX2];
              }
              var output;
              if (isRange) {
                var diff = value2 - value1;
                if (easeFunction) {
                  output = gridSpace / gridMax * diff * easeFunction(gridSpace / gridMax);
                } else {
                  output = gridSpace / gridMax * diff;
                }
              } else if (easeFunction) {
                output = gridSpace * value1 * easeFunction(gridSpace / gridMax);
              } else {
                output = gridSpace * value1;
              }
              return output + start;
            };
          } else {
            result = function(target, key, value3, index2, total) {
              total--;
              var fromIndex;
              if (fromFirst) {
                fromIndex = index2;
              } else if (fromCenter) {
                fromIndex = Math.abs(total / 2 - index2);
              } else if (fromLast) {
                fromIndex = total - index2;
              } else if (fromValue) {
                fromIndex = Math.abs(from - index2);
              }
              var output;
              if (isRange) {
                var spacing;
                if (fromCenter) {
                  spacing = (value2 - value1) / total * (fromIndex * 2);
                } else {
                  spacing = (value2 - value1) / total * fromIndex;
                }
                if (easeFunction) {
                  output = spacing * easeFunction(fromIndex / total);
                } else {
                  output = spacing;
                }
              } else if (easeFunction) {
                output = total * maxValue * easeFunction(fromIndex / total);
              } else {
                output = fromIndex * value1;
              }
              return output + start;
            };
          }
          return result;
        };
        module2.exports = StaggerBuilder;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clone = __webpack_require__(77);
        var Defaults = __webpack_require__(265);
        var GetAdvancedValue = __webpack_require__(13);
        var GetBoolean = __webpack_require__(99);
        var GetEaseFunction = __webpack_require__(80);
        var GetNewValue = __webpack_require__(162);
        var GetTargets = __webpack_require__(263);
        var GetTweens = __webpack_require__(584);
        var GetValue = __webpack_require__(6);
        var Timeline = __webpack_require__(588);
        var TweenBuilder = __webpack_require__(163);
        var TimelineBuilder = function(manager, config) {
          var timeline = new Timeline(manager);
          timeline.completeDelay = GetAdvancedValue(config, "completeDelay", 0);
          timeline.loop = Math.round(GetAdvancedValue(config, "loop", 0));
          timeline.loopDelay = Math.round(GetAdvancedValue(config, "loopDelay", 0));
          timeline.paused = GetBoolean(config, "paused", false);
          timeline.useFrames = GetBoolean(config, "useFrames", false);
          var scope = GetValue(config, "callbackScope", timeline);
          var timelineArray = [timeline];
          var onStart = GetValue(config, "onStart", false);
          if (onStart) {
            var onStartScope = GetValue(config, "onStartScope", scope);
            var onStartParams = GetValue(config, "onStartParams", []);
            timeline.setCallback("onStart", onStart, timelineArray.concat(onStartParams), onStartScope);
          }
          var onUpdate = GetValue(config, "onUpdate", false);
          if (onUpdate) {
            var onUpdateScope = GetValue(config, "onUpdateScope", scope);
            var onUpdateParams = GetValue(config, "onUpdateParams", []);
            timeline.setCallback("onUpdate", onUpdate, timelineArray.concat(onUpdateParams), onUpdateScope);
          }
          var onLoop = GetValue(config, "onLoop", false);
          if (onLoop) {
            var onLoopScope = GetValue(config, "onLoopScope", scope);
            var onLoopParams = GetValue(config, "onLoopParams", []);
            timeline.setCallback("onLoop", onLoop, timelineArray.concat(onLoopParams), onLoopScope);
          }
          var onYoyo = GetValue(config, "onYoyo", false);
          if (onYoyo) {
            var onYoyoScope = GetValue(config, "onYoyoScope", scope);
            var onYoyoParams = GetValue(config, "onYoyoParams", []);
            timeline.setCallback("onYoyo", onYoyo, timelineArray.concat(null, onYoyoParams), onYoyoScope);
          }
          var onComplete = GetValue(config, "onComplete", false);
          if (onComplete) {
            var onCompleteScope = GetValue(config, "onCompleteScope", scope);
            var onCompleteParams = GetValue(config, "onCompleteParams", []);
            timeline.setCallback("onComplete", onComplete, timelineArray.concat(onCompleteParams), onCompleteScope);
          }
          var tweens = GetTweens(config);
          if (tweens.length === 0) {
            timeline.paused = true;
            return timeline;
          }
          var defaults = Clone(Defaults);
          defaults.targets = GetTargets(config);
          var totalDuration = GetAdvancedValue(config, "totalDuration", 0);
          if (totalDuration > 0) {
            defaults.duration = Math.floor(totalDuration / tweens.length);
          } else {
            defaults.duration = GetNewValue(config, "duration", defaults.duration);
          }
          defaults.delay = GetNewValue(config, "delay", defaults.delay);
          defaults.easeParams = GetValue(config, "easeParams", defaults.easeParams);
          defaults.ease = GetEaseFunction(GetValue(config, "ease", defaults.ease), defaults.easeParams);
          defaults.hold = GetNewValue(config, "hold", defaults.hold);
          defaults.repeat = GetNewValue(config, "repeat", defaults.repeat);
          defaults.repeatDelay = GetNewValue(config, "repeatDelay", defaults.repeatDelay);
          defaults.yoyo = GetBoolean(config, "yoyo", defaults.yoyo);
          defaults.flipX = GetBoolean(config, "flipX", defaults.flipX);
          defaults.flipY = GetBoolean(config, "flipY", defaults.flipY);
          for (var i2 = 0; i2 < tweens.length; i2++) {
            timeline.queue(TweenBuilder(timeline, tweens[i2], defaults));
          }
          return timeline;
        };
        module2.exports = TimelineBuilder;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(267);
        var TweenBuilder = __webpack_require__(163);
        var TWEEN_CONST = __webpack_require__(100);
        var Timeline = new Class({
          Extends: EventEmitter,
          initialize: function Timeline2(manager) {
            EventEmitter.call(this);
            this.manager = manager;
            this.isTimeline = true;
            this.data = [];
            this.totalData = 0;
            this.useFrames = false;
            this.timeScale = 1;
            this.loop = 0;
            this.loopDelay = 0;
            this.loopCounter = 0;
            this.completeDelay = 0;
            this.countdown = 0;
            this.state = TWEEN_CONST.PENDING_ADD;
            this._pausedState = TWEEN_CONST.PENDING_ADD;
            this.paused = false;
            this.elapsed = 0;
            this.totalElapsed = 0;
            this.duration = 0;
            this.progress = 0;
            this.totalDuration = 0;
            this.totalProgress = 0;
            this.callbacks = {
              onComplete: null,
              onLoop: null,
              onStart: null,
              onUpdate: null,
              onYoyo: null
            };
            this.callbackScope;
          },
          dispatchTimelineEvent: function(event, callback) {
            this.emit(event, this);
            if (callback) {
              callback.func.apply(callback.scope, callback.params);
            }
          },
          setTimeScale: function(value) {
            this.timeScale = value;
            return this;
          },
          getTimeScale: function() {
            return this.timeScale;
          },
          isPlaying: function() {
            return this.state === TWEEN_CONST.ACTIVE;
          },
          add: function(config) {
            return this.queue(TweenBuilder(this, config));
          },
          queue: function(tween) {
            if (!this.isPlaying()) {
              tween.parent = this;
              tween.parentIsTimeline = true;
              this.data.push(tween);
              this.totalData = this.data.length;
            }
            return this;
          },
          hasOffset: function(tween) {
            return tween.offset !== null;
          },
          isOffsetAbsolute: function(value) {
            return typeof value === "number";
          },
          isOffsetRelative: function(value) {
            var t2 = typeof value;
            if (t2 === "string") {
              var op = value[0];
              if (op === "-" || op === "+") {
                return true;
              }
            }
            return false;
          },
          getRelativeOffset: function(value, base) {
            var op = value[0];
            var num = parseFloat(value.substr(2));
            var result = base;
            switch (op) {
              case "+":
                result += num;
                break;
              case "-":
                result -= num;
                break;
            }
            return Math.max(0, result);
          },
          calcDuration: function() {
            var prevEnd = 0;
            var totalDuration = 0;
            var offsetDuration = 0;
            for (var i2 = 0; i2 < this.totalData; i2++) {
              var tween = this.data[i2];
              tween.init();
              if (this.hasOffset(tween)) {
                if (this.isOffsetAbsolute(tween.offset)) {
                  tween.calculatedOffset = tween.offset;
                  if (tween.offset === 0) {
                    offsetDuration = 0;
                  }
                } else if (this.isOffsetRelative(tween.offset)) {
                  tween.calculatedOffset = this.getRelativeOffset(tween.offset, prevEnd);
                }
              } else {
                tween.calculatedOffset = offsetDuration;
              }
              prevEnd = tween.totalDuration + tween.calculatedOffset;
              totalDuration += tween.totalDuration;
              offsetDuration += tween.totalDuration;
            }
            this.duration = totalDuration;
            this.loopCounter = this.loop === -1 ? 999999999999 : this.loop;
            if (this.loopCounter > 0) {
              this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter;
            } else {
              this.totalDuration = this.duration + this.completeDelay;
            }
          },
          init: function() {
            this.calcDuration();
            this.progress = 0;
            this.totalProgress = 0;
            if (this.paused) {
              this.state = TWEEN_CONST.PAUSED;
              return false;
            } else {
              return true;
            }
          },
          resetTweens: function(resetFromLoop) {
            for (var i2 = 0; i2 < this.totalData; i2++) {
              var tween = this.data[i2];
              tween.play(resetFromLoop);
            }
          },
          setCallback: function(type, callback, params, scope) {
            if (Timeline.TYPES.indexOf(type) !== -1) {
              this.callbacks[type] = { func: callback, scope, params };
            }
            return this;
          },
          makeActive: function(tween) {
            return this.manager.makeActive(tween);
          },
          play: function() {
            if (this.state === TWEEN_CONST.ACTIVE) {
              return;
            }
            if (this.paused) {
              this.paused = false;
              this.manager.makeActive(this);
              return;
            } else {
              this.resetTweens(false);
              this.state = TWEEN_CONST.ACTIVE;
            }
            this.dispatchTimelineEvent(Events.TIMELINE_START, this.callbacks.onStart);
          },
          nextState: function() {
            if (this.loopCounter > 0) {
              this.elapsed = 0;
              this.progress = 0;
              this.loopCounter--;
              this.resetTweens(true);
              if (this.loopDelay > 0) {
                this.countdown = this.loopDelay;
                this.state = TWEEN_CONST.LOOP_DELAY;
              } else {
                this.state = TWEEN_CONST.ACTIVE;
                this.dispatchTimelineEvent(Events.TIMELINE_LOOP, this.callbacks.onLoop);
              }
            } else if (this.completeDelay > 0) {
              this.state = TWEEN_CONST.COMPLETE_DELAY;
              this.countdown = this.completeDelay;
            } else {
              this.state = TWEEN_CONST.PENDING_REMOVE;
              this.dispatchTimelineEvent(Events.TIMELINE_COMPLETE, this.callbacks.onComplete);
            }
          },
          update: function(timestamp, delta) {
            if (this.state === TWEEN_CONST.PAUSED) {
              return;
            }
            if (this.useFrames) {
              delta = 1 * this.manager.timeScale;
            }
            delta *= this.timeScale;
            this.elapsed += delta;
            this.progress = Math.min(this.elapsed / this.duration, 1);
            this.totalElapsed += delta;
            this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);
            switch (this.state) {
              case TWEEN_CONST.ACTIVE:
                var stillRunning = this.totalData;
                for (var i2 = 0; i2 < this.totalData; i2++) {
                  var tween = this.data[i2];
                  if (tween.update(timestamp, delta)) {
                    stillRunning--;
                  }
                }
                this.dispatchTimelineEvent(Events.TIMELINE_UPDATE, this.callbacks.onUpdate);
                if (stillRunning === 0) {
                  this.nextState();
                }
                break;
              case TWEEN_CONST.LOOP_DELAY:
                this.countdown -= delta;
                if (this.countdown <= 0) {
                  this.state = TWEEN_CONST.ACTIVE;
                  this.dispatchTimelineEvent(Events.TIMELINE_LOOP, this.callbacks.onLoop);
                }
                break;
              case TWEEN_CONST.COMPLETE_DELAY:
                this.countdown -= delta;
                if (this.countdown <= 0) {
                  this.state = TWEEN_CONST.PENDING_REMOVE;
                  this.dispatchTimelineEvent(Events.TIMELINE_COMPLETE, this.callbacks.onComplete);
                }
                break;
            }
            return this.state === TWEEN_CONST.PENDING_REMOVE;
          },
          stop: function() {
            this.state = TWEEN_CONST.PENDING_REMOVE;
          },
          pause: function() {
            if (this.state === TWEEN_CONST.PAUSED) {
              return;
            }
            this.paused = true;
            this._pausedState = this.state;
            this.state = TWEEN_CONST.PAUSED;
            this.emit(Events.TIMELINE_PAUSE, this);
            return this;
          },
          resume: function() {
            if (this.state === TWEEN_CONST.PAUSED) {
              this.paused = false;
              this.state = this._pausedState;
              this.emit(Events.TIMELINE_RESUME, this);
            }
            return this;
          },
          hasTarget: function(target) {
            for (var i2 = 0; i2 < this.data.length; i2++) {
              if (this.data[i2].hasTarget(target)) {
                return true;
              }
            }
            return false;
          },
          destroy: function() {
            for (var i2 = 0; i2 < this.data.length; i2++) {
              this.data[i2].stop();
            }
          }
        });
        Timeline.TYPES = ["onStart", "onUpdate", "onLoop", "onComplete", "onYoyo"];
        module2.exports = Timeline;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Joachim Grill <joachim@codeandweb.com>
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2018 CodeAndWeb GmbH
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Bodies = __webpack_require__(86);
        var Body = __webpack_require__(41);
        var Common = __webpack_require__(32);
        var GetFastValue = __webpack_require__(2);
        var Vertices = __webpack_require__(64);
        var PhysicsEditorParser = {
          parseBody: function(x2, y2, config, options) {
            if (options === void 0) {
              options = {};
            }
            var fixtureConfigs = GetFastValue(config, "fixtures", []);
            var fixtures = [];
            for (var fc2 = 0; fc2 < fixtureConfigs.length; fc2++) {
              var fixtureParts = this.parseFixture(fixtureConfigs[fc2]);
              for (var i2 = 0; i2 < fixtureParts.length; i2++) {
                fixtures.push(fixtureParts[i2]);
              }
            }
            var matterConfig = Common.clone(config, true);
            Common.extend(matterConfig, options, true);
            delete matterConfig.fixtures;
            delete matterConfig.type;
            var body = Body.create(matterConfig);
            Body.setParts(body, fixtures);
            Body.setPosition(body, { x: x2, y: y2 });
            return body;
          },
          parseFixture: function(fixtureConfig) {
            var matterConfig = Common.extend({}, false, fixtureConfig);
            delete matterConfig.circle;
            delete matterConfig.vertices;
            var fixtures;
            if (fixtureConfig.circle) {
              var x2 = GetFastValue(fixtureConfig.circle, "x");
              var y2 = GetFastValue(fixtureConfig.circle, "y");
              var r2 = GetFastValue(fixtureConfig.circle, "radius");
              fixtures = [Bodies.circle(x2, y2, r2, matterConfig)];
            } else if (fixtureConfig.vertices) {
              fixtures = this.parseVertices(fixtureConfig.vertices, matterConfig);
            }
            return fixtures;
          },
          parseVertices: function(vertexSets, options) {
            if (options === void 0) {
              options = {};
            }
            var parts = [];
            for (var v2 = 0; v2 < vertexSets.length; v2++) {
              Vertices.clockwiseSort(vertexSets[v2]);
              parts.push(Body.create(Common.extend({
                position: Vertices.centre(vertexSets[v2]),
                vertices: vertexSets[v2]
              }, options)));
            }
            return Bodies.flagCoincidentParts(parts);
          }
        };
        module2.exports = PhysicsEditorParser;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Bodies = __webpack_require__(86);
        var Body = __webpack_require__(41);
        var PhysicsJSONParser = {
          parseBody: function(x2, y2, config, options) {
            if (options === void 0) {
              options = {};
            }
            var body;
            var vertexSets = config.vertices;
            if (vertexSets.length === 1) {
              options.vertices = vertexSets[0];
              body = Body.create(options);
              Bodies.flagCoincidentParts(body.parts);
            } else {
              var parts = [];
              for (var i2 = 0; i2 < vertexSets.length; i2++) {
                var part = Body.create({
                  vertices: vertexSets[i2]
                });
                parts.push(part);
              }
              Bodies.flagCoincidentParts(parts);
              options.parts = parts;
              body = Body.create(options);
            }
            body.label = config.label;
            Body.setPosition(body, { x: x2, y: y2 });
            return body;
          }
        };
        module2.exports = PhysicsJSONParser;
      },
      function(module2, exports2, __webpack_require__) {
        var Composites = {};
        module2.exports = Composites;
        var Composite = __webpack_require__(118);
        var Constraint = __webpack_require__(128);
        var Common = __webpack_require__(32);
        var Body = __webpack_require__(41);
        var Bodies = __webpack_require__(86);
        (function() {
          Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
            var stack = Composite.create({ label: "Stack" }), x2 = xx, y2 = yy, lastBody, i2 = 0;
            for (var row = 0; row < rows; row++) {
              var maxHeight = 0;
              for (var column = 0; column < columns; column++) {
                var body = callback(x2, y2, column, row, lastBody, i2);
                if (body) {
                  var bodyHeight = body.bounds.max.y - body.bounds.min.y, bodyWidth = body.bounds.max.x - body.bounds.min.x;
                  if (bodyHeight > maxHeight)
                    maxHeight = bodyHeight;
                  Body.translate(body, { x: bodyWidth * 0.5, y: bodyHeight * 0.5 });
                  x2 = body.bounds.max.x + columnGap;
                  Composite.addBody(stack, body);
                  lastBody = body;
                  i2 += 1;
                } else {
                  x2 += columnGap;
                }
              }
              y2 += maxHeight + rowGap;
              x2 = xx;
            }
            return stack;
          };
          Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
            var bodies = composite.bodies;
            for (var i2 = 1; i2 < bodies.length; i2++) {
              var bodyA = bodies[i2 - 1], bodyB = bodies[i2], bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y, bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y, bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;
              var defaults = {
                bodyA,
                pointA: { x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA },
                bodyB,
                pointB: { x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB }
              };
              var constraint = Common.extend(defaults, options);
              Composite.addConstraint(composite, Constraint.create(constraint));
            }
            composite.label += " Chain";
            return composite;
          };
          Composites.mesh = function(composite, columns, rows, crossBrace, options) {
            var bodies = composite.bodies, row, col, bodyA, bodyB, bodyC;
            for (row = 0; row < rows; row++) {
              for (col = 1; col < columns; col++) {
                bodyA = bodies[col - 1 + row * columns];
                bodyB = bodies[col + row * columns];
                Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA, bodyB }, options)));
              }
              if (row > 0) {
                for (col = 0; col < columns; col++) {
                  bodyA = bodies[col + (row - 1) * columns];
                  bodyB = bodies[col + row * columns];
                  Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA, bodyB }, options)));
                  if (crossBrace && col > 0) {
                    bodyC = bodies[col - 1 + (row - 1) * columns];
                    Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB }, options)));
                  }
                  if (crossBrace && col < columns - 1) {
                    bodyC = bodies[col + 1 + (row - 1) * columns];
                    Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB }, options)));
                  }
                }
              }
            }
            composite.label += " Mesh";
            return composite;
          };
          Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
            return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x2, y2, column, row, lastBody, i2) {
              var actualRows = Math.min(rows, Math.ceil(columns / 2)), lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;
              if (row > actualRows)
                return;
              row = actualRows - row;
              var start = row, end = columns - 1 - row;
              if (column < start || column > end)
                return;
              if (i2 === 1) {
                Body.translate(lastBody, { x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0 });
              }
              var xOffset = lastBody ? column * lastBodyWidth : 0;
              return callback(xx + xOffset + column * columnGap, y2, column, row, lastBody, i2);
            });
          };
          Composites.newtonsCradle = function(xx, yy, number, size, length) {
            var newtonsCradle = Composite.create({ label: "Newtons Cradle" });
            for (var i2 = 0; i2 < number; i2++) {
              var separation = 1.9, circle = Bodies.circle(xx + i2 * (size * separation), yy + length, size, { inertia: Infinity, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }), constraint = Constraint.create({ pointA: { x: xx + i2 * (size * separation), y: yy }, bodyB: circle });
              Composite.addBody(newtonsCradle, circle);
              Composite.addConstraint(newtonsCradle, constraint);
            }
            return newtonsCradle;
          };
          Composites.car = function(xx, yy, width, height, wheelSize) {
            var group = Body.nextGroup(true), wheelBase = 20, wheelAOffset = -width * 0.5 + wheelBase, wheelBOffset = width * 0.5 - wheelBase, wheelYOffset = 0;
            var car = Composite.create({ label: "Car" }), body = Bodies.rectangle(xx, yy, width, height, {
              collisionFilter: {
                group
              },
              chamfer: {
                radius: height * 0.5
              },
              density: 2e-4
            });
            var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, {
              collisionFilter: {
                group
              },
              friction: 0.8
            });
            var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, {
              collisionFilter: {
                group
              },
              friction: 0.8
            });
            var axelA = Constraint.create({
              bodyB: body,
              pointB: { x: wheelAOffset, y: wheelYOffset },
              bodyA: wheelA,
              stiffness: 1,
              length: 0
            });
            var axelB = Constraint.create({
              bodyB: body,
              pointB: { x: wheelBOffset, y: wheelYOffset },
              bodyA: wheelB,
              stiffness: 1,
              length: 0
            });
            Composite.addBody(car, body);
            Composite.addBody(car, wheelA);
            Composite.addBody(car, wheelB);
            Composite.addConstraint(car, axelA);
            Composite.addConstraint(car, axelB);
            return car;
          };
          Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
            particleOptions = Common.extend({ inertia: Infinity }, particleOptions);
            constraintOptions = Common.extend({ stiffness: 0.2, render: { type: "line", anchors: false } }, constraintOptions);
            var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x2, y2) {
              return Bodies.circle(x2, y2, particleRadius, particleOptions);
            });
            Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);
            softBody.label = "Soft Body";
            return softBody;
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        var Svg = {};
        module2.exports = Svg;
        __webpack_require__(84);
        var Common = __webpack_require__(32);
        (function() {
          Svg.pathToVertices = function(path, sampleLength) {
            if (typeof window !== "undefined" && !("SVGPathSeg" in window)) {
              Common.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
            }
            var i2, il2, total, point, segment, segments, segmentsQueue, lastSegment, lastPoint, segmentIndex, points = [], lx, ly, length = 0, x2 = 0, y2 = 0;
            sampleLength = sampleLength || 15;
            var addPoint = function(px, py, pathSegType) {
              var isRelative = pathSegType % 2 === 1 && pathSegType > 1;
              if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {
                if (lastPoint && isRelative) {
                  lx = lastPoint.x;
                  ly = lastPoint.y;
                } else {
                  lx = 0;
                  ly = 0;
                }
                var point2 = {
                  x: lx + px,
                  y: ly + py
                };
                if (isRelative || !lastPoint) {
                  lastPoint = point2;
                }
                points.push(point2);
                x2 = lx + px;
                y2 = ly + py;
              }
            };
            var addSegmentPoint = function(segment2) {
              var segType = segment2.pathSegTypeAsLetter.toUpperCase();
              if (segType === "Z")
                return;
              switch (segType) {
                case "M":
                case "L":
                case "T":
                case "C":
                case "S":
                case "Q":
                  x2 = segment2.x;
                  y2 = segment2.y;
                  break;
                case "H":
                  x2 = segment2.x;
                  break;
                case "V":
                  y2 = segment2.y;
                  break;
              }
              addPoint(x2, y2, segment2.pathSegType);
            };
            Svg._svgPathToAbsolute(path);
            total = path.getTotalLength();
            segments = [];
            for (i2 = 0; i2 < path.pathSegList.numberOfItems; i2 += 1)
              segments.push(path.pathSegList.getItem(i2));
            segmentsQueue = segments.concat();
            while (length < total) {
              segmentIndex = path.getPathSegAtLength(length);
              segment = segments[segmentIndex];
              if (segment != lastSegment) {
                while (segmentsQueue.length && segmentsQueue[0] != segment)
                  addSegmentPoint(segmentsQueue.shift());
                lastSegment = segment;
              }
              switch (segment.pathSegTypeAsLetter.toUpperCase()) {
                case "C":
                case "T":
                case "S":
                case "Q":
                case "A":
                  point = path.getPointAtLength(length);
                  addPoint(point.x, point.y, 0);
                  break;
              }
              length += sampleLength;
            }
            for (i2 = 0, il2 = segmentsQueue.length; i2 < il2; ++i2)
              addSegmentPoint(segmentsQueue[i2]);
            return points;
          };
          Svg._svgPathToAbsolute = function(path) {
            var x0, y0, x1, y1, x2, y2, segs = path.pathSegList, x3 = 0, y3 = 0, len = segs.numberOfItems;
            for (var i2 = 0; i2 < len; ++i2) {
              var seg = segs.getItem(i2), segType = seg.pathSegTypeAsLetter;
              if (/[MLHVCSQTA]/.test(segType)) {
                if ("x" in seg)
                  x3 = seg.x;
                if ("y" in seg)
                  y3 = seg.y;
              } else {
                if ("x1" in seg)
                  x1 = x3 + seg.x1;
                if ("x2" in seg)
                  x2 = x3 + seg.x2;
                if ("y1" in seg)
                  y1 = y3 + seg.y1;
                if ("y2" in seg)
                  y2 = y3 + seg.y2;
                if ("x" in seg)
                  x3 += seg.x;
                if ("y" in seg)
                  y3 += seg.y;
                switch (segType) {
                  case "m":
                    segs.replaceItem(path.createSVGPathSegMovetoAbs(x3, y3), i2);
                    break;
                  case "l":
                    segs.replaceItem(path.createSVGPathSegLinetoAbs(x3, y3), i2);
                    break;
                  case "h":
                    segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x3), i2);
                    break;
                  case "v":
                    segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y3), i2);
                    break;
                  case "c":
                    segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x3, y3, x1, y1, x2, y2), i2);
                    break;
                  case "s":
                    segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x3, y3, x2, y2), i2);
                    break;
                  case "q":
                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x3, y3, x1, y1), i2);
                    break;
                  case "t":
                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x3, y3), i2);
                    break;
                  case "a":
                    segs.replaceItem(path.createSVGPathSegArcAbs(x3, y3, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i2);
                    break;
                  case "z":
                  case "Z":
                    x3 = x0;
                    y3 = y0;
                    break;
                }
              }
              if (segType == "M" || segType == "m") {
                x0 = x3;
                y0 = y3;
              }
            }
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Bodies = __webpack_require__(86);
        var Body = __webpack_require__(41);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(249);
        var EventEmitter = __webpack_require__(9);
        var GetFastValue = __webpack_require__(2);
        var HasValue = __webpack_require__(126);
        var Vertices = __webpack_require__(64);
        var MatterTileBody = new Class({
          Extends: EventEmitter,
          Mixins: [
            Components.Bounce,
            Components.Collision,
            Components.Friction,
            Components.Gravity,
            Components.Mass,
            Components.Sensor,
            Components.Sleep,
            Components.Static
          ],
          initialize: function MatterTileBody2(world, tile, options) {
            EventEmitter.call(this);
            this.tile = tile;
            this.world = world;
            if (tile.physics.matterBody) {
              tile.physics.matterBody.destroy();
            }
            tile.physics.matterBody = this;
            var body = GetFastValue(options, "body", null);
            var addToWorld = GetFastValue(options, "addToWorld", true);
            if (!body) {
              var collisionGroup = tile.getCollisionGroup();
              var collisionObjects = GetFastValue(collisionGroup, "objects", []);
              if (collisionObjects.length > 0) {
                this.setFromTileCollision(options);
              } else {
                this.setFromTileRectangle(options);
              }
            } else {
              this.setBody(body, addToWorld);
            }
          },
          setFromTileRectangle: function(options) {
            if (options === void 0) {
              options = {};
            }
            if (!HasValue(options, "isStatic")) {
              options.isStatic = true;
            }
            if (!HasValue(options, "addToWorld")) {
              options.addToWorld = true;
            }
            var bounds = this.tile.getBounds();
            var cx = bounds.x + bounds.width / 2;
            var cy = bounds.y + bounds.height / 2;
            var body = Bodies.rectangle(cx, cy, bounds.width, bounds.height, options);
            this.setBody(body, options.addToWorld);
            return this;
          },
          setFromTileCollision: function(options) {
            if (options === void 0) {
              options = {};
            }
            if (!HasValue(options, "isStatic")) {
              options.isStatic = true;
            }
            if (!HasValue(options, "addToWorld")) {
              options.addToWorld = true;
            }
            var sx = this.tile.tilemapLayer.scaleX;
            var sy = this.tile.tilemapLayer.scaleY;
            var tileX = this.tile.getLeft();
            var tileY = this.tile.getTop();
            var collisionGroup = this.tile.getCollisionGroup();
            var collisionObjects = GetFastValue(collisionGroup, "objects", []);
            var parts = [];
            for (var i2 = 0; i2 < collisionObjects.length; i2++) {
              var object = collisionObjects[i2];
              var ox = tileX + object.x * sx;
              var oy = tileY + object.y * sy;
              var ow = object.width * sx;
              var oh2 = object.height * sy;
              var body = null;
              if (object.rectangle) {
                body = Bodies.rectangle(ox + ow / 2, oy + oh2 / 2, ow, oh2, options);
              } else if (object.ellipse) {
                body = Bodies.circle(ox + ow / 2, oy + oh2 / 2, ow / 2, options);
              } else if (object.polygon || object.polyline) {
                var originalPoints = object.polygon ? object.polygon : object.polyline;
                var points = originalPoints.map(function(p2) {
                  return { x: p2.x * sx, y: p2.y * sy };
                });
                var vertices = Vertices.create(points);
                var center = Vertices.centre(vertices);
                ox += center.x;
                oy += center.y;
                body = Bodies.fromVertices(ox, oy, vertices, options);
              }
              if (body) {
                parts.push(body);
              }
            }
            if (parts.length === 1) {
              this.setBody(parts[0], options.addToWorld);
            } else if (parts.length > 1) {
              options.parts = parts;
              this.setBody(Body.create(options), options.addToWorld);
            }
            return this;
          },
          setBody: function(body, addToWorld) {
            if (addToWorld === void 0) {
              addToWorld = true;
            }
            if (this.body) {
              this.removeBody();
            }
            this.body = body;
            this.body.gameObject = this;
            if (addToWorld) {
              this.world.add(this.body);
            }
            return this;
          },
          removeBody: function() {
            if (this.body) {
              this.world.remove(this.body);
              this.body.gameObject = void 0;
              this.body = void 0;
            }
            return this;
          },
          destroy: function() {
            this.removeBody();
            this.tile.physics.matterBody = void 0;
            this.removeAllListeners();
          }
        });
        module2.exports = MatterTileBody;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Matter = __webpack_require__(1399);
        Matter.Body = __webpack_require__(41);
        Matter.Composite = __webpack_require__(118);
        Matter.World = __webpack_require__(596);
        Matter.Detector = __webpack_require__(273);
        Matter.Grid = __webpack_require__(597);
        Matter.Pairs = __webpack_require__(598);
        Matter.Pair = __webpack_require__(250);
        Matter.Query = __webpack_require__(1400);
        Matter.Resolver = __webpack_require__(599);
        Matter.SAT = __webpack_require__(274);
        Matter.Constraint = __webpack_require__(128);
        Matter.Common = __webpack_require__(32);
        Matter.Engine = __webpack_require__(1401);
        Matter.Events = __webpack_require__(166);
        Matter.Sleeping = __webpack_require__(165);
        Matter.Plugin = __webpack_require__(595);
        Matter.Bodies = __webpack_require__(86);
        Matter.Composites = __webpack_require__(591);
        Matter.Axes = __webpack_require__(271);
        Matter.Bounds = __webpack_require__(84);
        Matter.Svg = __webpack_require__(592);
        Matter.Vector = __webpack_require__(83);
        Matter.Vertices = __webpack_require__(64);
        Matter.World.add = Matter.Composite.add;
        Matter.World.remove = Matter.Composite.remove;
        Matter.World.addComposite = Matter.Composite.addComposite;
        Matter.World.addBody = Matter.Composite.addBody;
        Matter.World.addConstraint = Matter.Composite.addConstraint;
        Matter.World.clear = Matter.Composite.clear;
        module2.exports = Matter;
      },
      function(module2, exports2, __webpack_require__) {
        var Plugin = {};
        module2.exports = Plugin;
        var Common = __webpack_require__(32);
        (function() {
          Plugin._registry = {};
          Plugin.register = function(plugin) {
            if (!Plugin.isPlugin(plugin)) {
              Common.warn("Plugin.register:", Plugin.toString(plugin), "does not implement all required fields.");
            }
            if (plugin.name in Plugin._registry) {
              var registered = Plugin._registry[plugin.name], pluginVersion = Plugin.versionParse(plugin.version).number, registeredVersion = Plugin.versionParse(registered.version).number;
              if (pluginVersion > registeredVersion) {
                Common.warn("Plugin.register:", Plugin.toString(registered), "was upgraded to", Plugin.toString(plugin));
                Plugin._registry[plugin.name] = plugin;
              } else if (pluginVersion < registeredVersion) {
                Common.warn("Plugin.register:", Plugin.toString(registered), "can not be downgraded to", Plugin.toString(plugin));
              } else if (plugin !== registered) {
                Common.warn("Plugin.register:", Plugin.toString(plugin), "is already registered to different plugin object");
              }
            } else {
              Plugin._registry[plugin.name] = plugin;
            }
            return plugin;
          };
          Plugin.resolve = function(dependency) {
            return Plugin._registry[Plugin.dependencyParse(dependency).name];
          };
          Plugin.toString = function(plugin) {
            return typeof plugin === "string" ? plugin : (plugin.name || "anonymous") + "@" + (plugin.version || plugin.range || "0.0.0");
          };
          Plugin.isPlugin = function(obj) {
            return obj && obj.name && obj.version && obj.install;
          };
          Plugin.isUsed = function(module3, name) {
            return module3.used.indexOf(name) > -1;
          };
          Plugin.isFor = function(plugin, module3) {
            var parsed = plugin.for && Plugin.dependencyParse(plugin.for);
            return !plugin.for || module3.name === parsed.name && Plugin.versionSatisfies(module3.version, parsed.range);
          };
          Plugin.use = function(module3, plugins) {
            module3.uses = (module3.uses || []).concat(plugins || []);
            if (module3.uses.length === 0) {
              Common.warn("Plugin.use:", Plugin.toString(module3), "does not specify any dependencies to install.");
              return;
            }
            var dependencies = Plugin.dependencies(module3), sortedDependencies = Common.topologicalSort(dependencies), status = [];
            for (var i2 = 0; i2 < sortedDependencies.length; i2 += 1) {
              if (sortedDependencies[i2] === module3.name) {
                continue;
              }
              var plugin = Plugin.resolve(sortedDependencies[i2]);
              if (!plugin) {
                status.push("\u274C " + sortedDependencies[i2]);
                continue;
              }
              if (Plugin.isUsed(module3, plugin.name)) {
                continue;
              }
              if (!Plugin.isFor(plugin, module3)) {
                Common.warn("Plugin.use:", Plugin.toString(plugin), "is for", plugin.for, "but installed on", Plugin.toString(module3) + ".");
                plugin._warned = true;
              }
              if (plugin.install) {
                plugin.install(module3);
              } else {
                Common.warn("Plugin.use:", Plugin.toString(plugin), "does not specify an install function.");
                plugin._warned = true;
              }
              if (plugin._warned) {
                status.push("\u{1F536} " + Plugin.toString(plugin));
                delete plugin._warned;
              } else {
                status.push("\u2705 " + Plugin.toString(plugin));
              }
              module3.used.push(plugin.name);
            }
            if (status.length > 0 && !plugin.silent) {
              Common.info(status.join("  "));
            }
          };
          Plugin.dependencies = function(module3, tracked) {
            var parsedBase = Plugin.dependencyParse(module3), name = parsedBase.name;
            tracked = tracked || {};
            if (name in tracked) {
              return;
            }
            module3 = Plugin.resolve(module3) || module3;
            tracked[name] = Common.map(module3.uses || [], function(dependency) {
              if (Plugin.isPlugin(dependency)) {
                Plugin.register(dependency);
              }
              var parsed = Plugin.dependencyParse(dependency), resolved = Plugin.resolve(dependency);
              if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {
                Common.warn("Plugin.dependencies:", Plugin.toString(resolved), "does not satisfy", Plugin.toString(parsed), "used by", Plugin.toString(parsedBase) + ".");
                resolved._warned = true;
                module3._warned = true;
              } else if (!resolved) {
                Common.warn("Plugin.dependencies:", Plugin.toString(dependency), "used by", Plugin.toString(parsedBase), "could not be resolved.");
                module3._warned = true;
              }
              return parsed.name;
            });
            for (var i2 = 0; i2 < tracked[name].length; i2 += 1) {
              Plugin.dependencies(tracked[name][i2], tracked);
            }
            return tracked;
          };
          Plugin.dependencyParse = function(dependency) {
            if (Common.isString(dependency)) {
              var pattern = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/;
              if (!pattern.test(dependency)) {
                Common.warn("Plugin.dependencyParse:", dependency, "is not a valid dependency string.");
              }
              return {
                name: dependency.split("@")[0],
                range: dependency.split("@")[1] || "*"
              };
            }
            return {
              name: dependency.name,
              range: dependency.range || dependency.version
            };
          };
          Plugin.versionParse = function(range) {
            var pattern = /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/;
            if (!pattern.test(range)) {
              Common.warn("Plugin.versionParse:", range, "is not a valid version or range.");
            }
            var identifiers = range.split("-");
            range = identifiers[0];
            var isRange = isNaN(Number(range[0])), version = isRange ? range.substr(1) : range, parts = Common.map(version.split("."), function(part) {
              return Number(part);
            });
            return {
              isRange,
              version,
              range,
              operator: isRange ? range[0] : "",
              parts,
              prerelease: identifiers[1],
              number: parts[0] * 1e8 + parts[1] * 1e4 + parts[2]
            };
          };
          Plugin.versionSatisfies = function(version, range) {
            range = range || "*";
            var rangeParsed = Plugin.versionParse(range), rangeParts = rangeParsed.parts, versionParsed = Plugin.versionParse(version), versionParts = versionParsed.parts;
            if (rangeParsed.isRange) {
              if (rangeParsed.operator === "*" || version === "*") {
                return true;
              }
              if (rangeParsed.operator === "~") {
                return versionParts[0] === rangeParts[0] && versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
              }
              if (rangeParsed.operator === "^") {
                if (rangeParts[0] > 0) {
                  return versionParts[0] === rangeParts[0] && versionParsed.number >= rangeParsed.number;
                }
                if (rangeParts[1] > 0) {
                  return versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
                }
                return versionParts[2] === rangeParts[2];
              }
            }
            return version === range || version === "*";
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        var World = {};
        module2.exports = World;
        var Composite = __webpack_require__(118);
        __webpack_require__(128);
        var Common = __webpack_require__(32);
        (function() {
          World.create = function(options) {
            var composite = Composite.create();
            var defaults = {
              label: "World",
              gravity: {
                x: 0,
                y: 1,
                scale: 1e-3
              },
              bounds: {
                min: { x: -Infinity, y: -Infinity },
                max: { x: Infinity, y: Infinity }
              }
            };
            return Common.extend(composite, defaults, options);
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        var Grid = {};
        module2.exports = Grid;
        var Pair = __webpack_require__(250);
        var Detector = __webpack_require__(273);
        var Common = __webpack_require__(32);
        (function() {
          Grid.create = function(options) {
            var defaults = {
              controller: Grid,
              detector: Detector.collisions,
              buckets: {},
              pairs: {},
              pairsList: [],
              bucketWidth: 48,
              bucketHeight: 48
            };
            return Common.extend(defaults, options);
          };
          Grid.update = function(grid, bodies, engine, forceUpdate) {
            var i2, col, row, world = engine.world, buckets = grid.buckets, bucket, bucketId, gridChanged = false;
            var metrics = engine.metrics;
            metrics.broadphaseTests = 0;
            for (i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2];
              if (body.isSleeping && !forceUpdate)
                continue;
              if (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y)
                continue;
              var newRegion = Grid._getRegion(grid, body);
              if (!body.region || newRegion.id !== body.region.id || forceUpdate) {
                metrics.broadphaseTests += 1;
                if (!body.region || forceUpdate)
                  body.region = newRegion;
                var union = Grid._regionUnion(newRegion, body.region);
                for (col = union.startCol; col <= union.endCol; col++) {
                  for (row = union.startRow; row <= union.endRow; row++) {
                    bucketId = Grid._getBucketId(col, row);
                    bucket = buckets[bucketId];
                    var isInsideNewRegion = col >= newRegion.startCol && col <= newRegion.endCol && row >= newRegion.startRow && row <= newRegion.endRow;
                    var isInsideOldRegion = col >= body.region.startCol && col <= body.region.endCol && row >= body.region.startRow && row <= body.region.endRow;
                    if (!isInsideNewRegion && isInsideOldRegion) {
                      if (isInsideOldRegion) {
                        if (bucket)
                          Grid._bucketRemoveBody(grid, bucket, body);
                      }
                    }
                    if (body.region === newRegion || isInsideNewRegion && !isInsideOldRegion || forceUpdate) {
                      if (!bucket)
                        bucket = Grid._createBucket(buckets, bucketId);
                      Grid._bucketAddBody(grid, bucket, body);
                    }
                  }
                }
                body.region = newRegion;
                gridChanged = true;
              }
            }
            if (gridChanged)
              grid.pairsList = Grid._createActivePairsList(grid);
          };
          Grid.clear = function(grid) {
            grid.buckets = {};
            grid.pairs = {};
            grid.pairsList = [];
          };
          Grid._regionUnion = function(regionA, regionB) {
            var startCol = Math.min(regionA.startCol, regionB.startCol), endCol = Math.max(regionA.endCol, regionB.endCol), startRow = Math.min(regionA.startRow, regionB.startRow), endRow = Math.max(regionA.endRow, regionB.endRow);
            return Grid._createRegion(startCol, endCol, startRow, endRow);
          };
          Grid._getRegion = function(grid, body) {
            var bounds = body.bounds, startCol = Math.floor(bounds.min.x / grid.bucketWidth), endCol = Math.floor(bounds.max.x / grid.bucketWidth), startRow = Math.floor(bounds.min.y / grid.bucketHeight), endRow = Math.floor(bounds.max.y / grid.bucketHeight);
            return Grid._createRegion(startCol, endCol, startRow, endRow);
          };
          Grid._createRegion = function(startCol, endCol, startRow, endRow) {
            return {
              id: startCol + "," + endCol + "," + startRow + "," + endRow,
              startCol,
              endCol,
              startRow,
              endRow
            };
          };
          Grid._getBucketId = function(column, row) {
            return "C" + column + "R" + row;
          };
          Grid._createBucket = function(buckets, bucketId) {
            var bucket = buckets[bucketId] = [];
            return bucket;
          };
          Grid._bucketAddBody = function(grid, bucket, body) {
            for (var i2 = 0; i2 < bucket.length; i2++) {
              var bodyB = bucket[i2];
              if (body.id === bodyB.id || body.isStatic && bodyB.isStatic)
                continue;
              var pairId = Pair.id(body, bodyB), pair = grid.pairs[pairId];
              if (pair) {
                pair[2] += 1;
              } else {
                grid.pairs[pairId] = [body, bodyB, 1];
              }
            }
            bucket.push(body);
          };
          Grid._bucketRemoveBody = function(grid, bucket, body) {
            bucket.splice(bucket.indexOf(body), 1);
            for (var i2 = 0; i2 < bucket.length; i2++) {
              var bodyB = bucket[i2], pairId = Pair.id(body, bodyB), pair = grid.pairs[pairId];
              if (pair)
                pair[2] -= 1;
            }
          };
          Grid._createActivePairsList = function(grid) {
            var pairKeys, pair, pairs = [];
            pairKeys = Common.keys(grid.pairs);
            for (var k2 = 0; k2 < pairKeys.length; k2++) {
              pair = grid.pairs[pairKeys[k2]];
              if (pair[2] > 0) {
                pairs.push(pair);
              } else {
                delete grid.pairs[pairKeys[k2]];
              }
            }
            return pairs;
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        var Pairs = {};
        module2.exports = Pairs;
        var Pair = __webpack_require__(250);
        var Common = __webpack_require__(32);
        (function() {
          Pairs._pairMaxIdleLife = 1e3;
          Pairs.create = function(options) {
            return Common.extend({
              table: {},
              list: [],
              collisionStart: [],
              collisionActive: [],
              collisionEnd: []
            }, options);
          };
          Pairs.update = function(pairs, collisions, timestamp) {
            var pairsList = pairs.list, pairsTable = pairs.table, collisionStart = pairs.collisionStart, collisionEnd = pairs.collisionEnd, collisionActive = pairs.collisionActive, collision, pairId, pair, i2;
            collisionStart.length = 0;
            collisionEnd.length = 0;
            collisionActive.length = 0;
            for (i2 = 0; i2 < pairsList.length; i2++) {
              pairsList[i2].confirmedActive = false;
            }
            for (i2 = 0; i2 < collisions.length; i2++) {
              collision = collisions[i2];
              if (collision.collided) {
                pairId = Pair.id(collision.bodyA, collision.bodyB);
                pair = pairsTable[pairId];
                if (pair) {
                  if (pair.isActive) {
                    collisionActive.push(pair);
                  } else {
                    collisionStart.push(pair);
                  }
                  Pair.update(pair, collision, timestamp);
                  pair.confirmedActive = true;
                } else {
                  pair = Pair.create(collision, timestamp);
                  pairsTable[pairId] = pair;
                  collisionStart.push(pair);
                  pairsList.push(pair);
                }
              }
            }
            for (i2 = 0; i2 < pairsList.length; i2++) {
              pair = pairsList[i2];
              if (pair.isActive && !pair.confirmedActive) {
                Pair.setActive(pair, false, timestamp);
                collisionEnd.push(pair);
              }
            }
          };
          Pairs.removeOld = function(pairs, timestamp) {
            var pairsList = pairs.list, pairsTable = pairs.table, indexesToRemove = [], pair, collision, pairIndex, i2;
            for (i2 = 0; i2 < pairsList.length; i2++) {
              pair = pairsList[i2];
              collision = pair.collision;
              if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {
                pair.timeUpdated = timestamp;
                continue;
              }
              if (timestamp - pair.timeUpdated > Pairs._pairMaxIdleLife) {
                indexesToRemove.push(i2);
              }
            }
            for (i2 = 0; i2 < indexesToRemove.length; i2++) {
              pairIndex = indexesToRemove[i2] - i2;
              pair = pairsList[pairIndex];
              delete pairsTable[pair.id];
              pairsList.splice(pairIndex, 1);
            }
          };
          Pairs.clear = function(pairs) {
            pairs.table = {};
            pairs.list.length = 0;
            pairs.collisionStart.length = 0;
            pairs.collisionActive.length = 0;
            pairs.collisionEnd.length = 0;
            return pairs;
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        var Resolver = {};
        module2.exports = Resolver;
        var Vertices = __webpack_require__(64);
        var Vector = __webpack_require__(83);
        var Common = __webpack_require__(32);
        var Bounds = __webpack_require__(84);
        (function() {
          Resolver._restingThresh = 4;
          Resolver._restingThreshTangent = 6;
          Resolver._positionDampen = 0.9;
          Resolver._positionWarming = 0.8;
          Resolver._frictionNormalMultiplier = 5;
          Resolver.preSolvePosition = function(pairs) {
            var i2, pair, activeCount;
            for (i2 = 0; i2 < pairs.length; i2++) {
              pair = pairs[i2];
              if (!pair.isActive)
                continue;
              activeCount = pair.activeContacts.length;
              pair.collision.parentA.totalContacts += activeCount;
              pair.collision.parentB.totalContacts += activeCount;
            }
          };
          Resolver.solvePosition = function(pairs, bodies, timeScale) {
            var i2, normalX, normalY, pair, collision, bodyA, bodyB, normal, separation, penetration, positionImpulseA, positionImpulseB, contactShare, bodyBtoAX, bodyBtoAY, positionImpulse, impulseCoefficient = timeScale * Resolver._positionDampen;
            for (i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2];
              body.previousPositionImpulse.x = body.positionImpulse.x;
              body.previousPositionImpulse.y = body.positionImpulse.y;
            }
            for (i2 = 0; i2 < pairs.length; i2++) {
              pair = pairs[i2];
              if (!pair.isActive || pair.isSensor)
                continue;
              collision = pair.collision;
              bodyA = collision.parentA;
              bodyB = collision.parentB;
              normal = collision.normal;
              positionImpulseA = bodyA.previousPositionImpulse;
              positionImpulseB = bodyB.previousPositionImpulse;
              penetration = collision.penetration;
              bodyBtoAX = positionImpulseB.x - positionImpulseA.x + penetration.x;
              bodyBtoAY = positionImpulseB.y - positionImpulseA.y + penetration.y;
              normalX = normal.x;
              normalY = normal.y;
              separation = normalX * bodyBtoAX + normalY * bodyBtoAY;
              pair.separation = separation;
              positionImpulse = (separation - pair.slop) * impulseCoefficient;
              if (bodyA.isStatic || bodyB.isStatic)
                positionImpulse *= 2;
              if (!(bodyA.isStatic || bodyA.isSleeping)) {
                contactShare = positionImpulse / bodyA.totalContacts;
                bodyA.positionImpulse.x += normalX * contactShare;
                bodyA.positionImpulse.y += normalY * contactShare;
              }
              if (!(bodyB.isStatic || bodyB.isSleeping)) {
                contactShare = positionImpulse / bodyB.totalContacts;
                bodyB.positionImpulse.x -= normalX * contactShare;
                bodyB.positionImpulse.y -= normalY * contactShare;
              }
            }
          };
          Resolver.postSolvePosition = function(bodies) {
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2];
              body.totalContacts = 0;
              if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {
                for (var j = 0; j < body.parts.length; j++) {
                  var part = body.parts[j];
                  Vertices.translate(part.vertices, body.positionImpulse);
                  Bounds.update(part.bounds, part.vertices, body.velocity);
                  part.position.x += body.positionImpulse.x;
                  part.position.y += body.positionImpulse.y;
                }
                body.positionPrev.x += body.positionImpulse.x;
                body.positionPrev.y += body.positionImpulse.y;
                if (Vector.dot(body.positionImpulse, body.velocity) < 0) {
                  body.positionImpulse.x = 0;
                  body.positionImpulse.y = 0;
                } else {
                  body.positionImpulse.x *= Resolver._positionWarming;
                  body.positionImpulse.y *= Resolver._positionWarming;
                }
              }
            }
          };
          Resolver.preSolveVelocity = function(pairs) {
            var i2, j, pair, contacts, collision, bodyA, bodyB, normal, tangent, contact, contactVertex, normalImpulse, tangentImpulse, offset, impulse = Vector._temp[0], tempA = Vector._temp[1];
            for (i2 = 0; i2 < pairs.length; i2++) {
              pair = pairs[i2];
              if (!pair.isActive || pair.isSensor)
                continue;
              contacts = pair.activeContacts;
              collision = pair.collision;
              bodyA = collision.parentA;
              bodyB = collision.parentB;
              normal = collision.normal;
              tangent = collision.tangent;
              for (j = 0; j < contacts.length; j++) {
                contact = contacts[j];
                contactVertex = contact.vertex;
                normalImpulse = contact.normalImpulse;
                tangentImpulse = contact.tangentImpulse;
                if (normalImpulse !== 0 || tangentImpulse !== 0) {
                  impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;
                  impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse;
                  if (!(bodyA.isStatic || bodyA.isSleeping)) {
                    offset = Vector.sub(contactVertex, bodyA.position, tempA);
                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                    bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;
                  }
                  if (!(bodyB.isStatic || bodyB.isSleeping)) {
                    offset = Vector.sub(contactVertex, bodyB.position, tempA);
                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                    bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;
                  }
                }
              }
            }
          };
          Resolver.solveVelocity = function(pairs, timeScale) {
            var timeScaleSquared = timeScale * timeScale, impulse = Vector._temp[0], tempA = Vector._temp[1], tempB = Vector._temp[2], tempC = Vector._temp[3], tempD = Vector._temp[4], tempE = Vector._temp[5];
            for (var i2 = 0; i2 < pairs.length; i2++) {
              var pair = pairs[i2];
              if (!pair.isActive || pair.isSensor)
                continue;
              var collision = pair.collision, bodyA = collision.parentA, bodyB = collision.parentB, normal = collision.normal, tangent = collision.tangent, contacts = pair.activeContacts, contactShare = 1 / contacts.length;
              bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;
              bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;
              bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;
              bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;
              bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;
              bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;
              for (var j = 0; j < contacts.length; j++) {
                var contact = contacts[j], contactVertex = contact.vertex, offsetA = Vector.sub(contactVertex, bodyA.position, tempA), offsetB = Vector.sub(contactVertex, bodyB.position, tempB), velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC), velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD), relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE), normalVelocity = Vector.dot(normal, relativeVelocity);
                var tangentVelocity = Vector.dot(tangent, relativeVelocity), tangentSpeed = Math.abs(tangentVelocity), tangentVelocityDirection = Common.sign(tangentVelocity);
                var normalImpulse = (1 + pair.restitution) * normalVelocity, normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;
                var tangentImpulse = tangentVelocity, maxFriction = Infinity;
                if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {
                  maxFriction = tangentSpeed;
                  tangentImpulse = Common.clamp(pair.friction * tangentVelocityDirection * timeScaleSquared, -maxFriction, maxFriction);
                }
                var oAcN = Vector.cross(offsetA, normal), oBcN = Vector.cross(offsetB, normal), share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);
                normalImpulse *= share;
                tangentImpulse *= share;
                if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {
                  contact.normalImpulse = 0;
                } else {
                  var contactNormalImpulse = contact.normalImpulse;
                  contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);
                  normalImpulse = contact.normalImpulse - contactNormalImpulse;
                }
                if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {
                  contact.tangentImpulse = 0;
                } else {
                  var contactTangentImpulse = contact.tangentImpulse;
                  contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);
                  tangentImpulse = contact.tangentImpulse - contactTangentImpulse;
                }
                impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;
                impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse;
                if (!(bodyA.isStatic || bodyA.isSleeping)) {
                  bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                  bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                  bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;
                }
                if (!(bodyB.isStatic || bodyB.isSleeping)) {
                  bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                  bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                  bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;
                }
              }
            }
          };
        })();
      },
      function(module2, exports2) {
        var g2;
        g2 = function() {
          return this;
        }();
        try {
          g2 = g2 || new Function("return this")();
        } catch (e) {
          if (typeof window === "object")
            g2 = window;
        }
        module2.exports = g2;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       samme
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var QuickSet = __webpack_require__(276);
        var AlignTo = function(items, position, offsetX, offsetY) {
          var target = items[0];
          for (var i2 = 1; i2 < items.length; i2++) {
            var item = items[i2];
            QuickSet(item, target, position, offsetX, offsetY);
            target = item;
          }
          return items;
        };
        module2.exports = AlignTo;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueInc = __webpack_require__(46);
        var Angle = function(items, value, step, index2, direction) {
          return PropertyValueInc(items, "angle", value, step, index2, direction);
        };
        module2.exports = Angle;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Call = function(items, callback, context) {
          for (var i2 = 0; i2 < items.length; i2++) {
            var item = items[i2];
            callback.call(context, item);
          }
          return items;
        };
        module2.exports = Call;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetFirst = function(items, compare, index2) {
          if (index2 === void 0) {
            index2 = 0;
          }
          for (var i2 = index2; i2 < items.length; i2++) {
            var item = items[i2];
            var match = true;
            for (var property in compare) {
              if (item[property] !== compare[property]) {
                match = false;
              }
            }
            if (match) {
              return item;
            }
          }
          return null;
        };
        module2.exports = GetFirst;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetLast = function(items, compare, index2) {
          if (index2 === void 0) {
            index2 = 0;
          }
          for (var i2 = index2; i2 < items.length; i2++) {
            var item = items[i2];
            var match = true;
            for (var property in compare) {
              if (item[property] !== compare[property]) {
                match = false;
              }
            }
            if (match) {
              return item;
            }
          }
          return null;
        };
        module2.exports = GetLast;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AlignIn = __webpack_require__(289);
        var CONST = __webpack_require__(123);
        var GetFastValue = __webpack_require__(2);
        var NOOP = __webpack_require__(1);
        var Zone = __webpack_require__(129);
        var tempZone = new Zone({ sys: { queueDepthSort: NOOP, events: { once: NOOP } } }, 0, 0, 1, 1);
        var GridAlign = function(items, options) {
          if (options === void 0) {
            options = {};
          }
          var widthSet = options.hasOwnProperty("width");
          var heightSet = options.hasOwnProperty("height");
          var width = GetFastValue(options, "width", -1);
          var height = GetFastValue(options, "height", -1);
          var cellWidth = GetFastValue(options, "cellWidth", 1);
          var cellHeight = GetFastValue(options, "cellHeight", cellWidth);
          var position = GetFastValue(options, "position", CONST.TOP_LEFT);
          var x2 = GetFastValue(options, "x", 0);
          var y2 = GetFastValue(options, "y", 0);
          var cx = 0;
          var cy = 0;
          var w2 = width * cellWidth;
          var h2 = height * cellHeight;
          tempZone.setPosition(x2, y2);
          tempZone.setSize(cellWidth, cellHeight);
          for (var i2 = 0; i2 < items.length; i2++) {
            AlignIn(items[i2], tempZone, position);
            if (widthSet && width === -1) {
              tempZone.x += cellWidth;
            } else if (heightSet && height === -1) {
              tempZone.y += cellHeight;
            } else if (heightSet && !widthSet) {
              cy += cellHeight;
              tempZone.y += cellHeight;
              if (cy === h2) {
                cy = 0;
                cx += cellWidth;
                tempZone.y = y2;
                tempZone.x += cellWidth;
                if (cx === w2) {
                  break;
                }
              }
            } else {
              cx += cellWidth;
              tempZone.x += cellWidth;
              if (cx === w2) {
                cx = 0;
                cy += cellHeight;
                tempZone.x = x2;
                tempZone.y += cellHeight;
                if (cy === h2) {
                  break;
                }
              }
            }
          }
          return items;
        };
        module2.exports = GridAlign;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clamp = __webpack_require__(18);
        var _FLAG = 2;
        var Alpha = {
          _alpha: 1,
          _alphaTL: 1,
          _alphaTR: 1,
          _alphaBL: 1,
          _alphaBR: 1,
          clearAlpha: function() {
            return this.setAlpha(1);
          },
          setAlpha: function(topLeft, topRight, bottomLeft, bottomRight) {
            if (topLeft === void 0) {
              topLeft = 1;
            }
            if (topRight === void 0) {
              this.alpha = topLeft;
            } else {
              this._alphaTL = Clamp(topLeft, 0, 1);
              this._alphaTR = Clamp(topRight, 0, 1);
              this._alphaBL = Clamp(bottomLeft, 0, 1);
              this._alphaBR = Clamp(bottomRight, 0, 1);
            }
            return this;
          },
          alpha: {
            get: function() {
              return this._alpha;
            },
            set: function(value) {
              var v2 = Clamp(value, 0, 1);
              this._alpha = v2;
              this._alphaTL = v2;
              this._alphaTR = v2;
              this._alphaBL = v2;
              this._alphaBR = v2;
              if (v2 === 0) {
                this.renderFlags &= ~_FLAG;
              } else {
                this.renderFlags |= _FLAG;
              }
            }
          },
          alphaTopLeft: {
            get: function() {
              return this._alphaTL;
            },
            set: function(value) {
              var v2 = Clamp(value, 0, 1);
              this._alphaTL = v2;
              if (v2 !== 0) {
                this.renderFlags |= _FLAG;
              }
            }
          },
          alphaTopRight: {
            get: function() {
              return this._alphaTR;
            },
            set: function(value) {
              var v2 = Clamp(value, 0, 1);
              this._alphaTR = v2;
              if (v2 !== 0) {
                this.renderFlags |= _FLAG;
              }
            }
          },
          alphaBottomLeft: {
            get: function() {
              return this._alphaBL;
            },
            set: function(value) {
              var v2 = Clamp(value, 0, 1);
              this._alphaBL = v2;
              if (v2 !== 0) {
                this.renderFlags |= _FLAG;
              }
            }
          },
          alphaBottomRight: {
            get: function() {
              return this._alphaBR;
            },
            set: function(value) {
              var v2 = Clamp(value, 0, 1);
              this._alphaBR = v2;
              if (v2 !== 0) {
                this.renderFlags |= _FLAG;
              }
            }
          }
        };
        module2.exports = Alpha;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ComputedSize = {
          width: 0,
          height: 0,
          displayWidth: {
            get: function() {
              return this.scaleX * this.width;
            },
            set: function(value) {
              this.scaleX = value / this.width;
            }
          },
          displayHeight: {
            get: function() {
              return this.scaleY * this.height;
            },
            set: function(value) {
              this.scaleY = value / this.height;
            }
          },
          setSize: function(width, height) {
            this.width = width;
            this.height = height;
            return this;
          },
          setDisplaySize: function(width, height) {
            this.displayWidth = width;
            this.displayHeight = height;
            return this;
          }
        };
        module2.exports = ComputedSize;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Crop = {
          texture: null,
          frame: null,
          isCropped: false,
          setCrop: function(x2, y2, width, height) {
            if (x2 === void 0) {
              this.isCropped = false;
            } else if (this.frame) {
              if (typeof x2 === "number") {
                this.frame.setCropUVs(this._crop, x2, y2, width, height, this.flipX, this.flipY);
              } else {
                var rect = x2;
                this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);
              }
              this.isCropped = true;
            }
            return this;
          },
          resetCropObject: function() {
            return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0 };
          }
        };
        module2.exports = Crop;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Flip = {
          flipX: false,
          flipY: false,
          toggleFlipX: function() {
            this.flipX = !this.flipX;
            return this;
          },
          toggleFlipY: function() {
            this.flipY = !this.flipY;
            return this;
          },
          setFlipX: function(value) {
            this.flipX = value;
            return this;
          },
          setFlipY: function(value) {
            this.flipY = value;
            return this;
          },
          setFlip: function(x2, y2) {
            this.flipX = x2;
            this.flipY = y2;
            return this;
          },
          resetFlip: function() {
            this.flipX = false;
            this.flipY = false;
            return this;
          }
        };
        module2.exports = Flip;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rectangle = __webpack_require__(10);
        var RotateAround = __webpack_require__(308);
        var Vector2 = __webpack_require__(3);
        var GetBounds = {
          prepareBoundsOutput: function(output, includeParent) {
            if (includeParent === void 0) {
              includeParent = false;
            }
            if (this.rotation !== 0) {
              RotateAround(output, this.x, this.y, this.rotation);
            }
            if (includeParent && this.parentContainer) {
              var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
              parentMatrix.transformPoint(output.x, output.y, output);
            }
            return output;
          },
          getCenter: function(output) {
            if (output === void 0) {
              output = new Vector2();
            }
            output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
            output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
            return output;
          },
          getTopLeft: function(output, includeParent) {
            if (!output) {
              output = new Vector2();
            }
            output.x = this.x - this.displayWidth * this.originX;
            output.y = this.y - this.displayHeight * this.originY;
            return this.prepareBoundsOutput(output, includeParent);
          },
          getTopCenter: function(output, includeParent) {
            if (!output) {
              output = new Vector2();
            }
            output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
            output.y = this.y - this.displayHeight * this.originY;
            return this.prepareBoundsOutput(output, includeParent);
          },
          getTopRight: function(output, includeParent) {
            if (!output) {
              output = new Vector2();
            }
            output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
            output.y = this.y - this.displayHeight * this.originY;
            return this.prepareBoundsOutput(output, includeParent);
          },
          getLeftCenter: function(output, includeParent) {
            if (!output) {
              output = new Vector2();
            }
            output.x = this.x - this.displayWidth * this.originX;
            output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
            return this.prepareBoundsOutput(output, includeParent);
          },
          getRightCenter: function(output, includeParent) {
            if (!output) {
              output = new Vector2();
            }
            output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
            output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
            return this.prepareBoundsOutput(output, includeParent);
          },
          getBottomLeft: function(output, includeParent) {
            if (!output) {
              output = new Vector2();
            }
            output.x = this.x - this.displayWidth * this.originX;
            output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
            return this.prepareBoundsOutput(output, includeParent);
          },
          getBottomCenter: function(output, includeParent) {
            if (!output) {
              output = new Vector2();
            }
            output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
            output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
            return this.prepareBoundsOutput(output, includeParent);
          },
          getBottomRight: function(output, includeParent) {
            if (!output) {
              output = new Vector2();
            }
            output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
            output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
            return this.prepareBoundsOutput(output, includeParent);
          },
          getBounds: function(output) {
            if (output === void 0) {
              output = new Rectangle();
            }
            var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;
            if (this.parentContainer) {
              var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
              this.getTopLeft(output);
              parentMatrix.transformPoint(output.x, output.y, output);
              TLx = output.x;
              TLy = output.y;
              this.getTopRight(output);
              parentMatrix.transformPoint(output.x, output.y, output);
              TRx = output.x;
              TRy = output.y;
              this.getBottomLeft(output);
              parentMatrix.transformPoint(output.x, output.y, output);
              BLx = output.x;
              BLy = output.y;
              this.getBottomRight(output);
              parentMatrix.transformPoint(output.x, output.y, output);
              BRx = output.x;
              BRy = output.y;
            } else {
              this.getTopLeft(output);
              TLx = output.x;
              TLy = output.y;
              this.getTopRight(output);
              TRx = output.x;
              TRy = output.y;
              this.getBottomLeft(output);
              BLx = output.x;
              BLy = output.y;
              this.getBottomRight(output);
              BRx = output.x;
              BRy = output.y;
            }
            output.x = Math.min(TLx, TRx, BLx, BRx);
            output.y = Math.min(TLy, TRy, BLy, BRy);
            output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;
            output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;
            return output;
          }
        };
        module2.exports = GetBounds;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "blur";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "boot";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "contextlost";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "contextrestored";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "destroy";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "focus";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "hidden";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pause";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "postrender";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "poststep";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "prerender";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "prestep";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "ready";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "resume";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "step";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "visible";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "postrender";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "prerender";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "render";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "resize";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Origin = {
          _originComponent: true,
          originX: 0.5,
          originY: 0.5,
          _displayOriginX: 0,
          _displayOriginY: 0,
          displayOriginX: {
            get: function() {
              return this._displayOriginX;
            },
            set: function(value) {
              this._displayOriginX = value;
              this.originX = value / this.width;
            }
          },
          displayOriginY: {
            get: function() {
              return this._displayOriginY;
            },
            set: function(value) {
              this._displayOriginY = value;
              this.originY = value / this.height;
            }
          },
          setOrigin: function(x2, y2) {
            if (x2 === void 0) {
              x2 = 0.5;
            }
            if (y2 === void 0) {
              y2 = x2;
            }
            this.originX = x2;
            this.originY = y2;
            return this.updateDisplayOrigin();
          },
          setOriginFromFrame: function() {
            if (!this.frame || !this.frame.customPivot) {
              return this.setOrigin();
            } else {
              this.originX = this.frame.pivotX;
              this.originY = this.frame.pivotY;
            }
            return this.updateDisplayOrigin();
          },
          setDisplayOrigin: function(x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = x2;
            }
            this.displayOriginX = x2;
            this.displayOriginY = y2;
            return this;
          },
          updateDisplayOrigin: function() {
            this._displayOriginX = this.originX * this.width;
            this._displayOriginY = this.originY * this.height;
            return this;
          }
        };
        module2.exports = Origin;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DegToRad = __webpack_require__(36);
        var GetBoolean = __webpack_require__(99);
        var GetValue = __webpack_require__(6);
        var TWEEN_CONST = __webpack_require__(100);
        var Vector2 = __webpack_require__(3);
        var PathFollower = {
          path: null,
          rotateToPath: false,
          pathRotationOffset: 0,
          pathOffset: null,
          pathVector: null,
          pathDelta: null,
          pathTween: null,
          pathConfig: null,
          _prevDirection: TWEEN_CONST.PLAYING_FORWARD,
          setPath: function(path, config) {
            if (config === void 0) {
              config = this.pathConfig;
            }
            var tween = this.pathTween;
            if (tween && tween.isPlaying()) {
              tween.stop();
            }
            this.path = path;
            if (config) {
              this.startFollow(config);
            }
            return this;
          },
          setRotateToPath: function(value, offset) {
            if (offset === void 0) {
              offset = 0;
            }
            this.rotateToPath = value;
            this.pathRotationOffset = offset;
            return this;
          },
          isFollowing: function() {
            var tween = this.pathTween;
            return tween && tween.isPlaying();
          },
          startFollow: function(config, startAt) {
            if (config === void 0) {
              config = {};
            }
            if (startAt === void 0) {
              startAt = 0;
            }
            var tween = this.pathTween;
            if (tween && tween.isPlaying()) {
              tween.stop();
            }
            if (typeof config === "number") {
              config = { duration: config };
            }
            config.from = GetValue(config, "from", 0);
            config.to = GetValue(config, "to", 1);
            var positionOnPath = GetBoolean(config, "positionOnPath", false);
            this.rotateToPath = GetBoolean(config, "rotateToPath", false);
            this.pathRotationOffset = GetValue(config, "rotationOffset", 0);
            var seek = GetValue(config, "startAt", startAt);
            if (seek) {
              config.onStart = function(tween2) {
                var tweenData = tween2.data[0];
                tweenData.progress = seek;
                tweenData.elapsed = tweenData.duration * seek;
                var v2 = tweenData.ease(tweenData.progress);
                tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v2;
                tweenData.target[tweenData.key] = tweenData.current;
              };
            }
            if (!this.pathOffset) {
              this.pathOffset = new Vector2(this.x, this.y);
            }
            if (!this.pathVector) {
              this.pathVector = new Vector2();
            }
            if (!this.pathDelta) {
              this.pathDelta = new Vector2();
            }
            this.pathDelta.reset();
            this.pathTween = this.scene.sys.tweens.addCounter(config);
            this.path.getStartPoint(this.pathOffset);
            if (positionOnPath) {
              this.x = this.pathOffset.x;
              this.y = this.pathOffset.y;
            }
            this.pathOffset.x = this.x - this.pathOffset.x;
            this.pathOffset.y = this.y - this.pathOffset.y;
            this._prevDirection = TWEEN_CONST.PLAYING_FORWARD;
            if (this.rotateToPath) {
              var nextPoint = this.path.getPoint(0.1);
              this.rotation = Math.atan2(nextPoint.y - this.y, nextPoint.x - this.x) + DegToRad(this.pathRotationOffset);
            }
            this.pathConfig = config;
            return this;
          },
          pauseFollow: function() {
            var tween = this.pathTween;
            if (tween && tween.isPlaying()) {
              tween.pause();
            }
            return this;
          },
          resumeFollow: function() {
            var tween = this.pathTween;
            if (tween && tween.isPaused()) {
              tween.resume();
            }
            return this;
          },
          stopFollow: function() {
            var tween = this.pathTween;
            if (tween && tween.isPlaying()) {
              tween.stop();
            }
            return this;
          },
          pathUpdate: function() {
            var tween = this.pathTween;
            if (tween) {
              var tweenData = tween.data[0];
              var pathDelta = this.pathDelta;
              var pathVector = this.pathVector;
              pathDelta.copy(pathVector).negate();
              if (tweenData.state === TWEEN_CONST.COMPLETE) {
                this.path.getPoint(1, pathVector);
                pathDelta.add(pathVector);
                pathVector.add(this.pathOffset);
                this.setPosition(pathVector.x, pathVector.y);
                return;
              } else if (tweenData.state !== TWEEN_CONST.PLAYING_FORWARD && tweenData.state !== TWEEN_CONST.PLAYING_BACKWARD) {
                return;
              }
              this.path.getPoint(tween.getValue(), pathVector);
              pathDelta.add(pathVector);
              pathVector.add(this.pathOffset);
              var oldX = this.x;
              var oldY = this.y;
              this.setPosition(pathVector.x, pathVector.y);
              var speedX = this.x - oldX;
              var speedY = this.y - oldY;
              if (speedX === 0 && speedY === 0) {
                return;
              }
              if (tweenData.state !== this._prevDirection) {
                this._prevDirection = tweenData.state;
                return;
              }
              if (this.rotateToPath) {
                this.rotation = Math.atan2(speedY, speedX) + DegToRad(this.pathRotationOffset);
              }
            }
          }
        };
        module2.exports = PathFollower;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Size = {
          _sizeComponent: true,
          width: 0,
          height: 0,
          displayWidth: {
            get: function() {
              return Math.abs(this.scaleX * this.frame.realWidth);
            },
            set: function(value) {
              this.scaleX = value / this.frame.realWidth;
            }
          },
          displayHeight: {
            get: function() {
              return Math.abs(this.scaleY * this.frame.realHeight);
            },
            set: function(value) {
              this.scaleY = value / this.frame.realHeight;
            }
          },
          setSizeToFrame: function(frame) {
            if (frame === void 0) {
              frame = this.frame;
            }
            this.width = frame.realWidth;
            this.height = frame.realHeight;
            return this;
          },
          setSize: function(width, height) {
            this.width = width;
            this.height = height;
            return this;
          },
          setDisplaySize: function(width, height) {
            this.displayWidth = width;
            this.displayHeight = height;
            return this;
          }
        };
        module2.exports = Size;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var _FLAG = 8;
        var Texture = {
          texture: null,
          frame: null,
          isCropped: false,
          setTexture: function(key, frame) {
            this.texture = this.scene.sys.textures.get(key);
            return this.setFrame(frame);
          },
          setFrame: function(frame, updateSize, updateOrigin) {
            if (updateSize === void 0) {
              updateSize = true;
            }
            if (updateOrigin === void 0) {
              updateOrigin = true;
            }
            this.frame = this.texture.get(frame);
            if (!this.frame.cutWidth || !this.frame.cutHeight) {
              this.renderFlags &= ~_FLAG;
            } else {
              this.renderFlags |= _FLAG;
            }
            if (this._sizeComponent && updateSize) {
              this.setSizeToFrame();
            }
            if (this._originComponent && updateOrigin) {
              if (this.frame.customPivot) {
                this.setOrigin(this.frame.pivotX, this.frame.pivotY);
              } else {
                this.updateDisplayOrigin();
              }
            }
            return this;
          }
        };
        module2.exports = Texture;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var _FLAG = 8;
        var TextureCrop = {
          texture: null,
          frame: null,
          isCropped: false,
          setCrop: function(x2, y2, width, height) {
            if (x2 === void 0) {
              this.isCropped = false;
            } else if (this.frame) {
              if (typeof x2 === "number") {
                this.frame.setCropUVs(this._crop, x2, y2, width, height, this.flipX, this.flipY);
              } else {
                var rect = x2;
                this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);
              }
              this.isCropped = true;
            }
            return this;
          },
          setTexture: function(key, frame) {
            this.texture = this.scene.sys.textures.get(key);
            return this.setFrame(frame);
          },
          setFrame: function(frame, updateSize, updateOrigin) {
            if (updateSize === void 0) {
              updateSize = true;
            }
            if (updateOrigin === void 0) {
              updateOrigin = true;
            }
            this.frame = this.texture.get(frame);
            if (!this.frame.cutWidth || !this.frame.cutHeight) {
              this.renderFlags &= ~_FLAG;
            } else {
              this.renderFlags |= _FLAG;
            }
            if (this._sizeComponent && updateSize) {
              this.setSizeToFrame();
            }
            if (this._originComponent && updateOrigin) {
              if (this.frame.customPivot) {
                this.setOrigin(this.frame.pivotX, this.frame.pivotY);
              } else {
                this.updateDisplayOrigin();
              }
            }
            if (this.isCropped) {
              this.frame.updateCropUVs(this._crop, this.flipX, this.flipY);
            }
            return this;
          },
          resetCropObject: function() {
            return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0 };
          }
        };
        module2.exports = TextureCrop;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Tint = {
          tintTopLeft: 16777215,
          tintTopRight: 16777215,
          tintBottomLeft: 16777215,
          tintBottomRight: 16777215,
          tintFill: false,
          clearTint: function() {
            this.setTint(16777215);
            return this;
          },
          setTint: function(topLeft, topRight, bottomLeft, bottomRight) {
            if (topLeft === void 0) {
              topLeft = 16777215;
            }
            if (topRight === void 0) {
              topRight = topLeft;
              bottomLeft = topLeft;
              bottomRight = topLeft;
            }
            this.tintTopLeft = topLeft;
            this.tintTopRight = topRight;
            this.tintBottomLeft = bottomLeft;
            this.tintBottomRight = bottomRight;
            this.tintFill = false;
            return this;
          },
          setTintFill: function(topLeft, topRight, bottomLeft, bottomRight) {
            this.setTint(topLeft, topRight, bottomLeft, bottomRight);
            this.tintFill = true;
            return this;
          },
          tint: {
            set: function(value) {
              this.setTint(value, value, value, value);
            }
          },
          isTinted: {
            get: function() {
              var white = 16777215;
              return this.tintFill || this.tintTopLeft !== white || this.tintTopRight !== white || this.tintBottomLeft !== white || this.tintBottomRight !== white;
            }
          }
        };
        module2.exports = Tint;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "changedata";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "changedata-";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "destroy";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "removedata";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "setdata";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "addedtoscene";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "destroy";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "removedfromscene";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "complete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "created";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "error";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "loop";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "play";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "seeked";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "seeking";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "stop";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "timeout";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "unlocked";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "addedtoscene";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "boot";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "create";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "destroy";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pause";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "postupdate";
      },
      function(module2, exports2) {
        /**
         * @author       samme
         * @copyright    2021 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "prerender";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "preupdate";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "ready";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "removedfromscene";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "render";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "resume";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "shutdown";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "sleep";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "start";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "transitioncomplete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "transitioninit";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "transitionout";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "transitionstart";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "transitionwake";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "update";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "wake";
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueInc = __webpack_require__(46);
        var IncAlpha = function(items, value, step, index2, direction) {
          return PropertyValueInc(items, "alpha", value, step, index2, direction);
        };
        module2.exports = IncAlpha;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueInc = __webpack_require__(46);
        var IncX = function(items, value, step, index2, direction) {
          return PropertyValueInc(items, "x", value, step, index2, direction);
        };
        module2.exports = IncX;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueInc = __webpack_require__(46);
        var IncXY = function(items, x2, y2, stepX, stepY, index2, direction) {
          if (y2 === void 0 || y2 === null) {
            y2 = x2;
          }
          PropertyValueInc(items, "x", x2, stepX, index2, direction);
          return PropertyValueInc(items, "y", y2, stepY, index2, direction);
        };
        module2.exports = IncXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueInc = __webpack_require__(46);
        var IncY = function(items, value, step, index2, direction) {
          return PropertyValueInc(items, "y", value, step, index2, direction);
        };
        module2.exports = IncY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PlaceOnCircle = function(items, circle, startAngle, endAngle) {
          if (startAngle === void 0) {
            startAngle = 0;
          }
          if (endAngle === void 0) {
            endAngle = 6.28;
          }
          var angle = startAngle;
          var angleStep = (endAngle - startAngle) / items.length;
          for (var i2 = 0; i2 < items.length; i2++) {
            items[i2].x = circle.x + circle.radius * Math.cos(angle);
            items[i2].y = circle.y + circle.radius * Math.sin(angle);
            angle += angleStep;
          }
          return items;
        };
        module2.exports = PlaceOnCircle;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PlaceOnEllipse = function(items, ellipse, startAngle, endAngle) {
          if (startAngle === void 0) {
            startAngle = 0;
          }
          if (endAngle === void 0) {
            endAngle = 6.28;
          }
          var angle = startAngle;
          var angleStep = (endAngle - startAngle) / items.length;
          var a = ellipse.width / 2;
          var b2 = ellipse.height / 2;
          for (var i2 = 0; i2 < items.length; i2++) {
            items[i2].x = ellipse.x + a * Math.cos(angle);
            items[i2].y = ellipse.y + b2 * Math.sin(angle);
            angle += angleStep;
          }
          return items;
        };
        module2.exports = PlaceOnEllipse;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetPoints = __webpack_require__(172);
        var PlaceOnLine = function(items, line) {
          var points = GetPoints(line, items.length);
          for (var i2 = 0; i2 < items.length; i2++) {
            var item = items[i2];
            var point = points[i2];
            item.x = point.x;
            item.y = point.y;
          }
          return items;
        };
        module2.exports = PlaceOnLine;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MarchingAnts = __webpack_require__(316);
        var RotateLeft = __webpack_require__(178);
        var RotateRight = __webpack_require__(179);
        var PlaceOnRectangle = function(items, rect, shift) {
          if (shift === void 0) {
            shift = 0;
          }
          var points = MarchingAnts(rect, false, items.length);
          if (shift > 0) {
            RotateLeft(points, shift);
          } else if (shift < 0) {
            RotateRight(points, Math.abs(shift));
          }
          for (var i2 = 0; i2 < items.length; i2++) {
            items[i2].x = points[i2].x;
            items[i2].y = points[i2].y;
          }
          return items;
        };
        module2.exports = PlaceOnRectangle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BresenhamPoints = __webpack_require__(317);
        var PlaceOnTriangle = function(items, triangle, stepRate) {
          var p1 = BresenhamPoints({ x1: triangle.x1, y1: triangle.y1, x2: triangle.x2, y2: triangle.y2 }, stepRate);
          var p2 = BresenhamPoints({ x1: triangle.x2, y1: triangle.y2, x2: triangle.x3, y2: triangle.y3 }, stepRate);
          var p3 = BresenhamPoints({ x1: triangle.x3, y1: triangle.y3, x2: triangle.x1, y2: triangle.y1 }, stepRate);
          p1.pop();
          p2.pop();
          p3.pop();
          p1 = p1.concat(p2, p3);
          var step = p1.length / items.length;
          var p4 = 0;
          for (var i2 = 0; i2 < items.length; i2++) {
            var item = items[i2];
            var point = p1[Math.floor(p4)];
            item.x = point.x;
            item.y = point.y;
            p4 += step;
          }
          return items;
        };
        module2.exports = PlaceOnTriangle;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PlayAnimation = function(items, key, ignoreIfPlaying) {
          for (var i2 = 0; i2 < items.length; i2++) {
            var gameObject = items[i2];
            if (gameObject.anims) {
              gameObject.anims.play(key, ignoreIfPlaying);
            }
          }
          return items;
        };
        module2.exports = PlayAnimation;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Random = __webpack_require__(170);
        var RandomCircle = function(items, circle) {
          for (var i2 = 0; i2 < items.length; i2++) {
            Random(circle, items[i2]);
          }
          return items;
        };
        module2.exports = RandomCircle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Random = __webpack_require__(180);
        var RandomEllipse = function(items, ellipse) {
          for (var i2 = 0; i2 < items.length; i2++) {
            Random(ellipse, items[i2]);
          }
          return items;
        };
        module2.exports = RandomEllipse;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Random = __webpack_require__(173);
        var RandomLine = function(items, line) {
          for (var i2 = 0; i2 < items.length; i2++) {
            Random(line, items[i2]);
          }
          return items;
        };
        module2.exports = RandomLine;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Random = __webpack_require__(174);
        var RandomRectangle = function(items, rect) {
          for (var i2 = 0; i2 < items.length; i2++) {
            Random(rect, items[i2]);
          }
          return items;
        };
        module2.exports = RandomRectangle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Random = __webpack_require__(181);
        var RandomTriangle = function(items, triangle) {
          for (var i2 = 0; i2 < items.length; i2++) {
            Random(triangle, items[i2]);
          }
          return items;
        };
        module2.exports = RandomTriangle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueInc = __webpack_require__(46);
        var Rotate = function(items, value, step, index2, direction) {
          return PropertyValueInc(items, "rotation", value, step, index2, direction);
        };
        module2.exports = Rotate;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateAroundDistance = __webpack_require__(182);
        var DistanceBetween = __webpack_require__(50);
        var RotateAround = function(items, point, angle) {
          var x2 = point.x;
          var y2 = point.y;
          for (var i2 = 0; i2 < items.length; i2++) {
            var item = items[i2];
            RotateAroundDistance(item, x2, y2, angle, Math.max(1, DistanceBetween(item.x, item.y, x2, y2)));
          }
          return items;
        };
        module2.exports = RotateAround;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MathRotateAroundDistance = __webpack_require__(182);
        var RotateAroundDistance = function(items, point, angle, distance) {
          var x2 = point.x;
          var y2 = point.y;
          if (distance === 0) {
            return items;
          }
          for (var i2 = 0; i2 < items.length; i2++) {
            MathRotateAroundDistance(items[i2], x2, y2, angle, distance);
          }
          return items;
        };
        module2.exports = RotateAroundDistance;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueInc = __webpack_require__(46);
        var ScaleX = function(items, value, step, index2, direction) {
          return PropertyValueInc(items, "scaleX", value, step, index2, direction);
        };
        module2.exports = ScaleX;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueInc = __webpack_require__(46);
        var ScaleXY = function(items, scaleX, scaleY, stepX, stepY, index2, direction) {
          if (scaleY === void 0 || scaleY === null) {
            scaleY = scaleX;
          }
          PropertyValueInc(items, "scaleX", scaleX, stepX, index2, direction);
          return PropertyValueInc(items, "scaleY", scaleY, stepY, index2, direction);
        };
        module2.exports = ScaleXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueInc = __webpack_require__(46);
        var ScaleY = function(items, value, step, index2, direction) {
          return PropertyValueInc(items, "scaleY", value, step, index2, direction);
        };
        module2.exports = ScaleY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetAlpha = function(items, value, step, index2, direction) {
          return PropertyValueSet(items, "alpha", value, step, index2, direction);
        };
        module2.exports = SetAlpha;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetBlendMode = function(items, value, index2, direction) {
          return PropertyValueSet(items, "blendMode", value, 0, index2, direction);
        };
        module2.exports = SetBlendMode;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetDepth = function(items, value, step, index2, direction) {
          return PropertyValueSet(items, "depth", value, step, index2, direction);
        };
        module2.exports = SetDepth;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetHitArea = function(items, hitArea, hitAreaCallback) {
          for (var i2 = 0; i2 < items.length; i2++) {
            items[i2].setInteractive(hitArea, hitAreaCallback);
          }
          return items;
        };
        module2.exports = SetHitArea;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetOrigin = function(items, originX, originY, stepX, stepY, index2, direction) {
          if (originY === void 0 || originY === null) {
            originY = originX;
          }
          PropertyValueSet(items, "originX", originX, stepX, index2, direction);
          PropertyValueSet(items, "originY", originY, stepY, index2, direction);
          items.forEach(function(item) {
            item.updateDisplayOrigin();
          });
          return items;
        };
        module2.exports = SetOrigin;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetRotation = function(items, value, step, index2, direction) {
          return PropertyValueSet(items, "rotation", value, step, index2, direction);
        };
        module2.exports = SetRotation;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetScale = function(items, scaleX, scaleY, stepX, stepY, index2, direction) {
          if (scaleY === void 0 || scaleY === null) {
            scaleY = scaleX;
          }
          PropertyValueSet(items, "scaleX", scaleX, stepX, index2, direction);
          return PropertyValueSet(items, "scaleY", scaleY, stepY, index2, direction);
        };
        module2.exports = SetScale;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetScaleX = function(items, value, step, index2, direction) {
          return PropertyValueSet(items, "scaleX", value, step, index2, direction);
        };
        module2.exports = SetScaleX;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetScaleY = function(items, value, step, index2, direction) {
          return PropertyValueSet(items, "scaleY", value, step, index2, direction);
        };
        module2.exports = SetScaleY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetScrollFactor = function(items, scrollFactorX, scrollFactorY, stepX, stepY, index2, direction) {
          if (scrollFactorY === void 0 || scrollFactorY === null) {
            scrollFactorY = scrollFactorX;
          }
          PropertyValueSet(items, "scrollFactorX", scrollFactorX, stepX, index2, direction);
          return PropertyValueSet(items, "scrollFactorY", scrollFactorY, stepY, index2, direction);
        };
        module2.exports = SetScrollFactor;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetScrollFactorX = function(items, value, step, index2, direction) {
          return PropertyValueSet(items, "scrollFactorX", value, step, index2, direction);
        };
        module2.exports = SetScrollFactorX;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetScrollFactorY = function(items, value, step, index2, direction) {
          return PropertyValueSet(items, "scrollFactorY", value, step, index2, direction);
        };
        module2.exports = SetScrollFactorY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetTint = function(items, topLeft, topRight, bottomLeft, bottomRight) {
          for (var i2 = 0; i2 < items.length; i2++) {
            items[i2].setTint(topLeft, topRight, bottomLeft, bottomRight);
          }
          return items;
        };
        module2.exports = SetTint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetVisible = function(items, value, index2, direction) {
          return PropertyValueSet(items, "visible", value, 0, index2, direction);
        };
        module2.exports = SetVisible;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetX = function(items, value, step, index2, direction) {
          return PropertyValueSet(items, "x", value, step, index2, direction);
        };
        module2.exports = SetX;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetXY = function(items, x2, y2, stepX, stepY, index2, direction) {
          if (y2 === void 0 || y2 === null) {
            y2 = x2;
          }
          PropertyValueSet(items, "x", x2, stepX, index2, direction);
          return PropertyValueSet(items, "y", y2, stepY, index2, direction);
        };
        module2.exports = SetXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PropertyValueSet = __webpack_require__(27);
        var SetY = function(items, value, step, index2, direction) {
          return PropertyValueSet(items, "y", value, step, index2, direction);
        };
        module2.exports = SetY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector2 = __webpack_require__(3);
        var ShiftPosition = function(items, x2, y2, direction, output) {
          if (direction === void 0) {
            direction = 0;
          }
          if (output === void 0) {
            output = new Vector2();
          }
          var px;
          var py;
          if (items.length > 1) {
            var i2;
            var cx;
            var cy;
            var cur;
            if (direction === 0) {
              var len = items.length - 1;
              px = items[len].x;
              py = items[len].y;
              for (i2 = len - 1; i2 >= 0; i2--) {
                cur = items[i2];
                cx = cur.x;
                cy = cur.y;
                cur.x = px;
                cur.y = py;
                px = cx;
                py = cy;
              }
              items[len].x = x2;
              items[len].y = y2;
            } else {
              px = items[0].x;
              py = items[0].y;
              for (i2 = 1; i2 < items.length; i2++) {
                cur = items[i2];
                cx = cur.x;
                cy = cur.y;
                cur.x = px;
                cur.y = py;
                px = cx;
                py = cy;
              }
              items[0].x = x2;
              items[0].y = y2;
            }
          } else {
            px = items[0].x;
            py = items[0].y;
            items[0].x = x2;
            items[0].y = y2;
          }
          output.x = px;
          output.y = py;
          return output;
        };
        module2.exports = ShiftPosition;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ArrayShuffle = __webpack_require__(131);
        var Shuffle = function(items) {
          return ArrayShuffle(items);
        };
        module2.exports = Shuffle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MathSmootherStep = __webpack_require__(183);
        var SmootherStep = function(items, property, min, max, inc) {
          if (inc === void 0) {
            inc = false;
          }
          var step = Math.abs(max - min) / items.length;
          var i2;
          if (inc) {
            for (i2 = 0; i2 < items.length; i2++) {
              items[i2][property] += MathSmootherStep(i2 * step, min, max);
            }
          } else {
            for (i2 = 0; i2 < items.length; i2++) {
              items[i2][property] = MathSmootherStep(i2 * step, min, max);
            }
          }
          return items;
        };
        module2.exports = SmootherStep;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MathSmoothStep = __webpack_require__(184);
        var SmoothStep = function(items, property, min, max, inc) {
          if (inc === void 0) {
            inc = false;
          }
          var step = Math.abs(max - min) / items.length;
          var i2;
          if (inc) {
            for (i2 = 0; i2 < items.length; i2++) {
              items[i2][property] += MathSmoothStep(i2 * step, min, max);
            }
          } else {
            for (i2 = 0; i2 < items.length; i2++) {
              items[i2][property] = MathSmoothStep(i2 * step, min, max);
            }
          }
          return items;
        };
        module2.exports = SmoothStep;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Spread = function(items, property, min, max, inc) {
          if (inc === void 0) {
            inc = false;
          }
          var step = Math.abs(max - min) / items.length;
          var i2;
          if (inc) {
            for (i2 = 0; i2 < items.length; i2++) {
              items[i2][property] += i2 * step + min;
            }
          } else {
            for (i2 = 0; i2 < items.length; i2++) {
              items[i2][property] = i2 * step + min;
            }
          }
          return items;
        };
        module2.exports = Spread;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ToggleVisible = function(items) {
          for (var i2 = 0; i2 < items.length; i2++) {
            items[i2].visible = !items[i2].visible;
          }
          return items;
        };
        module2.exports = ToggleVisible;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       samme <samme.npm@gmail.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Wrap = __webpack_require__(68);
        var WrapInRectangle = function(items, rect, padding) {
          if (padding === void 0) {
            padding = 0;
          }
          for (var i2 = 0; i2 < items.length; i2++) {
            var item = items[i2];
            item.x = Wrap(item.x, rect.left - padding, rect.right + padding);
            item.y = Wrap(item.y, rect.top - padding, rect.bottom + padding);
          }
          return items;
        };
        module2.exports = WrapInRectangle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Animation: __webpack_require__(185),
          AnimationFrame: __webpack_require__(319),
          AnimationManager: __webpack_require__(321),
          AnimationState: __webpack_require__(164),
          Events: __webpack_require__(132)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "add";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "animationcomplete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "animationcomplete-";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "animationrepeat";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "animationrestart";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "animationstart";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "animationstop";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "animationupdate";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pauseall";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "remove";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "resumeall";
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          BaseCache: __webpack_require__(323),
          CacheManager: __webpack_require__(325),
          Events: __webpack_require__(324)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "add";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "remove";
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Controls: __webpack_require__(739),
          Scene2D: __webpack_require__(742)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          FixedKeyControl: __webpack_require__(740),
          SmoothedKeyControl: __webpack_require__(741)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetValue = __webpack_require__(6);
        var FixedKeyControl = new Class({
          initialize: function FixedKeyControl2(config) {
            this.camera = GetValue(config, "camera", null);
            this.left = GetValue(config, "left", null);
            this.right = GetValue(config, "right", null);
            this.up = GetValue(config, "up", null);
            this.down = GetValue(config, "down", null);
            this.zoomIn = GetValue(config, "zoomIn", null);
            this.zoomOut = GetValue(config, "zoomOut", null);
            this.zoomSpeed = GetValue(config, "zoomSpeed", 0.01);
            this.minZoom = GetValue(config, "minZoom", 1e-3);
            this.maxZoom = GetValue(config, "maxZoom", 1e3);
            this.speedX = 0;
            this.speedY = 0;
            var speed = GetValue(config, "speed", null);
            if (typeof speed === "number") {
              this.speedX = speed;
              this.speedY = speed;
            } else {
              this.speedX = GetValue(config, "speed.x", 0);
              this.speedY = GetValue(config, "speed.y", 0);
            }
            this._zoom = 0;
            this.active = this.camera !== null;
          },
          start: function() {
            this.active = this.camera !== null;
            return this;
          },
          stop: function() {
            this.active = false;
            return this;
          },
          setCamera: function(camera) {
            this.camera = camera;
            return this;
          },
          update: function(delta) {
            if (!this.active) {
              return;
            }
            if (delta === void 0) {
              delta = 1;
            }
            var cam = this.camera;
            if (this.up && this.up.isDown) {
              cam.scrollY -= this.speedY * delta | 0;
            } else if (this.down && this.down.isDown) {
              cam.scrollY += this.speedY * delta | 0;
            }
            if (this.left && this.left.isDown) {
              cam.scrollX -= this.speedX * delta | 0;
            } else if (this.right && this.right.isDown) {
              cam.scrollX += this.speedX * delta | 0;
            }
            if (this.zoomIn && this.zoomIn.isDown) {
              cam.zoom -= this.zoomSpeed;
              if (cam.zoom < this.minZoom) {
                cam.zoom = this.minZoom;
              }
            } else if (this.zoomOut && this.zoomOut.isDown) {
              cam.zoom += this.zoomSpeed;
              if (cam.zoom > this.maxZoom) {
                cam.zoom = this.maxZoom;
              }
            }
          },
          destroy: function() {
            this.camera = null;
            this.left = null;
            this.right = null;
            this.up = null;
            this.down = null;
            this.zoomIn = null;
            this.zoomOut = null;
          }
        });
        module2.exports = FixedKeyControl;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var GetValue = __webpack_require__(6);
        var SmoothedKeyControl = new Class({
          initialize: function SmoothedKeyControl2(config) {
            this.camera = GetValue(config, "camera", null);
            this.left = GetValue(config, "left", null);
            this.right = GetValue(config, "right", null);
            this.up = GetValue(config, "up", null);
            this.down = GetValue(config, "down", null);
            this.zoomIn = GetValue(config, "zoomIn", null);
            this.zoomOut = GetValue(config, "zoomOut", null);
            this.zoomSpeed = GetValue(config, "zoomSpeed", 0.01);
            this.minZoom = GetValue(config, "minZoom", 1e-3);
            this.maxZoom = GetValue(config, "maxZoom", 1e3);
            this.accelX = 0;
            this.accelY = 0;
            var accel = GetValue(config, "acceleration", null);
            if (typeof accel === "number") {
              this.accelX = accel;
              this.accelY = accel;
            } else {
              this.accelX = GetValue(config, "acceleration.x", 0);
              this.accelY = GetValue(config, "acceleration.y", 0);
            }
            this.dragX = 0;
            this.dragY = 0;
            var drag = GetValue(config, "drag", null);
            if (typeof drag === "number") {
              this.dragX = drag;
              this.dragY = drag;
            } else {
              this.dragX = GetValue(config, "drag.x", 0);
              this.dragY = GetValue(config, "drag.y", 0);
            }
            this.maxSpeedX = 0;
            this.maxSpeedY = 0;
            var maxSpeed = GetValue(config, "maxSpeed", null);
            if (typeof maxSpeed === "number") {
              this.maxSpeedX = maxSpeed;
              this.maxSpeedY = maxSpeed;
            } else {
              this.maxSpeedX = GetValue(config, "maxSpeed.x", 0);
              this.maxSpeedY = GetValue(config, "maxSpeed.y", 0);
            }
            this._speedX = 0;
            this._speedY = 0;
            this._zoom = 0;
            this.active = this.camera !== null;
          },
          start: function() {
            this.active = this.camera !== null;
            return this;
          },
          stop: function() {
            this.active = false;
            return this;
          },
          setCamera: function(camera) {
            this.camera = camera;
            return this;
          },
          update: function(delta) {
            if (!this.active) {
              return;
            }
            if (delta === void 0) {
              delta = 1;
            }
            var cam = this.camera;
            if (this._speedX > 0) {
              this._speedX -= this.dragX * delta;
              if (this._speedX < 0) {
                this._speedX = 0;
              }
            } else if (this._speedX < 0) {
              this._speedX += this.dragX * delta;
              if (this._speedX > 0) {
                this._speedX = 0;
              }
            }
            if (this._speedY > 0) {
              this._speedY -= this.dragY * delta;
              if (this._speedY < 0) {
                this._speedY = 0;
              }
            } else if (this._speedY < 0) {
              this._speedY += this.dragY * delta;
              if (this._speedY > 0) {
                this._speedY = 0;
              }
            }
            if (this.up && this.up.isDown) {
              this._speedY += this.accelY;
              if (this._speedY > this.maxSpeedY) {
                this._speedY = this.maxSpeedY;
              }
            } else if (this.down && this.down.isDown) {
              this._speedY -= this.accelY;
              if (this._speedY < -this.maxSpeedY) {
                this._speedY = -this.maxSpeedY;
              }
            }
            if (this.left && this.left.isDown) {
              this._speedX += this.accelX;
              if (this._speedX > this.maxSpeedX) {
                this._speedX = this.maxSpeedX;
              }
            } else if (this.right && this.right.isDown) {
              this._speedX -= this.accelX;
              if (this._speedX < -this.maxSpeedX) {
                this._speedX = -this.maxSpeedX;
              }
            }
            if (this.zoomIn && this.zoomIn.isDown) {
              this._zoom = -this.zoomSpeed;
            } else if (this.zoomOut && this.zoomOut.isDown) {
              this._zoom = this.zoomSpeed;
            } else {
              this._zoom = 0;
            }
            if (this._speedX !== 0) {
              cam.scrollX -= this._speedX * delta | 0;
            }
            if (this._speedY !== 0) {
              cam.scrollY -= this._speedY * delta | 0;
            }
            if (this._zoom !== 0) {
              cam.zoom += this._zoom;
              if (cam.zoom < this.minZoom) {
                cam.zoom = this.minZoom;
              } else if (cam.zoom > this.maxZoom) {
                cam.zoom = this.maxZoom;
              }
            }
          },
          destroy: function() {
            this.camera = null;
            this.left = null;
            this.right = null;
            this.up = null;
            this.down = null;
            this.zoomIn = null;
            this.zoomOut = null;
          }
        });
        module2.exports = SmoothedKeyControl;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Camera: __webpack_require__(326),
          BaseCamera: __webpack_require__(133),
          CameraManager: __webpack_require__(799),
          Effects: __webpack_require__(333),
          Events: __webpack_require__(37)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "cameradestroy";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "camerafadeincomplete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "camerafadeinstart";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "camerafadeoutcomplete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "camerafadeoutstart";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "cameraflashcomplete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "cameraflashstart";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "followupdate";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "camerapancomplete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "camerapanstart";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "postrender";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "prerender";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "camerarotatecomplete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "camerarotatestart";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "camerashakecomplete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "camerashakestart";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "camerazoomcomplete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "camerazoomstart";
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clamp = __webpack_require__(18);
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(37);
        var Fade = new Class({
          initialize: function Fade2(camera) {
            this.camera = camera;
            this.isRunning = false;
            this.isComplete = false;
            this.direction = true;
            this.duration = 0;
            this.red = 0;
            this.green = 0;
            this.blue = 0;
            this.alpha = 0;
            this.progress = 0;
            this._elapsed = 0;
            this._onUpdate;
            this._onUpdateScope;
          },
          start: function(direction, duration, red, green, blue, force, callback, context) {
            if (direction === void 0) {
              direction = true;
            }
            if (duration === void 0) {
              duration = 1e3;
            }
            if (red === void 0) {
              red = 0;
            }
            if (green === void 0) {
              green = 0;
            }
            if (blue === void 0) {
              blue = 0;
            }
            if (force === void 0) {
              force = false;
            }
            if (callback === void 0) {
              callback = null;
            }
            if (context === void 0) {
              context = this.camera.scene;
            }
            if (!force && this.isRunning) {
              return this.camera;
            }
            this.isRunning = true;
            this.isComplete = false;
            this.duration = duration;
            this.direction = direction;
            this.progress = 0;
            this.red = red;
            this.green = green;
            this.blue = blue;
            this.alpha = direction ? Number.MIN_VALUE : 1;
            this._elapsed = 0;
            this._onUpdate = callback;
            this._onUpdateScope = context;
            var eventName = direction ? Events.FADE_OUT_START : Events.FADE_IN_START;
            this.camera.emit(eventName, this.camera, this, duration, red, green, blue);
            return this.camera;
          },
          update: function(time, delta) {
            if (!this.isRunning) {
              return;
            }
            this._elapsed += delta;
            this.progress = Clamp(this._elapsed / this.duration, 0, 1);
            if (this._onUpdate) {
              this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
            }
            if (this._elapsed < this.duration) {
              this.alpha = this.direction ? this.progress : 1 - this.progress;
            } else {
              this.alpha = this.direction ? 1 : 0;
              this.effectComplete();
            }
          },
          postRenderCanvas: function(ctx) {
            if (!this.isRunning && !this.isComplete) {
              return false;
            }
            var camera = this.camera;
            ctx.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
            ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
            return true;
          },
          postRenderWebGL: function(pipeline, getTintFunction) {
            if (!this.isRunning && !this.isComplete) {
              return false;
            }
            var camera = this.camera;
            var red = this.red / 255;
            var green = this.green / 255;
            var blue = this.blue / 255;
            pipeline.drawFillRect(camera.x, camera.y, camera.width, camera.height, getTintFunction(blue, green, red, 1), this.alpha);
            return true;
          },
          effectComplete: function() {
            this._onUpdate = null;
            this._onUpdateScope = null;
            this.isRunning = false;
            this.isComplete = true;
            var eventName = this.direction ? Events.FADE_OUT_COMPLETE : Events.FADE_IN_COMPLETE;
            this.camera.emit(eventName, this.camera, this);
          },
          reset: function() {
            this.isRunning = false;
            this.isComplete = false;
            this._onUpdate = null;
            this._onUpdateScope = null;
          },
          destroy: function() {
            this.reset();
            this.camera = null;
          }
        });
        module2.exports = Fade;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clamp = __webpack_require__(18);
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(37);
        var Flash = new Class({
          initialize: function Flash2(camera) {
            this.camera = camera;
            this.isRunning = false;
            this.duration = 0;
            this.red = 0;
            this.green = 0;
            this.blue = 0;
            this.alpha = 0;
            this.progress = 0;
            this._elapsed = 0;
            this._onUpdate;
            this._onUpdateScope;
          },
          start: function(duration, red, green, blue, force, callback, context) {
            if (duration === void 0) {
              duration = 250;
            }
            if (red === void 0) {
              red = 255;
            }
            if (green === void 0) {
              green = 255;
            }
            if (blue === void 0) {
              blue = 255;
            }
            if (force === void 0) {
              force = false;
            }
            if (callback === void 0) {
              callback = null;
            }
            if (context === void 0) {
              context = this.camera.scene;
            }
            if (!force && this.isRunning) {
              return this.camera;
            }
            this.isRunning = true;
            this.duration = duration;
            this.progress = 0;
            this.red = red;
            this.green = green;
            this.blue = blue;
            this.alpha = 1;
            this._elapsed = 0;
            this._onUpdate = callback;
            this._onUpdateScope = context;
            this.camera.emit(Events.FLASH_START, this.camera, this, duration, red, green, blue);
            return this.camera;
          },
          update: function(time, delta) {
            if (!this.isRunning) {
              return;
            }
            this._elapsed += delta;
            this.progress = Clamp(this._elapsed / this.duration, 0, 1);
            if (this._onUpdate) {
              this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
            }
            if (this._elapsed < this.duration) {
              this.alpha = 1 - this.progress;
            } else {
              this.effectComplete();
            }
          },
          postRenderCanvas: function(ctx) {
            if (!this.isRunning) {
              return false;
            }
            var camera = this.camera;
            ctx.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
            ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
            return true;
          },
          postRenderWebGL: function(pipeline, getTintFunction) {
            if (!this.isRunning) {
              return false;
            }
            var camera = this.camera;
            var red = this.red / 255;
            var green = this.green / 255;
            var blue = this.blue / 255;
            pipeline.drawFillRect(camera.x, camera.y, camera.width, camera.height, getTintFunction(blue, green, red, 1), this.alpha);
            return true;
          },
          effectComplete: function() {
            this._onUpdate = null;
            this._onUpdateScope = null;
            this.isRunning = false;
            this.camera.emit(Events.FLASH_COMPLETE, this.camera, this);
          },
          reset: function() {
            this.isRunning = false;
            this._onUpdate = null;
            this._onUpdateScope = null;
          },
          destroy: function() {
            this.reset();
            this.camera = null;
          }
        });
        module2.exports = Flash;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clamp = __webpack_require__(18);
        var Class = __webpack_require__(0);
        var EaseMap = __webpack_require__(134);
        var Events = __webpack_require__(37);
        var Vector2 = __webpack_require__(3);
        var Pan = new Class({
          initialize: function Pan2(camera) {
            this.camera = camera;
            this.isRunning = false;
            this.duration = 0;
            this.source = new Vector2();
            this.current = new Vector2();
            this.destination = new Vector2();
            this.ease;
            this.progress = 0;
            this._elapsed = 0;
            this._onUpdate;
            this._onUpdateScope;
          },
          start: function(x2, y2, duration, ease, force, callback, context) {
            if (duration === void 0) {
              duration = 1e3;
            }
            if (ease === void 0) {
              ease = EaseMap.Linear;
            }
            if (force === void 0) {
              force = false;
            }
            if (callback === void 0) {
              callback = null;
            }
            if (context === void 0) {
              context = this.camera.scene;
            }
            var cam = this.camera;
            if (!force && this.isRunning) {
              return cam;
            }
            this.isRunning = true;
            this.duration = duration;
            this.progress = 0;
            this.source.set(cam.scrollX, cam.scrollY);
            this.destination.set(x2, y2);
            cam.getScroll(x2, y2, this.current);
            if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
              this.ease = EaseMap[ease];
            } else if (typeof ease === "function") {
              this.ease = ease;
            }
            this._elapsed = 0;
            this._onUpdate = callback;
            this._onUpdateScope = context;
            this.camera.emit(Events.PAN_START, this.camera, this, duration, x2, y2);
            return cam;
          },
          update: function(time, delta) {
            if (!this.isRunning) {
              return;
            }
            this._elapsed += delta;
            var progress = Clamp(this._elapsed / this.duration, 0, 1);
            this.progress = progress;
            var cam = this.camera;
            if (this._elapsed < this.duration) {
              var v2 = this.ease(progress);
              cam.getScroll(this.destination.x, this.destination.y, this.current);
              var x2 = this.source.x + (this.current.x - this.source.x) * v2;
              var y2 = this.source.y + (this.current.y - this.source.y) * v2;
              cam.setScroll(x2, y2);
              if (this._onUpdate) {
                this._onUpdate.call(this._onUpdateScope, cam, progress, x2, y2);
              }
            } else {
              cam.centerOn(this.destination.x, this.destination.y);
              if (this._onUpdate) {
                this._onUpdate.call(this._onUpdateScope, cam, progress, cam.scrollX, cam.scrollY);
              }
              this.effectComplete();
            }
          },
          effectComplete: function() {
            this._onUpdate = null;
            this._onUpdateScope = null;
            this.isRunning = false;
            this.camera.emit(Events.PAN_COMPLETE, this.camera, this);
          },
          reset: function() {
            this.isRunning = false;
            this._onUpdate = null;
            this._onUpdateScope = null;
          },
          destroy: function() {
            this.reset();
            this.camera = null;
            this.source = null;
            this.destination = null;
          }
        });
        module2.exports = Pan;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var In = function(v2, overshoot) {
          if (overshoot === void 0) {
            overshoot = 1.70158;
          }
          return v2 * v2 * ((overshoot + 1) * v2 - overshoot);
        };
        module2.exports = In;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Out = function(v2, overshoot) {
          if (overshoot === void 0) {
            overshoot = 1.70158;
          }
          return --v2 * v2 * ((overshoot + 1) * v2 + overshoot) + 1;
        };
        module2.exports = Out;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var InOut = function(v2, overshoot) {
          if (overshoot === void 0) {
            overshoot = 1.70158;
          }
          var s = overshoot * 1.525;
          if ((v2 *= 2) < 1) {
            return 0.5 * (v2 * v2 * ((s + 1) * v2 - s));
          } else {
            return 0.5 * ((v2 -= 2) * v2 * ((s + 1) * v2 + s) + 2);
          }
        };
        module2.exports = InOut;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var In = function(v2) {
          v2 = 1 - v2;
          if (v2 < 1 / 2.75) {
            return 1 - 7.5625 * v2 * v2;
          } else if (v2 < 2 / 2.75) {
            return 1 - (7.5625 * (v2 -= 1.5 / 2.75) * v2 + 0.75);
          } else if (v2 < 2.5 / 2.75) {
            return 1 - (7.5625 * (v2 -= 2.25 / 2.75) * v2 + 0.9375);
          } else {
            return 1 - (7.5625 * (v2 -= 2.625 / 2.75) * v2 + 0.984375);
          }
        };
        module2.exports = In;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Out = function(v2) {
          if (v2 < 1 / 2.75) {
            return 7.5625 * v2 * v2;
          } else if (v2 < 2 / 2.75) {
            return 7.5625 * (v2 -= 1.5 / 2.75) * v2 + 0.75;
          } else if (v2 < 2.5 / 2.75) {
            return 7.5625 * (v2 -= 2.25 / 2.75) * v2 + 0.9375;
          } else {
            return 7.5625 * (v2 -= 2.625 / 2.75) * v2 + 0.984375;
          }
        };
        module2.exports = Out;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var InOut = function(v2) {
          var reverse = false;
          if (v2 < 0.5) {
            v2 = 1 - v2 * 2;
            reverse = true;
          } else {
            v2 = v2 * 2 - 1;
          }
          if (v2 < 1 / 2.75) {
            v2 = 7.5625 * v2 * v2;
          } else if (v2 < 2 / 2.75) {
            v2 = 7.5625 * (v2 -= 1.5 / 2.75) * v2 + 0.75;
          } else if (v2 < 2.5 / 2.75) {
            v2 = 7.5625 * (v2 -= 2.25 / 2.75) * v2 + 0.9375;
          } else {
            v2 = 7.5625 * (v2 -= 2.625 / 2.75) * v2 + 0.984375;
          }
          if (reverse) {
            return (1 - v2) * 0.5;
          } else {
            return v2 * 0.5 + 0.5;
          }
        };
        module2.exports = InOut;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var In = function(v2) {
          return 1 - Math.sqrt(1 - v2 * v2);
        };
        module2.exports = In;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Out = function(v2) {
          return Math.sqrt(1 - --v2 * v2);
        };
        module2.exports = Out;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var InOut = function(v2) {
          if ((v2 *= 2) < 1) {
            return -0.5 * (Math.sqrt(1 - v2 * v2) - 1);
          } else {
            return 0.5 * (Math.sqrt(1 - (v2 -= 2) * v2) + 1);
          }
        };
        module2.exports = InOut;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var In = function(v2) {
          return v2 * v2 * v2;
        };
        module2.exports = In;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Out = function(v2) {
          return --v2 * v2 * v2 + 1;
        };
        module2.exports = Out;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var InOut = function(v2) {
          if ((v2 *= 2) < 1) {
            return 0.5 * v2 * v2 * v2;
          } else {
            return 0.5 * ((v2 -= 2) * v2 * v2 + 2);
          }
        };
        module2.exports = InOut;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var In = function(v2, amplitude, period) {
          if (amplitude === void 0) {
            amplitude = 0.1;
          }
          if (period === void 0) {
            period = 0.1;
          }
          if (v2 === 0) {
            return 0;
          } else if (v2 === 1) {
            return 1;
          } else {
            var s = period / 4;
            if (amplitude < 1) {
              amplitude = 1;
            } else {
              s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
            }
            return -(amplitude * Math.pow(2, 10 * (v2 -= 1)) * Math.sin((v2 - s) * (2 * Math.PI) / period));
          }
        };
        module2.exports = In;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Out = function(v2, amplitude, period) {
          if (amplitude === void 0) {
            amplitude = 0.1;
          }
          if (period === void 0) {
            period = 0.1;
          }
          if (v2 === 0) {
            return 0;
          } else if (v2 === 1) {
            return 1;
          } else {
            var s = period / 4;
            if (amplitude < 1) {
              amplitude = 1;
            } else {
              s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
            }
            return amplitude * Math.pow(2, -10 * v2) * Math.sin((v2 - s) * (2 * Math.PI) / period) + 1;
          }
        };
        module2.exports = Out;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var InOut = function(v2, amplitude, period) {
          if (amplitude === void 0) {
            amplitude = 0.1;
          }
          if (period === void 0) {
            period = 0.1;
          }
          if (v2 === 0) {
            return 0;
          } else if (v2 === 1) {
            return 1;
          } else {
            var s = period / 4;
            if (amplitude < 1) {
              amplitude = 1;
            } else {
              s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
            }
            if ((v2 *= 2) < 1) {
              return -0.5 * (amplitude * Math.pow(2, 10 * (v2 -= 1)) * Math.sin((v2 - s) * (2 * Math.PI) / period));
            } else {
              return amplitude * Math.pow(2, -10 * (v2 -= 1)) * Math.sin((v2 - s) * (2 * Math.PI) / period) * 0.5 + 1;
            }
          }
        };
        module2.exports = InOut;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var In = function(v2) {
          return Math.pow(2, 10 * (v2 - 1)) - 1e-3;
        };
        module2.exports = In;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Out = function(v2) {
          return 1 - Math.pow(2, -10 * v2);
        };
        module2.exports = Out;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var InOut = function(v2) {
          if ((v2 *= 2) < 1) {
            return 0.5 * Math.pow(2, 10 * (v2 - 1));
          } else {
            return 0.5 * (2 - Math.pow(2, -10 * (v2 - 1)));
          }
        };
        module2.exports = InOut;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Linear = function(v2) {
          return v2;
        };
        module2.exports = Linear;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var In = function(v2) {
          return v2 * v2;
        };
        module2.exports = In;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Out = function(v2) {
          return v2 * (2 - v2);
        };
        module2.exports = Out;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var InOut = function(v2) {
          if ((v2 *= 2) < 1) {
            return 0.5 * v2 * v2;
          } else {
            return -0.5 * (--v2 * (v2 - 2) - 1);
          }
        };
        module2.exports = InOut;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var In = function(v2) {
          return v2 * v2 * v2 * v2;
        };
        module2.exports = In;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Out = function(v2) {
          return 1 - --v2 * v2 * v2 * v2;
        };
        module2.exports = Out;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var InOut = function(v2) {
          if ((v2 *= 2) < 1) {
            return 0.5 * v2 * v2 * v2 * v2;
          } else {
            return -0.5 * ((v2 -= 2) * v2 * v2 * v2 - 2);
          }
        };
        module2.exports = InOut;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var In = function(v2) {
          return v2 * v2 * v2 * v2 * v2;
        };
        module2.exports = In;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Out = function(v2) {
          return --v2 * v2 * v2 * v2 * v2 + 1;
        };
        module2.exports = Out;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var InOut = function(v2) {
          if ((v2 *= 2) < 1) {
            return 0.5 * v2 * v2 * v2 * v2 * v2;
          } else {
            return 0.5 * ((v2 -= 2) * v2 * v2 * v2 * v2 + 2);
          }
        };
        module2.exports = InOut;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var In = function(v2) {
          if (v2 === 0) {
            return 0;
          } else if (v2 === 1) {
            return 1;
          } else {
            return 1 - Math.cos(v2 * Math.PI / 2);
          }
        };
        module2.exports = In;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Out = function(v2) {
          if (v2 === 0) {
            return 0;
          } else if (v2 === 1) {
            return 1;
          } else {
            return Math.sin(v2 * Math.PI / 2);
          }
        };
        module2.exports = Out;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var InOut = function(v2) {
          if (v2 === 0) {
            return 0;
          } else if (v2 === 1) {
            return 1;
          } else {
            return 0.5 * (1 - Math.cos(Math.PI * v2));
          }
        };
        module2.exports = InOut;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Stepped = function(v2, steps) {
          if (steps === void 0) {
            steps = 1;
          }
          if (v2 <= 0) {
            return 0;
          } else if (v2 >= 1) {
            return 1;
          } else {
            return ((steps * v2 | 0) + 1) * (1 / steps);
          }
        };
        module2.exports = Stepped;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clamp = __webpack_require__(18);
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(37);
        var Vector2 = __webpack_require__(3);
        var Shake = new Class({
          initialize: function Shake2(camera) {
            this.camera = camera;
            this.isRunning = false;
            this.duration = 0;
            this.intensity = new Vector2();
            this.progress = 0;
            this._elapsed = 0;
            this._offsetX = 0;
            this._offsetY = 0;
            this._onUpdate;
            this._onUpdateScope;
          },
          start: function(duration, intensity, force, callback, context) {
            if (duration === void 0) {
              duration = 100;
            }
            if (intensity === void 0) {
              intensity = 0.05;
            }
            if (force === void 0) {
              force = false;
            }
            if (callback === void 0) {
              callback = null;
            }
            if (context === void 0) {
              context = this.camera.scene;
            }
            if (!force && this.isRunning) {
              return this.camera;
            }
            this.isRunning = true;
            this.duration = duration;
            this.progress = 0;
            if (typeof intensity === "number") {
              this.intensity.set(intensity);
            } else {
              this.intensity.set(intensity.x, intensity.y);
            }
            this._elapsed = 0;
            this._offsetX = 0;
            this._offsetY = 0;
            this._onUpdate = callback;
            this._onUpdateScope = context;
            this.camera.emit(Events.SHAKE_START, this.camera, this, duration, intensity);
            return this.camera;
          },
          preRender: function() {
            if (this.isRunning) {
              this.camera.matrix.translate(this._offsetX, this._offsetY);
            }
          },
          update: function(time, delta) {
            if (!this.isRunning) {
              return;
            }
            this._elapsed += delta;
            this.progress = Clamp(this._elapsed / this.duration, 0, 1);
            if (this._onUpdate) {
              this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
            }
            if (this._elapsed < this.duration) {
              var intensity = this.intensity;
              var width = this.camera.width;
              var height = this.camera.height;
              var zoom = this.camera.zoom;
              this._offsetX = (Math.random() * intensity.x * width * 2 - intensity.x * width) * zoom;
              this._offsetY = (Math.random() * intensity.y * height * 2 - intensity.y * height) * zoom;
              if (this.camera.roundPixels) {
                this._offsetX = Math.round(this._offsetX);
                this._offsetY = Math.round(this._offsetY);
              }
            } else {
              this.effectComplete();
            }
          },
          effectComplete: function() {
            this._offsetX = 0;
            this._offsetY = 0;
            this._onUpdate = null;
            this._onUpdateScope = null;
            this.isRunning = false;
            this.camera.emit(Events.SHAKE_COMPLETE, this.camera, this);
          },
          reset: function() {
            this.isRunning = false;
            this._offsetX = 0;
            this._offsetY = 0;
            this._onUpdate = null;
            this._onUpdateScope = null;
          },
          destroy: function() {
            this.reset();
            this.camera = null;
            this.intensity = null;
          }
        });
        module2.exports = Shake;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Jason Nicholls <nicholls.jason@gmail.com>
         * @copyright    2018 Photon Storm Ltd.
         * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
         */
        var Clamp = __webpack_require__(18);
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(37);
        var EaseMap = __webpack_require__(134);
        var RotateTo = new Class({
          initialize: function RotateTo2(camera) {
            this.camera = camera;
            this.isRunning = false;
            this.duration = 0;
            this.source = 0;
            this.current = 0;
            this.destination = 0;
            this.ease;
            this.progress = 0;
            this._elapsed = 0;
            this._onUpdate;
            this._onUpdateScope;
            this.clockwise = true;
            this.shortestPath = false;
          },
          start: function(radians, shortestPath, duration, ease, force, callback, context) {
            if (duration === void 0) {
              duration = 1e3;
            }
            if (ease === void 0) {
              ease = EaseMap.Linear;
            }
            if (force === void 0) {
              force = false;
            }
            if (callback === void 0) {
              callback = null;
            }
            if (context === void 0) {
              context = this.camera.scene;
            }
            if (shortestPath === void 0) {
              shortestPath = false;
            }
            this.shortestPath = shortestPath;
            var tmpDestination = radians;
            if (radians < 0) {
              tmpDestination = -1 * radians;
              this.clockwise = false;
            } else {
              this.clockwise = true;
            }
            var maxRad = 360 * Math.PI / 180;
            tmpDestination = tmpDestination - Math.floor(tmpDestination / maxRad) * maxRad;
            var cam = this.camera;
            if (!force && this.isRunning) {
              return cam;
            }
            this.isRunning = true;
            this.duration = duration;
            this.progress = 0;
            this.source = cam.rotation;
            this.destination = tmpDestination;
            if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
              this.ease = EaseMap[ease];
            } else if (typeof ease === "function") {
              this.ease = ease;
            }
            this._elapsed = 0;
            this._onUpdate = callback;
            this._onUpdateScope = context;
            if (this.shortestPath) {
              var cwDist = 0;
              var acwDist = 0;
              if (this.destination > this.source) {
                cwDist = Math.abs(this.destination - this.source);
              } else {
                cwDist = Math.abs(this.destination + maxRad) - this.source;
              }
              if (this.source > this.destination) {
                acwDist = Math.abs(this.source - this.destination);
              } else {
                acwDist = Math.abs(this.source + maxRad) - this.destination;
              }
              if (cwDist < acwDist) {
                this.clockwise = true;
              } else if (cwDist > acwDist) {
                this.clockwise = false;
              }
            }
            this.camera.emit(Events.ROTATE_START, this.camera, this, duration, tmpDestination);
            return cam;
          },
          update: function(time, delta) {
            if (!this.isRunning) {
              return;
            }
            this._elapsed += delta;
            var progress = Clamp(this._elapsed / this.duration, 0, 1);
            this.progress = progress;
            var cam = this.camera;
            if (this._elapsed < this.duration) {
              var v2 = this.ease(progress);
              this.current = cam.rotation;
              var distance = 0;
              var maxRad = 360 * Math.PI / 180;
              var target = this.destination;
              var current = this.current;
              if (this.clockwise === false) {
                target = this.current;
                current = this.destination;
              }
              if (target >= current) {
                distance = Math.abs(target - current);
              } else {
                distance = Math.abs(target + maxRad) - current;
              }
              var r2 = 0;
              if (this.clockwise) {
                r2 = cam.rotation + distance * v2;
              } else {
                r2 = cam.rotation - distance * v2;
              }
              cam.rotation = r2;
              if (this._onUpdate) {
                this._onUpdate.call(this._onUpdateScope, cam, progress, r2);
              }
            } else {
              cam.rotation = this.destination;
              if (this._onUpdate) {
                this._onUpdate.call(this._onUpdateScope, cam, progress, this.destination);
              }
              this.effectComplete();
            }
          },
          effectComplete: function() {
            this._onUpdate = null;
            this._onUpdateScope = null;
            this.isRunning = false;
            this.camera.emit(Events.ROTATE_COMPLETE, this.camera, this);
          },
          reset: function() {
            this.isRunning = false;
            this._onUpdate = null;
            this._onUpdateScope = null;
          },
          destroy: function() {
            this.reset();
            this.camera = null;
            this.source = null;
            this.destination = null;
          }
        });
        module2.exports = RotateTo;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clamp = __webpack_require__(18);
        var Class = __webpack_require__(0);
        var EaseMap = __webpack_require__(134);
        var Events = __webpack_require__(37);
        var Zoom = new Class({
          initialize: function Zoom2(camera) {
            this.camera = camera;
            this.isRunning = false;
            this.duration = 0;
            this.source = 1;
            this.destination = 1;
            this.ease;
            this.progress = 0;
            this._elapsed = 0;
            this._onUpdate;
            this._onUpdateScope;
          },
          start: function(zoom, duration, ease, force, callback, context) {
            if (duration === void 0) {
              duration = 1e3;
            }
            if (ease === void 0) {
              ease = EaseMap.Linear;
            }
            if (force === void 0) {
              force = false;
            }
            if (callback === void 0) {
              callback = null;
            }
            if (context === void 0) {
              context = this.camera.scene;
            }
            var cam = this.camera;
            if (!force && this.isRunning) {
              return cam;
            }
            this.isRunning = true;
            this.duration = duration;
            this.progress = 0;
            this.source = cam.zoom;
            this.destination = zoom;
            if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
              this.ease = EaseMap[ease];
            } else if (typeof ease === "function") {
              this.ease = ease;
            }
            this._elapsed = 0;
            this._onUpdate = callback;
            this._onUpdateScope = context;
            this.camera.emit(Events.ZOOM_START, this.camera, this, duration, zoom);
            return cam;
          },
          update: function(time, delta) {
            if (!this.isRunning) {
              return;
            }
            this._elapsed += delta;
            this.progress = Clamp(this._elapsed / this.duration, 0, 1);
            if (this._elapsed < this.duration) {
              this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress);
              if (this._onUpdate) {
                this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom);
              }
            } else {
              this.camera.zoom = this.destination;
              if (this._onUpdate) {
                this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination);
              }
              this.effectComplete();
            }
          },
          effectComplete: function() {
            this._onUpdate = null;
            this._onUpdateScope = null;
            this.isRunning = false;
            this.camera.emit(Events.ZOOM_COMPLETE, this.camera, this);
          },
          reset: function() {
            this.isRunning = false;
            this._onUpdate = null;
            this._onUpdateScope = null;
          },
          destroy: function() {
            this.reset();
            this.camera = null;
          }
        });
        module2.exports = Zoom;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Camera = __webpack_require__(326);
        var Class = __webpack_require__(0);
        var GetFastValue = __webpack_require__(2);
        var PluginCache = __webpack_require__(24);
        var RectangleContains = __webpack_require__(57);
        var ScaleEvents = __webpack_require__(104);
        var SceneEvents = __webpack_require__(20);
        var CameraManager = new Class({
          initialize: function CameraManager2(scene) {
            this.scene = scene;
            this.systems = scene.sys;
            this.roundPixels = scene.sys.game.config.roundPixels;
            this.cameras = [];
            this.main;
            this.default;
            scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
            scene.sys.events.on(SceneEvents.START, this.start, this);
          },
          boot: function() {
            var sys = this.systems;
            if (sys.settings.cameras) {
              this.fromJSON(sys.settings.cameras);
            } else {
              this.add();
            }
            this.main = this.cameras[0];
            this.default = new Camera(0, 0, sys.scale.width, sys.scale.height).setScene(this.scene);
            sys.game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
            this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
          },
          start: function() {
            if (!this.main) {
              var sys = this.systems;
              if (sys.settings.cameras) {
                this.fromJSON(sys.settings.cameras);
              } else {
                this.add();
              }
              this.main = this.cameras[0];
            }
            var eventEmitter = this.systems.events;
            eventEmitter.on(SceneEvents.UPDATE, this.update, this);
            eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          add: function(x2, y2, width, height, makeMain, name) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = this.scene.sys.scale.width;
            }
            if (height === void 0) {
              height = this.scene.sys.scale.height;
            }
            if (makeMain === void 0) {
              makeMain = false;
            }
            if (name === void 0) {
              name = "";
            }
            var camera = new Camera(x2, y2, width, height);
            camera.setName(name);
            camera.setScene(this.scene);
            camera.setRoundPixels(this.roundPixels);
            camera.id = this.getNextID();
            this.cameras.push(camera);
            if (makeMain) {
              this.main = camera;
            }
            return camera;
          },
          addExisting: function(camera, makeMain) {
            if (makeMain === void 0) {
              makeMain = false;
            }
            var index2 = this.cameras.indexOf(camera);
            if (index2 === -1) {
              camera.id = this.getNextID();
              camera.setRoundPixels(this.roundPixels);
              this.cameras.push(camera);
              if (makeMain) {
                this.main = camera;
              }
              return camera;
            }
            return null;
          },
          getNextID: function() {
            var cameras = this.cameras;
            var testID = 1;
            for (var t2 = 0; t2 < 32; t2++) {
              var found = false;
              for (var i2 = 0; i2 < cameras.length; i2++) {
                var camera = cameras[i2];
                if (camera && camera.id === testID) {
                  found = true;
                  continue;
                }
              }
              if (found) {
                testID = testID << 1;
              } else {
                return testID;
              }
            }
            return 0;
          },
          getTotal: function(isVisible) {
            if (isVisible === void 0) {
              isVisible = false;
            }
            var total = 0;
            var cameras = this.cameras;
            for (var i2 = 0; i2 < cameras.length; i2++) {
              var camera = cameras[i2];
              if (!isVisible || isVisible && camera.visible) {
                total++;
              }
            }
            return total;
          },
          fromJSON: function(config) {
            if (!Array.isArray(config)) {
              config = [config];
            }
            var gameWidth = this.scene.sys.scale.width;
            var gameHeight = this.scene.sys.scale.height;
            for (var i2 = 0; i2 < config.length; i2++) {
              var cameraConfig = config[i2];
              var x2 = GetFastValue(cameraConfig, "x", 0);
              var y2 = GetFastValue(cameraConfig, "y", 0);
              var width = GetFastValue(cameraConfig, "width", gameWidth);
              var height = GetFastValue(cameraConfig, "height", gameHeight);
              var camera = this.add(x2, y2, width, height);
              camera.name = GetFastValue(cameraConfig, "name", "");
              camera.zoom = GetFastValue(cameraConfig, "zoom", 1);
              camera.rotation = GetFastValue(cameraConfig, "rotation", 0);
              camera.scrollX = GetFastValue(cameraConfig, "scrollX", 0);
              camera.scrollY = GetFastValue(cameraConfig, "scrollY", 0);
              camera.roundPixels = GetFastValue(cameraConfig, "roundPixels", false);
              camera.visible = GetFastValue(cameraConfig, "visible", true);
              var backgroundColor = GetFastValue(cameraConfig, "backgroundColor", false);
              if (backgroundColor) {
                camera.setBackgroundColor(backgroundColor);
              }
              var boundsConfig = GetFastValue(cameraConfig, "bounds", null);
              if (boundsConfig) {
                var bx = GetFastValue(boundsConfig, "x", 0);
                var by = GetFastValue(boundsConfig, "y", 0);
                var bwidth = GetFastValue(boundsConfig, "width", gameWidth);
                var bheight = GetFastValue(boundsConfig, "height", gameHeight);
                camera.setBounds(bx, by, bwidth, bheight);
              }
            }
            return this;
          },
          getCamera: function(name) {
            var cameras = this.cameras;
            for (var i2 = 0; i2 < cameras.length; i2++) {
              if (cameras[i2].name === name) {
                return cameras[i2];
              }
            }
            return null;
          },
          getCamerasBelowPointer: function(pointer) {
            var cameras = this.cameras;
            var x2 = pointer.x;
            var y2 = pointer.y;
            var output = [];
            for (var i2 = 0; i2 < cameras.length; i2++) {
              var camera = cameras[i2];
              if (camera.visible && camera.inputEnabled && RectangleContains(camera, x2, y2)) {
                output.unshift(camera);
              }
            }
            return output;
          },
          remove: function(camera, runDestroy) {
            if (runDestroy === void 0) {
              runDestroy = true;
            }
            if (!Array.isArray(camera)) {
              camera = [camera];
            }
            var total = 0;
            var cameras = this.cameras;
            for (var i2 = 0; i2 < camera.length; i2++) {
              var index2 = cameras.indexOf(camera[i2]);
              if (index2 !== -1) {
                if (runDestroy) {
                  cameras[index2].destroy();
                } else {
                  cameras[index2].renderList = [];
                }
                cameras.splice(index2, 1);
                total++;
              }
            }
            if (!this.main && cameras[0]) {
              this.main = cameras[0];
            }
            return total;
          },
          render: function(renderer, displayList) {
            var scene = this.scene;
            var cameras = this.cameras;
            for (var i2 = 0; i2 < this.cameras.length; i2++) {
              var camera = cameras[i2];
              if (camera.visible && camera.alpha > 0) {
                camera.preRender();
                var visibleChildren = this.getVisibleChildren(displayList.getChildren(), camera);
                renderer.render(scene, visibleChildren, camera);
              }
            }
          },
          getVisibleChildren: function(children, camera) {
            var visible = [];
            for (var i2 = 0; i2 < children.length; i2++) {
              var child = children[i2];
              if (child.willRender(camera)) {
                visible.push(child);
              }
            }
            return visible;
          },
          resetAll: function() {
            for (var i2 = 0; i2 < this.cameras.length; i2++) {
              this.cameras[i2].destroy();
            }
            this.cameras = [];
            this.main = this.add();
            return this.main;
          },
          update: function(time, delta) {
            for (var i2 = 0; i2 < this.cameras.length; i2++) {
              this.cameras[i2].update(time, delta);
            }
          },
          onResize: function(gameSize, baseSize, displaySize, previousWidth, previousHeight) {
            for (var i2 = 0; i2 < this.cameras.length; i2++) {
              var cam = this.cameras[i2];
              if (cam._x === 0 && cam._y === 0 && cam._width === previousWidth && cam._height === previousHeight) {
                cam.setSize(baseSize.width, baseSize.height);
              }
            }
          },
          resize: function(width, height) {
            for (var i2 = 0; i2 < this.cameras.length; i2++) {
              this.cameras[i2].setSize(width, height);
            }
          },
          shutdown: function() {
            this.main = void 0;
            for (var i2 = 0; i2 < this.cameras.length; i2++) {
              this.cameras[i2].destroy();
            }
            this.cameras = [];
            var eventEmitter = this.systems.events;
            eventEmitter.off(SceneEvents.UPDATE, this.update, this);
            eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          destroy: function() {
            this.shutdown();
            this.default.destroy();
            this.scene.sys.events.off(SceneEvents.START, this.start, this);
            this.scene = null;
            this.systems = null;
          }
        });
        PluginCache.register("CameraManager", CameraManager, "cameras");
        module2.exports = CameraManager;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "enterfullscreen";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "fullscreenfailed";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "fullscreenunsupported";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "leavefullscreen";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "orientationchange";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "resize";
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Config: __webpack_require__(346),
          CreateRenderer: __webpack_require__(366),
          DebugHeader: __webpack_require__(384),
          Events: __webpack_require__(22),
          TimeStep: __webpack_require__(385),
          VisibilityHandler: __webpack_require__(387)
        };
      },
      function(module2, exports2) {
        var process = module2.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e2) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e2) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
              args[i2 - 1] = arguments[i2];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {
        }
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;
        process.listeners = function(name) {
          return [];
        };
        process.binding = function(name) {
          throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
          return "/";
        };
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
          return 0;
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Browser = __webpack_require__(136);
        var Input = {
          gamepads: false,
          mspointer: false,
          touch: false,
          wheelEvent: null
        };
        function init() {
          if (typeof importScripts === "function") {
            return Input;
          }
          if ("ontouchstart" in document.documentElement || navigator.maxTouchPoints && navigator.maxTouchPoints >= 1) {
            Input.touch = true;
          }
          if (navigator.msPointerEnabled || navigator.pointerEnabled) {
            Input.mspointer = true;
          }
          if (navigator.getGamepads) {
            Input.gamepads = true;
          }
          if ("onwheel" in window || Browser.ie && "WheelEvent" in window) {
            Input.wheelEvent = "wheel";
          } else if ("onmousewheel" in window) {
            Input.wheelEvent = "mousewheel";
          } else if (Browser.firefox && "MouseScrollEvent" in window) {
            Input.wheelEvent = "DOMMouseScroll";
          }
          return Input;
        }
        module2.exports = init();
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Browser = __webpack_require__(136);
        var Audio2 = {
          audioData: false,
          dolby: false,
          m4a: false,
          mp3: false,
          ogg: false,
          opus: false,
          wav: false,
          webAudio: false,
          webm: false
        };
        function init() {
          if (typeof importScripts === "function") {
            return Audio2;
          }
          Audio2.audioData = !!window["Audio"];
          Audio2.webAudio = !!(window["AudioContext"] || window["webkitAudioContext"]);
          var audioElement = document.createElement("audio");
          var result = !!audioElement.canPlayType;
          try {
            if (result) {
              if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "")) {
                Audio2.ogg = true;
              }
              if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || audioElement.canPlayType("audio/opus;").replace(/^no$/, "")) {
                Audio2.opus = true;
              }
              if (audioElement.canPlayType("audio/mpeg;").replace(/^no$/, "")) {
                Audio2.mp3 = true;
              }
              if (audioElement.canPlayType("audio/wav").replace(/^no$/, "")) {
                Audio2.wav = true;
              }
              if (audioElement.canPlayType("audio/x-m4a;") || audioElement.canPlayType("audio/aac;").replace(/^no$/, "")) {
                Audio2.m4a = true;
              }
              if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")) {
                Audio2.webm = true;
              }
              if (audioElement.canPlayType('audio/mp4;codecs="ec-3"') !== "") {
                if (Browser.edge) {
                  Audio2.dolby = true;
                } else if (Browser.safari && Browser.safariVersion >= 9) {
                  if (/Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                    var major = parseInt(RegExp.$1, 10);
                    var minor = parseInt(RegExp.$2, 10);
                    if (major === 10 && minor >= 11 || major > 10) {
                      Audio2.dolby = true;
                    }
                  }
                }
              }
            }
          } catch (e) {
          }
          return Audio2;
        }
        module2.exports = init();
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Video = {
          h264: false,
          hls: false,
          mp4: false,
          ogg: false,
          vp9: false,
          webm: false
        };
        function init() {
          if (typeof importScripts === "function") {
            return Video;
          }
          var videoElement = document.createElement("video");
          var result = !!videoElement.canPlayType;
          try {
            if (result) {
              if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "")) {
                Video.ogg = true;
              }
              if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "")) {
                Video.h264 = true;
                Video.mp4 = true;
              }
              if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "")) {
                Video.webm = true;
              }
              if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "")) {
                Video.vp9 = true;
              }
              if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "")) {
                Video.hls = true;
              }
            }
          } catch (e) {
          }
          return Video;
        }
        module2.exports = init();
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Fullscreen = {
          available: false,
          cancel: "",
          keyboard: false,
          request: ""
        };
        function init() {
          if (typeof importScripts === "function") {
            return Fullscreen;
          }
          var i2;
          var suffix1 = "Fullscreen";
          var suffix2 = "FullScreen";
          var fs = [
            "request" + suffix1,
            "request" + suffix2,
            "webkitRequest" + suffix1,
            "webkitRequest" + suffix2,
            "msRequest" + suffix1,
            "msRequest" + suffix2,
            "mozRequest" + suffix2,
            "mozRequest" + suffix1
          ];
          for (i2 = 0; i2 < fs.length; i2++) {
            if (document.documentElement[fs[i2]]) {
              Fullscreen.available = true;
              Fullscreen.request = fs[i2];
              break;
            }
          }
          var cfs = [
            "cancel" + suffix2,
            "exit" + suffix1,
            "webkitCancel" + suffix2,
            "webkitExit" + suffix1,
            "msCancel" + suffix2,
            "msExit" + suffix1,
            "mozCancel" + suffix2,
            "mozExit" + suffix1
          ];
          if (Fullscreen.available) {
            for (i2 = 0; i2 < cfs.length; i2++) {
              if (document[cfs[i2]]) {
                Fullscreen.cancel = cfs[i2];
                break;
              }
            }
          }
          if (window["Element"] && Element["ALLOW_KEYBOARD_INPUT"] && !/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent)) {
            Fullscreen.keyboard = true;
          }
          Object.defineProperty(Fullscreen, "active", { get: function() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
          } });
          return Fullscreen;
        }
        module2.exports = init();
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Between: __webpack_require__(349),
          BetweenPoints: __webpack_require__(350),
          BetweenPointsY: __webpack_require__(813),
          BetweenY: __webpack_require__(814),
          CounterClockwise: __webpack_require__(815),
          Normalize: __webpack_require__(351),
          Random: __webpack_require__(816),
          RandomDegrees: __webpack_require__(817),
          Reverse: __webpack_require__(818),
          RotateTo: __webpack_require__(819),
          ShortestBetween: __webpack_require__(820),
          Wrap: __webpack_require__(269),
          WrapDegrees: __webpack_require__(270)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BetweenPointsY = function(point1, point2) {
          return Math.atan2(point2.x - point1.x, point2.y - point1.y);
        };
        module2.exports = BetweenPointsY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BetweenY = function(x1, y1, x2, y2) {
          return Math.atan2(x2 - x1, y2 - y1);
        };
        module2.exports = BetweenY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(14);
        var CounterClockwise = function(angle) {
          if (angle > Math.PI) {
            angle -= CONST.PI2;
          }
          return Math.abs(((angle + CONST.TAU) % CONST.PI2 - CONST.PI2) % CONST.PI2);
        };
        module2.exports = CounterClockwise;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       @samme
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FloatBetween = __webpack_require__(137);
        var Random = function() {
          return FloatBetween(-Math.PI, Math.PI);
        };
        module2.exports = Random;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       @samme
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FloatBetween = __webpack_require__(137);
        var RandomDegrees = function() {
          return FloatBetween(-180, 180);
        };
        module2.exports = RandomDegrees;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Normalize = __webpack_require__(351);
        var Reverse = function(angle) {
          return Normalize(angle + Math.PI);
        };
        module2.exports = Reverse;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MATH_CONST = __webpack_require__(14);
        var RotateTo = function(currentAngle, targetAngle, lerp) {
          if (lerp === void 0) {
            lerp = 0.05;
          }
          if (currentAngle === targetAngle) {
            return currentAngle;
          }
          if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= MATH_CONST.PI2 - lerp) {
            currentAngle = targetAngle;
          } else {
            if (Math.abs(targetAngle - currentAngle) > Math.PI) {
              if (targetAngle < currentAngle) {
                targetAngle += MATH_CONST.PI2;
              } else {
                targetAngle -= MATH_CONST.PI2;
              }
            }
            if (targetAngle > currentAngle) {
              currentAngle += lerp;
            } else if (targetAngle < currentAngle) {
              currentAngle -= lerp;
            }
          }
          return currentAngle;
        };
        module2.exports = RotateTo;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ShortestBetween = function(angle1, angle2) {
          var difference = angle2 - angle1;
          if (difference === 0) {
            return 0;
          }
          var times = Math.floor((difference - -180) / 360);
          return difference - times * 360;
        };
        module2.exports = ShortestBetween;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Between: __webpack_require__(50),
          BetweenPoints: __webpack_require__(352),
          BetweenPointsSquared: __webpack_require__(822),
          Chebyshev: __webpack_require__(823),
          Power: __webpack_require__(824),
          Snake: __webpack_require__(825),
          Squared: __webpack_require__(353)
        };
      },
      function(module2, exports2) {
        /**
         * @author       samme
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DistanceBetweenPointsSquared = function(a, b2) {
          var dx = a.x - b2.x;
          var dy = a.y - b2.y;
          return dx * dx + dy * dy;
        };
        module2.exports = DistanceBetweenPointsSquared;
      },
      function(module2, exports2) {
        /**
         * @author       samme
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ChebyshevDistance = function(x1, y1, x2, y2) {
          return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
        };
        module2.exports = ChebyshevDistance;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DistancePower = function(x1, y1, x2, y2, pow) {
          if (pow === void 0) {
            pow = 2;
          }
          return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
        };
        module2.exports = DistancePower;
      },
      function(module2, exports2) {
        /**
         * @author       samme
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SnakeDistance = function(x1, y1, x2, y2) {
          return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        };
        module2.exports = SnakeDistance;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Back: __webpack_require__(334),
          Bounce: __webpack_require__(335),
          Circular: __webpack_require__(336),
          Cubic: __webpack_require__(337),
          Elastic: __webpack_require__(338),
          Expo: __webpack_require__(339),
          Linear: __webpack_require__(340),
          Quadratic: __webpack_require__(341),
          Quartic: __webpack_require__(342),
          Quintic: __webpack_require__(343),
          Sine: __webpack_require__(344),
          Stepped: __webpack_require__(345)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Ceil: __webpack_require__(828),
          Equal: __webpack_require__(124),
          Floor: __webpack_require__(829),
          GreaterThan: __webpack_require__(354),
          LessThan: __webpack_require__(355)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Ceil = function(value, epsilon) {
          if (epsilon === void 0) {
            epsilon = 1e-4;
          }
          return Math.ceil(value - epsilon);
        };
        module2.exports = Ceil;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Floor = function(value, epsilon) {
          if (epsilon === void 0) {
            epsilon = 1e-4;
          }
          return Math.floor(value + epsilon);
        };
        module2.exports = Floor;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Bezier: __webpack_require__(831),
          CatmullRom: __webpack_require__(832),
          CubicBezier: __webpack_require__(358),
          Linear: __webpack_require__(833),
          QuadraticBezier: __webpack_require__(359),
          SmoothStep: __webpack_require__(360),
          SmootherStep: __webpack_require__(834)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Bernstein = __webpack_require__(356);
        var BezierInterpolation = function(v2, k2) {
          var b2 = 0;
          var n2 = v2.length - 1;
          for (var i2 = 0; i2 <= n2; i2++) {
            b2 += Math.pow(1 - k2, n2 - i2) * Math.pow(k2, i2) * v2[i2] * Bernstein(n2, i2);
          }
          return b2;
        };
        module2.exports = BezierInterpolation;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CatmullRom = __webpack_require__(194);
        var CatmullRomInterpolation = function(v2, k2) {
          var m2 = v2.length - 1;
          var f2 = m2 * k2;
          var i2 = Math.floor(f2);
          if (v2[0] === v2[m2]) {
            if (k2 < 0) {
              i2 = Math.floor(f2 = m2 * (1 + k2));
            }
            return CatmullRom(f2 - i2, v2[(i2 - 1 + m2) % m2], v2[i2], v2[(i2 + 1) % m2], v2[(i2 + 2) % m2]);
          } else {
            if (k2 < 0) {
              return v2[0] - (CatmullRom(-f2, v2[0], v2[0], v2[1], v2[1]) - v2[0]);
            }
            if (k2 > 1) {
              return v2[m2] - (CatmullRom(f2 - m2, v2[m2], v2[m2], v2[m2 - 1], v2[m2 - 1]) - v2[m2]);
            }
            return CatmullRom(f2 - i2, v2[i2 ? i2 - 1 : 0], v2[i2], v2[m2 < i2 + 1 ? m2 : i2 + 1], v2[m2 < i2 + 2 ? m2 : i2 + 2]);
          }
        };
        module2.exports = CatmullRomInterpolation;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Linear = __webpack_require__(135);
        var LinearInterpolation = function(v2, k2) {
          var m2 = v2.length - 1;
          var f2 = m2 * k2;
          var i2 = Math.floor(f2);
          if (k2 < 0) {
            return Linear(v2[0], v2[1], f2);
          } else if (k2 > 1) {
            return Linear(v2[m2], v2[m2 - 1], m2 - f2);
          } else {
            return Linear(v2[i2], v2[i2 + 1 > m2 ? m2 : i2 + 1], f2 - i2);
          }
        };
        module2.exports = LinearInterpolation;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SmootherStep = __webpack_require__(183);
        var SmootherStepInterpolation = function(t2, min, max) {
          return min + (max - min) * SmootherStep(t2, 0, 1);
        };
        module2.exports = SmootherStepInterpolation;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          GetNext: __webpack_require__(361),
          IsSize: __webpack_require__(138),
          IsValue: __webpack_require__(836)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var IsValuePowerOfTwo = function(value) {
          return value > 0 && (value & value - 1) === 0;
        };
        module2.exports = IsValuePowerOfTwo;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Ceil: __webpack_require__(139),
          Floor: __webpack_require__(76),
          To: __webpack_require__(838)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SnapTo = function(value, gap, start, divide) {
          if (start === void 0) {
            start = 0;
          }
          if (gap === 0) {
            return value;
          }
          value -= start;
          value = gap * Math.round(value / gap);
          return divide ? (start + value) / gap : start + value;
        };
        module2.exports = SnapTo;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var RandomDataGenerator = new Class({
          initialize: function RandomDataGenerator2(seeds) {
            if (seeds === void 0) {
              seeds = [(Date.now() * Math.random()).toString()];
            }
            this.c = 1;
            this.s0 = 0;
            this.s1 = 0;
            this.s2 = 0;
            this.n = 0;
            this.signs = [-1, 1];
            if (seeds) {
              this.init(seeds);
            }
          },
          rnd: function() {
            var t2 = 2091639 * this.s0 + this.c * 23283064365386963e-26;
            this.c = t2 | 0;
            this.s0 = this.s1;
            this.s1 = this.s2;
            this.s2 = t2 - this.c;
            return this.s2;
          },
          hash: function(data) {
            var h2;
            var n2 = this.n;
            data = data.toString();
            for (var i2 = 0; i2 < data.length; i2++) {
              n2 += data.charCodeAt(i2);
              h2 = 0.02519603282416938 * n2;
              n2 = h2 >>> 0;
              h2 -= n2;
              h2 *= n2;
              n2 = h2 >>> 0;
              h2 -= n2;
              n2 += h2 * 4294967296;
            }
            this.n = n2;
            return (n2 >>> 0) * 23283064365386963e-26;
          },
          init: function(seeds) {
            if (typeof seeds === "string") {
              this.state(seeds);
            } else {
              this.sow(seeds);
            }
          },
          sow: function(seeds) {
            this.n = 4022871197;
            this.s0 = this.hash(" ");
            this.s1 = this.hash(" ");
            this.s2 = this.hash(" ");
            this.c = 1;
            if (!seeds) {
              return;
            }
            for (var i2 = 0; i2 < seeds.length && seeds[i2] != null; i2++) {
              var seed = seeds[i2];
              this.s0 -= this.hash(seed);
              this.s0 += ~~(this.s0 < 0);
              this.s1 -= this.hash(seed);
              this.s1 += ~~(this.s1 < 0);
              this.s2 -= this.hash(seed);
              this.s2 += ~~(this.s2 < 0);
            }
          },
          integer: function() {
            return this.rnd() * 4294967296;
          },
          frac: function() {
            return this.rnd() + (this.rnd() * 2097152 | 0) * 11102230246251565e-32;
          },
          real: function() {
            return this.integer() + this.frac();
          },
          integerInRange: function(min, max) {
            return Math.floor(this.realInRange(0, max - min + 1) + min);
          },
          between: function(min, max) {
            return Math.floor(this.realInRange(0, max - min + 1) + min);
          },
          realInRange: function(min, max) {
            return this.frac() * (max - min) + min;
          },
          normal: function() {
            return 1 - 2 * this.frac();
          },
          uuid: function() {
            var a = "";
            var b2 = "";
            for (b2 = a = ""; a++ < 36; b2 += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
            }
            return b2;
          },
          pick: function(array) {
            return array[this.integerInRange(0, array.length - 1)];
          },
          sign: function() {
            return this.pick(this.signs);
          },
          weightedPick: function(array) {
            return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];
          },
          timestamp: function(min, max) {
            return this.realInRange(min || 9466848e5, max || 1577862e6);
          },
          angle: function() {
            return this.integerInRange(-180, 180);
          },
          rotation: function() {
            return this.realInRange(-3.1415926, 3.1415926);
          },
          state: function(state) {
            if (typeof state === "string" && state.match(/^!rnd/)) {
              state = state.split(",");
              this.c = parseFloat(state[1]);
              this.s0 = parseFloat(state[2]);
              this.s1 = parseFloat(state[3]);
              this.s2 = parseFloat(state[4]);
            }
            return ["!rnd", this.c, this.s0, this.s1, this.s2].join(",");
          },
          shuffle: function(array) {
            var len = array.length - 1;
            for (var i2 = len; i2 > 0; i2--) {
              var randomIndex = Math.floor(this.frac() * (i2 + 1));
              var itemAtIndex = array[randomIndex];
              array[randomIndex] = array[i2];
              array[i2] = itemAtIndex;
            }
            return array;
          }
        });
        module2.exports = RandomDataGenerator;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Average = function(values) {
          var sum = 0;
          for (var i2 = 0; i2 < values.length; i2++) {
            sum += +values[i2];
          }
          return sum / values.length;
        };
        module2.exports = Average;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CeilTo = function(value, place, base) {
          if (place === void 0) {
            place = 0;
          }
          if (base === void 0) {
            base = 10;
          }
          var p2 = Math.pow(base, -place);
          return Math.ceil(value * p2) / p2;
        };
        module2.exports = CeilTo;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Difference = function(a, b2) {
          return Math.abs(a - b2);
        };
        module2.exports = Difference;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clamp = __webpack_require__(18);
        var Class = __webpack_require__(0);
        var Matrix4 = __webpack_require__(69);
        var NOOP = __webpack_require__(1);
        var tempMatrix = new Matrix4();
        var Euler = new Class({
          initialize: function Euler2(x2, y2, z2, order) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (z2 === void 0) {
              z2 = 0;
            }
            if (order === void 0) {
              order = Euler2.DefaultOrder;
            }
            this._x = x2;
            this._y = y2;
            this._z = z2;
            this._order = order;
            this.onChangeCallback = NOOP;
          },
          x: {
            get: function() {
              return this._x;
            },
            set: function(value) {
              this._x = value;
              this.onChangeCallback(this);
            }
          },
          y: {
            get: function() {
              return this._y;
            },
            set: function(value) {
              this._y = value;
              this.onChangeCallback(this);
            }
          },
          z: {
            get: function() {
              return this._z;
            },
            set: function(value) {
              this._z = value;
              this.onChangeCallback(this);
            }
          },
          order: {
            get: function() {
              return this._order;
            },
            set: function(value) {
              this._order = value;
              this.onChangeCallback(this);
            }
          },
          set: function(x2, y2, z2, order) {
            if (order === void 0) {
              order = this._order;
            }
            this._x = x2;
            this._y = y2;
            this._z = z2;
            this._order = order;
            this.onChangeCallback(this);
            return this;
          },
          copy: function(euler) {
            return this.set(euler.x, euler.y, euler.z, euler.order);
          },
          setFromQuaternion: function(quaternion, order, update) {
            if (order === void 0) {
              order = this._order;
            }
            if (update === void 0) {
              update = false;
            }
            tempMatrix.fromQuat(quaternion);
            return this.setFromRotationMatrix(tempMatrix, order, update);
          },
          setFromRotationMatrix: function(matrix, order, update) {
            if (order === void 0) {
              order = this._order;
            }
            if (update === void 0) {
              update = false;
            }
            var elements = matrix.val;
            var m11 = elements[0];
            var m12 = elements[4];
            var m13 = elements[8];
            var m21 = elements[1];
            var m22 = elements[5];
            var m23 = elements[9];
            var m31 = elements[2];
            var m32 = elements[6];
            var m33 = elements[10];
            var x2 = 0;
            var y2 = 0;
            var z2 = 0;
            var epsilon = 0.99999;
            switch (order) {
              case "XYZ": {
                y2 = Math.asin(Clamp(m13, -1, 1));
                if (Math.abs(m13) < epsilon) {
                  x2 = Math.atan2(-m23, m33);
                  z2 = Math.atan2(-m12, m11);
                } else {
                  x2 = Math.atan2(m32, m22);
                }
                break;
              }
              case "YXZ": {
                x2 = Math.asin(-Clamp(m23, -1, 1));
                if (Math.abs(m23) < epsilon) {
                  y2 = Math.atan2(m13, m33);
                  z2 = Math.atan2(m21, m22);
                } else {
                  y2 = Math.atan2(-m31, m11);
                }
                break;
              }
              case "ZXY": {
                x2 = Math.asin(Clamp(m32, -1, 1));
                if (Math.abs(m32) < epsilon) {
                  y2 = Math.atan2(-m31, m33);
                  z2 = Math.atan2(-m12, m22);
                } else {
                  z2 = Math.atan2(m21, m11);
                }
                break;
              }
              case "ZYX": {
                y2 = Math.asin(-Clamp(m31, -1, 1));
                if (Math.abs(m31) < epsilon) {
                  x2 = Math.atan2(m32, m33);
                  z2 = Math.atan2(m21, m11);
                } else {
                  z2 = Math.atan2(-m12, m22);
                }
                break;
              }
              case "YZX": {
                z2 = Math.asin(Clamp(m21, -1, 1));
                if (Math.abs(m21) < epsilon) {
                  x2 = Math.atan2(-m23, m22);
                  y2 = Math.atan2(-m31, m11);
                } else {
                  y2 = Math.atan2(m13, m33);
                }
                break;
              }
              case "XZY": {
                z2 = Math.asin(-Clamp(m12, -1, 1));
                if (Math.abs(m12) < epsilon) {
                  x2 = Math.atan2(m32, m22);
                  y2 = Math.atan2(m13, m11);
                } else {
                  x2 = Math.atan2(-m23, m33);
                }
                break;
              }
            }
            this._x = x2;
            this._y = y2;
            this._z = z2;
            this._order = order;
            if (update) {
              this.onChangeCallback(this);
            }
            return this;
          }
        });
        Euler.RotationOrders = ["XYZ", "YXZ", "ZXY", "ZYX", "YZX", "XZY"];
        Euler.DefaultOrder = "XYZ";
        module2.exports = Euler;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FloorTo = function(value, place, base) {
          if (place === void 0) {
            place = 0;
          }
          if (base === void 0) {
            base = 10;
          }
          var p2 = Math.pow(base, -place);
          return Math.floor(value * p2) / p2;
        };
        module2.exports = FloorTo;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetSpeed = function(distance, time) {
          return distance / time / 1e3;
        };
        module2.exports = GetSpeed;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var IsEven = function(value) {
          return value == parseFloat(value) ? !(value % 2) : void 0;
        };
        module2.exports = IsEven;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var IsEvenStrict = function(value) {
          return value === parseFloat(value) ? !(value % 2) : void 0;
        };
        module2.exports = IsEvenStrict;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MaxAdd = function(value, amount, max) {
          return Math.min(value + amount, max);
        };
        module2.exports = MaxAdd;
      },
      function(module2, exports2) {
        /**
         * @author       Vladislav Forsh <vlad@robowhale.com>
         * @copyright    2021 RoboWhale
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Median = function(values) {
          var valuesNum = values.length;
          if (valuesNum === 0) {
            return 0;
          }
          values.sort(function(a, b2) {
            return a - b2;
          });
          var halfIndex = Math.floor(valuesNum / 2);
          return valuesNum % 2 === 0 ? (values[halfIndex] + values[halfIndex - 1]) / 2 : values[halfIndex];
        };
        module2.exports = Median;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MinSub = function(value, amount, min) {
          return Math.max(value - amount, min);
        };
        module2.exports = MinSub;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Percent = function(value, min, max, upperMax) {
          if (max === void 0) {
            max = min + 1;
          }
          var percentage = (value - min) / (max - min);
          if (percentage > 1) {
            if (upperMax !== void 0) {
              percentage = (upperMax - value) / (upperMax - max);
              if (percentage < 0) {
                percentage = 0;
              }
            } else {
              percentage = 1;
            }
          } else if (percentage < 0) {
            percentage = 0;
          }
          return percentage;
        };
        module2.exports = Percent;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RandomXY = function(vector, scale) {
          if (scale === void 0) {
            scale = 1;
          }
          var r2 = Math.random() * 2 * Math.PI;
          vector.x = Math.cos(r2) * scale;
          vector.y = Math.sin(r2) * scale;
          return vector;
        };
        module2.exports = RandomXY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RandomXYZ = function(vec3, radius) {
          if (radius === void 0) {
            radius = 1;
          }
          var r2 = Math.random() * 2 * Math.PI;
          var z2 = Math.random() * 2 - 1;
          var zScale = Math.sqrt(1 - z2 * z2) * radius;
          vec3.x = Math.cos(r2) * zScale;
          vec3.y = Math.sin(r2) * zScale;
          vec3.z = z2 * radius;
          return vec3;
        };
        module2.exports = RandomXYZ;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RandomXYZW = function(vec4, scale) {
          if (scale === void 0) {
            scale = 1;
          }
          vec4.x = (Math.random() * 2 - 1) * scale;
          vec4.y = (Math.random() * 2 - 1) * scale;
          vec4.z = (Math.random() * 2 - 1) * scale;
          vec4.w = (Math.random() * 2 - 1) * scale;
          return vec4;
        };
        module2.exports = RandomXYZW;
      },
      function(module2, exports2) {
        /**
         * @author       samme
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateTo = function(point, x2, y2, angle, distance) {
          point.x = x2 + distance * Math.cos(angle);
          point.y = y2 + distance * Math.sin(angle);
          return point;
        };
        module2.exports = RotateTo;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RoundTo = function(value, place, base) {
          if (place === void 0) {
            place = 0;
          }
          if (base === void 0) {
            base = 10;
          }
          var p2 = Math.pow(base, -place);
          return Math.round(value * p2) / p2;
        };
        module2.exports = RoundTo;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SinCosTableGenerator = function(length, sinAmp, cosAmp, frequency) {
          if (sinAmp === void 0) {
            sinAmp = 1;
          }
          if (cosAmp === void 0) {
            cosAmp = 1;
          }
          if (frequency === void 0) {
            frequency = 1;
          }
          frequency *= Math.PI / length;
          var cos = [];
          var sin = [];
          for (var c = 0; c < length; c++) {
            cosAmp -= sinAmp * frequency;
            sinAmp += cosAmp * frequency;
            cos[c] = cosAmp;
            sin[c] = sinAmp;
          }
          return {
            sin,
            cos,
            length
          };
        };
        module2.exports = SinCosTableGenerator;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector2 = __webpack_require__(3);
        var ToXY = function(index2, width, height, out) {
          if (out === void 0) {
            out = new Vector2();
          }
          var x2 = 0;
          var y2 = 0;
          var total = width * height;
          if (index2 > 0 && index2 <= total) {
            if (index2 > width - 1) {
              y2 = Math.floor(index2 / width);
              x2 = index2 - y2 * width;
            } else {
              x2 = index2;
            }
          }
          return out.set(x2, y2);
        };
        module2.exports = ToXY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Within = function(a, b2, tolerance) {
          return Math.abs(a - b2) <= tolerance;
        };
        module2.exports = Within;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector3 = __webpack_require__(39);
        var Matrix4 = __webpack_require__(69);
        var Quaternion = __webpack_require__(365);
        var tmpMat4 = new Matrix4();
        var tmpQuat = new Quaternion();
        var tmpVec3 = new Vector3();
        var RotateVec3 = function(vec, axis, radians) {
          tmpQuat.setAxisAngle(axis, radians);
          tmpMat4.fromRotationTranslation(tmpQuat, tmpVec3.set(0, 0, 0));
          return vec.transformMat4(tmpMat4);
        };
        module2.exports = RotateVec3;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "addtexture";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "onerror";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "onload";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "ready";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "removetexture";
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_BITMAP_MASK_FS",
          "",
          "precision mediump float;",
          "",
          "uniform vec2 uResolution;",
          "uniform sampler2D uMainSampler;",
          "uniform sampler2D uMaskSampler;",
          "uniform bool uInvertMaskAlpha;",
          "",
          "void main ()",
          "{",
          "    vec2 uv = gl_FragCoord.xy / uResolution;",
          "    vec4 mainColor = texture2D(uMainSampler, uv);",
          "    vec4 maskColor = texture2D(uMaskSampler, uv);",
          "    float alpha = mainColor.a;",
          "",
          "    if (!uInvertMaskAlpha)",
          "    {",
          "        alpha *= (maskColor.a);",
          "    }",
          "    else",
          "    {",
          "        alpha *= (1.0 - maskColor.a);",
          "    }",
          "",
          "    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_BITMAP_MASK_VS",
          "",
          "precision mediump float;",
          "",
          "attribute vec2 inPosition;",
          "",
          "void main ()",
          "{",
          "    gl_Position = vec4(inPosition, 0.0, 1.0);",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pipelineafterflush";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pipelinebeforeflush";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pipelinebind";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pipelineboot";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pipelinedestroy";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pipelinerebind";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pipelineresize";
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_GRAPHICS_FS",
          "",
          "precision mediump float;",
          "",
          "varying vec4 outColor;",
          "",
          "void main ()",
          "{",
          "    gl_FragColor = vec4(outColor.bgr * outColor.a, outColor.a);",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_GRAPHICS_VS",
          "",
          "precision mediump float;",
          "",
          "uniform mat4 uProjectionMatrix;",
          "",
          "attribute vec2 inPosition;",
          "attribute vec4 inColor;",
          "",
          "varying vec4 outColor;",
          "",
          "void main ()",
          "{",
          "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
          "",
          "    outColor = inColor;",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_LIGHT_FS",
          "",
          "precision mediump float;",
          "",
          "struct Light",
          "{",
          "    vec2 position;",
          "    vec3 color;",
          "    float intensity;",
          "    float radius;",
          "};",
          "",
          "const int kMaxLights = %LIGHT_COUNT%;",
          "",
          "uniform vec4 uCamera; /* x, y, rotation, zoom */",
          "uniform vec2 uResolution;",
          "uniform sampler2D uMainSampler;",
          "uniform sampler2D uNormSampler;",
          "uniform vec3 uAmbientLightColor;",
          "uniform Light uLights[kMaxLights];",
          "uniform mat3 uInverseRotationMatrix;",
          "",
          "varying vec2 outTexCoord;",
          "varying vec4 outTint;",
          "",
          "void main()",
          "{",
          "    vec3 finalColor = vec3(0.0, 0.0, 0.0);",
          "    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.bgr * outTint.a, outTint.a);",
          "    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;",
          "    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));",
          "    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;",
          "",
          "    for (int index = 0; index < kMaxLights; ++index)",
          "    {",
          "        Light light = uLights[index];",
          "        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);",
          "        vec3 lightNormal = normalize(lightDir);",
          "        float distToSurf = length(lightDir) * uCamera.w;",
          "        float diffuseFactor = max(dot(normal, lightNormal), 0.0);",
          "        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;",
          "        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);",
          "        vec3 diffuse = light.color * diffuseFactor;",
          "        finalColor += (attenuation * diffuse) * light.intensity;",
          "    }",
          "",
          "    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);",
          "",
          "    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_MULTI_FS",
          "",
          "precision mediump float;",
          "",
          "uniform sampler2D uMainSampler[%count%];",
          "",
          "varying vec2 outTexCoord;",
          "varying float outTexId;",
          "varying float outTintEffect;",
          "varying vec4 outTint;",
          "",
          "void main ()",
          "{",
          "    vec4 texture;",
          "",
          "    %forloop%",
          "",
          "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);",
          "",
          "    //  Multiply texture tint",
          "    vec4 color = texture * texel;",
          "",
          "    if (outTintEffect == 1.0)",
          "    {",
          "        //  Solid color + texture alpha",
          "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);",
          "    }",
          "    else if (outTintEffect == 2.0)",
          "    {",
          "        //  Solid color, no texture",
          "        color = texel;",
          "    }",
          "",
          "    gl_FragColor = color;",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_MULTI_VS",
          "",
          "precision mediump float;",
          "",
          "uniform mat4 uProjectionMatrix;",
          "",
          "attribute vec2 inPosition;",
          "attribute vec2 inTexCoord;",
          "attribute float inTexId;",
          "attribute float inTintEffect;",
          "attribute vec4 inTint;",
          "",
          "varying vec2 outTexCoord;",
          "varying float outTexId;",
          "varying float outTintEffect;",
          "varying vec4 outTint;",
          "",
          "void main ()",
          "{",
          "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
          "",
          "    outTexCoord = inTexCoord;",
          "    outTexId = inTexId;",
          "    outTint = inTint;",
          "    outTintEffect = inTintEffect;",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_POINTLIGHT_FS",
          "",
          "precision mediump float;",
          "",
          "uniform vec2 uResolution;",
          "uniform float uCameraZoom;",
          "",
          "varying vec4 lightPosition;",
          "varying vec4 lightColor;",
          "varying float lightRadius;",
          "varying float lightAttenuation;",
          "",
          "void main ()",
          "{",
          "    vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);",
          "",
          "    float distToSurf = length(center - gl_FragCoord.xy);",
          "",
          "    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);",
          "",
          "    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);",
          "",
          "    vec4 color = vec4(intensity, intensity, intensity, 0.0) * lightColor;",
          "",
          "    gl_FragColor = vec4(color.rgb * lightColor.a, color.a);",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_POINTLIGHT_VS",
          "",
          "precision mediump float;",
          "",
          "uniform mat4 uProjectionMatrix;",
          "",
          "attribute vec2 inPosition;",
          "attribute vec2 inLightPosition;",
          "attribute vec4 inLightColor;",
          "attribute float inLightRadius;",
          "attribute float inLightAttenuation;",
          "",
          "varying vec4 lightPosition;",
          "varying vec4 lightColor;",
          "varying float lightRadius;",
          "varying float lightAttenuation;",
          "",
          "void main ()",
          "{",
          "    lightColor = inLightColor;",
          "    lightRadius = inLightRadius;",
          "    lightAttenuation = inLightAttenuation;",
          "    lightPosition = uProjectionMatrix * vec4(inLightPosition, 1.0, 1.0);",
          "",
          "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_SINGLE_FS",
          "",
          "precision mediump float;",
          "",
          "uniform sampler2D uMainSampler;",
          "",
          "varying vec2 outTexCoord;",
          "varying float outTintEffect;",
          "varying vec4 outTint;",
          "",
          "void main ()",
          "{",
          "    vec4 texture = texture2D(uMainSampler, outTexCoord);",
          "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);",
          "",
          "    //  Multiply texture tint",
          "    vec4 color = texture * texel;",
          "",
          "    if (outTintEffect == 1.0)",
          "    {",
          "        //  Solid color + texture alpha",
          "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);",
          "    }",
          "    else if (outTintEffect == 2.0)",
          "    {",
          "        //  Solid color, no texture",
          "        color = texel;",
          "    }",
          "",
          "    gl_FragColor = color;",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_SINGLE_VS",
          "",
          "precision mediump float;",
          "",
          "uniform mat4 uProjectionMatrix;",
          "",
          "attribute vec2 inPosition;",
          "attribute vec2 inTexCoord;",
          "attribute float inTexId;",
          "attribute float inTintEffect;",
          "attribute vec4 inTint;",
          "",
          "varying vec2 outTexCoord;",
          "varying float outTintEffect;",
          "varying vec4 outTint;",
          "",
          "void main ()",
          "{",
          "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
          "",
          "    outTexCoord = inTexCoord;",
          "    outTint = inTint;",
          "    outTintEffect = inTintEffect;",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_ADD_BLEND_FS",
          "",
          "precision mediump float;",
          "",
          "uniform sampler2D uMainSampler1;",
          "uniform sampler2D uMainSampler2;",
          "uniform float uStrength;",
          "",
          "varying vec2 outTexCoord;",
          "",
          "void main ()",
          "{",
          "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);",
          "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);",
          "",
          "    gl_FragColor = frame1 + frame2 * uStrength;",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_COLORMATRIX_FS",
          "",
          "precision mediump float;",
          "",
          "uniform sampler2D uMainSampler;",
          "uniform float uColorMatrix[20];",
          "uniform float uAlpha;",
          "",
          "varying vec2 outTexCoord;",
          "",
          "void main ()",
          "{",
          "    vec4 c = texture2D(uMainSampler, outTexCoord);",
          "",
          "    if (uAlpha == 0.0)",
          "    {",
          "        gl_FragColor = c;",
          "",
          "        return;",
          "    }",
          "",
          "    if (c.a > 0.0)",
          "    {",
          "        c.rgb /= c.a;",
          "    }",
          "",
          "    vec4 result;",
          "",
          "    result.r = (uColorMatrix[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMatrix[4];",
          "    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b) + (uColorMatrix[8] * c.a) + uColorMatrix[9];",
          "    result.b = (uColorMatrix[10] * c.r) + (uColorMatrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];",
          "    result.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMatrix[18] * c.a) + uColorMatrix[19];",
          "",
          "    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);",
          "",
          "    rgb *= result.a;",
          "",
          "    gl_FragColor = vec4(rgb, result.a);",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_COPY_FS",
          "",
          "precision mediump float;",
          "",
          "uniform sampler2D uMainSampler;",
          "uniform float uBrightness;",
          "",
          "varying vec2 outTexCoord;",
          "",
          "void main ()",
          "{",
          "    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_LINEAR_BLEND_FS",
          "",
          "precision mediump float;",
          "",
          "uniform sampler2D uMainSampler1;",
          "uniform sampler2D uMainSampler2;",
          "uniform float uStrength;",
          "",
          "varying vec2 outTexCoord;",
          "",
          "void main ()",
          "{",
          "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);",
          "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);",
          "",
          "    gl_FragColor = mix(frame1, frame2 * uStrength, 0.5);",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          GenerateTexture: __webpack_require__(388),
          Palettes: __webpack_require__(889)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          ARNE16: __webpack_require__(389),
          C64: __webpack_require__(890),
          CGA: __webpack_require__(891),
          JMP: __webpack_require__(892),
          MSX: __webpack_require__(893)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          0: "#000",
          1: "#fff",
          2: "#8b4131",
          3: "#7bbdc5",
          4: "#8b41ac",
          5: "#6aac41",
          6: "#3931a4",
          7: "#d5de73",
          8: "#945a20",
          9: "#5a4100",
          A: "#bd736a",
          B: "#525252",
          C: "#838383",
          D: "#acee8b",
          E: "#7b73de",
          F: "#acacac"
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          0: "#000",
          1: "#2234d1",
          2: "#0c7e45",
          3: "#44aacc",
          4: "#8a3622",
          5: "#5c2e78",
          6: "#aa5c3d",
          7: "#b5b5b5",
          8: "#5e606e",
          9: "#4c81fb",
          A: "#6cd947",
          B: "#7be2f9",
          C: "#eb8a60",
          D: "#e23d69",
          E: "#ffd93f",
          F: "#fff"
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          0: "#000",
          1: "#191028",
          2: "#46af45",
          3: "#a1d685",
          4: "#453e78",
          5: "#7664fe",
          6: "#833129",
          7: "#9ec2e8",
          8: "#dc534b",
          9: "#e18d79",
          A: "#d6b97b",
          B: "#e9d8a1",
          C: "#216c4b",
          D: "#d365c8",
          E: "#afaab9",
          F: "#f5f4eb"
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          0: "#000",
          1: "#191028",
          2: "#46af45",
          3: "#a1d685",
          4: "#453e78",
          5: "#7664fe",
          6: "#833129",
          7: "#9ec2e8",
          8: "#dc534b",
          9: "#e18d79",
          A: "#d6b97b",
          B: "#e9d8a1",
          C: "#216c4b",
          D: "#d365c8",
          E: "#afaab9",
          F: "#fff"
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Path: __webpack_require__(895),
          MoveTo: __webpack_require__(393),
          CubicBezier: __webpack_require__(390),
          Curve: __webpack_require__(94),
          Ellipse: __webpack_require__(391),
          Line: __webpack_require__(392),
          QuadraticBezier: __webpack_require__(394),
          Spline: __webpack_require__(395)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CubicBezierCurve = __webpack_require__(390);
        var EllipseCurve = __webpack_require__(391);
        var GameObjectFactory = __webpack_require__(5);
        var LineCurve = __webpack_require__(392);
        var MovePathTo = __webpack_require__(393);
        var QuadraticBezierCurve = __webpack_require__(394);
        var Rectangle = __webpack_require__(10);
        var SplineCurve = __webpack_require__(395);
        var Vector2 = __webpack_require__(3);
        var MATH_CONST = __webpack_require__(14);
        var Path = new Class({
          initialize: function Path2(x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            this.name = "";
            this.curves = [];
            this.cacheLengths = [];
            this.autoClose = false;
            this.startPoint = new Vector2();
            this._tmpVec2A = new Vector2();
            this._tmpVec2B = new Vector2();
            if (typeof x2 === "object") {
              this.fromJSON(x2);
            } else {
              this.startPoint.set(x2, y2);
            }
          },
          add: function(curve) {
            this.curves.push(curve);
            return this;
          },
          circleTo: function(radius, clockwise, rotation) {
            if (clockwise === void 0) {
              clockwise = false;
            }
            return this.ellipseTo(radius, radius, 0, 360, clockwise, rotation);
          },
          closePath: function() {
            var startPoint = this.curves[0].getPoint(0);
            var endPoint = this.curves[this.curves.length - 1].getPoint(1);
            if (!startPoint.equals(endPoint)) {
              this.curves.push(new LineCurve(endPoint, startPoint));
            }
            return this;
          },
          cubicBezierTo: function(x2, y2, control1X, control1Y, control2X, control2Y) {
            var p0 = this.getEndPoint();
            var p1;
            var p2;
            var p3;
            if (x2 instanceof Vector2) {
              p1 = x2;
              p2 = y2;
              p3 = control1X;
            } else {
              p1 = new Vector2(control1X, control1Y);
              p2 = new Vector2(control2X, control2Y);
              p3 = new Vector2(x2, y2);
            }
            return this.add(new CubicBezierCurve(p0, p1, p2, p3));
          },
          quadraticBezierTo: function(x2, y2, controlX, controlY) {
            var p0 = this.getEndPoint();
            var p1;
            var p2;
            if (x2 instanceof Vector2) {
              p1 = x2;
              p2 = y2;
            } else {
              p1 = new Vector2(controlX, controlY);
              p2 = new Vector2(x2, y2);
            }
            return this.add(new QuadraticBezierCurve(p0, p1, p2));
          },
          draw: function(graphics, pointsTotal) {
            for (var i2 = 0; i2 < this.curves.length; i2++) {
              var curve = this.curves[i2];
              if (!curve.active) {
                continue;
              }
              curve.draw(graphics, pointsTotal);
            }
            return graphics;
          },
          ellipseTo: function(xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {
            var ellipse = new EllipseCurve(0, 0, xRadius, yRadius, startAngle, endAngle, clockwise, rotation);
            var end = this.getEndPoint(this._tmpVec2A);
            var start = ellipse.getStartPoint(this._tmpVec2B);
            end.subtract(start);
            ellipse.x = end.x;
            ellipse.y = end.y;
            return this.add(ellipse);
          },
          fromJSON: function(data) {
            this.curves = [];
            this.cacheLengths = [];
            this.startPoint.set(data.x, data.y);
            this.autoClose = data.autoClose;
            for (var i2 = 0; i2 < data.curves.length; i2++) {
              var curve = data.curves[i2];
              switch (curve.type) {
                case "LineCurve":
                  this.add(LineCurve.fromJSON(curve));
                  break;
                case "EllipseCurve":
                  this.add(EllipseCurve.fromJSON(curve));
                  break;
                case "SplineCurve":
                  this.add(SplineCurve.fromJSON(curve));
                  break;
                case "CubicBezierCurve":
                  this.add(CubicBezierCurve.fromJSON(curve));
                  break;
                case "QuadraticBezierCurve":
                  this.add(QuadraticBezierCurve.fromJSON(curve));
                  break;
              }
            }
            return this;
          },
          getBounds: function(out, accuracy) {
            if (out === void 0) {
              out = new Rectangle();
            }
            if (accuracy === void 0) {
              accuracy = 16;
            }
            out.x = Number.MAX_VALUE;
            out.y = Number.MAX_VALUE;
            var bounds = new Rectangle();
            var maxRight = MATH_CONST.MIN_SAFE_INTEGER;
            var maxBottom = MATH_CONST.MIN_SAFE_INTEGER;
            for (var i2 = 0; i2 < this.curves.length; i2++) {
              var curve = this.curves[i2];
              if (!curve.active) {
                continue;
              }
              curve.getBounds(bounds, accuracy);
              out.x = Math.min(out.x, bounds.x);
              out.y = Math.min(out.y, bounds.y);
              maxRight = Math.max(maxRight, bounds.right);
              maxBottom = Math.max(maxBottom, bounds.bottom);
            }
            out.right = maxRight;
            out.bottom = maxBottom;
            return out;
          },
          getCurveLengths: function() {
            if (this.cacheLengths.length === this.curves.length) {
              return this.cacheLengths;
            }
            var lengths = [];
            var sums = 0;
            for (var i2 = 0; i2 < this.curves.length; i2++) {
              sums += this.curves[i2].getLength();
              lengths.push(sums);
            }
            this.cacheLengths = lengths;
            return lengths;
          },
          getEndPoint: function(out) {
            if (out === void 0) {
              out = new Vector2();
            }
            if (this.curves.length > 0) {
              this.curves[this.curves.length - 1].getPoint(1, out);
            } else {
              out.copy(this.startPoint);
            }
            return out;
          },
          getLength: function() {
            var lens = this.getCurveLengths();
            return lens[lens.length - 1];
          },
          getPoint: function(t2, out) {
            if (out === void 0) {
              out = new Vector2();
            }
            var d = t2 * this.getLength();
            var curveLengths = this.getCurveLengths();
            var i2 = 0;
            while (i2 < curveLengths.length) {
              if (curveLengths[i2] >= d) {
                var diff = curveLengths[i2] - d;
                var curve = this.curves[i2];
                var segmentLength = curve.getLength();
                var u2 = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                return curve.getPointAt(u2, out);
              }
              i2++;
            }
            return null;
          },
          getPoints: function(divisions) {
            if (divisions === void 0) {
              divisions = 12;
            }
            var points = [];
            var last;
            for (var i2 = 0; i2 < this.curves.length; i2++) {
              var curve = this.curves[i2];
              if (!curve.active) {
                continue;
              }
              var resolution = curve.getResolution(divisions);
              var pts = curve.getPoints(resolution);
              for (var j = 0; j < pts.length; j++) {
                var point = pts[j];
                if (last && last.equals(point)) {
                  continue;
                }
                points.push(point);
                last = point;
              }
            }
            if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
              points.push(points[0]);
            }
            return points;
          },
          getRandomPoint: function(out) {
            if (out === void 0) {
              out = new Vector2();
            }
            return this.getPoint(Math.random(), out);
          },
          getSpacedPoints: function(divisions) {
            if (divisions === void 0) {
              divisions = 40;
            }
            var points = [];
            for (var i2 = 0; i2 <= divisions; i2++) {
              points.push(this.getPoint(i2 / divisions));
            }
            if (this.autoClose) {
              points.push(points[0]);
            }
            return points;
          },
          getStartPoint: function(out) {
            if (out === void 0) {
              out = new Vector2();
            }
            return out.copy(this.startPoint);
          },
          getTangent: function(t2, out) {
            if (out === void 0) {
              out = new Vector2();
            }
            var d = t2 * this.getLength();
            var curveLengths = this.getCurveLengths();
            var i2 = 0;
            while (i2 < curveLengths.length) {
              if (curveLengths[i2] >= d) {
                var diff = curveLengths[i2] - d;
                var curve = this.curves[i2];
                var segmentLength = curve.getLength();
                var u2 = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                return curve.getTangentAt(u2, out);
              }
              i2++;
            }
            return null;
          },
          lineTo: function(x2, y2) {
            if (x2 instanceof Vector2) {
              this._tmpVec2B.copy(x2);
            } else {
              this._tmpVec2B.set(x2, y2);
            }
            var end = this.getEndPoint(this._tmpVec2A);
            return this.add(new LineCurve([end.x, end.y, this._tmpVec2B.x, this._tmpVec2B.y]));
          },
          splineTo: function(points) {
            points.unshift(this.getEndPoint());
            return this.add(new SplineCurve(points));
          },
          moveTo: function(x2, y2) {
            if (x2 instanceof Vector2) {
              return this.add(new MovePathTo(x2.x, x2.y));
            } else {
              return this.add(new MovePathTo(x2, y2));
            }
          },
          toJSON: function() {
            var out = [];
            for (var i2 = 0; i2 < this.curves.length; i2++) {
              out.push(this.curves[i2].toJSON());
            }
            return {
              type: "Path",
              x: this.startPoint.x,
              y: this.startPoint.y,
              autoClose: this.autoClose,
              curves: out
            };
          },
          updateArcLengths: function() {
            this.cacheLengths = [];
            this.getCurveLengths();
          },
          destroy: function() {
            this.curves.length = 0;
            this.cacheLengths.length = 0;
            this.startPoint = void 0;
          }
        });
        GameObjectFactory.register("path", function(x2, y2) {
          return new Path(x2, y2);
        });
        module2.exports = Path;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          DataManager: __webpack_require__(101),
          DataManagerPlugin: __webpack_require__(897),
          Events: __webpack_require__(315)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var DataManager = __webpack_require__(101);
        var PluginCache = __webpack_require__(24);
        var SceneEvents = __webpack_require__(20);
        var DataManagerPlugin = new Class({
          Extends: DataManager,
          initialize: function DataManagerPlugin2(scene) {
            DataManager.call(this, scene, scene.sys.events);
            this.scene = scene;
            this.systems = scene.sys;
            scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
            scene.sys.events.on(SceneEvents.START, this.start, this);
          },
          boot: function() {
            this.events = this.systems.events;
            this.events.once(SceneEvents.DESTROY, this.destroy, this);
          },
          start: function() {
            this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          shutdown: function() {
            this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          destroy: function() {
            DataManager.prototype.destroy.call(this);
            this.events.off(SceneEvents.START, this.start, this);
            this.scene = null;
            this.systems = null;
          }
        });
        PluginCache.register("DataManagerPlugin", DataManagerPlugin, "data");
        module2.exports = DataManagerPlugin;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Align: __webpack_require__(899),
          BaseShader: __webpack_require__(396),
          Bounds: __webpack_require__(902),
          Canvas: __webpack_require__(906),
          Color: __webpack_require__(397),
          ColorMatrix: __webpack_require__(198),
          Masks: __webpack_require__(916),
          RGB: __webpack_require__(200)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(123);
        var Extend = __webpack_require__(17);
        var Align = {
          In: __webpack_require__(900),
          To: __webpack_require__(901)
        };
        Align = Extend(false, Align, CONST);
        module2.exports = Align;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          BottomCenter: __webpack_require__(290),
          BottomLeft: __webpack_require__(291),
          BottomRight: __webpack_require__(292),
          Center: __webpack_require__(293),
          LeftCenter: __webpack_require__(295),
          QuickSet: __webpack_require__(289),
          RightCenter: __webpack_require__(296),
          TopCenter: __webpack_require__(297),
          TopLeft: __webpack_require__(298),
          TopRight: __webpack_require__(299)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          BottomCenter: __webpack_require__(277),
          BottomLeft: __webpack_require__(278),
          BottomRight: __webpack_require__(279),
          LeftBottom: __webpack_require__(280),
          LeftCenter: __webpack_require__(281),
          LeftTop: __webpack_require__(282),
          QuickSet: __webpack_require__(276),
          RightBottom: __webpack_require__(283),
          RightCenter: __webpack_require__(284),
          RightTop: __webpack_require__(285),
          TopCenter: __webpack_require__(286),
          TopLeft: __webpack_require__(287),
          TopRight: __webpack_require__(288)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          CenterOn: __webpack_require__(294),
          GetBottom: __webpack_require__(42),
          GetBounds: __webpack_require__(903),
          GetCenterX: __webpack_require__(87),
          GetCenterY: __webpack_require__(89),
          GetLeft: __webpack_require__(43),
          GetOffsetX: __webpack_require__(904),
          GetOffsetY: __webpack_require__(905),
          GetRight: __webpack_require__(44),
          GetTop: __webpack_require__(45),
          SetBottom: __webpack_require__(55),
          SetCenterX: __webpack_require__(88),
          SetCenterY: __webpack_require__(90),
          SetLeft: __webpack_require__(53),
          SetRight: __webpack_require__(54),
          SetTop: __webpack_require__(52)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       samme
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetBottom = __webpack_require__(42);
        var GetLeft = __webpack_require__(43);
        var GetRight = __webpack_require__(44);
        var GetTop = __webpack_require__(45);
        var GetBounds = function(gameObject, output) {
          if (output === void 0) {
            output = {};
          }
          var left = GetLeft(gameObject);
          var top = GetTop(gameObject);
          output.x = left;
          output.y = top;
          output.width = GetRight(gameObject) - left;
          output.height = GetBottom(gameObject) - top;
          return output;
        };
        module2.exports = GetBounds;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetOffsetX = function(gameObject) {
          return gameObject.width * gameObject.originX;
        };
        module2.exports = GetOffsetX;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetOffsetY = function(gameObject) {
          return gameObject.height * gameObject.originY;
        };
        module2.exports = GetOffsetY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          CanvasInterpolation: __webpack_require__(367),
          CanvasPool: __webpack_require__(31),
          Smoothing: __webpack_require__(192),
          TouchAction: __webpack_require__(907),
          UserSelect: __webpack_require__(908)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TouchAction = function(canvas, value) {
          if (value === void 0) {
            value = "none";
          }
          canvas.style["msTouchAction"] = value;
          canvas.style["ms-touch-action"] = value;
          canvas.style["touch-action"] = value;
          return canvas;
        };
        module2.exports = TouchAction;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var UserSelect = function(canvas, value) {
          if (value === void 0) {
            value = "none";
          }
          var vendors = [
            "-webkit-",
            "-khtml-",
            "-moz-",
            "-ms-",
            ""
          ];
          vendors.forEach(function(vendor) {
            canvas.style[vendor + "user-select"] = value;
          });
          canvas.style["-webkit-touch-callout"] = value;
          canvas.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
          return canvas;
        };
        module2.exports = UserSelect;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetColor = __webpack_require__(103);
        var ColorSpectrum = function(limit) {
          if (limit === void 0) {
            limit = 1024;
          }
          var colors = [];
          var range = 255;
          var i2;
          var r2 = 255;
          var g2 = 0;
          var b2 = 0;
          for (i2 = 0; i2 <= range; i2++) {
            colors.push({ r: r2, g: i2, b: b2, color: GetColor(r2, i2, b2) });
          }
          g2 = 255;
          for (i2 = range; i2 >= 0; i2--) {
            colors.push({ r: i2, g: g2, b: b2, color: GetColor(i2, g2, b2) });
          }
          r2 = 0;
          for (i2 = 0; i2 <= range; i2++, g2--) {
            colors.push({ r: r2, g: g2, b: i2, color: GetColor(r2, g2, i2) });
          }
          g2 = 0;
          b2 = 255;
          for (i2 = 0; i2 <= range; i2++, b2--, r2++) {
            colors.push({ r: r2, g: g2, b: b2, color: GetColor(r2, g2, b2) });
          }
          if (limit === 1024) {
            return colors;
          } else {
            var out = [];
            var t2 = 0;
            var inc = 1024 / limit;
            for (i2 = 0; i2 < limit; i2++) {
              out.push(colors[Math.floor(t2)]);
              t2 += inc;
            }
            return out;
          }
        };
        module2.exports = ColorSpectrum;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ColorToRGBA = function(color) {
          var output = {
            r: color >> 16 & 255,
            g: color >> 8 & 255,
            b: color & 255,
            a: 255
          };
          if (color > 16777215) {
            output.a = color >>> 24;
          }
          return output;
        };
        module2.exports = ColorToRGBA;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Color = __webpack_require__(38);
        var HueToComponent = __webpack_require__(399);
        var HSLToColor = function(h2, s, l2) {
          var r2 = l2;
          var g2 = l2;
          var b2 = l2;
          if (s !== 0) {
            var q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
            var p2 = 2 * l2 - q2;
            r2 = HueToComponent(p2, q2, h2 + 1 / 3);
            g2 = HueToComponent(p2, q2, h2);
            b2 = HueToComponent(p2, q2, h2 - 1 / 3);
          }
          var color = new Color();
          return color.setGLTo(r2, g2, b2, 1);
        };
        module2.exports = HSLToColor;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var HSVToRGB = __webpack_require__(188);
        var HSVColorWheel = function(s, v2) {
          if (s === void 0) {
            s = 1;
          }
          if (v2 === void 0) {
            v2 = 1;
          }
          var colors = [];
          for (var c = 0; c <= 359; c++) {
            colors.push(HSVToRGB(c / 359, s, v2));
          }
          return colors;
        };
        module2.exports = HSVColorWheel;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Linear = __webpack_require__(135);
        var RGBWithRGB = function(r1, g1, b1, r2, g2, b2, length, index2) {
          if (length === void 0) {
            length = 100;
          }
          if (index2 === void 0) {
            index2 = 0;
          }
          var t2 = index2 / length;
          return {
            r: Linear(r1, r2, t2),
            g: Linear(g1, g2, t2),
            b: Linear(b1, b2, t2)
          };
        };
        var ColorWithColor = function(color1, color2, length, index2) {
          if (length === void 0) {
            length = 100;
          }
          if (index2 === void 0) {
            index2 = 0;
          }
          return RGBWithRGB(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b, length, index2);
        };
        var ColorWithRGB = function(color, r2, g2, b2, length, index2) {
          if (length === void 0) {
            length = 100;
          }
          if (index2 === void 0) {
            index2 = 0;
          }
          return RGBWithRGB(color.r, color.g, color.b, r2, g2, b2, length, index2);
        };
        module2.exports = {
          RGBWithRGB,
          ColorWithRGB,
          ColorWithColor
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Between = __webpack_require__(195);
        var Color = __webpack_require__(38);
        var RandomRGB = function(min, max) {
          if (min === void 0) {
            min = 0;
          }
          if (max === void 0) {
            max = 255;
          }
          return new Color(Between(min, max), Between(min, max), Between(min, max));
        };
        module2.exports = RandomRGB;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ComponentToHex = __webpack_require__(398);
        var RGBToString = function(r2, g2, b2, a, prefix) {
          if (a === void 0) {
            a = 255;
          }
          if (prefix === void 0) {
            prefix = "#";
          }
          if (prefix === "#") {
            return "#" + ((1 << 24) + (r2 << 16) + (g2 << 8) + b2).toString(16).slice(1, 7);
          } else {
            return "0x" + ComponentToHex(a) + ComponentToHex(r2) + ComponentToHex(g2) + ComponentToHex(b2);
          }
        };
        module2.exports = RGBToString;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          BitmapMask: __webpack_require__(310),
          GeometryMask: __webpack_require__(311)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Dom = {
          AddToDOM: __webpack_require__(142),
          DOMContentLoaded: __webpack_require__(400),
          GetInnerHeight: __webpack_require__(401),
          GetScreenOrientation: __webpack_require__(402),
          GetTarget: __webpack_require__(407),
          ParseXML: __webpack_require__(408),
          RemoveFromDOM: __webpack_require__(202),
          RequestAnimationFrame: __webpack_require__(386)
        };
        module2.exports = Dom;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = { EventEmitter: __webpack_require__(919) };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var EE = __webpack_require__(9);
        var PluginCache = __webpack_require__(24);
        var EventEmitter = new Class({
          Extends: EE,
          initialize: function EventEmitter2() {
            EE.call(this);
          },
          shutdown: function() {
            this.removeAllListeners();
          },
          destroy: function() {
            this.removeAllListeners();
          }
        });
        PluginCache.register("EventEmitter", EventEmitter, "events");
        module2.exports = EventEmitter;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AddToDOM = __webpack_require__(142);
        var AnimationManager = __webpack_require__(321);
        var CacheManager = __webpack_require__(325);
        var CanvasPool = __webpack_require__(31);
        var Class = __webpack_require__(0);
        var Config = __webpack_require__(346);
        var CreateDOMContainer = __webpack_require__(921);
        var CreateRenderer = __webpack_require__(366);
        var DataManager = __webpack_require__(101);
        var DebugHeader = __webpack_require__(384);
        var Device = __webpack_require__(347);
        var DOMContentLoaded = __webpack_require__(400);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(22);
        var InputManager = __webpack_require__(409);
        var PluginCache = __webpack_require__(24);
        var PluginManager = __webpack_require__(414);
        var ScaleManager = __webpack_require__(415);
        var SceneManager = __webpack_require__(417);
        var TextureEvents = __webpack_require__(106);
        var TextureManager = __webpack_require__(422);
        var TimeStep = __webpack_require__(385);
        var VisibilityHandler = __webpack_require__(387);
        {
          var SoundManagerCreator = __webpack_require__(426);
        }
        var Game2 = new Class({
          initialize: function Game3(config) {
            this.config = new Config(config);
            this.renderer = null;
            this.domContainer = null;
            this.canvas = null;
            this.context = null;
            this.isBooted = false;
            this.isRunning = false;
            this.events = new EventEmitter();
            this.anims = new AnimationManager(this);
            this.textures = new TextureManager(this);
            this.cache = new CacheManager(this);
            this.registry = new DataManager(this);
            this.input = new InputManager(this, this.config);
            this.scene = new SceneManager(this, this.config.sceneConfig);
            this.device = Device;
            this.scale = new ScaleManager(this, this.config);
            this.sound = null;
            {
              this.sound = SoundManagerCreator.create(this);
            }
            this.loop = new TimeStep(this, this.config.fps);
            this.plugins = new PluginManager(this, this.config);
            this.pendingDestroy = false;
            this.removeCanvas = false;
            this.noReturn = false;
            this.hasFocus = false;
            DOMContentLoaded(this.boot.bind(this));
          },
          boot: function() {
            if (!PluginCache.hasCore("EventEmitter")) {
              console.warn("Aborting. Core Plugins missing.");
              return;
            }
            this.isBooted = true;
            this.config.preBoot(this);
            this.scale.preBoot();
            CreateRenderer(this);
            CreateDOMContainer(this);
            DebugHeader(this);
            AddToDOM(this.canvas, this.config.parent);
            this.textures.once(TextureEvents.READY, this.texturesReady, this);
            this.events.emit(Events.BOOT);
          },
          texturesReady: function() {
            this.events.emit(Events.READY);
            this.start();
          },
          start: function() {
            this.isRunning = true;
            this.config.postBoot(this);
            if (this.renderer) {
              this.loop.start(this.step.bind(this));
            } else {
              this.loop.start(this.headlessStep.bind(this));
            }
            VisibilityHandler(this);
            var eventEmitter = this.events;
            eventEmitter.on(Events.HIDDEN, this.onHidden, this);
            eventEmitter.on(Events.VISIBLE, this.onVisible, this);
            eventEmitter.on(Events.BLUR, this.onBlur, this);
            eventEmitter.on(Events.FOCUS, this.onFocus, this);
          },
          step: function(time, delta) {
            if (this.pendingDestroy) {
              return this.runDestroy();
            }
            var eventEmitter = this.events;
            eventEmitter.emit(Events.PRE_STEP, time, delta);
            eventEmitter.emit(Events.STEP, time, delta);
            this.scene.update(time, delta);
            eventEmitter.emit(Events.POST_STEP, time, delta);
            var renderer = this.renderer;
            renderer.preRender();
            eventEmitter.emit(Events.PRE_RENDER, renderer, time, delta);
            this.scene.render(renderer);
            renderer.postRender();
            eventEmitter.emit(Events.POST_RENDER, renderer, time, delta);
          },
          headlessStep: function(time, delta) {
            if (this.pendingDestroy) {
              return this.runDestroy();
            }
            var eventEmitter = this.events;
            eventEmitter.emit(Events.PRE_STEP, time, delta);
            eventEmitter.emit(Events.STEP, time, delta);
            this.scene.update(time, delta);
            eventEmitter.emit(Events.POST_STEP, time, delta);
            eventEmitter.emit(Events.PRE_RENDER);
            eventEmitter.emit(Events.POST_RENDER);
          },
          onHidden: function() {
            this.loop.pause();
            this.events.emit(Events.PAUSE);
          },
          onVisible: function() {
            this.loop.resume();
            this.events.emit(Events.RESUME);
          },
          onBlur: function() {
            this.hasFocus = false;
            this.loop.blur();
          },
          onFocus: function() {
            this.hasFocus = true;
            this.loop.focus();
          },
          getFrame: function() {
            return this.loop.frame;
          },
          getTime: function() {
            return this.loop.now;
          },
          destroy: function(removeCanvas, noReturn) {
            if (noReturn === void 0) {
              noReturn = false;
            }
            this.pendingDestroy = true;
            this.removeCanvas = removeCanvas;
            this.noReturn = noReturn;
          },
          runDestroy: function() {
            this.scene.destroy();
            this.events.emit(Events.DESTROY);
            this.events.removeAllListeners();
            if (this.renderer) {
              this.renderer.destroy();
            }
            if (this.removeCanvas && this.canvas) {
              CanvasPool.remove(this.canvas);
              if (this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
              }
            }
            if (this.domContainer) {
              this.domContainer.parentNode.removeChild(this.domContainer);
            }
            this.loop.destroy();
            this.pendingDestroy = false;
          }
        });
        module2.exports = Game2;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AddToDOM = __webpack_require__(142);
        var CreateDOMContainer = function(game) {
          var config = game.config;
          if (!config.parent || !config.domCreateContainer) {
            return;
          }
          var div = document.createElement("div");
          div.style.cssText = [
            "display: block;",
            "width: " + game.scale.width + "px;",
            "height: " + game.scale.height + "px;",
            "padding: 0; margin: 0;",
            "position: absolute;",
            "overflow: hidden;",
            "pointer-events: " + config.domPointerEvents + ";",
            "transform: scale(1);",
            "transform-origin: left top;"
          ].join(" ");
          game.domContainer = div;
          AddToDOM(div, config.parent);
        };
        module2.exports = CreateDOMContainer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "boot";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "destroy";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "dragend";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "dragenter";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "drag";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "dragleave";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "dragover";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "dragstart";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "drop";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "gameout";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "gameover";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "gameobjectdown";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "dragend";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "dragenter";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "drag";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "dragleave";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "dragover";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "dragstart";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "drop";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "gameobjectmove";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "gameobjectout";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "gameobjectover";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pointerdown";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pointermove";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pointerout";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pointerover";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pointerup";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "wheel";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "gameobjectup";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "gameobjectwheel";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "boot";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "process";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "update";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pointerdown";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pointerdownoutside";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pointermove";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pointerout";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pointerover";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pointerup";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pointerupoutside";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "wheel";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pointerlockchange";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "preupdate";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "shutdown";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "start";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "update";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "addfile";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "complete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "filecomplete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "filecomplete-";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "loaderror";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "load";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "fileprogress";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "postprocess";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "progress";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "start";
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var InjectionMap = {
          game: "game",
          renderer: "renderer",
          anims: "anims",
          cache: "cache",
          plugins: "plugins",
          registry: "registry",
          scale: "scale",
          sound: "sound",
          textures: "textures",
          events: "events",
          cameras: "cameras",
          add: "add",
          make: "make",
          scenePlugin: "scene",
          displayList: "children",
          lights: "lights",
          data: "data",
          input: "input",
          load: "load",
          time: "time",
          tweens: "tweens",
          arcadePhysics: "physics",
          impactPhysics: "impact",
          matterPhysics: "matter"
        };
        module2.exports = InjectionMap;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AtlasXML = function(texture, sourceIndex, xml) {
          if (!xml.getElementsByTagName("TextureAtlas")) {
            console.warn("Invalid Texture Atlas XML given");
            return;
          }
          var source = texture.source[sourceIndex];
          texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
          var frames = xml.getElementsByTagName("SubTexture");
          var newFrame;
          for (var i2 = 0; i2 < frames.length; i2++) {
            var frame = frames[i2].attributes;
            var name = frame.name.value;
            var x2 = parseInt(frame.x.value, 10);
            var y2 = parseInt(frame.y.value, 10);
            var width = parseInt(frame.width.value, 10);
            var height = parseInt(frame.height.value, 10);
            newFrame = texture.add(name, sourceIndex, x2, y2, width, height);
            if (frame.frameX) {
              var frameX = Math.abs(parseInt(frame.frameX.value, 10));
              var frameY = Math.abs(parseInt(frame.frameY.value, 10));
              var frameWidth = parseInt(frame.frameWidth.value, 10);
              var frameHeight = parseInt(frame.frameHeight.value, 10);
              newFrame.setTrim(width, height, frameX, frameY, frameWidth, frameHeight);
            }
          }
          return texture;
        };
        module2.exports = AtlasXML;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Canvas = function(texture, sourceIndex) {
          var source = texture.source[sourceIndex];
          texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
          return texture;
        };
        module2.exports = Canvas;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Image2 = function(texture, sourceIndex) {
          var source = texture.source[sourceIndex];
          texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
          return texture;
        };
        module2.exports = Image2;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clone = __webpack_require__(77);
        var JSONArray = function(texture, sourceIndex, json) {
          if (!json["frames"] && !json["textures"]) {
            console.warn("Invalid Texture Atlas JSON Array");
            return;
          }
          var source = texture.source[sourceIndex];
          texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
          var frames = Array.isArray(json.textures) ? json.textures[sourceIndex].frames : json.frames;
          var newFrame;
          for (var i2 = 0; i2 < frames.length; i2++) {
            var src = frames[i2];
            newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);
            if (src.trimmed) {
              newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);
            }
            if (src.rotated) {
              newFrame.rotated = true;
              newFrame.updateUVsInverted();
            }
            var pivot = src.anchor || src.pivot;
            if (pivot) {
              newFrame.customPivot = true;
              newFrame.pivotX = pivot.x;
              newFrame.pivotY = pivot.y;
            }
            newFrame.customData = Clone(src);
          }
          for (var dataKey in json) {
            if (dataKey === "frames") {
              continue;
            }
            if (Array.isArray(json[dataKey])) {
              texture.customData[dataKey] = json[dataKey].slice(0);
            } else {
              texture.customData[dataKey] = json[dataKey];
            }
          }
          return texture;
        };
        module2.exports = JSONArray;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clone = __webpack_require__(77);
        var JSONHash = function(texture, sourceIndex, json) {
          if (!json["frames"]) {
            console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object");
            return;
          }
          var source = texture.source[sourceIndex];
          texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
          var frames = json.frames;
          var newFrame;
          for (var key in frames) {
            if (!frames.hasOwnProperty(key)) {
              continue;
            }
            var src = frames[key];
            newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);
            if (src.trimmed) {
              newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);
            }
            if (src.rotated) {
              newFrame.rotated = true;
              newFrame.updateUVsInverted();
            }
            var pivot = src.anchor || src.pivot;
            if (pivot) {
              newFrame.customPivot = true;
              newFrame.pivotX = pivot.x;
              newFrame.pivotY = pivot.y;
            }
            newFrame.customData = Clone(src);
          }
          for (var dataKey in json) {
            if (dataKey === "frames") {
              continue;
            }
            if (Array.isArray(json[dataKey])) {
              texture.customData[dataKey] = json[dataKey].slice(0);
            } else {
              texture.customData[dataKey] = json[dataKey];
            }
          }
          return texture;
        };
        module2.exports = JSONHash;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetFastValue = __webpack_require__(2);
        var SpriteSheet = function(texture, sourceIndex, x2, y2, width, height, config) {
          var frameWidth = GetFastValue(config, "frameWidth", null);
          var frameHeight = GetFastValue(config, "frameHeight", frameWidth);
          if (frameWidth === null) {
            throw new Error("TextureManager.SpriteSheet: Invalid frameWidth given.");
          }
          var source = texture.source[sourceIndex];
          texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
          var startFrame = GetFastValue(config, "startFrame", 0);
          var endFrame = GetFastValue(config, "endFrame", -1);
          var margin = GetFastValue(config, "margin", 0);
          var spacing = GetFastValue(config, "spacing", 0);
          var row = Math.floor((width - margin + spacing) / (frameWidth + spacing));
          var column = Math.floor((height - margin + spacing) / (frameHeight + spacing));
          var total = row * column;
          if (total === 0) {
            console.warn("SpriteSheet frame dimensions will result in zero frames for texture:", texture.key);
          }
          if (startFrame > total || startFrame < -total) {
            startFrame = 0;
          }
          if (startFrame < 0) {
            startFrame = total + startFrame;
          }
          if (endFrame !== -1) {
            total = startFrame + (endFrame + 1);
          }
          var fx = margin;
          var fy = margin;
          var ax = 0;
          var ay = 0;
          for (var i2 = 0; i2 < total; i2++) {
            ax = 0;
            ay = 0;
            var w2 = fx + frameWidth;
            var h2 = fy + frameHeight;
            if (w2 > width) {
              ax = w2 - width;
            }
            if (h2 > height) {
              ay = h2 - height;
            }
            texture.add(i2, sourceIndex, x2 + fx, y2 + fy, frameWidth - ax, frameHeight - ay);
            fx += frameWidth + spacing;
            if (fx + frameWidth > width) {
              fx = margin;
              fy += frameHeight + spacing;
            }
          }
          return texture;
        };
        module2.exports = SpriteSheet;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetFastValue = __webpack_require__(2);
        var SpriteSheetFromAtlas = function(texture, frame, config) {
          var frameWidth = GetFastValue(config, "frameWidth", null);
          var frameHeight = GetFastValue(config, "frameHeight", frameWidth);
          if (!frameWidth) {
            throw new Error("TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.");
          }
          var source = texture.source[0];
          texture.add("__BASE", 0, 0, 0, source.width, source.height);
          GetFastValue(config, "startFrame", 0);
          GetFastValue(config, "endFrame", -1);
          var margin = GetFastValue(config, "margin", 0);
          var spacing = GetFastValue(config, "spacing", 0);
          var x2 = frame.cutX;
          var y2 = frame.cutY;
          var cutWidth = frame.cutWidth;
          var cutHeight = frame.cutHeight;
          var sheetWidth = frame.realWidth;
          var sheetHeight = frame.realHeight;
          var row = Math.floor((sheetWidth - margin + spacing) / (frameWidth + spacing));
          var column = Math.floor((sheetHeight - margin + spacing) / (frameHeight + spacing));
          var leftPad = frame.x;
          var leftWidth = frameWidth - leftPad;
          var rightWidth = frameWidth - (sheetWidth - cutWidth - leftPad);
          var topPad = frame.y;
          var topHeight = frameHeight - topPad;
          var bottomHeight = frameHeight - (sheetHeight - cutHeight - topPad);
          var sheetFrame;
          var frameX = margin;
          var frameY = margin;
          var frameIndex = 0;
          var sourceIndex = frame.sourceIndex;
          for (var sheetY = 0; sheetY < column; sheetY++) {
            var topRow = sheetY === 0;
            var bottomRow = sheetY === column - 1;
            for (var sheetX = 0; sheetX < row; sheetX++) {
              var leftRow = sheetX === 0;
              var rightRow = sheetX === row - 1;
              sheetFrame = texture.add(frameIndex, sourceIndex, x2 + frameX, y2 + frameY, frameWidth, frameHeight);
              if (leftRow || topRow || rightRow || bottomRow) {
                var destX = leftRow ? leftPad : 0;
                var destY = topRow ? topPad : 0;
                var trimWidth = 0;
                var trimHeight = 0;
                if (leftRow) {
                  trimWidth += frameWidth - leftWidth;
                }
                if (rightRow) {
                  trimWidth += frameWidth - rightWidth;
                }
                if (topRow) {
                  trimHeight += frameHeight - topHeight;
                }
                if (bottomRow) {
                  trimHeight += frameHeight - bottomHeight;
                }
                var destWidth = frameWidth - trimWidth;
                var destHeight = frameHeight - trimHeight;
                sheetFrame.cutWidth = destWidth;
                sheetFrame.cutHeight = destHeight;
                sheetFrame.setTrim(frameWidth, frameHeight, destX, destY, destWidth, destHeight);
              }
              frameX += spacing;
              if (leftRow) {
                frameX += leftWidth;
              } else if (rightRow) {
                frameX += rightWidth;
              } else {
                frameX += frameWidth;
              }
              frameIndex++;
            }
            frameX = margin;
            frameY += spacing;
            if (topRow) {
              frameY += topHeight;
            } else if (bottomRow) {
              frameY += bottomHeight;
            } else {
              frameY += frameHeight;
            }
          }
          return texture;
        };
        module2.exports = SpriteSheetFromAtlas;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var imageHeight = 0;
        var addFrame = function(texture, sourceIndex, name, frame) {
          var y2 = imageHeight - frame.y - frame.height;
          texture.add(name, sourceIndex, frame.x, y2, frame.width, frame.height);
        };
        var UnityYAML = function(texture, sourceIndex, yaml) {
          var source = texture.source[sourceIndex];
          texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
          imageHeight = source.height;
          var data = yaml.split("\n");
          var lineRegExp = /^[ ]*(- )*(\w+)+[: ]+(.*)/;
          var prevSprite = "";
          var currentSprite = "";
          var rect = { x: 0, y: 0, width: 0, height: 0 };
          for (var i2 = 0; i2 < data.length; i2++) {
            var results = data[i2].match(lineRegExp);
            if (!results) {
              continue;
            }
            var isList = results[1] === "- ";
            var key = results[2];
            var value = results[3];
            if (isList) {
              if (currentSprite !== prevSprite) {
                addFrame(texture, sourceIndex, currentSprite, rect);
                prevSprite = currentSprite;
              }
              rect = { x: 0, y: 0, width: 0, height: 0 };
            }
            if (key === "name") {
              currentSprite = value;
              continue;
            }
            switch (key) {
              case "x":
              case "y":
              case "width":
              case "height":
                rect[key] = parseInt(value, 10);
                break;
            }
          }
          if (currentSprite !== prevSprite) {
            addFrame(texture, sourceIndex, currentSprite, rect);
          }
          return texture;
        };
        module2.exports = UnityYAML;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "complete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "decoded";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "decodedall";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "destroy";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "detune";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "detune";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "mute";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "rate";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "volume";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "loop";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "looped";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "mute";
      },
      function(module2, exports2) {
        /**
         * @author       pi-kei
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pan";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pauseall";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pause";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "play";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "rate";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "resumeall";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "resume";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "seek";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "stopall";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "stop";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "unlocked";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "volume";
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjects = {
          Events: __webpack_require__(75),
          DisplayList: __webpack_require__(1012),
          GameObjectCreator: __webpack_require__(16),
          GameObjectFactory: __webpack_require__(5),
          UpdateList: __webpack_require__(1040),
          Components: __webpack_require__(11),
          GetCalcMatrix: __webpack_require__(19),
          BuildGameObject: __webpack_require__(28),
          BuildGameObjectAnimation: __webpack_require__(439),
          GameObject: __webpack_require__(15),
          BitmapText: __webpack_require__(148),
          Blitter: __webpack_require__(213),
          Bob: __webpack_require__(440),
          Container: __webpack_require__(214),
          DOMElement: __webpack_require__(442),
          DynamicBitmapText: __webpack_require__(215),
          Extern: __webpack_require__(444),
          Graphics: __webpack_require__(216),
          Group: __webpack_require__(113),
          Image: __webpack_require__(125),
          Layer: __webpack_require__(219),
          Particles: __webpack_require__(1074),
          PathFollower: __webpack_require__(457),
          RenderTexture: __webpack_require__(221),
          RetroFont: __webpack_require__(1082),
          Rope: __webpack_require__(223),
          Sprite: __webpack_require__(73),
          Text: __webpack_require__(224),
          GetTextSize: __webpack_require__(458),
          MeasureText: __webpack_require__(460),
          TextStyle: __webpack_require__(459),
          TileSprite: __webpack_require__(225),
          Zone: __webpack_require__(129),
          Video: __webpack_require__(226),
          Shape: __webpack_require__(34),
          Arc: __webpack_require__(461),
          Curve: __webpack_require__(462),
          Ellipse: __webpack_require__(463),
          Grid: __webpack_require__(464),
          IsoBox: __webpack_require__(465),
          IsoTriangle: __webpack_require__(466),
          Line: __webpack_require__(467),
          Polygon: __webpack_require__(468),
          Rectangle: __webpack_require__(473),
          Star: __webpack_require__(474),
          Triangle: __webpack_require__(475),
          Factories: {
            Blitter: __webpack_require__(1130),
            Container: __webpack_require__(1131),
            DOMElement: __webpack_require__(1132),
            DynamicBitmapText: __webpack_require__(1133),
            Extern: __webpack_require__(1134),
            Graphics: __webpack_require__(1135),
            Group: __webpack_require__(1136),
            Image: __webpack_require__(1137),
            Layer: __webpack_require__(1138),
            Particles: __webpack_require__(1139),
            PathFollower: __webpack_require__(1140),
            RenderTexture: __webpack_require__(1141),
            Rope: __webpack_require__(1142),
            Sprite: __webpack_require__(1143),
            StaticBitmapText: __webpack_require__(1144),
            Text: __webpack_require__(1145),
            TileSprite: __webpack_require__(1146),
            Zone: __webpack_require__(1147),
            Video: __webpack_require__(1148),
            Arc: __webpack_require__(1149),
            Curve: __webpack_require__(1150),
            Ellipse: __webpack_require__(1151),
            Grid: __webpack_require__(1152),
            IsoBox: __webpack_require__(1153),
            IsoTriangle: __webpack_require__(1154),
            Line: __webpack_require__(1155),
            Polygon: __webpack_require__(1156),
            Rectangle: __webpack_require__(1157),
            Star: __webpack_require__(1158),
            Triangle: __webpack_require__(1159)
          },
          Creators: {
            Blitter: __webpack_require__(1160),
            Container: __webpack_require__(1161),
            DynamicBitmapText: __webpack_require__(1162),
            Graphics: __webpack_require__(1163),
            Group: __webpack_require__(1164),
            Image: __webpack_require__(1165),
            Layer: __webpack_require__(1166),
            Particles: __webpack_require__(1167),
            RenderTexture: __webpack_require__(1168),
            Rope: __webpack_require__(1169),
            Sprite: __webpack_require__(1170),
            StaticBitmapText: __webpack_require__(1171),
            Text: __webpack_require__(1172),
            TileSprite: __webpack_require__(1173),
            Zone: __webpack_require__(1174),
            Video: __webpack_require__(1175)
          }
        };
        {
          GameObjects.Shader = __webpack_require__(229);
          GameObjects.Mesh = __webpack_require__(230);
          GameObjects.PointLight = __webpack_require__(150);
          GameObjects.Factories.Shader = __webpack_require__(1184);
          GameObjects.Factories.Mesh = __webpack_require__(1185);
          GameObjects.Factories.PointLight = __webpack_require__(1186);
          GameObjects.Creators.Shader = __webpack_require__(1187);
          GameObjects.Creators.Mesh = __webpack_require__(1188);
          GameObjects.Creators.PointLight = __webpack_require__(1189);
          GameObjects.Light = __webpack_require__(481);
          GameObjects.LightsManager = __webpack_require__(482);
          GameObjects.LightsPlugin = __webpack_require__(1190);
        }
        module2.exports = GameObjects;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var List = __webpack_require__(110);
        var PluginCache = __webpack_require__(24);
        var GameObjectEvents = __webpack_require__(75);
        var SceneEvents = __webpack_require__(20);
        var StableSort = __webpack_require__(79);
        var DisplayList = new Class({
          Extends: List,
          initialize: function DisplayList2(scene) {
            List.call(this, scene);
            this.sortChildrenFlag = false;
            this.scene = scene;
            this.systems = scene.sys;
            this.events = scene.sys.events;
            this.addCallback = this.addChildCallback;
            this.removeCallback = this.removeChildCallback;
            this.events.once(SceneEvents.BOOT, this.boot, this);
            this.events.on(SceneEvents.START, this.start, this);
          },
          boot: function() {
            this.events.once(SceneEvents.DESTROY, this.destroy, this);
          },
          addChildCallback: function(gameObject) {
            if (gameObject.displayList && gameObject.displayList !== this) {
              gameObject.removeFromDisplayList();
            }
            if (!gameObject.displayList) {
              this.queueDepthSort();
              gameObject.displayList = this;
              gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);
              this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);
            }
          },
          removeChildCallback: function(gameObject) {
            this.queueDepthSort();
            gameObject.displayList = null;
            gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
            this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
          },
          start: function() {
            this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          queueDepthSort: function() {
            this.sortChildrenFlag = true;
          },
          depthSort: function() {
            if (this.sortChildrenFlag) {
              StableSort(this.list, this.sortByDepth);
              this.sortChildrenFlag = false;
            }
          },
          sortByDepth: function(childA, childB) {
            return childA._depth - childB._depth;
          },
          getChildren: function() {
            return this.list;
          },
          shutdown: function() {
            var list = this.list;
            var i2 = list.length;
            while (i2--) {
              list[i2].destroy(true);
            }
            list.length = 0;
            this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          destroy: function() {
            this.shutdown();
            this.events.off(SceneEvents.START, this.start, this);
            this.scene = null;
            this.systems = null;
            this.events = null;
          }
        });
        PluginCache.register("DisplayList", DisplayList, "displayList");
        module2.exports = DisplayList;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          CheckMatrix: __webpack_require__(209),
          MatrixToString: __webpack_require__(1014),
          ReverseColumns: __webpack_require__(1015),
          ReverseRows: __webpack_require__(1016),
          Rotate180: __webpack_require__(1017),
          RotateLeft: __webpack_require__(1018),
          RotateMatrix: __webpack_require__(147),
          RotateRight: __webpack_require__(1019),
          Translate: __webpack_require__(1020),
          TransposeMatrix: __webpack_require__(435)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Pad = __webpack_require__(186);
        var CheckMatrix = __webpack_require__(209);
        var MatrixToString = function(matrix) {
          var str = "";
          if (!CheckMatrix(matrix)) {
            return str;
          }
          for (var r2 = 0; r2 < matrix.length; r2++) {
            for (var c = 0; c < matrix[r2].length; c++) {
              var cell = matrix[r2][c].toString();
              if (cell !== "undefined") {
                str += Pad(cell, 2);
              } else {
                str += "?";
              }
              if (c < matrix[r2].length - 1) {
                str += " |";
              }
            }
            if (r2 < matrix.length - 1) {
              str += "\n";
              for (var i2 = 0; i2 < matrix[r2].length; i2++) {
                str += "---";
                if (i2 < matrix[r2].length - 1) {
                  str += "+";
                }
              }
              str += "\n";
            }
          }
          return str;
        };
        module2.exports = MatrixToString;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ReverseColumns = function(matrix) {
          return matrix.reverse();
        };
        module2.exports = ReverseColumns;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ReverseRows = function(matrix) {
          for (var i2 = 0; i2 < matrix.length; i2++) {
            matrix[i2].reverse();
          }
          return matrix;
        };
        module2.exports = ReverseRows;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateMatrix = __webpack_require__(147);
        var Rotate180 = function(matrix) {
          return RotateMatrix(matrix, 180);
        };
        module2.exports = Rotate180;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateMatrix = __webpack_require__(147);
        var RotateLeft = function(matrix) {
          return RotateMatrix(matrix, 90);
        };
        module2.exports = RotateLeft;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateMatrix = __webpack_require__(147);
        var RotateRight = function(matrix) {
          return RotateMatrix(matrix, -90);
        };
        module2.exports = RotateRight;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateLeft = __webpack_require__(178);
        var RotateRight = __webpack_require__(179);
        var TranslateMatrix = function(matrix, x2, y2) {
          if (x2 === void 0) {
            x2 = 0;
          }
          if (y2 === void 0) {
            y2 = 0;
          }
          if (y2 !== 0) {
            if (y2 < 0) {
              RotateLeft(matrix, Math.abs(y2));
            } else {
              RotateRight(matrix, y2);
            }
          }
          if (x2 !== 0) {
            for (var i2 = 0; i2 < matrix.length; i2++) {
              var row = matrix[i2];
              if (x2 < 0) {
                RotateLeft(row, Math.abs(x2));
              } else {
                RotateRight(row, x2);
              }
            }
          }
          return matrix;
        };
        module2.exports = TranslateMatrix;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Add = function(array, item, limit, callback, context) {
          if (context === void 0) {
            context = array;
          }
          if (limit > 0) {
            var remaining = limit - array.length;
            if (remaining <= 0) {
              return null;
            }
          }
          if (!Array.isArray(item)) {
            if (array.indexOf(item) === -1) {
              array.push(item);
              if (callback) {
                callback.call(context, item);
              }
              return item;
            } else {
              return null;
            }
          }
          var itemLength = item.length - 1;
          while (itemLength >= 0) {
            if (array.indexOf(item[itemLength]) !== -1) {
              item.splice(itemLength, 1);
            }
            itemLength--;
          }
          itemLength = item.length;
          if (itemLength === 0) {
            return null;
          }
          if (limit > 0 && itemLength > remaining) {
            item.splice(remaining);
            itemLength = remaining;
          }
          for (var i2 = 0; i2 < itemLength; i2++) {
            var entry = item[i2];
            array.push(entry);
            if (callback) {
              callback.call(context, entry);
            }
          }
          return item;
        };
        module2.exports = Add;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AddAt = function(array, item, index2, limit, callback, context) {
          if (index2 === void 0) {
            index2 = 0;
          }
          if (context === void 0) {
            context = array;
          }
          if (limit > 0) {
            var remaining = limit - array.length;
            if (remaining <= 0) {
              return null;
            }
          }
          if (!Array.isArray(item)) {
            if (array.indexOf(item) === -1) {
              array.splice(index2, 0, item);
              if (callback) {
                callback.call(context, item);
              }
              return item;
            } else {
              return null;
            }
          }
          var itemLength = item.length - 1;
          while (itemLength >= 0) {
            if (array.indexOf(item[itemLength]) !== -1) {
              item.pop();
            }
            itemLength--;
          }
          itemLength = item.length;
          if (itemLength === 0) {
            return null;
          }
          if (limit > 0 && itemLength > remaining) {
            item.splice(remaining);
            itemLength = remaining;
          }
          for (var i2 = itemLength - 1; i2 >= 0; i2--) {
            var entry = item[i2];
            array.splice(index2, 0, entry);
            if (callback) {
              callback.call(context, entry);
            }
          }
          return item;
        };
        module2.exports = AddAt;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BringToTop = function(array, item) {
          var currentIndex = array.indexOf(item);
          if (currentIndex !== -1 && currentIndex < array.length) {
            array.splice(currentIndex, 1);
            array.push(item);
          }
          return item;
        };
        module2.exports = BringToTop;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SafeRange = __webpack_require__(78);
        var CountAllMatching = function(array, property, value, startIndex, endIndex) {
          if (startIndex === void 0) {
            startIndex = 0;
          }
          if (endIndex === void 0) {
            endIndex = array.length;
          }
          var total = 0;
          if (SafeRange(array, startIndex, endIndex)) {
            for (var i2 = startIndex; i2 < endIndex; i2++) {
              var child = array[i2];
              if (child[property] === value) {
                total++;
              }
            }
          }
          return total;
        };
        module2.exports = CountAllMatching;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Each = function(array, callback, context) {
          var i2;
          var args = [null];
          for (i2 = 3; i2 < arguments.length; i2++) {
            args.push(arguments[i2]);
          }
          for (i2 = 0; i2 < array.length; i2++) {
            args[0] = array[i2];
            callback.apply(context, args);
          }
          return array;
        };
        module2.exports = Each;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SafeRange = __webpack_require__(78);
        var EachInRange = function(array, callback, context, startIndex, endIndex) {
          if (startIndex === void 0) {
            startIndex = 0;
          }
          if (endIndex === void 0) {
            endIndex = array.length;
          }
          if (SafeRange(array, startIndex, endIndex)) {
            var i2;
            var args = [null];
            for (i2 = 5; i2 < arguments.length; i2++) {
              args.push(arguments[i2]);
            }
            for (i2 = startIndex; i2 < endIndex; i2++) {
              args[0] = array[i2];
              callback.apply(context, args);
            }
          }
          return array;
        };
        module2.exports = EachInRange;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MoveDown = function(array, item) {
          var currentIndex = array.indexOf(item);
          if (currentIndex > 0) {
            var item2 = array[currentIndex - 1];
            var index2 = array.indexOf(item2);
            array[currentIndex] = item2;
            array[index2] = item;
          }
          return array;
        };
        module2.exports = MoveDown;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MoveTo = function(array, item, index2) {
          var currentIndex = array.indexOf(item);
          if (currentIndex === -1 || index2 < 0 || index2 >= array.length) {
            throw new Error("Supplied index out of bounds");
          }
          if (currentIndex !== index2) {
            array.splice(currentIndex, 1);
            array.splice(index2, 0, item);
          }
          return item;
        };
        module2.exports = MoveTo;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MoveUp = function(array, item) {
          var currentIndex = array.indexOf(item);
          if (currentIndex !== -1 && currentIndex < array.length - 1) {
            var item2 = array[currentIndex + 1];
            var index2 = array.indexOf(item2);
            array[currentIndex] = item2;
            array[index2] = item;
          }
          return array;
        };
        module2.exports = MoveUp;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MoveAbove = function(array, item1, item2) {
          if (item1 === item2) {
            return array;
          }
          var currentIndex = array.indexOf(item1);
          var baseIndex = array.indexOf(item2);
          if (currentIndex < 0 || baseIndex < 0) {
            throw new Error("Supplied items must be elements of the same array");
          }
          if (currentIndex > baseIndex) {
            return array;
          }
          array.splice(currentIndex, 1);
          if (baseIndex === array.length - 1) {
            array.push(item1);
          } else {
            array.splice(baseIndex, 0, item1);
          }
          return array;
        };
        module2.exports = MoveAbove;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MoveBelow = function(array, item1, item2) {
          if (item1 === item2) {
            return array;
          }
          var currentIndex = array.indexOf(item1);
          var baseIndex = array.indexOf(item2);
          if (currentIndex < 0 || baseIndex < 0) {
            throw new Error("Supplied items must be elements of the same array");
          }
          if (currentIndex < baseIndex) {
            return array;
          }
          array.splice(currentIndex, 1);
          if (baseIndex === 0) {
            array.unshift(item1);
          } else {
            array.splice(baseIndex, 0, item1);
          }
          return array;
        };
        module2.exports = MoveBelow;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RoundAwayFromZero = __webpack_require__(363);
        var NumberArrayStep = function(start, end, step) {
          if (start === void 0) {
            start = 0;
          }
          if (end === void 0) {
            end = null;
          }
          if (step === void 0) {
            step = 1;
          }
          if (end === null) {
            end = start;
            start = 0;
          }
          var result = [];
          var total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0);
          for (var i2 = 0; i2 < total; i2++) {
            result.push(start);
            start += step;
          }
          return result;
        };
        module2.exports = NumberArrayStep;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SpliceOne = __webpack_require__(74);
        var RemoveAt = function(array, index2, callback, context) {
          if (context === void 0) {
            context = array;
          }
          if (index2 < 0 || index2 > array.length - 1) {
            throw new Error("Index out of bounds");
          }
          var item = SpliceOne(array, index2);
          if (callback) {
            callback.call(context, item);
          }
          return item;
        };
        module2.exports = RemoveAt;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SafeRange = __webpack_require__(78);
        var RemoveBetween = function(array, startIndex, endIndex, callback, context) {
          if (startIndex === void 0) {
            startIndex = 0;
          }
          if (endIndex === void 0) {
            endIndex = array.length;
          }
          if (context === void 0) {
            context = array;
          }
          if (SafeRange(array, startIndex, endIndex)) {
            var size = endIndex - startIndex;
            var removed = array.splice(startIndex, size);
            if (callback) {
              for (var i2 = 0; i2 < removed.length; i2++) {
                var entry = removed[i2];
                callback.call(context, entry);
              }
            }
            return removed;
          } else {
            return [];
          }
        };
        module2.exports = RemoveBetween;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SpliceOne = __webpack_require__(74);
        var RemoveRandomElement = function(array, start, length) {
          if (start === void 0) {
            start = 0;
          }
          if (length === void 0) {
            length = array.length;
          }
          var randomIndex = start + Math.floor(Math.random() * length);
          return SpliceOne(array, randomIndex);
        };
        module2.exports = RemoveRandomElement;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Replace = function(array, oldChild, newChild) {
          var index1 = array.indexOf(oldChild);
          var index2 = array.indexOf(newChild);
          if (index1 !== -1 && index2 === -1) {
            array[index1] = newChild;
            return true;
          } else {
            return false;
          }
        };
        module2.exports = Replace;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SendToBack = function(array, item) {
          var currentIndex = array.indexOf(item);
          if (currentIndex !== -1 && currentIndex > 0) {
            array.splice(currentIndex, 1);
            array.unshift(item);
          }
          return item;
        };
        module2.exports = SendToBack;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SafeRange = __webpack_require__(78);
        var SetAll = function(array, property, value, startIndex, endIndex) {
          if (startIndex === void 0) {
            startIndex = 0;
          }
          if (endIndex === void 0) {
            endIndex = array.length;
          }
          if (SafeRange(array, startIndex, endIndex)) {
            for (var i2 = startIndex; i2 < endIndex; i2++) {
              var entry = array[i2];
              if (entry.hasOwnProperty(property)) {
                entry[property] = value;
              }
            }
          }
          return array;
        };
        module2.exports = SetAll;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Swap = function(array, item1, item2) {
          if (item1 === item2) {
            return array;
          }
          var index1 = array.indexOf(item1);
          var index2 = array.indexOf(item2);
          if (index1 < 0 || index2 < 0) {
            throw new Error("Supplied items must be elements of the same array");
          }
          array[index1] = item2;
          array[index2] = item1;
          return array;
        };
        module2.exports = Swap;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var ProcessQueue = __webpack_require__(211);
        var PluginCache = __webpack_require__(24);
        var SceneEvents = __webpack_require__(20);
        var UpdateList = new Class({
          Extends: ProcessQueue,
          initialize: function UpdateList2(scene) {
            ProcessQueue.call(this);
            this.checkQueue = true;
            this.scene = scene;
            this.systems = scene.sys;
            scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
            scene.sys.events.on(SceneEvents.START, this.start, this);
          },
          boot: function() {
            this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
          },
          start: function() {
            var eventEmitter = this.systems.events;
            eventEmitter.on(SceneEvents.PRE_UPDATE, this.update, this);
            eventEmitter.on(SceneEvents.UPDATE, this.sceneUpdate, this);
            eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          sceneUpdate: function(time, delta) {
            var list = this._active;
            var length = list.length;
            for (var i2 = 0; i2 < length; i2++) {
              var gameObject = list[i2];
              if (gameObject.active) {
                gameObject.preUpdate.call(gameObject, time, delta);
              }
            }
          },
          shutdown: function() {
            var i2 = this._active.length;
            while (i2--) {
              this._active[i2].destroy(true);
            }
            i2 = this._pending.length;
            while (i2--) {
              this._pending[i2].destroy(true);
            }
            i2 = this._destroy.length;
            while (i2--) {
              this._destroy[i2].destroy(true);
            }
            this._toProcess = 0;
            this._pending = [];
            this._active = [];
            this._destroy = [];
            this.removeAllListeners();
            var eventEmitter = this.systems.events;
            eventEmitter.off(SceneEvents.PRE_UPDATE, this.update, this);
            eventEmitter.off(SceneEvents.UPDATE, this.sceneUpdate, this);
            eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          destroy: function() {
            this.shutdown();
            this.systems.events.off(SceneEvents.START, this.start, this);
            this.scene = null;
            this.systems = null;
          }
        });
        PluginCache.register("UpdateList", UpdateList, "updateList");
        module2.exports = UpdateList;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "add";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "remove";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetBitmapTextSize = function(src, round, updateOrigin, out) {
          if (updateOrigin === void 0) {
            updateOrigin = false;
          }
          if (out === void 0) {
            out = {
              local: {
                x: 0,
                y: 0,
                width: 0,
                height: 0
              },
              global: {
                x: 0,
                y: 0,
                width: 0,
                height: 0
              },
              lines: {
                shortest: 0,
                longest: 0,
                lengths: null,
                height: 0
              },
              wrappedText: "",
              words: [],
              characters: [],
              scaleX: 0,
              scaleY: 0
            };
            return out;
          }
          var text = src.text;
          var textLength = text.length;
          var maxWidth = src.maxWidth;
          var wordWrapCharCode = src.wordWrapCharCode;
          var bx = Number.MAX_VALUE;
          var by = Number.MAX_VALUE;
          var bw = 0;
          var bh2 = 0;
          var chars = src.fontData.chars;
          var lineHeight = src.fontData.lineHeight;
          var letterSpacing = src.letterSpacing;
          var xAdvance = 0;
          var yAdvance = 0;
          var charCode = 0;
          var glyph = null;
          var align = src._align;
          var x2 = 0;
          var y2 = 0;
          var scale = src.fontSize / src.fontData.size;
          var sx = scale * src.scaleX;
          var sy = scale * src.scaleY;
          var lastGlyph = null;
          var lastCharCode = 0;
          var lineWidths = [];
          var shortestLine = Number.MAX_VALUE;
          var longestLine = 0;
          var currentLine = 0;
          var currentLineWidth = 0;
          var i2;
          var words = [];
          var characters = [];
          var current = null;
          if (maxWidth > 0) {
            for (i2 = 0; i2 < textLength; i2++) {
              charCode = text.charCodeAt(i2);
              if (charCode === 10) {
                if (current !== null) {
                  words.push({
                    word: current.word,
                    i: current.i,
                    x: current.x * sx,
                    y: current.y * sy,
                    w: current.w * sx,
                    h: current.h * sy,
                    cr: true
                  });
                  current = null;
                }
                xAdvance = 0;
                yAdvance += lineHeight;
                lastGlyph = null;
                continue;
              }
              glyph = chars[charCode];
              if (!glyph) {
                continue;
              }
              if (lastGlyph !== null) {
                var glyphKerningOffset = glyph.kerning[lastCharCode];
              }
              if (charCode === wordWrapCharCode) {
                if (current !== null) {
                  words.push({
                    word: current.word,
                    i: current.i,
                    x: current.x * sx,
                    y: current.y * sy,
                    w: current.w * sx,
                    h: current.h * sy,
                    cr: false
                  });
                  current = null;
                }
              } else {
                if (current === null) {
                  current = { word: "", i: i2, x: xAdvance, y: yAdvance, w: 0, h: lineHeight, cr: false };
                }
                current.word = current.word.concat(text[i2]);
                current.w += glyph.xOffset + glyph.xAdvance + (glyphKerningOffset !== void 0 ? glyphKerningOffset : 0);
              }
              xAdvance += glyph.xAdvance + letterSpacing;
              lastGlyph = glyph;
              lastCharCode = charCode;
            }
            if (current !== null) {
              words.push({
                word: current.word,
                i: current.i,
                x: current.x * sx,
                y: current.y * sy,
                w: current.w * sx,
                h: current.h * sy,
                cr: false
              });
            }
            xAdvance = 0;
            yAdvance = 0;
            lastGlyph = null;
            lastCharCode = 0;
            var prev;
            var offset = 0;
            var crs = [];
            for (i2 = 0; i2 < words.length; i2++) {
              var entry = words[i2];
              var left = entry.x;
              var right = entry.x + entry.w;
              if (prev) {
                var diff = left - (prev.x + prev.w);
                offset = left - (diff + prev.w);
                prev = null;
              }
              var checkLeft = left - offset;
              var checkRight = right - offset;
              if (checkLeft > maxWidth || checkRight > maxWidth) {
                crs.push(entry.i - 1);
                if (entry.cr) {
                  crs.push(entry.i + entry.word.length);
                  offset = 0;
                  prev = null;
                } else {
                  prev = entry;
                }
              } else if (entry.cr) {
                crs.push(entry.i + entry.word.length);
                offset = 0;
                prev = null;
              }
            }
            var stringInsert = function(str, index2, value) {
              return str.substr(0, index2) + value + str.substr(index2 + 1);
            };
            for (i2 = crs.length - 1; i2 >= 0; i2--) {
              text = stringInsert(text, crs[i2], "\n");
            }
            out.wrappedText = text;
            textLength = text.length;
            words = [];
            current = null;
          }
          var charIndex = 0;
          for (i2 = 0; i2 < textLength; i2++) {
            charCode = text.charCodeAt(i2);
            if (charCode === 10) {
              if (current !== null) {
                words.push({
                  word: current.word,
                  i: current.i,
                  x: current.x * sx,
                  y: current.y * sy,
                  w: current.w * sx,
                  h: current.h * sy
                });
                current = null;
              }
              xAdvance = 0;
              yAdvance += lineHeight;
              lastGlyph = null;
              lineWidths[currentLine] = currentLineWidth;
              if (currentLineWidth > longestLine) {
                longestLine = currentLineWidth;
              }
              if (currentLineWidth < shortestLine) {
                shortestLine = currentLineWidth;
              }
              currentLine++;
              currentLineWidth = 0;
              continue;
            }
            glyph = chars[charCode];
            if (!glyph) {
              continue;
            }
            x2 = xAdvance;
            y2 = yAdvance;
            if (lastGlyph !== null) {
              var kerningOffset = glyph.kerning[lastCharCode];
              x2 += kerningOffset !== void 0 ? kerningOffset : 0;
            }
            if (bx > x2) {
              bx = x2;
            }
            if (by > y2) {
              by = y2;
            }
            var gw = x2 + glyph.xAdvance;
            var gh2 = y2 + lineHeight;
            if (bw < gw) {
              bw = gw;
            }
            if (bh2 < gh2) {
              bh2 = gh2;
            }
            var charWidth = glyph.xOffset + glyph.xAdvance + (kerningOffset !== void 0 ? kerningOffset : 0);
            if (charCode === wordWrapCharCode) {
              if (current !== null) {
                words.push({
                  word: current.word,
                  i: current.i,
                  x: current.x * sx,
                  y: current.y * sy,
                  w: current.w * sx,
                  h: current.h * sy
                });
                current = null;
              }
            } else {
              if (current === null) {
                current = { word: "", i: charIndex, x: xAdvance, y: yAdvance, w: 0, h: lineHeight };
              }
              current.word = current.word.concat(text[i2]);
              current.w += charWidth;
            }
            characters.push({
              i: charIndex,
              char: text[i2],
              code: charCode,
              x: (glyph.xOffset + xAdvance) * scale,
              y: (glyph.yOffset + yAdvance) * scale,
              w: glyph.width * scale,
              h: glyph.height * scale,
              t: yAdvance * scale,
              r: gw * scale,
              b: lineHeight * scale,
              line: currentLine,
              glyph
            });
            xAdvance += glyph.xAdvance + letterSpacing;
            lastGlyph = glyph;
            lastCharCode = charCode;
            currentLineWidth = gw * scale;
            charIndex++;
          }
          if (current !== null) {
            words.push({
              word: current.word,
              i: current.i,
              x: current.x * sx,
              y: current.y * sy,
              w: current.w * sx,
              h: current.h * sy
            });
          }
          lineWidths[currentLine] = currentLineWidth;
          if (currentLineWidth > longestLine) {
            longestLine = currentLineWidth;
          }
          if (currentLineWidth < shortestLine) {
            shortestLine = currentLineWidth;
          }
          if (align > 0) {
            for (var c = 0; c < characters.length; c++) {
              var currentChar = characters[c];
              if (align === 1) {
                var ax1 = (longestLine - lineWidths[currentChar.line]) / 2;
                currentChar.x += ax1;
                currentChar.r += ax1;
              } else if (align === 2) {
                var ax2 = longestLine - lineWidths[currentChar.line];
                currentChar.x += ax2;
                currentChar.r += ax2;
              }
            }
          }
          var local = out.local;
          var global2 = out.global;
          var lines = out.lines;
          local.x = bx * scale;
          local.y = by * scale;
          local.width = bw * scale;
          local.height = bh2 * scale;
          global2.x = src.x - src._displayOriginX + bx * sx;
          global2.y = src.y - src._displayOriginY + by * sy;
          global2.width = bw * sx;
          global2.height = bh2 * sy;
          lines.shortest = shortestLine;
          lines.longest = longestLine;
          lines.lengths = lineWidths;
          if (round) {
            local.x = Math.ceil(local.x);
            local.y = Math.ceil(local.y);
            local.width = Math.ceil(local.width);
            local.height = Math.ceil(local.height);
            global2.x = Math.ceil(global2.x);
            global2.y = Math.ceil(global2.y);
            global2.width = Math.ceil(global2.width);
            global2.height = Math.ceil(global2.height);
            lines.shortest = Math.ceil(shortestLine);
            lines.longest = Math.ceil(longestLine);
          }
          if (updateOrigin) {
            src._displayOriginX = src.originX * local.width;
            src._displayOriginY = src.originY * local.height;
            global2.x = src.x - src._displayOriginX * src.scaleX;
            global2.y = src.y - src._displayOriginY * src.scaleY;
            if (round) {
              global2.x = Math.ceil(global2.x);
              global2.y = Math.ceil(global2.y);
            }
          }
          out.words = words;
          out.characters = characters;
          out.lines.height = lineHeight;
          out.scale = scale;
          out.scaleX = src.scaleX;
          out.scaleY = src.scaleY;
          return out;
        };
        module2.exports = GetBitmapTextSize;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ParseXMLBitmapFont = __webpack_require__(212);
        var ParseFromAtlas = function(scene, fontName, textureKey, frameKey, xmlKey, xSpacing, ySpacing) {
          var texture = scene.sys.textures.get(textureKey);
          var frame = texture.get(frameKey);
          var xml = scene.sys.cache.xml.get(xmlKey);
          if (frame && xml) {
            var data = ParseXMLBitmapFont(xml, frame, xSpacing, ySpacing, texture);
            scene.sys.cache.bitmapFont.add(fontName, { data, texture: textureKey, frame: frameKey, fromAtlas: true });
            return true;
          } else {
            return false;
          }
        };
        module2.exports = ParseFromAtlas;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1046);
        }
        {
          renderCanvas = __webpack_require__(1048);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BatchChar = __webpack_require__(1047);
        var GetCalcMatrix = __webpack_require__(19);
        var Utils = __webpack_require__(12);
        var BitmapTextWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          var text = src._text;
          var textLength = text.length;
          if (textLength === 0) {
            return;
          }
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline, src);
          var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
          var roundPixels = camera.roundPixels;
          var cameraAlpha = camera.alpha;
          var charColors = src.charColors;
          var tintEffect = src.tintFill;
          var getTint = Utils.getTintAppendFloatAlpha;
          var tintTL = getTint(src.tintTopLeft, cameraAlpha * src._alphaTL);
          var tintTR = getTint(src.tintTopRight, cameraAlpha * src._alphaTR);
          var tintBL = getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL);
          var tintBR = getTint(src.tintBottomRight, cameraAlpha * src._alphaBR);
          var texture = src.frame.glTexture;
          var textureUnit = pipeline.setGameObject(src);
          var bounds = src.getTextBounds(false);
          var i2;
          var char;
          var glyph;
          var characters = bounds.characters;
          var dropShadowX = src.dropShadowX;
          var dropShadowY = src.dropShadowY;
          var dropShadow = dropShadowX !== 0 || dropShadowY !== 0;
          renderer.pipelines.preBatch(src);
          if (dropShadow) {
            var srcShadowColor = src.dropShadowColor;
            var srcShadowAlpha = src.dropShadowAlpha;
            var shadowTL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTL);
            var shadowTR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTR);
            var shadowBL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBL);
            var shadowBR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBR);
            for (i2 = 0; i2 < characters.length; i2++) {
              char = characters[i2];
              glyph = char.glyph;
              if (char.code === 32 || glyph.width === 0 || glyph.height === 0) {
                continue;
              }
              BatchChar(pipeline, src, char, glyph, dropShadowX, dropShadowY, calcMatrix, roundPixels, shadowTL, shadowTR, shadowBL, shadowBR, 1, texture, textureUnit);
            }
          }
          for (i2 = 0; i2 < characters.length; i2++) {
            char = characters[i2];
            glyph = char.glyph;
            if (char.code === 32 || glyph.width === 0 || glyph.height === 0) {
              continue;
            }
            if (charColors[char.i]) {
              var color = charColors[char.i];
              var charTintEffect = color.tintEffect;
              var charTintTL = getTint(color.tintTL, cameraAlpha * src._alphaTL);
              var charTintTR = getTint(color.tintTR, cameraAlpha * src._alphaTR);
              var charTintBL = getTint(color.tintBL, cameraAlpha * src._alphaBL);
              var charTintBR = getTint(color.tintBR, cameraAlpha * src._alphaBR);
              BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, charTintTL, charTintTR, charTintBL, charTintBR, charTintEffect, texture, textureUnit);
            } else {
              BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
            }
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = BitmapTextWebGLRenderer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BatchChar = function(pipeline, src, char, glyph, offsetX, offsetY, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit) {
          var x2 = char.x - src.displayOriginX + offsetX;
          var y2 = char.y - src.displayOriginY + offsetY;
          var xw = x2 + char.w;
          var yh2 = y2 + char.h;
          var tx0 = calcMatrix.getXRound(x2, y2, roundPixels);
          var ty0 = calcMatrix.getYRound(x2, y2, roundPixels);
          var tx1 = calcMatrix.getXRound(x2, yh2, roundPixels);
          var ty1 = calcMatrix.getYRound(x2, yh2, roundPixels);
          var tx2 = calcMatrix.getXRound(xw, yh2, roundPixels);
          var ty2 = calcMatrix.getYRound(xw, yh2, roundPixels);
          var tx3 = calcMatrix.getXRound(xw, y2, roundPixels);
          var ty3 = calcMatrix.getYRound(xw, y2, roundPixels);
          pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, glyph.u0, glyph.v0, glyph.u1, glyph.v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
        };
        module2.exports = BatchChar;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetTransform = __webpack_require__(30);
        var BitmapTextCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          var text = src._text;
          var textLength = text.length;
          var ctx = renderer.currentContext;
          if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
            return;
          }
          camera.addToRenderList(src);
          var textureFrame = src.fromAtlas ? src.frame : src.texture.frames["__BASE"];
          var chars = src.fontData.chars;
          var lineHeight = src.fontData.lineHeight;
          var letterSpacing = src._letterSpacing;
          var xAdvance = 0;
          var yAdvance = 0;
          var charCode = 0;
          var glyph = null;
          var glyphX = 0;
          var glyphY = 0;
          var glyphW = 0;
          var glyphH = 0;
          var x2 = 0;
          var y2 = 0;
          var lastGlyph = null;
          var lastCharCode = 0;
          var image = textureFrame.source.image;
          var textureX = textureFrame.cutX;
          var textureY = textureFrame.cutY;
          var scale = src._fontSize / src.fontData.size;
          var align = src._align;
          var currentLine = 0;
          var lineOffsetX = 0;
          var bounds = src.getTextBounds(false);
          if (src.maxWidth > 0) {
            text = bounds.wrappedText;
            textLength = text.length;
          }
          var lineData = src._bounds.lines;
          if (align === 1) {
            lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
          } else if (align === 2) {
            lineOffsetX = lineData.longest - lineData.lengths[0];
          }
          ctx.translate(-src.displayOriginX, -src.displayOriginY);
          var roundPixels = camera.roundPixels;
          for (var i2 = 0; i2 < textLength; i2++) {
            charCode = text.charCodeAt(i2);
            if (charCode === 10) {
              currentLine++;
              if (align === 1) {
                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
              } else if (align === 2) {
                lineOffsetX = lineData.longest - lineData.lengths[currentLine];
              }
              xAdvance = 0;
              yAdvance += lineHeight;
              lastGlyph = null;
              continue;
            }
            glyph = chars[charCode];
            if (!glyph) {
              continue;
            }
            glyphX = textureX + glyph.x;
            glyphY = textureY + glyph.y;
            glyphW = glyph.width;
            glyphH = glyph.height;
            x2 = glyph.xOffset + xAdvance;
            y2 = glyph.yOffset + yAdvance;
            if (lastGlyph !== null) {
              var kerningOffset = glyph.kerning[lastCharCode];
              x2 += kerningOffset !== void 0 ? kerningOffset : 0;
            }
            x2 *= scale;
            y2 *= scale;
            x2 += lineOffsetX;
            xAdvance += glyph.xAdvance + letterSpacing;
            lastGlyph = glyph;
            lastCharCode = charCode;
            if (glyphW === 0 || glyphH === 0 || charCode === 32) {
              continue;
            }
            if (roundPixels) {
              x2 = Math.round(x2);
              y2 = Math.round(y2);
            }
            ctx.save();
            ctx.translate(x2, y2);
            ctx.scale(scale, scale);
            ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
            ctx.restore();
          }
          ctx.restore();
        };
        module2.exports = BitmapTextCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1050);
        }
        {
          renderCanvas = __webpack_require__(1051);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TransformMatrix = __webpack_require__(25);
        var Utils = __webpack_require__(12);
        var tempMatrix = new TransformMatrix();
        var BlitterWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          var list = src.getRenderList();
          if (list.length === 0) {
            return;
          }
          var alpha = camera.alpha * src.alpha;
          if (alpha === 0) {
            return;
          }
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(this.pipeline, src);
          var cameraScrollX = camera.scrollX * src.scrollFactorX;
          var cameraScrollY = camera.scrollY * src.scrollFactorY;
          var calcMatrix = tempMatrix.copyFrom(camera.matrix);
          if (parentMatrix) {
            calcMatrix.multiplyWithOffset(parentMatrix, -cameraScrollX, -cameraScrollY);
            cameraScrollX = 0;
            cameraScrollY = 0;
          }
          var blitterX = src.x - cameraScrollX;
          var blitterY = src.y - cameraScrollY;
          var prevTextureSourceIndex = -1;
          var tintEffect = false;
          var roundPixels = camera.roundPixels;
          renderer.pipelines.preBatch(src);
          for (var index2 = 0; index2 < list.length; index2++) {
            var bob = list[index2];
            var frame = bob.frame;
            var bobAlpha = bob.alpha * alpha;
            if (bobAlpha === 0) {
              continue;
            }
            var width = frame.width;
            var height = frame.height;
            var x2 = blitterX + bob.x + frame.x;
            var y2 = blitterY + bob.y + frame.y;
            if (bob.flipX) {
              width *= -1;
              x2 += frame.width;
            }
            if (bob.flipY) {
              height *= -1;
              y2 += frame.height;
            }
            var xw = x2 + width;
            var yh2 = y2 + height;
            var tx0 = calcMatrix.getX(x2, y2);
            var ty0 = calcMatrix.getY(x2, y2);
            var tx1 = calcMatrix.getX(xw, yh2);
            var ty1 = calcMatrix.getY(xw, yh2);
            var tint = Utils.getTintAppendFloatAlpha(bob.tint, bobAlpha);
            if (frame.sourceIndex !== prevTextureSourceIndex) {
              var textureUnit = pipeline.setGameObject(src, frame);
              prevTextureSourceIndex = frame.sourceIndex;
            }
            if (roundPixels) {
              tx0 = Math.round(tx0);
              ty0 = Math.round(ty0);
              tx1 = Math.round(tx1);
              ty1 = Math.round(ty1);
            }
            if (pipeline.batchQuad(src, tx0, ty0, tx0, ty1, tx1, ty1, tx1, ty0, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, frame.glTexture, textureUnit)) {
              prevTextureSourceIndex = -1;
            }
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = BlitterWebGLRenderer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BlitterCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          var list = src.getRenderList();
          if (list.length === 0) {
            return;
          }
          var ctx = renderer.currentContext;
          var alpha = camera.alpha * src.alpha;
          if (alpha === 0) {
            return;
          }
          camera.addToRenderList(src);
          ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
          ctx.imageSmoothingEnabled = !(!renderer.antialias || src.frame.source.scaleMode);
          var cameraScrollX = src.x - camera.scrollX * src.scrollFactorX;
          var cameraScrollY = src.y - camera.scrollY * src.scrollFactorY;
          ctx.save();
          if (parentMatrix) {
            parentMatrix.copyToContext(ctx);
          }
          var roundPixels = camera.roundPixels;
          for (var i2 = 0; i2 < list.length; i2++) {
            var bob = list[i2];
            var flip = bob.flipX || bob.flipY;
            var frame = bob.frame;
            var cd2 = frame.canvasData;
            var dx = frame.x;
            var dy = frame.y;
            var fx = 1;
            var fy = 1;
            var bobAlpha = bob.alpha * alpha;
            if (bobAlpha === 0) {
              continue;
            }
            ctx.globalAlpha = bobAlpha;
            if (!flip) {
              if (roundPixels) {
                dx = Math.round(dx);
                dy = Math.round(dy);
              }
              ctx.drawImage(frame.source.image, cd2.x, cd2.y, cd2.width, cd2.height, dx + bob.x + cameraScrollX, dy + bob.y + cameraScrollY, cd2.width, cd2.height);
            } else {
              if (bob.flipX) {
                fx = -1;
                dx -= cd2.width;
              }
              if (bob.flipY) {
                fy = -1;
                dy -= cd2.height;
              }
              ctx.save();
              ctx.translate(bob.x + cameraScrollX, bob.y + cameraScrollY);
              ctx.scale(fx, fy);
              ctx.drawImage(frame.source.image, cd2.x, cd2.y, cd2.width, cd2.height, dx, dy, cd2.width, cd2.height);
              ctx.restore();
            }
          }
          ctx.restore();
        };
        module2.exports = BlitterCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Felipe Alfonso <@bitnenfer>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1053);
        }
        {
          renderCanvas = __webpack_require__(1054);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Felipe Alfonso <@bitnenfer>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ContainerWebGLRenderer = function(renderer, container, camera, parentMatrix) {
          camera.addToRenderList(container);
          var children = container.list;
          var childCount = children.length;
          if (childCount === 0) {
            return;
          }
          var transformMatrix = container.localTransform;
          if (parentMatrix) {
            transformMatrix.loadIdentity();
            transformMatrix.multiply(parentMatrix);
            transformMatrix.translate(container.x, container.y);
            transformMatrix.rotate(container.rotation);
            transformMatrix.scale(container.scaleX, container.scaleY);
          } else {
            transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
          }
          renderer.pipelines.preBatch(container);
          var containerHasBlendMode = container.blendMode !== -1;
          if (!containerHasBlendMode) {
            renderer.setBlendMode(0);
          }
          var alpha = container.alpha;
          var scrollFactorX = container.scrollFactorX;
          var scrollFactorY = container.scrollFactorY;
          for (var i2 = 0; i2 < childCount; i2++) {
            var child = children[i2];
            if (!child.willRender(camera)) {
              continue;
            }
            var childAlphaTopLeft;
            var childAlphaTopRight;
            var childAlphaBottomLeft;
            var childAlphaBottomRight;
            if (child.alphaTopLeft !== void 0) {
              childAlphaTopLeft = child.alphaTopLeft;
              childAlphaTopRight = child.alphaTopRight;
              childAlphaBottomLeft = child.alphaBottomLeft;
              childAlphaBottomRight = child.alphaBottomRight;
            } else {
              var childAlpha = child.alpha;
              childAlphaTopLeft = childAlpha;
              childAlphaTopRight = childAlpha;
              childAlphaBottomLeft = childAlpha;
              childAlphaBottomRight = childAlpha;
            }
            var childScrollFactorX = child.scrollFactorX;
            var childScrollFactorY = child.scrollFactorY;
            if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
              renderer.setBlendMode(child.blendMode);
            }
            var mask = child.mask;
            if (mask) {
              mask.preRenderWebGL(renderer, child, camera);
            }
            var type = child.type;
            if (type !== renderer.currentType) {
              renderer.newType = true;
              renderer.currentType = type;
            }
            renderer.nextTypeMatch = i2 < childCount - 1 ? children[i2 + 1].type === renderer.currentType : false;
            child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);
            child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);
            child.renderWebGL(renderer, child, camera, transformMatrix);
            child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);
            child.setScrollFactor(childScrollFactorX, childScrollFactorY);
            if (mask) {
              mask.postRenderWebGL(renderer, camera);
            }
            renderer.newType = false;
          }
          renderer.pipelines.postBatch(container);
        };
        module2.exports = ContainerWebGLRenderer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Felipe Alfonso <@bitnenfer>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ContainerCanvasRenderer = function(renderer, container, camera, parentMatrix) {
          camera.addToRenderList(container);
          var children = container.list;
          if (children.length === 0) {
            return;
          }
          var transformMatrix = container.localTransform;
          if (parentMatrix) {
            transformMatrix.loadIdentity();
            transformMatrix.multiply(parentMatrix);
            transformMatrix.translate(container.x, container.y);
            transformMatrix.rotate(container.rotation);
            transformMatrix.scale(container.scaleX, container.scaleY);
          } else {
            transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
          }
          var containerHasBlendMode = container.blendMode !== -1;
          if (!containerHasBlendMode) {
            renderer.setBlendMode(0);
          }
          var alpha = container._alpha;
          var scrollFactorX = container.scrollFactorX;
          var scrollFactorY = container.scrollFactorY;
          if (container.mask) {
            container.mask.preRenderCanvas(renderer, null, camera);
          }
          for (var i2 = 0; i2 < children.length; i2++) {
            var child = children[i2];
            if (!child.willRender(camera)) {
              continue;
            }
            var childAlpha = child.alpha;
            var childScrollFactorX = child.scrollFactorX;
            var childScrollFactorY = child.scrollFactorY;
            if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
              renderer.setBlendMode(child.blendMode);
            }
            child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);
            child.setAlpha(childAlpha * alpha);
            child.renderCanvas(renderer, child, camera, transformMatrix);
            child.setAlpha(childAlpha);
            child.setScrollFactor(childScrollFactorX, childScrollFactorY);
          }
          if (container.mask) {
            container.mask.postRenderCanvas(renderer);
          }
        };
        module2.exports = ContainerCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(443);
        }
        {
          renderCanvas = __webpack_require__(443);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = [
          "normal",
          "multiply",
          "multiply",
          "screen",
          "overlay",
          "darken",
          "lighten",
          "color-dodge",
          "color-burn",
          "hard-light",
          "soft-light",
          "difference",
          "exclusion",
          "hue",
          "saturation",
          "color",
          "luminosity"
        ];
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1058);
        }
        {
          renderCanvas = __webpack_require__(1059);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCalcMatrix = __webpack_require__(19);
        var TransformMatrix = __webpack_require__(25);
        var Utils = __webpack_require__(12);
        var tempMatrix = new TransformMatrix();
        var DynamicBitmapTextWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          var text = src.text;
          var textLength = text.length;
          if (textLength === 0) {
            return;
          }
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline, src);
          var result = GetCalcMatrix(src, camera, parentMatrix);
          var spriteMatrix = result.sprite;
          var calcMatrix = result.calc;
          var fontMatrix = tempMatrix;
          var crop = src.cropWidth > 0 || src.cropHeight > 0;
          if (crop) {
            pipeline.flush();
            renderer.pushScissor(calcMatrix.tx, calcMatrix.ty, src.cropWidth * calcMatrix.scaleX, src.cropHeight * calcMatrix.scaleY);
          }
          var frame = src.frame;
          var texture = frame.glTexture;
          var tintEffect = src.tintFill;
          var tintTL = Utils.getTintAppendFloatAlpha(src.tintTopLeft, camera.alpha * src._alphaTL);
          var tintTR = Utils.getTintAppendFloatAlpha(src.tintTopRight, camera.alpha * src._alphaTR);
          var tintBL = Utils.getTintAppendFloatAlpha(src.tintBottomLeft, camera.alpha * src._alphaBL);
          var tintBR = Utils.getTintAppendFloatAlpha(src.tintBottomRight, camera.alpha * src._alphaBR);
          var textureUnit = pipeline.setGameObject(src);
          var xAdvance = 0;
          var yAdvance = 0;
          var charCode = 0;
          var lastCharCode = 0;
          var letterSpacing = src.letterSpacing;
          var glyph;
          var glyphW = 0;
          var glyphH = 0;
          var lastGlyph;
          var scrollX = src.scrollX;
          var scrollY = src.scrollY;
          var fontData = src.fontData;
          var chars = fontData.chars;
          var lineHeight = fontData.lineHeight;
          var scale = src.fontSize / fontData.size;
          var rotation = 0;
          var align = src._align;
          var currentLine = 0;
          var lineOffsetX = 0;
          var bounds = src.getTextBounds(false);
          if (src.maxWidth > 0) {
            text = bounds.wrappedText;
            textLength = text.length;
          }
          var lineData = src._bounds.lines;
          if (align === 1) {
            lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
          } else if (align === 2) {
            lineOffsetX = lineData.longest - lineData.lengths[0];
          }
          var roundPixels = camera.roundPixels;
          var displayCallback = src.displayCallback;
          var callbackData = src.callbackData;
          renderer.pipelines.preBatch(src);
          for (var i2 = 0; i2 < textLength; i2++) {
            charCode = text.charCodeAt(i2);
            if (charCode === 10) {
              currentLine++;
              if (align === 1) {
                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
              } else if (align === 2) {
                lineOffsetX = lineData.longest - lineData.lengths[currentLine];
              }
              xAdvance = 0;
              yAdvance += lineHeight;
              lastGlyph = null;
              continue;
            }
            glyph = chars[charCode];
            if (!glyph) {
              continue;
            }
            glyphW = glyph.width;
            glyphH = glyph.height;
            var x2 = glyph.xOffset + xAdvance - scrollX;
            var y2 = glyph.yOffset + yAdvance - scrollY;
            if (lastGlyph !== null) {
              var kerningOffset = glyph.kerning[lastCharCode];
              x2 += kerningOffset !== void 0 ? kerningOffset : 0;
            }
            xAdvance += glyph.xAdvance + letterSpacing;
            lastGlyph = glyph;
            lastCharCode = charCode;
            if (glyphW === 0 || glyphH === 0 || charCode === 32) {
              continue;
            }
            scale = src.fontSize / src.fontData.size;
            rotation = 0;
            if (displayCallback) {
              callbackData.color = 0;
              callbackData.tint.topLeft = tintTL;
              callbackData.tint.topRight = tintTR;
              callbackData.tint.bottomLeft = tintBL;
              callbackData.tint.bottomRight = tintBR;
              callbackData.index = i2;
              callbackData.charCode = charCode;
              callbackData.x = x2;
              callbackData.y = y2;
              callbackData.scale = scale;
              callbackData.rotation = rotation;
              callbackData.data = glyph.data;
              var output = displayCallback(callbackData);
              x2 = output.x;
              y2 = output.y;
              scale = output.scale;
              rotation = output.rotation;
              if (output.color) {
                tintTL = output.color;
                tintTR = output.color;
                tintBL = output.color;
                tintBR = output.color;
              } else {
                tintTL = output.tint.topLeft;
                tintTR = output.tint.topRight;
                tintBL = output.tint.bottomLeft;
                tintBR = output.tint.bottomRight;
              }
              tintTL = Utils.getTintAppendFloatAlpha(tintTL, camera.alpha * src._alphaTL);
              tintTR = Utils.getTintAppendFloatAlpha(tintTR, camera.alpha * src._alphaTR);
              tintBL = Utils.getTintAppendFloatAlpha(tintBL, camera.alpha * src._alphaBL);
              tintBR = Utils.getTintAppendFloatAlpha(tintBR, camera.alpha * src._alphaBR);
            }
            x2 *= scale;
            y2 *= scale;
            x2 -= src.displayOriginX;
            y2 -= src.displayOriginY;
            x2 += lineOffsetX;
            fontMatrix.applyITRS(x2, y2, rotation, scale, scale);
            calcMatrix.multiply(fontMatrix, spriteMatrix);
            var u0 = glyph.u0;
            var v0 = glyph.v0;
            var u1 = glyph.u1;
            var v1 = glyph.v1;
            var xw = glyphW;
            var yh2 = glyphH;
            var tx0 = spriteMatrix.e;
            var ty0 = spriteMatrix.f;
            var tx1 = yh2 * spriteMatrix.c + spriteMatrix.e;
            var ty1 = yh2 * spriteMatrix.d + spriteMatrix.f;
            var tx2 = xw * spriteMatrix.a + yh2 * spriteMatrix.c + spriteMatrix.e;
            var ty2 = xw * spriteMatrix.b + yh2 * spriteMatrix.d + spriteMatrix.f;
            var tx3 = xw * spriteMatrix.a + spriteMatrix.e;
            var ty3 = xw * spriteMatrix.b + spriteMatrix.f;
            if (roundPixels) {
              tx0 = Math.round(tx0);
              ty0 = Math.round(ty0);
              tx1 = Math.round(tx1);
              ty1 = Math.round(ty1);
              tx2 = Math.round(tx2);
              ty2 = Math.round(ty2);
              tx3 = Math.round(tx3);
              ty3 = Math.round(ty3);
            }
            pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
          }
          if (crop) {
            pipeline.flush();
            renderer.popScissor();
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = DynamicBitmapTextWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetTransform = __webpack_require__(30);
        var DynamicBitmapTextCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          var text = src._text;
          var textLength = text.length;
          var ctx = renderer.currentContext;
          if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
            return;
          }
          camera.addToRenderList(src);
          var textureFrame = src.fromAtlas ? src.frame : src.texture.frames["__BASE"];
          var displayCallback = src.displayCallback;
          var callbackData = src.callbackData;
          var chars = src.fontData.chars;
          var lineHeight = src.fontData.lineHeight;
          var letterSpacing = src._letterSpacing;
          var xAdvance = 0;
          var yAdvance = 0;
          var charCode = 0;
          var glyph = null;
          var glyphX = 0;
          var glyphY = 0;
          var glyphW = 0;
          var glyphH = 0;
          var x2 = 0;
          var y2 = 0;
          var lastGlyph = null;
          var lastCharCode = 0;
          var image = src.frame.source.image;
          var textureX = textureFrame.cutX;
          var textureY = textureFrame.cutY;
          var rotation = 0;
          var scale = 0;
          var baseScale = src._fontSize / src.fontData.size;
          var align = src._align;
          var currentLine = 0;
          var lineOffsetX = 0;
          src.getTextBounds(false);
          var lineData = src._bounds.lines;
          if (align === 1) {
            lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
          } else if (align === 2) {
            lineOffsetX = lineData.longest - lineData.lengths[0];
          }
          ctx.translate(-src.displayOriginX, -src.displayOriginY);
          var roundPixels = camera.roundPixels;
          if (src.cropWidth > 0 && src.cropHeight > 0) {
            ctx.beginPath();
            ctx.rect(0, 0, src.cropWidth, src.cropHeight);
            ctx.clip();
          }
          for (var i2 = 0; i2 < textLength; i2++) {
            scale = baseScale;
            rotation = 0;
            charCode = text.charCodeAt(i2);
            if (charCode === 10) {
              currentLine++;
              if (align === 1) {
                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
              } else if (align === 2) {
                lineOffsetX = lineData.longest - lineData.lengths[currentLine];
              }
              xAdvance = 0;
              yAdvance += lineHeight;
              lastGlyph = null;
              continue;
            }
            glyph = chars[charCode];
            if (!glyph) {
              continue;
            }
            glyphX = textureX + glyph.x;
            glyphY = textureY + glyph.y;
            glyphW = glyph.width;
            glyphH = glyph.height;
            x2 = glyph.xOffset + xAdvance - src.scrollX;
            y2 = glyph.yOffset + yAdvance - src.scrollY;
            if (lastGlyph !== null) {
              var kerningOffset = glyph.kerning[lastCharCode];
              x2 += kerningOffset !== void 0 ? kerningOffset : 0;
            }
            if (displayCallback) {
              callbackData.index = i2;
              callbackData.charCode = charCode;
              callbackData.x = x2;
              callbackData.y = y2;
              callbackData.scale = scale;
              callbackData.rotation = rotation;
              callbackData.data = glyph.data;
              var output = displayCallback(callbackData);
              x2 = output.x;
              y2 = output.y;
              scale = output.scale;
              rotation = output.rotation;
            }
            x2 *= scale;
            y2 *= scale;
            x2 += lineOffsetX;
            xAdvance += glyph.xAdvance + letterSpacing;
            lastGlyph = glyph;
            lastCharCode = charCode;
            if (glyphW === 0 || glyphH === 0 || charCode === 32) {
              continue;
            }
            if (roundPixels) {
              x2 = Math.round(x2);
              y2 = Math.round(y2);
            }
            ctx.save();
            ctx.translate(x2, y2);
            ctx.rotate(rotation);
            ctx.scale(scale, scale);
            ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
            ctx.restore();
          }
          ctx.restore();
        };
        module2.exports = DynamicBitmapTextCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1061);
        }
        {
          renderCanvas = __webpack_require__(1062);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCalcMatrix = __webpack_require__(19);
        var ExternWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          renderer.pipelines.clear();
          var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
          src.render.call(src, renderer, camera, calcMatrix);
          renderer.pipelines.rebind();
        };
        module2.exports = ExternWebGLRenderer;
      },
      function(module2, exports2) {
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1064);
          renderCanvas = __webpack_require__(448);
        }
        {
          renderCanvas = __webpack_require__(448);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Commands = __webpack_require__(217);
        var GetCalcMatrix = __webpack_require__(19);
        var TransformMatrix = __webpack_require__(25);
        var Utils = __webpack_require__(12);
        var Point = function(x2, y2, width) {
          this.x = x2;
          this.y = y2;
          this.width = width;
        };
        var Path = function(x2, y2, width) {
          this.points = [];
          this.pointsLength = 1;
          this.points[0] = new Point(x2, y2, width);
        };
        var matrixStack = [];
        var tempMatrix = new TransformMatrix();
        var GraphicsWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          if (src.commandBuffer.length === 0) {
            return;
          }
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline, src);
          renderer.pipelines.preBatch(src);
          var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
          var currentMatrix = tempMatrix.loadIdentity();
          var commands = src.commandBuffer;
          var alpha = camera.alpha * src.alpha;
          var lineWidth = 1;
          var fillTint = pipeline.fillTint;
          var strokeTint = pipeline.strokeTint;
          var tx = 0;
          var ty = 0;
          var ta2 = 0;
          var iterStep = 0.01;
          var PI2 = Math.PI * 2;
          var cmd;
          var path = [];
          var pathIndex = 0;
          var pathOpen = true;
          var lastPath = null;
          var getTint = Utils.getTintAppendFloatAlpha;
          for (var cmdIndex = 0; cmdIndex < commands.length; cmdIndex++) {
            cmd = commands[cmdIndex];
            switch (cmd) {
              case Commands.BEGIN_PATH: {
                path.length = 0;
                lastPath = null;
                pathOpen = true;
                break;
              }
              case Commands.CLOSE_PATH: {
                pathOpen = false;
                if (lastPath && lastPath.points.length) {
                  lastPath.points.push(lastPath.points[0]);
                }
                break;
              }
              case Commands.FILL_PATH: {
                for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                  pipeline.batchFillPath(path[pathIndex].points, currentMatrix, calcMatrix);
                }
                break;
              }
              case Commands.STROKE_PATH: {
                for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                  pipeline.batchStrokePath(path[pathIndex].points, lineWidth, pathOpen, currentMatrix, calcMatrix);
                }
                break;
              }
              case Commands.LINE_STYLE: {
                lineWidth = commands[++cmdIndex];
                var strokeColor = commands[++cmdIndex];
                var strokeAlpha = commands[++cmdIndex] * alpha;
                var strokeTintColor = getTint(strokeColor, strokeAlpha);
                strokeTint.TL = strokeTintColor;
                strokeTint.TR = strokeTintColor;
                strokeTint.BL = strokeTintColor;
                strokeTint.BR = strokeTintColor;
                break;
              }
              case Commands.FILL_STYLE: {
                var fillColor = commands[++cmdIndex];
                var fillAlpha = commands[++cmdIndex] * alpha;
                var fillTintColor = getTint(fillColor, fillAlpha);
                fillTint.TL = fillTintColor;
                fillTint.TR = fillTintColor;
                fillTint.BL = fillTintColor;
                fillTint.BR = fillTintColor;
                break;
              }
              case Commands.GRADIENT_FILL_STYLE: {
                var alphaTL = commands[++cmdIndex] * alpha;
                var alphaTR = commands[++cmdIndex] * alpha;
                var alphaBL = commands[++cmdIndex] * alpha;
                var alphaBR = commands[++cmdIndex] * alpha;
                fillTint.TL = getTint(commands[++cmdIndex], alphaTL);
                fillTint.TR = getTint(commands[++cmdIndex], alphaTR);
                fillTint.BL = getTint(commands[++cmdIndex], alphaBL);
                fillTint.BR = getTint(commands[++cmdIndex], alphaBR);
                break;
              }
              case Commands.GRADIENT_LINE_STYLE: {
                lineWidth = commands[++cmdIndex];
                var gradientLineAlpha = commands[++cmdIndex] * alpha;
                strokeTint.TL = getTint(commands[++cmdIndex], gradientLineAlpha);
                strokeTint.TR = getTint(commands[++cmdIndex], gradientLineAlpha);
                strokeTint.BL = getTint(commands[++cmdIndex], gradientLineAlpha);
                strokeTint.BR = getTint(commands[++cmdIndex], gradientLineAlpha);
                break;
              }
              case Commands.ARC: {
                var iteration = 0;
                var x2 = commands[++cmdIndex];
                var y2 = commands[++cmdIndex];
                var radius = commands[++cmdIndex];
                var startAngle = commands[++cmdIndex];
                var endAngle = commands[++cmdIndex];
                var anticlockwise = commands[++cmdIndex];
                var overshoot = commands[++cmdIndex];
                endAngle -= startAngle;
                if (anticlockwise) {
                  if (endAngle < -PI2) {
                    endAngle = -PI2;
                  } else if (endAngle > 0) {
                    endAngle = -PI2 + endAngle % PI2;
                  }
                } else if (endAngle > PI2) {
                  endAngle = PI2;
                } else if (endAngle < 0) {
                  endAngle = PI2 + endAngle % PI2;
                }
                if (lastPath === null) {
                  lastPath = new Path(x2 + Math.cos(startAngle) * radius, y2 + Math.sin(startAngle) * radius, lineWidth);
                  path.push(lastPath);
                  iteration += iterStep;
                }
                while (iteration < 1 + overshoot) {
                  ta2 = endAngle * iteration + startAngle;
                  tx = x2 + Math.cos(ta2) * radius;
                  ty = y2 + Math.sin(ta2) * radius;
                  lastPath.points.push(new Point(tx, ty, lineWidth));
                  iteration += iterStep;
                }
                ta2 = endAngle + startAngle;
                tx = x2 + Math.cos(ta2) * radius;
                ty = y2 + Math.sin(ta2) * radius;
                lastPath.points.push(new Point(tx, ty, lineWidth));
                break;
              }
              case Commands.FILL_RECT: {
                pipeline.batchFillRect(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, calcMatrix);
                break;
              }
              case Commands.FILL_TRIANGLE: {
                pipeline.batchFillTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, calcMatrix);
                break;
              }
              case Commands.STROKE_TRIANGLE: {
                pipeline.batchStrokeTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], lineWidth, currentMatrix, calcMatrix);
                break;
              }
              case Commands.LINE_TO: {
                if (lastPath !== null) {
                  lastPath.points.push(new Point(commands[++cmdIndex], commands[++cmdIndex], lineWidth));
                } else {
                  lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);
                  path.push(lastPath);
                }
                break;
              }
              case Commands.MOVE_TO: {
                lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);
                path.push(lastPath);
                break;
              }
              case Commands.SAVE: {
                matrixStack.push(currentMatrix.copyToArray());
                break;
              }
              case Commands.RESTORE: {
                currentMatrix.copyFromArray(matrixStack.pop());
                break;
              }
              case Commands.TRANSLATE: {
                x2 = commands[++cmdIndex];
                y2 = commands[++cmdIndex];
                currentMatrix.translate(x2, y2);
                break;
              }
              case Commands.SCALE: {
                x2 = commands[++cmdIndex];
                y2 = commands[++cmdIndex];
                currentMatrix.scale(x2, y2);
                break;
              }
              case Commands.ROTATE: {
                currentMatrix.rotate(commands[++cmdIndex]);
                break;
              }
            }
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = GraphicsWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1066);
        }
        {
          renderCanvas = __webpack_require__(1067);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SpriteWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          src.pipeline.batchSprite(src, camera, parentMatrix);
        };
        module2.exports = SpriteWebGLRenderer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SpriteCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          renderer.batchSprite(src, src.frame, camera, parentMatrix);
        };
        module2.exports = SpriteCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1069);
        }
        {
          renderCanvas = __webpack_require__(1070);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ImageWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          this.pipeline.batchSprite(src, camera, parentMatrix);
        };
        module2.exports = ImageWebGLRenderer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ImageCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          renderer.batchSprite(src, src.frame, camera, parentMatrix);
        };
        module2.exports = ImageCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1072);
        }
        {
          renderCanvas = __webpack_require__(1073);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var LayerWebGLRenderer = function(renderer, layer, camera) {
          var children = layer.list;
          var childCount = children.length;
          if (childCount === 0) {
            return;
          }
          layer.depthSort();
          renderer.pipelines.preBatch(layer);
          var layerHasBlendMode = layer.blendMode !== -1;
          if (!layerHasBlendMode) {
            renderer.setBlendMode(0);
          }
          var alpha = layer.alpha;
          for (var i2 = 0; i2 < childCount; i2++) {
            var child = children[i2];
            if (!child.willRender(camera)) {
              continue;
            }
            var childAlphaTopLeft;
            var childAlphaTopRight;
            var childAlphaBottomLeft;
            var childAlphaBottomRight;
            if (child.alphaTopLeft !== void 0) {
              childAlphaTopLeft = child.alphaTopLeft;
              childAlphaTopRight = child.alphaTopRight;
              childAlphaBottomLeft = child.alphaBottomLeft;
              childAlphaBottomRight = child.alphaBottomRight;
            } else {
              var childAlpha = child.alpha;
              childAlphaTopLeft = childAlpha;
              childAlphaTopRight = childAlpha;
              childAlphaBottomLeft = childAlpha;
              childAlphaBottomRight = childAlpha;
            }
            if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
              renderer.setBlendMode(child.blendMode);
            }
            var mask = child.mask;
            if (mask) {
              mask.preRenderWebGL(renderer, child, camera);
            }
            var type = child.type;
            if (type !== renderer.currentType) {
              renderer.newType = true;
              renderer.currentType = type;
            }
            renderer.nextTypeMatch = i2 < childCount - 1 ? children[i2 + 1].type === renderer.currentType : false;
            child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);
            child.renderWebGL(renderer, child, camera);
            child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);
            if (mask) {
              mask.postRenderWebGL(renderer, camera);
            }
            renderer.newType = false;
          }
          renderer.pipelines.postBatch(layer);
        };
        module2.exports = LayerWebGLRenderer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var LayerCanvasRenderer = function(renderer, layer, camera) {
          var children = layer.list;
          if (children.length === 0) {
            return;
          }
          layer.depthSort();
          var layerHasBlendMode = layer.blendMode !== -1;
          if (!layerHasBlendMode) {
            renderer.setBlendMode(0);
          }
          var alpha = layer._alpha;
          if (layer.mask) {
            layer.mask.preRenderCanvas(renderer, null, camera);
          }
          for (var i2 = 0; i2 < children.length; i2++) {
            var child = children[i2];
            if (!child.willRender(camera)) {
              continue;
            }
            var childAlpha = child.alpha;
            if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
              renderer.setBlendMode(child.blendMode);
            }
            child.setAlpha(childAlpha * alpha);
            child.renderCanvas(renderer, child, camera);
            child.setAlpha(childAlpha);
          }
          if (layer.mask) {
            layer.mask.postRenderCanvas(renderer);
          }
        };
        module2.exports = LayerCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          EmitterOp: __webpack_require__(449),
          GravityWell: __webpack_require__(450),
          Particle: __webpack_require__(451),
          ParticleEmitter: __webpack_require__(452),
          ParticleEmitterManager: __webpack_require__(220),
          Zones: __webpack_require__(1078)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1076);
        }
        {
          renderCanvas = __webpack_require__(1077);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TransformMatrix = __webpack_require__(25);
        var Utils = __webpack_require__(12);
        var tempMatrix1 = new TransformMatrix();
        var tempMatrix2 = new TransformMatrix();
        var tempMatrix3 = new TransformMatrix();
        var tempMatrix4 = new TransformMatrix();
        var ParticleManagerWebGLRenderer = function(renderer, emitterManager, camera, parentMatrix) {
          var emitters = emitterManager.emitters.list;
          var emittersLength = emitters.length;
          if (emittersLength === 0) {
            return;
          }
          var pipeline = renderer.pipelines.set(emitterManager.pipeline);
          var camMatrix = tempMatrix1;
          var calcMatrix = tempMatrix2;
          var particleMatrix = tempMatrix3;
          var managerMatrix = tempMatrix4;
          if (parentMatrix) {
            managerMatrix.loadIdentity();
            managerMatrix.multiply(parentMatrix);
            managerMatrix.translate(emitterManager.x, emitterManager.y);
            managerMatrix.rotate(emitterManager.rotation);
            managerMatrix.scale(emitterManager.scaleX, emitterManager.scaleY);
          } else {
            managerMatrix.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);
          }
          var roundPixels = camera.roundPixels;
          var texture = emitterManager.defaultFrame.glTexture;
          var getTint = Utils.getTintAppendFloatAlpha;
          var textureUnit = pipeline.setGameObject(emitterManager, emitterManager.defaultFrame);
          renderer.pipelines.preBatch(emitterManager);
          for (var e = 0; e < emittersLength; e++) {
            var emitter = emitters[e];
            var particles = emitter.alive;
            var particleCount = particles.length;
            if (!emitter.visible || particleCount === 0) {
              continue;
            }
            camera.addToRenderList(emitter);
            var scrollFactorX = emitter.scrollFactorX;
            var scrollFactorY = emitter.scrollFactorY;
            renderer.setBlendMode(emitter.blendMode);
            if (emitter.mask) {
              emitter.mask.preRenderWebGL(renderer, emitter, camera);
              renderer.pipelines.set(emitterManager.pipeline);
            }
            var tintEffect = 0;
            for (var i2 = 0; i2 < particleCount; i2++) {
              var particle = particles[i2];
              var alpha = particle.alpha * camera.alpha;
              if (alpha <= 0) {
                continue;
              }
              particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);
              camMatrix.copyFrom(camera.matrix);
              camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
              particleMatrix.e = particle.x;
              particleMatrix.f = particle.y;
              camMatrix.multiply(particleMatrix, calcMatrix);
              var frame = particle.frame;
              var x2 = -frame.halfWidth;
              var y2 = -frame.halfHeight;
              var xw = x2 + frame.width;
              var yh2 = y2 + frame.height;
              var tx0 = calcMatrix.getXRound(x2, y2, roundPixels);
              var ty0 = calcMatrix.getYRound(x2, y2, roundPixels);
              var tx1 = calcMatrix.getXRound(x2, yh2, roundPixels);
              var ty1 = calcMatrix.getYRound(x2, yh2, roundPixels);
              var tx2 = calcMatrix.getXRound(xw, yh2, roundPixels);
              var ty2 = calcMatrix.getYRound(xw, yh2, roundPixels);
              var tx3 = calcMatrix.getXRound(xw, y2, roundPixels);
              var ty3 = calcMatrix.getYRound(xw, y2, roundPixels);
              var tint = getTint(particle.tint, alpha);
              pipeline.batchQuad(emitter, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, texture, textureUnit);
            }
            if (emitter.mask) {
              emitter.mask.postRenderWebGL(renderer, camera);
            }
          }
          renderer.pipelines.postBatch(emitterManager);
        };
        module2.exports = ParticleManagerWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TransformMatrix = __webpack_require__(25);
        var tempMatrix1 = new TransformMatrix();
        var tempMatrix2 = new TransformMatrix();
        var tempMatrix3 = new TransformMatrix();
        var tempMatrix4 = new TransformMatrix();
        var ParticleManagerCanvasRenderer = function(renderer, emitterManager, camera, parentMatrix) {
          var emitters = emitterManager.emitters.list;
          var emittersLength = emitters.length;
          if (emittersLength === 0) {
            return;
          }
          var camMatrix = tempMatrix1.copyFrom(camera.matrix);
          var calcMatrix = tempMatrix2;
          var particleMatrix = tempMatrix3;
          var managerMatrix = tempMatrix4;
          if (parentMatrix) {
            managerMatrix.loadIdentity();
            managerMatrix.multiply(parentMatrix);
            managerMatrix.translate(emitterManager.x, emitterManager.y);
            managerMatrix.rotate(emitterManager.rotation);
            managerMatrix.scale(emitterManager.scaleX, emitterManager.scaleY);
          } else {
            managerMatrix.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);
          }
          var ctx = renderer.currentContext;
          var roundPixels = camera.roundPixels;
          for (var e = 0; e < emittersLength; e++) {
            var emitter = emitters[e];
            var particles = emitter.alive;
            var particleCount = particles.length;
            if (!emitter.visible || particleCount === 0) {
              continue;
            }
            camera.addToRenderList(emitter);
            var scrollFactorX = emitter.scrollFactorX;
            var scrollFactorY = emitter.scrollFactorY;
            ctx.save();
            ctx.globalCompositeOperation = renderer.blendModes[emitter.blendMode];
            for (var i2 = 0; i2 < particleCount; i2++) {
              var particle = particles[i2];
              var alpha = particle.alpha * camera.alpha;
              if (alpha <= 0) {
                continue;
              }
              particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);
              camMatrix.copyFrom(camera.matrix);
              camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
              particleMatrix.e = particle.x;
              particleMatrix.f = particle.y;
              camMatrix.multiply(particleMatrix, calcMatrix);
              var frame = particle.frame;
              var cd2 = frame.canvasData;
              var x2 = -frame.halfWidth;
              var y2 = -frame.halfHeight;
              ctx.globalAlpha = alpha;
              ctx.save();
              calcMatrix.setToContext(ctx);
              if (roundPixels) {
                x2 = Math.round(x2);
                y2 = Math.round(y2);
              }
              ctx.imageSmoothingEnabled = !(!renderer.antialias || frame.source.scaleMode);
              ctx.drawImage(frame.source.image, cd2.x, cd2.y, cd2.width, cd2.height, x2, y2, cd2.width, cd2.height);
              ctx.restore();
            }
            ctx.restore();
          }
        };
        module2.exports = ParticleManagerCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          DeathZone: __webpack_require__(453),
          EdgeZone: __webpack_require__(454),
          RandomZone: __webpack_require__(456)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1080);
        }
        {
          renderCanvas = __webpack_require__(1081);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Utils = __webpack_require__(12);
        var RenderTextureWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var cameraAlpha = camera.alpha;
          var renderTarget = src.renderTarget;
          var width = renderTarget.width;
          var height = renderTarget.height;
          var getTint = Utils.getTintAppendFloatAlpha;
          var pipeline = renderer.pipelines.set(src.pipeline);
          var textureUnit = pipeline.setTexture2D(renderTarget.texture);
          renderer.pipelines.preBatch(src);
          pipeline.batchTexture(src, renderTarget.texture, width, height, src.x, src.y, width, height, src.scaleX, src.scaleY, src.rotation, src.flipX, !src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, cameraAlpha * src._alphaTL), getTint(src.tintTopRight, cameraAlpha * src._alphaTR), getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL), getTint(src.tintBottomRight, cameraAlpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, true, textureUnit);
          renderer.resetTextures();
          renderer.pipelines.postBatch(src);
        };
        module2.exports = RenderTextureWebGLRenderer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RenderTextureCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          renderer.batchSprite(src, src.frame, camera, parentMatrix);
        };
        module2.exports = RenderTextureCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RETRO_FONT_CONST = __webpack_require__(1083);
        var Extend = __webpack_require__(17);
        var RetroFont = { Parse: __webpack_require__(1084) };
        RetroFont = Extend(false, RetroFont, RETRO_FONT_CONST);
        module2.exports = RetroFont;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RETRO_FONT_CONST = {
          TEXT_SET1: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
          TEXT_SET2: ` !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ`,
          TEXT_SET3: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ",
          TEXT_SET4: "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789",
          TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789",
          TEXT_SET6: `ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.' `,
          TEXT_SET7: `AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-'39`,
          TEXT_SET8: "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          TEXT_SET9: `ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'"?!`,
          TEXT_SET10: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          TEXT_SET11: `ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()':;0123456789`
        };
        module2.exports = RETRO_FONT_CONST;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetValue = __webpack_require__(6);
        var ParseRetroFont = function(scene, config) {
          var w2 = config.width;
          var h2 = config.height;
          var cx = Math.floor(w2 / 2);
          var cy = Math.floor(h2 / 2);
          var letters = GetValue(config, "chars", "");
          if (letters === "") {
            return;
          }
          var key = GetValue(config, "image", "");
          var frame = scene.sys.textures.getFrame(key);
          var textureX = frame.cutX;
          var textureY = frame.cutY;
          var textureWidth = frame.source.width;
          var textureHeight = frame.source.height;
          var offsetX = GetValue(config, "offset.x", 0);
          var offsetY = GetValue(config, "offset.y", 0);
          var spacingX = GetValue(config, "spacing.x", 0);
          var spacingY = GetValue(config, "spacing.y", 0);
          var lineSpacing = GetValue(config, "lineSpacing", 0);
          var charsPerRow = GetValue(config, "charsPerRow", null);
          if (charsPerRow === null) {
            charsPerRow = textureWidth / w2;
            if (charsPerRow > letters.length) {
              charsPerRow = letters.length;
            }
          }
          var x2 = offsetX;
          var y2 = offsetY;
          var data = {
            retroFont: true,
            font: key,
            size: w2,
            lineHeight: h2 + lineSpacing,
            chars: {}
          };
          var r2 = 0;
          for (var i2 = 0; i2 < letters.length; i2++) {
            var charCode = letters.charCodeAt(i2);
            var u0 = (textureX + x2) / textureWidth;
            var v0 = (textureY + y2) / textureHeight;
            var u1 = (textureX + x2 + w2) / textureWidth;
            var v1 = (textureY + y2 + h2) / textureHeight;
            data.chars[charCode] = {
              x: x2,
              y: y2,
              width: w2,
              height: h2,
              centerX: cx,
              centerY: cy,
              xOffset: 0,
              yOffset: 0,
              xAdvance: w2,
              data: {},
              kerning: {},
              u0,
              v0,
              u1,
              v1
            };
            r2++;
            if (r2 === charsPerRow) {
              r2 = 0;
              x2 = offsetX;
              y2 += h2 + spacingY;
            } else {
              x2 += w2 + spacingX;
            }
          }
          var entry = {
            data,
            frame: null,
            texture: key
          };
          return entry;
        };
        module2.exports = ParseRetroFont;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1086);
        }
        {
          renderCanvas = __webpack_require__(1087);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCalcMatrix = __webpack_require__(19);
        var Utils = __webpack_require__(12);
        var RopeWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline, src);
          var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
          var vertices = src.vertices;
          var uvs = src.uv;
          var colors = src.colors;
          var alphas = src.alphas;
          var alpha = src.alpha;
          var getTint = Utils.getTintAppendFloatAlpha;
          var roundPixels = camera.roundPixels;
          var meshVerticesLength = vertices.length;
          var vertexCount = Math.floor(meshVerticesLength * 0.5);
          pipeline.flush();
          renderer.pipelines.preBatch(src);
          var textureUnit = pipeline.setGameObject(src);
          var vertexViewF32 = pipeline.vertexViewF32;
          var vertexViewU32 = pipeline.vertexViewU32;
          var vertexOffset = pipeline.vertexCount * pipeline.currentShader.vertexComponentCount - 1;
          var colorIndex = 0;
          var tintEffect = src.tintFill;
          if (src.dirty) {
            src.updateVertices();
          }
          var debugCallback = src.debugCallback;
          var debugVerts = [];
          for (var i2 = 0; i2 < meshVerticesLength; i2 += 2) {
            var x2 = vertices[i2 + 0];
            var y2 = vertices[i2 + 1];
            var tx = x2 * calcMatrix.a + y2 * calcMatrix.c + calcMatrix.e;
            var ty = x2 * calcMatrix.b + y2 * calcMatrix.d + calcMatrix.f;
            if (roundPixels) {
              tx = Math.round(tx);
              ty = Math.round(ty);
            }
            vertexViewF32[++vertexOffset] = tx;
            vertexViewF32[++vertexOffset] = ty;
            vertexViewF32[++vertexOffset] = uvs[i2 + 0];
            vertexViewF32[++vertexOffset] = uvs[i2 + 1];
            vertexViewF32[++vertexOffset] = textureUnit;
            vertexViewF32[++vertexOffset] = tintEffect;
            vertexViewU32[++vertexOffset] = getTint(colors[colorIndex], camera.alpha * (alphas[colorIndex] * alpha));
            colorIndex++;
            if (debugCallback) {
              debugVerts[i2 + 0] = tx;
              debugVerts[i2 + 1] = ty;
            }
          }
          if (debugCallback) {
            debugCallback.call(src, src, meshVerticesLength, debugVerts);
          }
          pipeline.vertexCount += vertexCount;
          renderer.pipelines.postBatch(src);
        };
        module2.exports = RopeWebGLRenderer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RopeCanvasRenderer = function() {
        };
        module2.exports = RopeCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1089);
        }
        {
          renderCanvas = __webpack_require__(1090);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Utils = __webpack_require__(12);
        var TextWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          if (src.width === 0 || src.height === 0) {
            return;
          }
          camera.addToRenderList(src);
          var frame = src.frame;
          var width = frame.width;
          var height = frame.height;
          var getTint = Utils.getTintAppendFloatAlpha;
          var pipeline = renderer.pipelines.set(src.pipeline, src);
          var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
          renderer.pipelines.preBatch(src);
          pipeline.batchTexture(src, frame.glTexture, width, height, src.x, src.y, width / src.style.resolution, height / src.style.resolution, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, false, textureUnit);
          renderer.pipelines.postBatch(src);
        };
        module2.exports = TextWebGLRenderer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TextCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          if (src.width === 0 || src.height === 0) {
            return;
          }
          camera.addToRenderList(src);
          renderer.batchSprite(src, src.frame, camera, parentMatrix);
        };
        module2.exports = TextCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1092);
        }
        {
          renderCanvas = __webpack_require__(1093);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Utils = __webpack_require__(12);
        var TileSpriteWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          src.updateCanvas();
          var width = src.width;
          var height = src.height;
          if (width === 0 || height === 0) {
            return;
          }
          camera.addToRenderList(src);
          renderer.pipelines.preBatch(src);
          var getTint = Utils.getTintAppendFloatAlpha;
          var pipeline = renderer.pipelines.set(src.pipeline, src);
          var textureUnit = pipeline.setTexture2D(src.fillPattern, src);
          pipeline.batchTexture(src, src.fillPattern, src.displayFrame.width * src.tileScaleX, src.displayFrame.height * src.tileScaleY, src.x, src.y, width, height, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.originX * width, src.originY * height, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, src.tilePositionX % src.displayFrame.width / src.displayFrame.width, src.tilePositionY % src.displayFrame.height / src.displayFrame.height, camera, parentMatrix, false, textureUnit);
          renderer.pipelines.postBatch(src);
        };
        module2.exports = TileSpriteWebGLRenderer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TileSpriteCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          src.updateCanvas();
          camera.addToRenderList(src);
          renderer.batchSprite(src, src.frame, camera, parentMatrix);
        };
        module2.exports = TileSpriteCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1095);
        }
        {
          renderCanvas = __webpack_require__(1096);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var VideoWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          if (src.videoTexture) {
            camera.addToRenderList(src);
            src.pipeline.batchSprite(src, camera, parentMatrix);
          }
        };
        module2.exports = VideoWebGLRenderer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var VideoCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          if (src.videoTexture) {
            camera.addToRenderList(src);
            renderer.batchSprite(src, src.frame, camera, parentMatrix);
          }
        };
        module2.exports = VideoCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1098);
        }
        {
          renderCanvas = __webpack_require__(1099);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCalcMatrix = __webpack_require__(19);
        var FillPathWebGL = __webpack_require__(114);
        var StrokePathWebGL = __webpack_require__(81);
        var ArcWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline);
          var result = GetCalcMatrix(src, camera, parentMatrix);
          var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
          var dx = src._displayOriginX;
          var dy = src._displayOriginY;
          var alpha = camera.alpha * src.alpha;
          renderer.pipelines.preBatch(src);
          if (src.isFilled) {
            FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
          }
          if (src.isStroked) {
            StrokePathWebGL(pipeline, src, alpha, dx, dy);
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = ArcWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DegToRad = __webpack_require__(36);
        var FillStyleCanvas = __webpack_require__(48);
        var LineStyleCanvas = __webpack_require__(60);
        var SetTransform = __webpack_require__(30);
        var ArcCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var ctx = renderer.currentContext;
          if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
            var radius = src.radius;
            ctx.beginPath();
            ctx.arc(radius - src.originX * (radius * 2), radius - src.originY * (radius * 2), radius, DegToRad(src._startAngle), DegToRad(src._endAngle), src.anticlockwise);
            if (src.closePath) {
              ctx.closePath();
            }
            if (src.isFilled) {
              FillStyleCanvas(ctx, src);
              ctx.fill();
            }
            if (src.isStroked) {
              LineStyleCanvas(ctx, src);
              ctx.stroke();
            }
            ctx.restore();
          }
        };
        module2.exports = ArcCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1101);
        }
        {
          renderCanvas = __webpack_require__(1102);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FillPathWebGL = __webpack_require__(114);
        var GetCalcMatrix = __webpack_require__(19);
        var StrokePathWebGL = __webpack_require__(81);
        var CurveWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline);
          var result = GetCalcMatrix(src, camera, parentMatrix);
          var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
          var dx = src._displayOriginX + src._curveBounds.x;
          var dy = src._displayOriginY + src._curveBounds.y;
          var alpha = camera.alpha * src.alpha;
          renderer.pipelines.preBatch(src);
          if (src.isFilled) {
            FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
          }
          if (src.isStroked) {
            StrokePathWebGL(pipeline, src, alpha, dx, dy);
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = CurveWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FillStyleCanvas = __webpack_require__(48);
        var LineStyleCanvas = __webpack_require__(60);
        var SetTransform = __webpack_require__(30);
        var CurveCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var ctx = renderer.currentContext;
          if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
            var dx = src._displayOriginX + src._curveBounds.x;
            var dy = src._displayOriginY + src._curveBounds.y;
            var path = src.pathData;
            var pathLength = path.length - 1;
            var px1 = path[0] - dx;
            var py1 = path[1] - dy;
            ctx.beginPath();
            ctx.moveTo(px1, py1);
            if (!src.closePath) {
              pathLength -= 2;
            }
            for (var i2 = 2; i2 < pathLength; i2 += 2) {
              var px2 = path[i2] - dx;
              var py2 = path[i2 + 1] - dy;
              ctx.lineTo(px2, py2);
            }
            if (src.closePath) {
              ctx.closePath();
            }
            if (src.isFilled) {
              FillStyleCanvas(ctx, src);
              ctx.fill();
            }
            if (src.isStroked) {
              LineStyleCanvas(ctx, src);
              ctx.stroke();
            }
            ctx.restore();
          }
        };
        module2.exports = CurveCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1104);
        }
        {
          renderCanvas = __webpack_require__(1105);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FillPathWebGL = __webpack_require__(114);
        var GetCalcMatrix = __webpack_require__(19);
        var StrokePathWebGL = __webpack_require__(81);
        var EllipseWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline);
          var result = GetCalcMatrix(src, camera, parentMatrix);
          var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
          var dx = src._displayOriginX;
          var dy = src._displayOriginY;
          var alpha = camera.alpha * src.alpha;
          renderer.pipelines.preBatch(src);
          if (src.isFilled) {
            FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
          }
          if (src.isStroked) {
            StrokePathWebGL(pipeline, src, alpha, dx, dy);
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = EllipseWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FillStyleCanvas = __webpack_require__(48);
        var LineStyleCanvas = __webpack_require__(60);
        var SetTransform = __webpack_require__(30);
        var EllipseCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var ctx = renderer.currentContext;
          if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var path = src.pathData;
            var pathLength = path.length - 1;
            var px1 = path[0] - dx;
            var py1 = path[1] - dy;
            ctx.beginPath();
            ctx.moveTo(px1, py1);
            if (!src.closePath) {
              pathLength -= 2;
            }
            for (var i2 = 2; i2 < pathLength; i2 += 2) {
              var px2 = path[i2] - dx;
              var py2 = path[i2 + 1] - dy;
              ctx.lineTo(px2, py2);
            }
            ctx.closePath();
            if (src.isFilled) {
              FillStyleCanvas(ctx, src);
              ctx.fill();
            }
            if (src.isStroked) {
              LineStyleCanvas(ctx, src);
              ctx.stroke();
            }
            ctx.restore();
          }
        };
        module2.exports = EllipseCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1107);
        }
        {
          renderCanvas = __webpack_require__(1108);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCalcMatrix = __webpack_require__(19);
        var Utils = __webpack_require__(12);
        var GridWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline);
          var result = GetCalcMatrix(src, camera, parentMatrix);
          var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
          calcMatrix.translate(-src._displayOriginX, -src._displayOriginY);
          var alpha = camera.alpha * src.alpha;
          var width = src.width;
          var height = src.height;
          var cellWidth = src.cellWidth;
          var cellHeight = src.cellHeight;
          var gridWidth = Math.ceil(width / cellWidth);
          var gridHeight = Math.ceil(height / cellHeight);
          var cellWidthA = cellWidth;
          var cellHeightA = cellHeight;
          var cellWidthB = cellWidth - (gridWidth * cellWidth - width);
          var cellHeightB = cellHeight - (gridHeight * cellHeight - height);
          var fillTint;
          var fillTintColor;
          var showCells = src.showCells;
          var showAltCells = src.showAltCells;
          var showOutline = src.showOutline;
          var x2 = 0;
          var y2 = 0;
          var r2 = 0;
          var cw = 0;
          var ch2 = 0;
          if (showOutline) {
            cellWidthA--;
            cellHeightA--;
            if (cellWidthB === cellWidth) {
              cellWidthB--;
            }
            if (cellHeightB === cellHeight) {
              cellHeightB--;
            }
          }
          renderer.pipelines.preBatch(src);
          if (showCells && src.fillAlpha > 0) {
            fillTint = pipeline.fillTint;
            fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
            fillTint.TL = fillTintColor;
            fillTint.TR = fillTintColor;
            fillTint.BL = fillTintColor;
            fillTint.BR = fillTintColor;
            for (y2 = 0; y2 < gridHeight; y2++) {
              if (showAltCells) {
                r2 = y2 % 2;
              }
              for (x2 = 0; x2 < gridWidth; x2++) {
                if (showAltCells && r2) {
                  r2 = 0;
                  continue;
                }
                r2++;
                cw = x2 < gridWidth - 1 ? cellWidthA : cellWidthB;
                ch2 = y2 < gridHeight - 1 ? cellHeightA : cellHeightB;
                pipeline.batchFillRect(x2 * cellWidth, y2 * cellHeight, cw, ch2);
              }
            }
          }
          if (showAltCells && src.altFillAlpha > 0) {
            fillTint = pipeline.fillTint;
            fillTintColor = Utils.getTintAppendFloatAlpha(src.altFillColor, src.altFillAlpha * alpha);
            fillTint.TL = fillTintColor;
            fillTint.TR = fillTintColor;
            fillTint.BL = fillTintColor;
            fillTint.BR = fillTintColor;
            for (y2 = 0; y2 < gridHeight; y2++) {
              if (showAltCells) {
                r2 = y2 % 2;
              }
              for (x2 = 0; x2 < gridWidth; x2++) {
                if (showAltCells && !r2) {
                  r2 = 1;
                  continue;
                }
                r2 = 0;
                cw = x2 < gridWidth - 1 ? cellWidthA : cellWidthB;
                ch2 = y2 < gridHeight - 1 ? cellHeightA : cellHeightB;
                pipeline.batchFillRect(x2 * cellWidth, y2 * cellHeight, cw, ch2);
              }
            }
          }
          if (showOutline && src.outlineFillAlpha > 0) {
            var strokeTint = pipeline.strokeTint;
            var color = Utils.getTintAppendFloatAlpha(src.outlineFillColor, src.outlineFillAlpha * alpha);
            strokeTint.TL = color;
            strokeTint.TR = color;
            strokeTint.BL = color;
            strokeTint.BR = color;
            for (x2 = 1; x2 < gridWidth; x2++) {
              var x1 = x2 * cellWidth;
              pipeline.batchLine(x1, 0, x1, height, 1, 1, 1, 0, false);
            }
            for (y2 = 1; y2 < gridHeight; y2++) {
              var y1 = y2 * cellHeight;
              pipeline.batchLine(0, y1, width, y1, 1, 1, 1, 0, false);
            }
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = GridWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FillStyleCanvas = __webpack_require__(48);
        var LineStyleCanvas = __webpack_require__(60);
        var SetTransform = __webpack_require__(30);
        var GridCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var ctx = renderer.currentContext;
          if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
            var dx = -src._displayOriginX;
            var dy = -src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            var width = src.width;
            var height = src.height;
            var cellWidth = src.cellWidth;
            var cellHeight = src.cellHeight;
            var gridWidth = Math.ceil(width / cellWidth);
            var gridHeight = Math.ceil(height / cellHeight);
            var cellWidthA = cellWidth;
            var cellHeightA = cellHeight;
            var cellWidthB = cellWidth - (gridWidth * cellWidth - width);
            var cellHeightB = cellHeight - (gridHeight * cellHeight - height);
            var showCells = src.showCells;
            var showAltCells = src.showAltCells;
            var showOutline = src.showOutline;
            var x2 = 0;
            var y2 = 0;
            var r2 = 0;
            var cw = 0;
            var ch2 = 0;
            if (showOutline) {
              cellWidthA--;
              cellHeightA--;
              if (cellWidthB === cellWidth) {
                cellWidthB--;
              }
              if (cellHeightB === cellHeight) {
                cellHeightB--;
              }
            }
            if (showCells && src.fillAlpha > 0) {
              FillStyleCanvas(ctx, src);
              for (y2 = 0; y2 < gridHeight; y2++) {
                if (showAltCells) {
                  r2 = y2 % 2;
                }
                for (x2 = 0; x2 < gridWidth; x2++) {
                  if (showAltCells && r2) {
                    r2 = 0;
                    continue;
                  }
                  r2++;
                  cw = x2 < gridWidth - 1 ? cellWidthA : cellWidthB;
                  ch2 = y2 < gridHeight - 1 ? cellHeightA : cellHeightB;
                  ctx.fillRect(dx + x2 * cellWidth, dy + y2 * cellHeight, cw, ch2);
                }
              }
            }
            if (showAltCells && src.altFillAlpha > 0) {
              FillStyleCanvas(ctx, src, src.altFillColor, src.altFillAlpha * alpha);
              for (y2 = 0; y2 < gridHeight; y2++) {
                if (showAltCells) {
                  r2 = y2 % 2;
                }
                for (x2 = 0; x2 < gridWidth; x2++) {
                  if (showAltCells && !r2) {
                    r2 = 1;
                    continue;
                  }
                  r2 = 0;
                  cw = x2 < gridWidth - 1 ? cellWidthA : cellWidthB;
                  ch2 = y2 < gridHeight - 1 ? cellHeightA : cellHeightB;
                  ctx.fillRect(dx + x2 * cellWidth, dy + y2 * cellHeight, cw, ch2);
                }
              }
            }
            if (showOutline && src.outlineFillAlpha > 0) {
              LineStyleCanvas(ctx, src, src.outlineFillColor, src.outlineFillAlpha * alpha);
              for (x2 = 1; x2 < gridWidth; x2++) {
                var x1 = x2 * cellWidth;
                ctx.beginPath();
                ctx.moveTo(x1 + dx, dy);
                ctx.lineTo(x1 + dx, height + dy);
                ctx.stroke();
              }
              for (y2 = 1; y2 < gridHeight; y2++) {
                var y1 = y2 * cellHeight;
                ctx.beginPath();
                ctx.moveTo(dx, y1 + dy);
                ctx.lineTo(dx + width, y1 + dy);
                ctx.stroke();
              }
            }
            ctx.restore();
          }
        };
        module2.exports = GridCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1110);
        }
        {
          renderCanvas = __webpack_require__(1111);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCalcMatrix = __webpack_require__(19);
        var Utils = __webpack_require__(12);
        var IsoBoxWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline);
          var result = GetCalcMatrix(src, camera, parentMatrix);
          var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
          var size = src.width;
          var height = src.height;
          var sizeA = size / 2;
          var sizeB = size / src.projection;
          var alpha = camera.alpha * src.alpha;
          if (!src.isFilled) {
            return;
          }
          var tint;
          var x0;
          var y0;
          var x1;
          var y1;
          var x2;
          var y2;
          var x3;
          var y3;
          renderer.pipelines.preBatch(src);
          if (src.showTop) {
            tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);
            x0 = calcMatrix.getX(-sizeA, -height);
            y0 = calcMatrix.getY(-sizeA, -height);
            x1 = calcMatrix.getX(0, -sizeB - height);
            y1 = calcMatrix.getY(0, -sizeB - height);
            x2 = calcMatrix.getX(sizeA, -height);
            y2 = calcMatrix.getY(sizeA, -height);
            x3 = calcMatrix.getX(0, sizeB - height);
            y3 = calcMatrix.getY(0, sizeB - height);
            pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
          }
          if (src.showLeft) {
            tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);
            x0 = calcMatrix.getX(-sizeA, 0);
            y0 = calcMatrix.getY(-sizeA, 0);
            x1 = calcMatrix.getX(0, sizeB);
            y1 = calcMatrix.getY(0, sizeB);
            x2 = calcMatrix.getX(0, sizeB - height);
            y2 = calcMatrix.getY(0, sizeB - height);
            x3 = calcMatrix.getX(-sizeA, -height);
            y3 = calcMatrix.getY(-sizeA, -height);
            pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
          }
          if (src.showRight) {
            tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);
            x0 = calcMatrix.getX(sizeA, 0);
            y0 = calcMatrix.getY(sizeA, 0);
            x1 = calcMatrix.getX(0, sizeB);
            y1 = calcMatrix.getY(0, sizeB);
            x2 = calcMatrix.getX(0, sizeB - height);
            y2 = calcMatrix.getY(0, sizeB - height);
            x3 = calcMatrix.getX(sizeA, -height);
            y3 = calcMatrix.getY(sizeA, -height);
            pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = IsoBoxWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FillStyleCanvas = __webpack_require__(48);
        var SetTransform = __webpack_require__(30);
        var IsoBoxCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var ctx = renderer.currentContext;
          if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled) {
            var size = src.width;
            var height = src.height;
            var sizeA = size / 2;
            var sizeB = size / src.projection;
            if (src.showTop) {
              FillStyleCanvas(ctx, src, src.fillTop);
              ctx.beginPath();
              ctx.moveTo(-sizeA, -height);
              ctx.lineTo(0, -sizeB - height);
              ctx.lineTo(sizeA, -height);
              ctx.lineTo(sizeA, -1);
              ctx.lineTo(0, sizeB - 1);
              ctx.lineTo(-sizeA, -1);
              ctx.lineTo(-sizeA, -height);
              ctx.fill();
            }
            if (src.showLeft) {
              FillStyleCanvas(ctx, src, src.fillLeft);
              ctx.beginPath();
              ctx.moveTo(-sizeA, 0);
              ctx.lineTo(0, sizeB);
              ctx.lineTo(0, sizeB - height);
              ctx.lineTo(-sizeA, -height);
              ctx.lineTo(-sizeA, 0);
              ctx.fill();
            }
            if (src.showRight) {
              FillStyleCanvas(ctx, src, src.fillRight);
              ctx.beginPath();
              ctx.moveTo(sizeA, 0);
              ctx.lineTo(0, sizeB);
              ctx.lineTo(0, sizeB - height);
              ctx.lineTo(sizeA, -height);
              ctx.lineTo(sizeA, 0);
              ctx.fill();
            }
            ctx.restore();
          }
        };
        module2.exports = IsoBoxCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1113);
        }
        {
          renderCanvas = __webpack_require__(1114);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCalcMatrix = __webpack_require__(19);
        var Utils = __webpack_require__(12);
        var IsoTriangleWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline);
          var result = GetCalcMatrix(src, camera, parentMatrix);
          var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
          var size = src.width;
          var height = src.height;
          var sizeA = size / 2;
          var sizeB = size / src.projection;
          var reversed = src.isReversed;
          var alpha = camera.alpha * src.alpha;
          if (!src.isFilled) {
            return;
          }
          renderer.pipelines.preBatch(src);
          var tint;
          var x0;
          var y0;
          var x1;
          var y1;
          var x2;
          var y2;
          if (src.showTop && reversed) {
            tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);
            x0 = calcMatrix.getX(-sizeA, -height);
            y0 = calcMatrix.getY(-sizeA, -height);
            x1 = calcMatrix.getX(0, -sizeB - height);
            y1 = calcMatrix.getY(0, -sizeB - height);
            x2 = calcMatrix.getX(sizeA, -height);
            y2 = calcMatrix.getY(sizeA, -height);
            var x3 = calcMatrix.getX(0, sizeB - height);
            var y3 = calcMatrix.getY(0, sizeB - height);
            pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
          }
          if (src.showLeft) {
            tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);
            if (reversed) {
              x0 = calcMatrix.getX(-sizeA, -height);
              y0 = calcMatrix.getY(-sizeA, -height);
              x1 = calcMatrix.getX(0, sizeB);
              y1 = calcMatrix.getY(0, sizeB);
              x2 = calcMatrix.getX(0, sizeB - height);
              y2 = calcMatrix.getY(0, sizeB - height);
            } else {
              x0 = calcMatrix.getX(-sizeA, 0);
              y0 = calcMatrix.getY(-sizeA, 0);
              x1 = calcMatrix.getX(0, sizeB);
              y1 = calcMatrix.getY(0, sizeB);
              x2 = calcMatrix.getX(0, sizeB - height);
              y2 = calcMatrix.getY(0, sizeB - height);
            }
            pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2);
          }
          if (src.showRight) {
            tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);
            if (reversed) {
              x0 = calcMatrix.getX(sizeA, -height);
              y0 = calcMatrix.getY(sizeA, -height);
              x1 = calcMatrix.getX(0, sizeB);
              y1 = calcMatrix.getY(0, sizeB);
              x2 = calcMatrix.getX(0, sizeB - height);
              y2 = calcMatrix.getY(0, sizeB - height);
            } else {
              x0 = calcMatrix.getX(sizeA, 0);
              y0 = calcMatrix.getY(sizeA, 0);
              x1 = calcMatrix.getX(0, sizeB);
              y1 = calcMatrix.getY(0, sizeB);
              x2 = calcMatrix.getX(0, sizeB - height);
              y2 = calcMatrix.getY(0, sizeB - height);
            }
            pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2);
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = IsoTriangleWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FillStyleCanvas = __webpack_require__(48);
        var SetTransform = __webpack_require__(30);
        var IsoTriangleCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var ctx = renderer.currentContext;
          if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled) {
            var size = src.width;
            var height = src.height;
            var sizeA = size / 2;
            var sizeB = size / src.projection;
            var reversed = src.isReversed;
            if (src.showTop && reversed) {
              FillStyleCanvas(ctx, src, src.fillTop);
              ctx.beginPath();
              ctx.moveTo(-sizeA, -height);
              ctx.lineTo(0, -sizeB - height);
              ctx.lineTo(sizeA, -height);
              ctx.lineTo(0, sizeB - height);
              ctx.fill();
            }
            if (src.showLeft) {
              FillStyleCanvas(ctx, src, src.fillLeft);
              ctx.beginPath();
              if (reversed) {
                ctx.moveTo(-sizeA, -height);
                ctx.lineTo(0, sizeB);
                ctx.lineTo(0, sizeB - height);
              } else {
                ctx.moveTo(-sizeA, 0);
                ctx.lineTo(0, sizeB);
                ctx.lineTo(0, sizeB - height);
              }
              ctx.fill();
            }
            if (src.showRight) {
              FillStyleCanvas(ctx, src, src.fillRight);
              ctx.beginPath();
              if (reversed) {
                ctx.moveTo(sizeA, -height);
                ctx.lineTo(0, sizeB);
                ctx.lineTo(0, sizeB - height);
              } else {
                ctx.moveTo(sizeA, 0);
                ctx.lineTo(0, sizeB);
                ctx.lineTo(0, sizeB - height);
              }
              ctx.fill();
            }
            ctx.restore();
          }
        };
        module2.exports = IsoTriangleCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1116);
        }
        {
          renderCanvas = __webpack_require__(1117);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCalcMatrix = __webpack_require__(19);
        var Utils = __webpack_require__(12);
        var LineWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline);
          var result = GetCalcMatrix(src, camera, parentMatrix);
          pipeline.calcMatrix.copyFrom(result.calc);
          var dx = src._displayOriginX;
          var dy = src._displayOriginY;
          var alpha = camera.alpha * src.alpha;
          renderer.pipelines.preBatch(src);
          if (src.isStroked) {
            var strokeTint = pipeline.strokeTint;
            var color = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
            strokeTint.TL = color;
            strokeTint.TR = color;
            strokeTint.BL = color;
            strokeTint.BR = color;
            var startWidth = src._startWidth;
            var endWidth = src._endWidth;
            pipeline.batchLine(src.geom.x1 - dx, src.geom.y1 - dy, src.geom.x2 - dx, src.geom.y2 - dy, startWidth, endWidth, 1, 0, false, result.sprite, result.camera);
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = LineWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var LineStyleCanvas = __webpack_require__(60);
        var SetTransform = __webpack_require__(30);
        var LineCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var ctx = renderer.currentContext;
          if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            if (src.isStroked) {
              LineStyleCanvas(ctx, src);
              ctx.beginPath();
              ctx.moveTo(src.geom.x1 - dx, src.geom.y1 - dy);
              ctx.lineTo(src.geom.x2 - dx, src.geom.y2 - dy);
              ctx.stroke();
            }
            ctx.restore();
          }
        };
        module2.exports = LineCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1119);
        }
        {
          renderCanvas = __webpack_require__(1120);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FillPathWebGL = __webpack_require__(114);
        var GetCalcMatrix = __webpack_require__(19);
        var StrokePathWebGL = __webpack_require__(81);
        var PolygonWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline);
          var result = GetCalcMatrix(src, camera, parentMatrix);
          var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
          var dx = src._displayOriginX;
          var dy = src._displayOriginY;
          var alpha = camera.alpha * src.alpha;
          renderer.pipelines.preBatch(src);
          if (src.isFilled) {
            FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
          }
          if (src.isStroked) {
            StrokePathWebGL(pipeline, src, alpha, dx, dy);
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = PolygonWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FillStyleCanvas = __webpack_require__(48);
        var LineStyleCanvas = __webpack_require__(60);
        var SetTransform = __webpack_require__(30);
        var PolygonCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var ctx = renderer.currentContext;
          if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var path = src.pathData;
            var pathLength = path.length - 1;
            var px1 = path[0] - dx;
            var py1 = path[1] - dy;
            ctx.beginPath();
            ctx.moveTo(px1, py1);
            if (!src.closePath) {
              pathLength -= 2;
            }
            for (var i2 = 2; i2 < pathLength; i2 += 2) {
              var px2 = path[i2] - dx;
              var py2 = path[i2 + 1] - dy;
              ctx.lineTo(px2, py2);
            }
            ctx.closePath();
            if (src.isFilled) {
              FillStyleCanvas(ctx, src);
              ctx.fill();
            }
            if (src.isStroked) {
              LineStyleCanvas(ctx, src);
              ctx.stroke();
            }
            ctx.restore();
          }
        };
        module2.exports = PolygonCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1122);
        }
        {
          renderCanvas = __webpack_require__(1123);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCalcMatrix = __webpack_require__(19);
        var StrokePathWebGL = __webpack_require__(81);
        var Utils = __webpack_require__(12);
        var RectangleWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline);
          var result = GetCalcMatrix(src, camera, parentMatrix);
          pipeline.calcMatrix.copyFrom(result.calc);
          var dx = src._displayOriginX;
          var dy = src._displayOriginY;
          var alpha = camera.alpha * src.alpha;
          renderer.pipelines.preBatch(src);
          if (src.isFilled) {
            var fillTint = pipeline.fillTint;
            var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
            fillTint.TL = fillTintColor;
            fillTint.TR = fillTintColor;
            fillTint.BL = fillTintColor;
            fillTint.BR = fillTintColor;
            pipeline.batchFillRect(-dx, -dy, src.width, src.height);
          }
          if (src.isStroked) {
            StrokePathWebGL(pipeline, src, alpha, dx, dy);
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = RectangleWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FillStyleCanvas = __webpack_require__(48);
        var LineStyleCanvas = __webpack_require__(60);
        var SetTransform = __webpack_require__(30);
        var RectangleCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var ctx = renderer.currentContext;
          if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            if (src.isFilled) {
              FillStyleCanvas(ctx, src);
              ctx.fillRect(-dx, -dy, src.width, src.height);
            }
            if (src.isStroked) {
              LineStyleCanvas(ctx, src);
              ctx.beginPath();
              ctx.rect(-dx, -dy, src.width, src.height);
              ctx.stroke();
            }
            ctx.restore();
          }
        };
        module2.exports = RectangleCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1125);
        }
        {
          renderCanvas = __webpack_require__(1126);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FillPathWebGL = __webpack_require__(114);
        var GetCalcMatrix = __webpack_require__(19);
        var StrokePathWebGL = __webpack_require__(81);
        var StarWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline);
          var result = GetCalcMatrix(src, camera, parentMatrix);
          var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
          var dx = src._displayOriginX;
          var dy = src._displayOriginY;
          var alpha = camera.alpha * src.alpha;
          renderer.pipelines.preBatch(src);
          if (src.isFilled) {
            FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
          }
          if (src.isStroked) {
            StrokePathWebGL(pipeline, src, alpha, dx, dy);
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = StarWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FillStyleCanvas = __webpack_require__(48);
        var LineStyleCanvas = __webpack_require__(60);
        var SetTransform = __webpack_require__(30);
        var StarCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var ctx = renderer.currentContext;
          if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var path = src.pathData;
            var pathLength = path.length - 1;
            var px1 = path[0] - dx;
            var py1 = path[1] - dy;
            ctx.beginPath();
            ctx.moveTo(px1, py1);
            if (!src.closePath) {
              pathLength -= 2;
            }
            for (var i2 = 2; i2 < pathLength; i2 += 2) {
              var px2 = path[i2] - dx;
              var py2 = path[i2 + 1] - dy;
              ctx.lineTo(px2, py2);
            }
            ctx.closePath();
            if (src.isFilled) {
              FillStyleCanvas(ctx, src);
              ctx.fill();
            }
            if (src.isStroked) {
              LineStyleCanvas(ctx, src);
              ctx.stroke();
            }
            ctx.restore();
          }
        };
        module2.exports = StarCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1128);
        }
        {
          renderCanvas = __webpack_require__(1129);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCalcMatrix = __webpack_require__(19);
        var StrokePathWebGL = __webpack_require__(81);
        var Utils = __webpack_require__(12);
        var TriangleWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline);
          var result = GetCalcMatrix(src, camera, parentMatrix);
          pipeline.calcMatrix.copyFrom(result.calc);
          var dx = src._displayOriginX;
          var dy = src._displayOriginY;
          var alpha = camera.alpha * src.alpha;
          renderer.pipelines.preBatch(src);
          if (src.isFilled) {
            var fillTint = pipeline.fillTint;
            var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
            fillTint.TL = fillTintColor;
            fillTint.TR = fillTintColor;
            fillTint.BL = fillTintColor;
            fillTint.BR = fillTintColor;
            var x1 = src.geom.x1 - dx;
            var y1 = src.geom.y1 - dy;
            var x2 = src.geom.x2 - dx;
            var y2 = src.geom.y2 - dy;
            var x3 = src.geom.x3 - dx;
            var y3 = src.geom.y3 - dy;
            pipeline.batchFillTriangle(x1, y1, x2, y2, x3, y3, result.sprite, result.camera);
          }
          if (src.isStroked) {
            StrokePathWebGL(pipeline, src, alpha, dx, dy);
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = TriangleWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FillStyleCanvas = __webpack_require__(48);
        var LineStyleCanvas = __webpack_require__(60);
        var SetTransform = __webpack_require__(30);
        var TriangleCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var ctx = renderer.currentContext;
          if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var x1 = src.geom.x1 - dx;
            var y1 = src.geom.y1 - dy;
            var x2 = src.geom.x2 - dx;
            var y2 = src.geom.y2 - dy;
            var x3 = src.geom.x3 - dx;
            var y3 = src.geom.y3 - dy;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.closePath();
            if (src.isFilled) {
              FillStyleCanvas(ctx, src);
              ctx.fill();
            }
            if (src.isStroked) {
              LineStyleCanvas(ctx, src);
              ctx.stroke();
            }
            ctx.restore();
          }
        };
        module2.exports = TriangleCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Blitter = __webpack_require__(213);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("blitter", function(x2, y2, key, frame) {
          return this.displayList.add(new Blitter(this.scene, x2, y2, key, frame));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Felipe Alfonso <@bitnenfer>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Container = __webpack_require__(214);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("container", function(x2, y2, children) {
          return this.displayList.add(new Container(this.scene, x2, y2, children));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DOMElement = __webpack_require__(442);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("dom", function(x2, y2, element, style, innerText) {
          var gameObject = new DOMElement(this.scene, x2, y2, element, style, innerText);
          this.displayList.add(gameObject);
          return gameObject;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DynamicBitmapText = __webpack_require__(215);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("dynamicBitmapText", function(x2, y2, font, text, size) {
          return this.displayList.add(new DynamicBitmapText(this.scene, x2, y2, font, text, size));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Extern = __webpack_require__(444);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("extern", function() {
          var extern = new Extern(this.scene);
          this.displayList.add(extern);
          return extern;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Graphics = __webpack_require__(216);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("graphics", function(config) {
          return this.displayList.add(new Graphics(this.scene, config));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Group = __webpack_require__(113);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("group", function(children, config) {
          return this.updateList.add(new Group(this.scene, children, config));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Image2 = __webpack_require__(125);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("image", function(x2, y2, key, frame) {
          return this.displayList.add(new Image2(this.scene, x2, y2, key, frame));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Layer = __webpack_require__(219);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("layer", function(children) {
          return this.displayList.add(new Layer(this.scene, children));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectFactory = __webpack_require__(5);
        var ParticleEmitterManager = __webpack_require__(220);
        GameObjectFactory.register("particles", function(key, frame, emitters) {
          return this.displayList.add(new ParticleEmitterManager(this.scene, key, frame, emitters));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectFactory = __webpack_require__(5);
        var PathFollower = __webpack_require__(457);
        GameObjectFactory.register("follower", function(path, x2, y2, key, frame) {
          var sprite = new PathFollower(this.scene, path, x2, y2, key, frame);
          this.displayList.add(sprite);
          this.updateList.add(sprite);
          return sprite;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectFactory = __webpack_require__(5);
        var RenderTexture = __webpack_require__(221);
        GameObjectFactory.register("renderTexture", function(x2, y2, width, height, key, frame) {
          return this.displayList.add(new RenderTexture(this.scene, x2, y2, width, height, key, frame));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rope = __webpack_require__(223);
        var GameObjectFactory = __webpack_require__(5);
        {
          GameObjectFactory.register("rope", function(x2, y2, texture, frame, points, horizontal, colors, alphas) {
            return this.displayList.add(new Rope(this.scene, x2, y2, texture, frame, points, horizontal, colors, alphas));
          });
        }
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectFactory = __webpack_require__(5);
        var Sprite = __webpack_require__(73);
        GameObjectFactory.register("sprite", function(x2, y2, key, frame) {
          var sprite = new Sprite(this.scene, x2, y2, key, frame);
          this.displayList.add(sprite);
          return sprite;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BitmapText = __webpack_require__(148);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("bitmapText", function(x2, y2, font, text, size, align) {
          return this.displayList.add(new BitmapText(this.scene, x2, y2, font, text, size, align));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Text = __webpack_require__(224);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("text", function(x2, y2, text, style) {
          return this.displayList.add(new Text(this.scene, x2, y2, text, style));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TileSprite = __webpack_require__(225);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("tileSprite", function(x2, y2, width, height, key, frame) {
          return this.displayList.add(new TileSprite(this.scene, x2, y2, width, height, key, frame));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Zone = __webpack_require__(129);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("zone", function(x2, y2, width, height) {
          return this.displayList.add(new Zone(this.scene, x2, y2, width, height));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Video = __webpack_require__(226);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("video", function(x2, y2, key) {
          return this.displayList.add(new Video(this.scene, x2, y2, key));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Arc = __webpack_require__(461);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("arc", function(x2, y2, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha) {
          return this.displayList.add(new Arc(this.scene, x2, y2, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha));
        });
        GameObjectFactory.register("circle", function(x2, y2, radius, fillColor, fillAlpha) {
          return this.displayList.add(new Arc(this.scene, x2, y2, radius, 0, 360, false, fillColor, fillAlpha));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectFactory = __webpack_require__(5);
        var Curve = __webpack_require__(462);
        GameObjectFactory.register("curve", function(x2, y2, curve, fillColor, fillAlpha) {
          return this.displayList.add(new Curve(this.scene, x2, y2, curve, fillColor, fillAlpha));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Ellipse = __webpack_require__(463);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("ellipse", function(x2, y2, width, height, fillColor, fillAlpha) {
          return this.displayList.add(new Ellipse(this.scene, x2, y2, width, height, fillColor, fillAlpha));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectFactory = __webpack_require__(5);
        var Grid = __webpack_require__(464);
        GameObjectFactory.register("grid", function(x2, y2, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha) {
          return this.displayList.add(new Grid(this.scene, x2, y2, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectFactory = __webpack_require__(5);
        var IsoBox = __webpack_require__(465);
        GameObjectFactory.register("isobox", function(x2, y2, size, height, fillTop, fillLeft, fillRight) {
          return this.displayList.add(new IsoBox(this.scene, x2, y2, size, height, fillTop, fillLeft, fillRight));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectFactory = __webpack_require__(5);
        var IsoTriangle = __webpack_require__(466);
        GameObjectFactory.register("isotriangle", function(x2, y2, size, height, reversed, fillTop, fillLeft, fillRight) {
          return this.displayList.add(new IsoTriangle(this.scene, x2, y2, size, height, reversed, fillTop, fillLeft, fillRight));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectFactory = __webpack_require__(5);
        var Line = __webpack_require__(467);
        GameObjectFactory.register("line", function(x2, y2, x1, y1, x22, y22, strokeColor, strokeAlpha) {
          return this.displayList.add(new Line(this.scene, x2, y2, x1, y1, x22, y22, strokeColor, strokeAlpha));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectFactory = __webpack_require__(5);
        var Polygon = __webpack_require__(468);
        GameObjectFactory.register("polygon", function(x2, y2, points, fillColor, fillAlpha) {
          return this.displayList.add(new Polygon(this.scene, x2, y2, points, fillColor, fillAlpha));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectFactory = __webpack_require__(5);
        var Rectangle = __webpack_require__(473);
        GameObjectFactory.register("rectangle", function(x2, y2, width, height, fillColor, fillAlpha) {
          return this.displayList.add(new Rectangle(this.scene, x2, y2, width, height, fillColor, fillAlpha));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Star = __webpack_require__(474);
        var GameObjectFactory = __webpack_require__(5);
        GameObjectFactory.register("star", function(x2, y2, points, innerRadius, outerRadius, fillColor, fillAlpha) {
          return this.displayList.add(new Star(this.scene, x2, y2, points, innerRadius, outerRadius, fillColor, fillAlpha));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectFactory = __webpack_require__(5);
        var Triangle = __webpack_require__(475);
        GameObjectFactory.register("triangle", function(x2, y2, x1, y1, x22, y22, x3, y3, fillColor, fillAlpha) {
          return this.displayList.add(new Triangle(this.scene, x2, y2, x1, y1, x22, y22, x3, y3, fillColor, fillAlpha));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Blitter = __webpack_require__(213);
        var BuildGameObject = __webpack_require__(28);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        GameObjectCreator.register("blitter", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var key = GetAdvancedValue(config, "key", null);
          var frame = GetAdvancedValue(config, "frame", null);
          var blitter = new Blitter(this.scene, 0, 0, key, frame);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, blitter, config);
          return blitter;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Felipe Alfonso <@bitnenfer>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BuildGameObject = __webpack_require__(28);
        var Container = __webpack_require__(214);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        GameObjectCreator.register("container", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var x2 = GetAdvancedValue(config, "x", 0);
          var y2 = GetAdvancedValue(config, "y", 0);
          var children = GetAdvancedValue(config, "children", null);
          var container = new Container(this.scene, x2, y2, children);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, container, config);
          return container;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BitmapText = __webpack_require__(215);
        var BuildGameObject = __webpack_require__(28);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        GameObjectCreator.register("dynamicBitmapText", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var font = GetAdvancedValue(config, "font", "");
          var text = GetAdvancedValue(config, "text", "");
          var size = GetAdvancedValue(config, "size", false);
          var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, bitmapText, config);
          return bitmapText;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectCreator = __webpack_require__(16);
        var Graphics = __webpack_require__(216);
        GameObjectCreator.register("graphics", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          var graphics = new Graphics(this.scene, config);
          if (config.add) {
            this.scene.sys.displayList.add(graphics);
          }
          return graphics;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectCreator = __webpack_require__(16);
        var Group = __webpack_require__(113);
        GameObjectCreator.register("group", function(config) {
          return new Group(this.scene, null, config);
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BuildGameObject = __webpack_require__(28);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        var Image2 = __webpack_require__(125);
        GameObjectCreator.register("image", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var key = GetAdvancedValue(config, "key", null);
          var frame = GetAdvancedValue(config, "frame", null);
          var image = new Image2(this.scene, 0, 0, key, frame);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, image, config);
          return image;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BuildGameObject = __webpack_require__(28);
        var Layer = __webpack_require__(219);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        GameObjectCreator.register("layer", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var children = GetAdvancedValue(config, "children", null);
          var layer = new Layer(this.scene, children);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, layer, config);
          return layer;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        var GetFastValue = __webpack_require__(2);
        var ParticleEmitterManager = __webpack_require__(220);
        GameObjectCreator.register("particles", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var key = GetAdvancedValue(config, "key", null);
          var frame = GetAdvancedValue(config, "frame", null);
          var emitters = GetFastValue(config, "emitters", null);
          var manager = new ParticleEmitterManager(this.scene, key, frame, emitters);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          var add = GetFastValue(config, "add", false);
          if (add) {
            this.displayList.add(manager);
          } else {
            this.updateList.add(manager);
          }
          return manager;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BuildGameObject = __webpack_require__(28);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        var RenderTexture = __webpack_require__(221);
        GameObjectCreator.register("renderTexture", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var x2 = GetAdvancedValue(config, "x", 0);
          var y2 = GetAdvancedValue(config, "y", 0);
          var width = GetAdvancedValue(config, "width", 32);
          var height = GetAdvancedValue(config, "height", 32);
          var key = GetAdvancedValue(config, "key", void 0);
          var frame = GetAdvancedValue(config, "frame", void 0);
          var renderTexture = new RenderTexture(this.scene, x2, y2, width, height, key, frame);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, renderTexture, config);
          return renderTexture;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BuildGameObject = __webpack_require__(28);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        var GetValue = __webpack_require__(6);
        var Rope = __webpack_require__(223);
        GameObjectCreator.register("rope", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var key = GetAdvancedValue(config, "key", null);
          var frame = GetAdvancedValue(config, "frame", null);
          var horizontal = GetAdvancedValue(config, "horizontal", true);
          var points = GetValue(config, "points", void 0);
          var colors = GetValue(config, "colors", void 0);
          var alphas = GetValue(config, "alphas", void 0);
          var rope = new Rope(this.scene, 0, 0, key, frame, points, horizontal, colors, alphas);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, rope, config);
          if (!config.add) {
            this.updateList.add(rope);
          }
          return rope;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BuildGameObject = __webpack_require__(28);
        var BuildGameObjectAnimation = __webpack_require__(439);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        var Sprite = __webpack_require__(73);
        GameObjectCreator.register("sprite", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var key = GetAdvancedValue(config, "key", null);
          var frame = GetAdvancedValue(config, "frame", null);
          var sprite = new Sprite(this.scene, 0, 0, key, frame);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, sprite, config);
          BuildGameObjectAnimation(sprite, config);
          return sprite;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BitmapText = __webpack_require__(148);
        var BuildGameObject = __webpack_require__(28);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        var GetValue = __webpack_require__(6);
        GameObjectCreator.register("bitmapText", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var font = GetValue(config, "font", "");
          var text = GetAdvancedValue(config, "text", "");
          var size = GetAdvancedValue(config, "size", false);
          var align = GetValue(config, "align", 0);
          var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size, align);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, bitmapText, config);
          return bitmapText;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BuildGameObject = __webpack_require__(28);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        var Text = __webpack_require__(224);
        GameObjectCreator.register("text", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var content = GetAdvancedValue(config, "text", "");
          var style = GetAdvancedValue(config, "style", null);
          var padding = GetAdvancedValue(config, "padding", null);
          if (padding !== null) {
            style.padding = padding;
          }
          var text = new Text(this.scene, 0, 0, content, style);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, text, config);
          text.autoRound = GetAdvancedValue(config, "autoRound", true);
          text.resolution = GetAdvancedValue(config, "resolution", 1);
          return text;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BuildGameObject = __webpack_require__(28);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        var TileSprite = __webpack_require__(225);
        GameObjectCreator.register("tileSprite", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var x2 = GetAdvancedValue(config, "x", 0);
          var y2 = GetAdvancedValue(config, "y", 0);
          var width = GetAdvancedValue(config, "width", 512);
          var height = GetAdvancedValue(config, "height", 512);
          var key = GetAdvancedValue(config, "key", "");
          var frame = GetAdvancedValue(config, "frame", "");
          var tile = new TileSprite(this.scene, x2, y2, width, height, key, frame);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, tile, config);
          return tile;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        var Zone = __webpack_require__(129);
        GameObjectCreator.register("zone", function(config) {
          var x2 = GetAdvancedValue(config, "x", 0);
          var y2 = GetAdvancedValue(config, "y", 0);
          var width = GetAdvancedValue(config, "width", 1);
          var height = GetAdvancedValue(config, "height", width);
          return new Zone(this.scene, x2, y2, width, height);
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BuildGameObject = __webpack_require__(28);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        var Video = __webpack_require__(226);
        GameObjectCreator.register("video", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var key = GetAdvancedValue(config, "key", null);
          var video = new Video(this.scene, 0, 0, key);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, video, config);
          if (!config.add) {
            this.updateList.add(video);
          }
          return video;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1177);
        }
        {
          renderCanvas = __webpack_require__(1178);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCalcMatrix = __webpack_require__(19);
        var ShaderWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          if (!src.shader) {
            return;
          }
          camera.addToRenderList(src);
          renderer.pipelines.clear();
          if (src.renderToTexture) {
            src.load();
            src.flush();
          } else {
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            if (renderer.width !== src._rendererWidth || renderer.height !== src._rendererHeight) {
              src.projOrtho(0, renderer.width, renderer.height, 0);
            }
            src.load(calcMatrix.matrix);
            src.flush();
          }
          renderer.pipelines.rebind();
        };
        module2.exports = ShaderWebGLRenderer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ShaderCanvasRenderer = function() {
        };
        module2.exports = ShaderCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1180);
        }
        {
          renderCanvas = __webpack_require__(1181);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCalcMatrix = __webpack_require__(19);
        var MeshWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          var faces = src.faces;
          var totalFaces = faces.length;
          if (totalFaces === 0) {
            return;
          }
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline, src);
          var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
          var textureUnit = pipeline.setGameObject(src);
          var F32 = pipeline.vertexViewF32;
          var U32 = pipeline.vertexViewU32;
          var vertexOffset = pipeline.vertexCount * pipeline.currentShader.vertexComponentCount - 1;
          var tintEffect = src.tintFill;
          var debugFaces = [];
          var debugCallback = src.debugCallback;
          var a = calcMatrix.a;
          var b2 = calcMatrix.b;
          var c = calcMatrix.c;
          var d = calcMatrix.d;
          var e = calcMatrix.e;
          var f2 = calcMatrix.f;
          var z2 = src.viewPosition.z;
          var hideCCW = src.hideCCW;
          var roundPixels = camera.roundPixels;
          var alpha = camera.alpha * src.alpha;
          var totalFacesRendered = 0;
          renderer.pipelines.preBatch(src);
          for (var i2 = 0; i2 < totalFaces; i2++) {
            var face = faces[i2];
            if (!face.isInView(camera, hideCCW, z2, alpha, a, b2, c, d, e, f2, roundPixels)) {
              continue;
            }
            if (pipeline.shouldFlush(3)) {
              pipeline.flush();
              vertexOffset = 0;
            }
            vertexOffset = face.load(F32, U32, vertexOffset, textureUnit, tintEffect);
            totalFacesRendered++;
            pipeline.vertexCount += 3;
            if (debugCallback) {
              debugFaces.push(face);
            }
          }
          src.totalFrame += totalFacesRendered;
          if (debugCallback) {
            debugCallback.call(src, src, debugFaces);
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = MeshWebGLRenderer;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MeshCanvasRenderer = function() {
        };
        module2.exports = MeshCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1183);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetCalcMatrix = __webpack_require__(19);
        var PointLightWebGLRenderer = function(renderer, src, camera, parentMatrix) {
          camera.addToRenderList(src);
          var pipeline = renderer.pipelines.set(src.pipeline);
          var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
          var width = src.width;
          var height = src.height;
          var x2 = -src._radius;
          var y2 = -src._radius;
          var xw = x2 + width;
          var yh2 = y2 + height;
          var lightX = calcMatrix.getX(0, 0);
          var lightY = calcMatrix.getY(0, 0);
          var tx0 = calcMatrix.getX(x2, y2);
          var ty0 = calcMatrix.getY(x2, y2);
          var tx1 = calcMatrix.getX(x2, yh2);
          var ty1 = calcMatrix.getY(x2, yh2);
          var tx2 = calcMatrix.getX(xw, yh2);
          var ty2 = calcMatrix.getY(xw, yh2);
          var tx3 = calcMatrix.getX(xw, y2);
          var ty3 = calcMatrix.getY(xw, y2);
          renderer.pipelines.preBatch(src);
          pipeline.batchPointLight(src, camera, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, lightX, lightY);
          renderer.pipelines.postBatch(src);
        };
        module2.exports = PointLightWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Shader = __webpack_require__(229);
        var GameObjectFactory = __webpack_require__(5);
        {
          GameObjectFactory.register("shader", function(key, x2, y2, width, height, textures, textureData) {
            return this.displayList.add(new Shader(this.scene, key, x2, y2, width, height, textures, textureData));
          });
        }
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Mesh = __webpack_require__(230);
        var GameObjectFactory = __webpack_require__(5);
        {
          GameObjectFactory.register("mesh", function(x2, y2, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas) {
            return this.displayList.add(new Mesh(this.scene, x2, y2, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas));
          });
        }
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectFactory = __webpack_require__(5);
        var PointLight = __webpack_require__(150);
        GameObjectFactory.register("pointlight", function(x2, y2, color, radius, intensity, attenuation) {
          return this.displayList.add(new PointLight(this.scene, x2, y2, color, radius, intensity, attenuation));
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BuildGameObject = __webpack_require__(28);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        var Shader = __webpack_require__(229);
        GameObjectCreator.register("shader", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var key = GetAdvancedValue(config, "key", null);
          var x2 = GetAdvancedValue(config, "x", 0);
          var y2 = GetAdvancedValue(config, "y", 0);
          var width = GetAdvancedValue(config, "width", 128);
          var height = GetAdvancedValue(config, "height", 128);
          var shader = new Shader(this.scene, key, x2, y2, width, height);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, shader, config);
          return shader;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BuildGameObject = __webpack_require__(28);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        var GetValue = __webpack_require__(6);
        var Mesh = __webpack_require__(230);
        GameObjectCreator.register("mesh", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var key = GetAdvancedValue(config, "key", null);
          var frame = GetAdvancedValue(config, "frame", null);
          var vertices = GetValue(config, "vertices", []);
          var uvs = GetValue(config, "uvs", []);
          var indicies = GetValue(config, "indicies", []);
          var containsZ = GetValue(config, "containsZ", false);
          var normals = GetValue(config, "normals", []);
          var colors = GetValue(config, "colors", 16777215);
          var alphas = GetValue(config, "alphas", 1);
          var mesh = new Mesh(this.scene, 0, 0, key, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, mesh, config);
          return mesh;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var BuildGameObject = __webpack_require__(28);
        var GameObjectCreator = __webpack_require__(16);
        var GetAdvancedValue = __webpack_require__(13);
        var PointLight = __webpack_require__(150);
        GameObjectCreator.register("pointlight", function(config, addToScene) {
          if (config === void 0) {
            config = {};
          }
          var color = GetAdvancedValue(config, "color", 16777215);
          var radius = GetAdvancedValue(config, "radius", 128);
          var intensity = GetAdvancedValue(config, "intensity", 1);
          var attenuation = GetAdvancedValue(config, "attenuation", 0.1);
          var layer = new PointLight(this.scene, 0, 0, color, radius, intensity, attenuation);
          if (addToScene !== void 0) {
            config.add = addToScene;
          }
          BuildGameObject(this.scene, layer, config);
          return layer;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var LightsManager = __webpack_require__(482);
        var PluginCache = __webpack_require__(24);
        var SceneEvents = __webpack_require__(20);
        var LightsPlugin = new Class({
          Extends: LightsManager,
          initialize: function LightsPlugin2(scene) {
            this.scene = scene;
            this.systems = scene.sys;
            if (!scene.sys.settings.isBooted) {
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
            }
            LightsManager.call(this);
          },
          boot: function() {
            var eventEmitter = this.systems.events;
            eventEmitter.on(SceneEvents.SHUTDOWN, this.shutdown, this);
            eventEmitter.on(SceneEvents.DESTROY, this.destroy, this);
          },
          destroy: function() {
            this.shutdown();
            this.scene = void 0;
            this.systems = void 0;
          }
        });
        PluginCache.register("LightsPlugin", LightsPlugin, "lights");
        module2.exports = LightsPlugin;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Circle = __webpack_require__(65);
        Circle.Area = __webpack_require__(1192);
        Circle.Circumference = __webpack_require__(302);
        Circle.CircumferencePoint = __webpack_require__(169);
        Circle.Clone = __webpack_require__(1193);
        Circle.Contains = __webpack_require__(66);
        Circle.ContainsPoint = __webpack_require__(1194);
        Circle.ContainsRect = __webpack_require__(1195);
        Circle.CopyFrom = __webpack_require__(1196);
        Circle.Equals = __webpack_require__(1197);
        Circle.GetBounds = __webpack_require__(1198);
        Circle.GetPoint = __webpack_require__(300);
        Circle.GetPoints = __webpack_require__(301);
        Circle.Offset = __webpack_require__(1199);
        Circle.OffsetPoint = __webpack_require__(1200);
        Circle.Random = __webpack_require__(170);
        module2.exports = Circle;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Area = function(circle) {
          return circle.radius > 0 ? Math.PI * circle.radius * circle.radius : 0;
        };
        module2.exports = Area;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Circle = __webpack_require__(65);
        var Clone = function(source) {
          return new Circle(source.x, source.y, source.radius);
        };
        module2.exports = Clone;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Contains = __webpack_require__(66);
        var ContainsPoint = function(circle, point) {
          return Contains(circle, point.x, point.y);
        };
        module2.exports = ContainsPoint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Contains = __webpack_require__(66);
        var ContainsRect = function(circle, rect) {
          return Contains(circle, rect.x, rect.y) && Contains(circle, rect.right, rect.y) && Contains(circle, rect.x, rect.bottom) && Contains(circle, rect.right, rect.bottom);
        };
        module2.exports = ContainsRect;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CopyFrom = function(source, dest) {
          return dest.setTo(source.x, source.y, source.radius);
        };
        module2.exports = CopyFrom;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Equals = function(circle, toCompare) {
          return circle.x === toCompare.x && circle.y === toCompare.y && circle.radius === toCompare.radius;
        };
        module2.exports = Equals;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rectangle = __webpack_require__(10);
        var GetBounds = function(circle, out) {
          if (out === void 0) {
            out = new Rectangle();
          }
          out.x = circle.left;
          out.y = circle.top;
          out.width = circle.diameter;
          out.height = circle.diameter;
          return out;
        };
        module2.exports = GetBounds;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Offset = function(circle, x2, y2) {
          circle.x += x2;
          circle.y += y2;
          return circle;
        };
        module2.exports = Offset;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var OffsetPoint = function(circle, point) {
          circle.x += point.x;
          circle.y += point.y;
          return circle;
        };
        module2.exports = OffsetPoint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Ellipse = __webpack_require__(111);
        Ellipse.Area = __webpack_require__(1202);
        Ellipse.Circumference = __webpack_require__(447);
        Ellipse.CircumferencePoint = __webpack_require__(218);
        Ellipse.Clone = __webpack_require__(1203);
        Ellipse.Contains = __webpack_require__(112);
        Ellipse.ContainsPoint = __webpack_require__(1204);
        Ellipse.ContainsRect = __webpack_require__(1205);
        Ellipse.CopyFrom = __webpack_require__(1206);
        Ellipse.Equals = __webpack_require__(1207);
        Ellipse.GetBounds = __webpack_require__(1208);
        Ellipse.GetPoint = __webpack_require__(445);
        Ellipse.GetPoints = __webpack_require__(446);
        Ellipse.Offset = __webpack_require__(1209);
        Ellipse.OffsetPoint = __webpack_require__(1210);
        Ellipse.Random = __webpack_require__(180);
        module2.exports = Ellipse;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Area = function(ellipse) {
          if (ellipse.isEmpty()) {
            return 0;
          }
          return ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI;
        };
        module2.exports = Area;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Ellipse = __webpack_require__(111);
        var Clone = function(source) {
          return new Ellipse(source.x, source.y, source.width, source.height);
        };
        module2.exports = Clone;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Contains = __webpack_require__(112);
        var ContainsPoint = function(ellipse, point) {
          return Contains(ellipse, point.x, point.y);
        };
        module2.exports = ContainsPoint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Contains = __webpack_require__(112);
        var ContainsRect = function(ellipse, rect) {
          return Contains(ellipse, rect.x, rect.y) && Contains(ellipse, rect.right, rect.y) && Contains(ellipse, rect.x, rect.bottom) && Contains(ellipse, rect.right, rect.bottom);
        };
        module2.exports = ContainsRect;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CopyFrom = function(source, dest) {
          return dest.setTo(source.x, source.y, source.width, source.height);
        };
        module2.exports = CopyFrom;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Equals = function(ellipse, toCompare) {
          return ellipse.x === toCompare.x && ellipse.y === toCompare.y && ellipse.width === toCompare.width && ellipse.height === toCompare.height;
        };
        module2.exports = Equals;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rectangle = __webpack_require__(10);
        var GetBounds = function(ellipse, out) {
          if (out === void 0) {
            out = new Rectangle();
          }
          out.x = ellipse.left;
          out.y = ellipse.top;
          out.width = ellipse.width;
          out.height = ellipse.height;
          return out;
        };
        module2.exports = GetBounds;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Offset = function(ellipse, x2, y2) {
          ellipse.x += x2;
          ellipse.y += y2;
          return ellipse;
        };
        module2.exports = Offset;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var OffsetPoint = function(ellipse, point) {
          ellipse.x += point.x;
          ellipse.y += point.y;
          return ellipse;
        };
        module2.exports = OffsetPoint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Florian Vazelle
         * @author       Geoffrey Glaive
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var CircleToCircle = __webpack_require__(231);
        var GetCircleToCircle = function(circleA, circleB, out) {
          if (out === void 0) {
            out = [];
          }
          if (CircleToCircle(circleA, circleB)) {
            var x0 = circleA.x;
            var y0 = circleA.y;
            var r0 = circleA.radius;
            var x1 = circleB.x;
            var y1 = circleB.y;
            var r1 = circleB.radius;
            var coefficientA, coefficientB, coefficientC, lambda, x2;
            if (y0 === y1) {
              x2 = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0) / (2 * (x0 - x1));
              coefficientA = 1;
              coefficientB = -2 * y1;
              coefficientC = x1 * x1 + x2 * x2 - 2 * x1 * x2 + y1 * y1 - r1 * r1;
              lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
              if (lambda === 0) {
                out.push(new Point(x2, -coefficientB / (2 * coefficientA)));
              } else if (lambda > 0) {
                out.push(new Point(x2, (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA)));
                out.push(new Point(x2, (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA)));
              }
            } else {
              var v1 = (x0 - x1) / (y0 - y1);
              var n2 = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0 - y1 * y1 + y0 * y0) / (2 * (y0 - y1));
              coefficientA = v1 * v1 + 1;
              coefficientB = 2 * y0 * v1 - 2 * n2 * v1 - 2 * x0;
              coefficientC = x0 * x0 + y0 * y0 + n2 * n2 - r0 * r0 - 2 * y0 * n2;
              lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
              if (lambda === 0) {
                x2 = -coefficientB / (2 * coefficientA);
                out.push(new Point(x2, n2 - x2 * v1));
              } else if (lambda > 0) {
                x2 = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);
                out.push(new Point(x2, n2 - x2 * v1));
                x2 = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);
                out.push(new Point(x2, n2 - x2 * v1));
              }
            }
          }
          return out;
        };
        module2.exports = GetCircleToCircle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Florian Vazelle
         * @author       Geoffrey Glaive
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetLineToCircle = __webpack_require__(232);
        var CircleToRectangle = __webpack_require__(151);
        var GetCircleToRectangle = function(circle, rect, out) {
          if (out === void 0) {
            out = [];
          }
          if (CircleToRectangle(circle, rect)) {
            var lineA = rect.getLineA();
            var lineB = rect.getLineB();
            var lineC = rect.getLineC();
            var lineD = rect.getLineD();
            GetLineToCircle(lineA, circle, out);
            GetLineToCircle(lineB, circle, out);
            GetLineToCircle(lineC, circle, out);
            GetLineToCircle(lineD, circle, out);
          }
          return out;
        };
        module2.exports = GetCircleToRectangle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector4 = __webpack_require__(140);
        var GetLineToPolygon = __webpack_require__(487);
        var Line = __webpack_require__(47);
        var segment = new Line();
        function CheckIntersects(angle, x2, y2, polygons, intersects) {
          var dx = Math.cos(angle);
          var dy = Math.sin(angle);
          segment.setTo(x2, y2, x2 + dx, y2 + dy);
          var closestIntersect = GetLineToPolygon(segment, polygons);
          if (closestIntersect) {
            intersects.push(new Vector4(closestIntersect.x, closestIntersect.y, angle, closestIntersect.w));
          }
        }
        function SortIntersects(a, b2) {
          return a.z - b2.z;
        }
        var GetRaysFromPointToPolygon = function(x2, y2, polygons) {
          if (!Array.isArray(polygons)) {
            polygons = [polygons];
          }
          var intersects = [];
          var angles = [];
          for (var i2 = 0; i2 < polygons.length; i2++) {
            var points = polygons[i2].points;
            for (var p2 = 0; p2 < points.length; p2++) {
              var angle = Math.atan2(points[p2].y - y2, points[p2].x - x2);
              if (angles.indexOf(angle) === -1) {
                CheckIntersects(angle, x2, y2, polygons, intersects);
                CheckIntersects(angle - 1e-5, x2, y2, polygons, intersects);
                CheckIntersects(angle + 1e-5, x2, y2, polygons, intersects);
                angles.push(angle);
              }
            }
          }
          return intersects.sort(SortIntersects);
        };
        module2.exports = GetRaysFromPointToPolygon;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rectangle = __webpack_require__(10);
        var RectangleToRectangle = __webpack_require__(152);
        var GetRectangleIntersection = function(rectA, rectB, output) {
          if (output === void 0) {
            output = new Rectangle();
          }
          if (RectangleToRectangle(rectA, rectB)) {
            output.x = Math.max(rectA.x, rectB.x);
            output.y = Math.max(rectA.y, rectB.y);
            output.width = Math.min(rectA.right, rectB.right) - output.x;
            output.height = Math.min(rectA.bottom, rectB.bottom) - output.y;
          }
          return output;
        };
        module2.exports = GetRectangleIntersection;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Florian Vazelle
         * @author       Geoffrey Glaive
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetLineToRectangle = __webpack_require__(234);
        var RectangleToRectangle = __webpack_require__(152);
        var GetRectangleToRectangle = function(rectA, rectB, out) {
          if (out === void 0) {
            out = [];
          }
          if (RectangleToRectangle(rectA, rectB)) {
            var lineA = rectA.getLineA();
            var lineB = rectA.getLineB();
            var lineC = rectA.getLineC();
            var lineD = rectA.getLineD();
            GetLineToRectangle(lineA, rectB, out);
            GetLineToRectangle(lineB, rectB, out);
            GetLineToRectangle(lineC, rectB, out);
            GetLineToRectangle(lineD, rectB, out);
          }
          return out;
        };
        module2.exports = GetRectangleToRectangle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Florian Vazelle
         * @author       Geoffrey Glaive
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RectangleToTriangle = __webpack_require__(489);
        var GetLineToRectangle = __webpack_require__(234);
        var GetRectangleToTriangle = function(rect, triangle, out) {
          if (out === void 0) {
            out = [];
          }
          if (RectangleToTriangle(rect, triangle)) {
            var lineA = triangle.getLineA();
            var lineB = triangle.getLineB();
            var lineC = triangle.getLineC();
            GetLineToRectangle(lineA, rect, out);
            GetLineToRectangle(lineB, rect, out);
            GetLineToRectangle(lineC, rect, out);
          }
          return out;
        };
        module2.exports = GetRectangleToTriangle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Florian Vazelle
         * @author       Geoffrey Glaive
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetLineToCircle = __webpack_require__(232);
        var TriangleToCircle = __webpack_require__(491);
        var GetTriangleToCircle = function(triangle, circle, out) {
          if (out === void 0) {
            out = [];
          }
          if (TriangleToCircle(triangle, circle)) {
            var lineA = triangle.getLineA();
            var lineB = triangle.getLineB();
            var lineC = triangle.getLineC();
            GetLineToCircle(lineA, circle, out);
            GetLineToCircle(lineB, circle, out);
            GetLineToCircle(lineC, circle, out);
          }
          return out;
        };
        module2.exports = GetTriangleToCircle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Florian Vazelle
         * @author       Geoffrey Glaive
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TriangleToTriangle = __webpack_require__(494);
        var GetTriangleToLine = __webpack_require__(492);
        var GetTriangleToTriangle = function(triangleA, triangleB, out) {
          if (out === void 0) {
            out = [];
          }
          if (TriangleToTriangle(triangleA, triangleB)) {
            var lineA = triangleB.getLineA();
            var lineB = triangleB.getLineB();
            var lineC = triangleB.getLineC();
            GetTriangleToLine(triangleA, lineA, out);
            GetTriangleToLine(triangleA, lineB, out);
            GetTriangleToLine(triangleA, lineC, out);
          }
          return out;
        };
        module2.exports = GetTriangleToTriangle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PointToLine = __webpack_require__(496);
        var PointToLineSegment = function(point, line) {
          if (!PointToLine(point, line)) {
            return false;
          }
          var xMin = Math.min(line.x1, line.x2);
          var xMax = Math.max(line.x1, line.x2);
          var yMin = Math.min(line.y1, line.y2);
          var yMax = Math.max(line.y1, line.y2);
          return point.x >= xMin && point.x <= xMax && (point.y >= yMin && point.y <= yMax);
        };
        module2.exports = PointToLineSegment;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RectangleToValues = function(rect, left, right, top, bottom, tolerance) {
          if (tolerance === void 0) {
            tolerance = 0;
          }
          return !(left > rect.right + tolerance || right < rect.left - tolerance || top > rect.bottom + tolerance || bottom < rect.top - tolerance);
        };
        module2.exports = RectangleToValues;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Line = __webpack_require__(47);
        Line.Angle = __webpack_require__(97);
        Line.BresenhamPoints = __webpack_require__(317);
        Line.CenterOn = __webpack_require__(1222);
        Line.Clone = __webpack_require__(1223);
        Line.CopyFrom = __webpack_require__(1224);
        Line.Equals = __webpack_require__(1225);
        Line.Extend = __webpack_require__(1226);
        Line.GetEasedPoints = __webpack_require__(1227);
        Line.GetMidPoint = __webpack_require__(1228);
        Line.GetNearestPoint = __webpack_require__(1229);
        Line.GetNormal = __webpack_require__(1230);
        Line.GetPoint = __webpack_require__(307);
        Line.GetPoints = __webpack_require__(172);
        Line.GetShortestDistance = __webpack_require__(1231);
        Line.Height = __webpack_require__(1232);
        Line.Length = __webpack_require__(67);
        Line.NormalAngle = __webpack_require__(497);
        Line.NormalX = __webpack_require__(1233);
        Line.NormalY = __webpack_require__(1234);
        Line.Offset = __webpack_require__(1235);
        Line.PerpSlope = __webpack_require__(1236);
        Line.Random = __webpack_require__(173);
        Line.ReflectAngle = __webpack_require__(1237);
        Line.Rotate = __webpack_require__(1238);
        Line.RotateAroundPoint = __webpack_require__(1239);
        Line.RotateAroundXY = __webpack_require__(236);
        Line.SetToAngle = __webpack_require__(1240);
        Line.Slope = __webpack_require__(1241);
        Line.Width = __webpack_require__(1242);
        module2.exports = Line;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CenterOn = function(line, x2, y2) {
          var tx = x2 - (line.x1 + line.x2) / 2;
          var ty = y2 - (line.y1 + line.y2) / 2;
          line.x1 += tx;
          line.y1 += ty;
          line.x2 += tx;
          line.y2 += ty;
          return line;
        };
        module2.exports = CenterOn;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Line = __webpack_require__(47);
        var Clone = function(source) {
          return new Line(source.x1, source.y1, source.x2, source.y2);
        };
        module2.exports = Clone;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CopyFrom = function(source, dest) {
          return dest.setTo(source.x1, source.y1, source.x2, source.y2);
        };
        module2.exports = CopyFrom;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Equals = function(line, toCompare) {
          return line.x1 === toCompare.x1 && line.y1 === toCompare.y1 && line.x2 === toCompare.x2 && line.y2 === toCompare.y2;
        };
        module2.exports = Equals;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Length = __webpack_require__(67);
        var Extend = function(line, left, right) {
          if (right === void 0) {
            right = left;
          }
          var length = Length(line);
          var slopX = line.x2 - line.x1;
          var slopY = line.y2 - line.y1;
          if (left) {
            line.x1 = line.x1 - slopX / length * left;
            line.y1 = line.y1 - slopY / length * left;
          }
          if (right) {
            line.x2 = line.x2 + slopX / length * right;
            line.y2 = line.y2 + slopY / length * right;
          }
          return line;
        };
        module2.exports = Extend;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DistanceBetweenPoints = __webpack_require__(352);
        var GetEaseFunction = __webpack_require__(80);
        var Point = __webpack_require__(4);
        var GetEasedPoints = function(line, ease, quantity, collinearThreshold, easeParams) {
          if (collinearThreshold === void 0) {
            collinearThreshold = 0;
          }
          if (easeParams === void 0) {
            easeParams = [];
          }
          var results = [];
          var x1 = line.x1;
          var y1 = line.y1;
          var spaceX = line.x2 - x1;
          var spaceY = line.y2 - y1;
          var easeFunc = GetEaseFunction(ease, easeParams);
          var i2;
          var v2;
          var q2 = quantity - 1;
          for (i2 = 0; i2 < q2; i2++) {
            v2 = easeFunc(i2 / q2);
            results.push(new Point(x1 + spaceX * v2, y1 + spaceY * v2));
          }
          v2 = easeFunc(1);
          results.push(new Point(x1 + spaceX * v2, y1 + spaceY * v2));
          if (collinearThreshold > 0) {
            var prevPoint = results[0];
            var sortedResults = [prevPoint];
            for (i2 = 1; i2 < results.length - 1; i2++) {
              var point = results[i2];
              if (DistanceBetweenPoints(prevPoint, point) >= collinearThreshold) {
                sortedResults.push(point);
                prevPoint = point;
              }
            }
            var endPoint = results[results.length - 1];
            if (DistanceBetweenPoints(prevPoint, endPoint) < collinearThreshold) {
              sortedResults.pop();
            }
            sortedResults.push(endPoint);
            return sortedResults;
          } else {
            return results;
          }
        };
        module2.exports = GetEasedPoints;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var GetMidPoint = function(line, out) {
          if (out === void 0) {
            out = new Point();
          }
          out.x = (line.x1 + line.x2) / 2;
          out.y = (line.y1 + line.y2) / 2;
          return out;
        };
        module2.exports = GetMidPoint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Florian Mertens
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var GetNearestPoint = function(line, point, out) {
          if (out === void 0) {
            out = new Point();
          }
          var x1 = line.x1;
          var y1 = line.y1;
          var x2 = line.x2;
          var y2 = line.y2;
          var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
          if (L2 === 0) {
            return out;
          }
          var r2 = ((point.x - x1) * (x2 - x1) + (point.y - y1) * (y2 - y1)) / L2;
          out.x = x1 + r2 * (x2 - x1);
          out.y = y1 + r2 * (y2 - y1);
          return out;
        };
        module2.exports = GetNearestPoint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MATH_CONST = __webpack_require__(14);
        var Angle = __webpack_require__(97);
        var Point = __webpack_require__(4);
        var GetNormal = function(line, out) {
          if (out === void 0) {
            out = new Point();
          }
          var a = Angle(line) - MATH_CONST.TAU;
          out.x = Math.cos(a);
          out.y = Math.sin(a);
          return out;
        };
        module2.exports = GetNormal;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Florian Mertens
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetShortestDistance = function(line, point) {
          var x1 = line.x1;
          var y1 = line.y1;
          var x2 = line.x2;
          var y2 = line.y2;
          var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
          if (L2 === 0) {
            return false;
          }
          var s = ((y1 - point.y) * (x2 - x1) - (x1 - point.x) * (y2 - y1)) / L2;
          return Math.abs(s) * Math.sqrt(L2);
        };
        module2.exports = GetShortestDistance;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Height = function(line) {
          return Math.abs(line.y1 - line.y2);
        };
        module2.exports = Height;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MATH_CONST = __webpack_require__(14);
        var Angle = __webpack_require__(97);
        var NormalX = function(line) {
          return Math.cos(Angle(line) - MATH_CONST.TAU);
        };
        module2.exports = NormalX;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MATH_CONST = __webpack_require__(14);
        var Angle = __webpack_require__(97);
        var NormalY = function(line) {
          return Math.sin(Angle(line) - MATH_CONST.TAU);
        };
        module2.exports = NormalY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Offset = function(line, x2, y2) {
          line.x1 += x2;
          line.y1 += y2;
          line.x2 += x2;
          line.y2 += y2;
          return line;
        };
        module2.exports = Offset;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PerpSlope = function(line) {
          return -((line.x2 - line.x1) / (line.y2 - line.y1));
        };
        module2.exports = PerpSlope;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Angle = __webpack_require__(97);
        var NormalAngle = __webpack_require__(497);
        var ReflectAngle = function(lineA, lineB) {
          return 2 * NormalAngle(lineB) - Math.PI - Angle(lineA);
        };
        module2.exports = ReflectAngle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateAroundXY = __webpack_require__(236);
        var Rotate = function(line, angle) {
          var x2 = (line.x1 + line.x2) / 2;
          var y2 = (line.y1 + line.y2) / 2;
          return RotateAroundXY(line, x2, y2, angle);
        };
        module2.exports = Rotate;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateAroundXY = __webpack_require__(236);
        var RotateAroundPoint = function(line, point, angle) {
          return RotateAroundXY(line, point.x, point.y, angle);
        };
        module2.exports = RotateAroundPoint;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetToAngle = function(line, x2, y2, angle, length) {
          line.x1 = x2;
          line.y1 = y2;
          line.x2 = x2 + Math.cos(angle) * length;
          line.y2 = y2 + Math.sin(angle) * length;
          return line;
        };
        module2.exports = SetToAngle;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Slope = function(line) {
          return (line.y2 - line.y1) / (line.x2 - line.x1);
        };
        module2.exports = Slope;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Width = function(line) {
          return Math.abs(line.x1 - line.x2);
        };
        module2.exports = Width;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Mesh = {
          Face: __webpack_require__(116),
          GenerateGridVerts: __webpack_require__(1244),
          GenerateObjVerts: __webpack_require__(480),
          GenerateVerts: __webpack_require__(479),
          ParseObj: __webpack_require__(498),
          ParseObjMaterial: __webpack_require__(499),
          RotateFace: __webpack_require__(1245),
          Vertex: __webpack_require__(117)
        };
        module2.exports = Mesh;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Face = __webpack_require__(116);
        var GetFastValue = __webpack_require__(2);
        var Matrix4 = __webpack_require__(69);
        var Vector3 = __webpack_require__(39);
        var Vertex = __webpack_require__(117);
        var tempPosition = new Vector3();
        var tempRotation = new Vector3();
        var tempMatrix = new Matrix4();
        var GenerateGridVerts = function(config) {
          var mesh = GetFastValue(config, "mesh");
          var texture = GetFastValue(config, "texture", null);
          var frame = GetFastValue(config, "frame");
          var width = GetFastValue(config, "width", 1);
          var height = GetFastValue(config, "height", width);
          var widthSegments = GetFastValue(config, "widthSegments", 1);
          var heightSegments = GetFastValue(config, "heightSegments", widthSegments);
          var posX = GetFastValue(config, "x", 0);
          var posY = GetFastValue(config, "y", 0);
          var posZ = GetFastValue(config, "z", 0);
          var rotateX = GetFastValue(config, "rotateX", 0);
          var rotateY = GetFastValue(config, "rotateY", 0);
          var rotateZ = GetFastValue(config, "rotateZ", 0);
          var zIsUp = GetFastValue(config, "zIsUp", true);
          var isOrtho = GetFastValue(config, "isOrtho", mesh ? mesh.dirtyCache[11] : false);
          var colors = GetFastValue(config, "colors", [16777215]);
          var alphas = GetFastValue(config, "alphas", [1]);
          var tile = GetFastValue(config, "tile", false);
          var flipY = GetFastValue(config, "flipY", false);
          var widthSet = GetFastValue(config, "width", null);
          var result = {
            faces: [],
            verts: []
          };
          tempPosition.set(posX, posY, posZ);
          tempRotation.set(rotateX, rotateY, rotateZ);
          tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);
          if (!texture && mesh) {
            texture = mesh.texture;
          } else if (mesh && typeof texture === "string") {
            texture = mesh.scene.sys.textures.get(texture);
          } else {
            return result;
          }
          var textureFrame = texture.get(frame);
          if (!widthSet && isOrtho && texture && mesh) {
            width = textureFrame.width / mesh.height;
            height = textureFrame.height / mesh.height;
          }
          var halfWidth = width / 2;
          var halfHeight = height / 2;
          var gridX = Math.floor(widthSegments);
          var gridY = Math.floor(heightSegments);
          var gridX1 = gridX + 1;
          var gridY1 = gridY + 1;
          var segmentWidth = width / gridX;
          var segmentHeight = height / gridY;
          var uvs = [];
          var vertices = [];
          var ix;
          var iy;
          var frameU0 = 0;
          var frameU1 = 1;
          var frameV0 = 0;
          var frameV1 = 1;
          if (textureFrame) {
            frameU0 = textureFrame.u0;
            frameU1 = textureFrame.u1;
            if (!flipY) {
              frameV0 = textureFrame.v0;
              frameV1 = textureFrame.v1;
            } else {
              frameV0 = textureFrame.v1;
              frameV1 = textureFrame.v0;
            }
          }
          var frameU = frameU1 - frameU0;
          var frameV = frameV1 - frameV0;
          for (iy = 0; iy < gridY1; iy++) {
            var y2 = iy * segmentHeight - halfHeight;
            for (ix = 0; ix < gridX1; ix++) {
              var x2 = ix * segmentWidth - halfWidth;
              vertices.push(x2, -y2);
              var tu = frameU0 + frameU * (ix / gridX);
              var tv = frameV0 + frameV * (iy / gridY);
              uvs.push(tu, tv);
            }
          }
          if (!Array.isArray(colors)) {
            colors = [colors];
          }
          if (!Array.isArray(alphas)) {
            alphas = [alphas];
          }
          var alphaIndex = 0;
          var colorIndex = 0;
          for (iy = 0; iy < gridY; iy++) {
            for (ix = 0; ix < gridX; ix++) {
              var a = (ix + gridX1 * iy) * 2;
              var b2 = (ix + gridX1 * (iy + 1)) * 2;
              var c = (ix + 1 + gridX1 * (iy + 1)) * 2;
              var d = (ix + 1 + gridX1 * iy) * 2;
              var color = colors[colorIndex];
              var alpha = alphas[alphaIndex];
              var vert1 = new Vertex(vertices[a], vertices[a + 1], 0, uvs[a], uvs[a + 1], color, alpha).transformMat4(tempMatrix);
              var vert2 = new Vertex(vertices[b2], vertices[b2 + 1], 0, uvs[b2], uvs[b2 + 1], color, alpha).transformMat4(tempMatrix);
              var vert3 = new Vertex(vertices[d], vertices[d + 1], 0, uvs[d], uvs[d + 1], color, alpha).transformMat4(tempMatrix);
              var vert4 = new Vertex(vertices[b2], vertices[b2 + 1], 0, uvs[b2], uvs[b2 + 1], color, alpha).transformMat4(tempMatrix);
              var vert5 = new Vertex(vertices[c], vertices[c + 1], 0, uvs[c], uvs[c + 1], color, alpha).transformMat4(tempMatrix);
              var vert6 = new Vertex(vertices[d], vertices[d + 1], 0, uvs[d], uvs[d + 1], color, alpha).transformMat4(tempMatrix);
              if (tile) {
                vert1.setUVs(frameU0, frameV1);
                vert2.setUVs(frameU0, frameV0);
                vert3.setUVs(frameU1, frameV1);
                vert4.setUVs(frameU0, frameV0);
                vert5.setUVs(frameU1, frameV0);
                vert6.setUVs(frameU1, frameV1);
              }
              colorIndex++;
              if (colorIndex === colors.length) {
                colorIndex = 0;
              }
              alphaIndex++;
              if (alphaIndex === alphas.length) {
                alphaIndex = 0;
              }
              result.verts.push(vert1, vert2, vert3, vert4, vert5, vert6);
              result.faces.push(new Face(vert1, vert2, vert3), new Face(vert4, vert5, vert6));
            }
          }
          if (mesh) {
            mesh.faces = mesh.faces.concat(result.faces);
            mesh.vertices = mesh.vertices.concat(result.verts);
          }
          return result;
        };
        module2.exports = GenerateGridVerts;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateFace = function(face, angle, cx, cy) {
          var x2;
          var y2;
          if (cx === void 0 && cy === void 0) {
            var inCenter = face.getInCenter();
            x2 = inCenter.x;
            y2 = inCenter.y;
          }
          var c = Math.cos(angle);
          var s = Math.sin(angle);
          var v1 = face.vertex1;
          var v2 = face.vertex2;
          var v3 = face.vertex3;
          var tx = v1.x - x2;
          var ty = v1.y - y2;
          v1.set(tx * c - ty * s + x2, tx * s + ty * c + y2);
          tx = v2.x - x2;
          ty = v2.y - y2;
          v2.set(tx * c - ty * s + x2, tx * s + ty * c + y2);
          tx = v3.x - x2;
          ty = v3.y - y2;
          v3.set(tx * c - ty * s + x2, tx * s + ty * c + y2);
        };
        module2.exports = RotateFace;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        Point.Ceil = __webpack_require__(1247);
        Point.Clone = __webpack_require__(1248);
        Point.CopyFrom = __webpack_require__(1249);
        Point.Equals = __webpack_require__(1250);
        Point.Floor = __webpack_require__(1251);
        Point.GetCentroid = __webpack_require__(1252);
        Point.GetMagnitude = __webpack_require__(500);
        Point.GetMagnitudeSq = __webpack_require__(501);
        Point.GetRectangleFromPoints = __webpack_require__(1253);
        Point.Interpolate = __webpack_require__(1254);
        Point.Invert = __webpack_require__(1255);
        Point.Negative = __webpack_require__(1256);
        Point.Project = __webpack_require__(1257);
        Point.ProjectUnit = __webpack_require__(1258);
        Point.SetMagnitude = __webpack_require__(1259);
        module2.exports = Point;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Ceil = function(point) {
          return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
        };
        module2.exports = Ceil;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var Clone = function(source) {
          return new Point(source.x, source.y);
        };
        module2.exports = Clone;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CopyFrom = function(source, dest) {
          return dest.setTo(source.x, source.y);
        };
        module2.exports = CopyFrom;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Equals = function(point, toCompare) {
          return point.x === toCompare.x && point.y === toCompare.y;
        };
        module2.exports = Equals;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Floor = function(point) {
          return point.setTo(Math.floor(point.x), Math.floor(point.y));
        };
        module2.exports = Floor;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var GetCentroid = function(points, out) {
          if (out === void 0) {
            out = new Point();
          }
          if (!Array.isArray(points)) {
            throw new Error("GetCentroid points argument must be an array");
          }
          var len = points.length;
          if (len < 1) {
            throw new Error("GetCentroid points array must not be empty");
          } else if (len === 1) {
            out.x = points[0].x;
            out.y = points[0].y;
          } else {
            for (var i2 = 0; i2 < len; i2++) {
              out.x += points[i2].x;
              out.y += points[i2].y;
            }
            out.x /= len;
            out.y /= len;
          }
          return out;
        };
        module2.exports = GetCentroid;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rectangle = __webpack_require__(10);
        var GetRectangleFromPoints = function(points, out) {
          if (out === void 0) {
            out = new Rectangle();
          }
          var xMax = Number.NEGATIVE_INFINITY;
          var xMin = Number.POSITIVE_INFINITY;
          var yMax = Number.NEGATIVE_INFINITY;
          var yMin = Number.POSITIVE_INFINITY;
          for (var i2 = 0; i2 < points.length; i2++) {
            var point = points[i2];
            if (point.x > xMax) {
              xMax = point.x;
            }
            if (point.x < xMin) {
              xMin = point.x;
            }
            if (point.y > yMax) {
              yMax = point.y;
            }
            if (point.y < yMin) {
              yMin = point.y;
            }
          }
          out.x = xMin;
          out.y = yMin;
          out.width = xMax - xMin;
          out.height = yMax - yMin;
          return out;
        };
        module2.exports = GetRectangleFromPoints;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var Interpolate = function(pointA, pointB, t2, out) {
          if (t2 === void 0) {
            t2 = 0;
          }
          if (out === void 0) {
            out = new Point();
          }
          out.x = pointA.x + (pointB.x - pointA.x) * t2;
          out.y = pointA.y + (pointB.y - pointA.y) * t2;
          return out;
        };
        module2.exports = Interpolate;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Invert = function(point) {
          return point.setTo(point.y, point.x);
        };
        module2.exports = Invert;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var Negative = function(point, out) {
          if (out === void 0) {
            out = new Point();
          }
          return out.setTo(-point.x, -point.y);
        };
        module2.exports = Negative;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var GetMagnitudeSq = __webpack_require__(501);
        var Project = function(pointA, pointB, out) {
          if (out === void 0) {
            out = new Point();
          }
          var dot = pointA.x * pointB.x + pointA.y * pointB.y;
          var amt = dot / GetMagnitudeSq(pointB);
          if (amt !== 0) {
            out.x = amt * pointB.x;
            out.y = amt * pointB.y;
          }
          return out;
        };
        module2.exports = Project;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var ProjectUnit = function(pointA, pointB, out) {
          if (out === void 0) {
            out = new Point();
          }
          var amt = pointA.x * pointB.x + pointA.y * pointB.y;
          if (amt !== 0) {
            out.x = amt * pointB.x;
            out.y = amt * pointB.y;
          }
          return out;
        };
        module2.exports = ProjectUnit;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetMagnitude = __webpack_require__(500);
        var SetMagnitude = function(point, magnitude) {
          if (point.x !== 0 || point.y !== 0) {
            var m2 = GetMagnitude(point);
            point.x /= m2;
            point.y /= m2;
          }
          point.x *= magnitude;
          point.y *= magnitude;
          return point;
        };
        module2.exports = SetMagnitude;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Polygon = __webpack_require__(227);
        Polygon.Clone = __webpack_require__(1261);
        Polygon.Contains = __webpack_require__(228);
        Polygon.ContainsPoint = __webpack_require__(1262);
        Polygon.Earcut = __webpack_require__(59);
        Polygon.GetAABB = __webpack_require__(469);
        Polygon.GetNumberArray = __webpack_require__(1263);
        Polygon.GetPoints = __webpack_require__(470);
        Polygon.Perimeter = __webpack_require__(471);
        Polygon.Reverse = __webpack_require__(1264);
        Polygon.Simplify = __webpack_require__(1265);
        Polygon.Smooth = __webpack_require__(472);
        Polygon.Translate = __webpack_require__(1266);
        module2.exports = Polygon;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Polygon = __webpack_require__(227);
        var Clone = function(polygon) {
          return new Polygon(polygon.points);
        };
        module2.exports = Clone;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Contains = __webpack_require__(228);
        var ContainsPoint = function(polygon, point) {
          return Contains(polygon, point.x, point.y);
        };
        module2.exports = ContainsPoint;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetNumberArray = function(polygon, output) {
          if (output === void 0) {
            output = [];
          }
          for (var i2 = 0; i2 < polygon.points.length; i2++) {
            output.push(polygon.points[i2].x);
            output.push(polygon.points[i2].y);
          }
          return output;
        };
        module2.exports = GetNumberArray;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Reverse = function(polygon) {
          polygon.points.reverse();
          return polygon;
        };
        module2.exports = Reverse;
      },
      function(module2, exports2) {
        function getSqDist(p1, p2) {
          var dx = p1.x - p2.x, dy = p1.y - p2.y;
          return dx * dx + dy * dy;
        }
        function getSqSegDist(p2, p1, p22) {
          var x2 = p1.x, y2 = p1.y, dx = p22.x - x2, dy = p22.y - y2;
          if (dx !== 0 || dy !== 0) {
            var t2 = ((p2.x - x2) * dx + (p2.y - y2) * dy) / (dx * dx + dy * dy);
            if (t2 > 1) {
              x2 = p22.x;
              y2 = p22.y;
            } else if (t2 > 0) {
              x2 += dx * t2;
              y2 += dy * t2;
            }
          }
          dx = p2.x - x2;
          dy = p2.y - y2;
          return dx * dx + dy * dy;
        }
        function simplifyRadialDist(points, sqTolerance) {
          var prevPoint = points[0], newPoints = [prevPoint], point;
          for (var i2 = 1, len = points.length; i2 < len; i2++) {
            point = points[i2];
            if (getSqDist(point, prevPoint) > sqTolerance) {
              newPoints.push(point);
              prevPoint = point;
            }
          }
          if (prevPoint !== point) {
            newPoints.push(point);
          }
          return newPoints;
        }
        function simplifyDPStep(points, first, last, sqTolerance, simplified) {
          var maxSqDist = sqTolerance, index2;
          for (var i2 = first + 1; i2 < last; i2++) {
            var sqDist = getSqSegDist(points[i2], points[first], points[last]);
            if (sqDist > maxSqDist) {
              index2 = i2;
              maxSqDist = sqDist;
            }
          }
          if (maxSqDist > sqTolerance) {
            if (index2 - first > 1) {
              simplifyDPStep(points, first, index2, sqTolerance, simplified);
            }
            simplified.push(points[index2]);
            if (last - index2 > 1) {
              simplifyDPStep(points, index2, last, sqTolerance, simplified);
            }
          }
        }
        function simplifyDouglasPeucker(points, sqTolerance) {
          var last = points.length - 1;
          var simplified = [points[0]];
          simplifyDPStep(points, 0, last, sqTolerance, simplified);
          simplified.push(points[last]);
          return simplified;
        }
        var Simplify = function(polygon, tolerance, highestQuality) {
          if (tolerance === void 0) {
            tolerance = 1;
          }
          if (highestQuality === void 0) {
            highestQuality = false;
          }
          var points = polygon.points;
          if (points.length > 2) {
            var sqTolerance = tolerance * tolerance;
            if (!highestQuality) {
              points = simplifyRadialDist(points, sqTolerance);
            }
            polygon.setTo(simplifyDouglasPeucker(points, sqTolerance));
          }
          return polygon;
        };
        module2.exports = Simplify;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Translate = function(polygon, x2, y2) {
          var points = polygon.points;
          for (var i2 = 0; i2 < points.length; i2++) {
            points[i2].x += x2;
            points[i2].y += y2;
          }
          return polygon;
        };
        module2.exports = Translate;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Area = function(rect) {
          return rect.width * rect.height;
        };
        module2.exports = Area;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Ceil = function(rect) {
          rect.x = Math.ceil(rect.x);
          rect.y = Math.ceil(rect.y);
          return rect;
        };
        module2.exports = Ceil;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CeilAll = function(rect) {
          rect.x = Math.ceil(rect.x);
          rect.y = Math.ceil(rect.y);
          rect.width = Math.ceil(rect.width);
          rect.height = Math.ceil(rect.height);
          return rect;
        };
        module2.exports = CeilAll;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rectangle = __webpack_require__(10);
        var Clone = function(source) {
          return new Rectangle(source.x, source.y, source.width, source.height);
        };
        module2.exports = Clone;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Contains = __webpack_require__(57);
        var ContainsPoint = function(rect, point) {
          return Contains(rect, point.x, point.y);
        };
        module2.exports = ContainsPoint;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CopyFrom = function(source, dest) {
          return dest.setTo(source.x, source.y, source.width, source.height);
        };
        module2.exports = CopyFrom;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Equals = function(rect, toCompare) {
          return rect.x === toCompare.x && rect.y === toCompare.y && rect.width === toCompare.width && rect.height === toCompare.height;
        };
        module2.exports = Equals;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetAspectRatio = __webpack_require__(237);
        var FitInside = function(target, source) {
          var ratio = GetAspectRatio(target);
          if (ratio < GetAspectRatio(source)) {
            target.setSize(source.height * ratio, source.height);
          } else {
            target.setSize(source.width, source.width / ratio);
          }
          return target.setPosition(source.centerX - target.width / 2, source.centerY - target.height / 2);
        };
        module2.exports = FitInside;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetAspectRatio = __webpack_require__(237);
        var FitOutside = function(target, source) {
          var ratio = GetAspectRatio(target);
          if (ratio > GetAspectRatio(source)) {
            target.setSize(source.height * ratio, source.height);
          } else {
            target.setSize(source.width, source.width / ratio);
          }
          return target.setPosition(source.centerX - target.width / 2, source.centerY - target.height / 2);
        };
        module2.exports = FitOutside;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Floor = function(rect) {
          rect.x = Math.floor(rect.x);
          rect.y = Math.floor(rect.y);
          return rect;
        };
        module2.exports = Floor;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FloorAll = function(rect) {
          rect.x = Math.floor(rect.x);
          rect.y = Math.floor(rect.y);
          rect.width = Math.floor(rect.width);
          rect.height = Math.floor(rect.height);
          return rect;
        };
        module2.exports = FloorAll;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       samme
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rectangle = __webpack_require__(10);
        var FromXY = function(x1, y1, x2, y2, out) {
          if (out === void 0) {
            out = new Rectangle();
          }
          return out.setTo(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));
        };
        module2.exports = FromXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var GetCenter = function(rect, out) {
          if (out === void 0) {
            out = new Point();
          }
          out.x = rect.centerX;
          out.y = rect.centerY;
          return out;
        };
        module2.exports = GetCenter;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var GetSize = function(rect, out) {
          if (out === void 0) {
            out = new Point();
          }
          out.x = rect.width;
          out.y = rect.height;
          return out;
        };
        module2.exports = GetSize;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CenterOn = __webpack_require__(190);
        var Inflate = function(rect, x2, y2) {
          var cx = rect.centerX;
          var cy = rect.centerY;
          rect.setSize(rect.width + x2 * 2, rect.height + y2 * 2);
          return CenterOn(rect, cx, cy);
        };
        module2.exports = Inflate;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Rectangle = __webpack_require__(10);
        var Intersects = __webpack_require__(152);
        var Intersection = function(rectA, rectB, out) {
          if (out === void 0) {
            out = new Rectangle();
          }
          if (Intersects(rectA, rectB)) {
            out.x = Math.max(rectA.x, rectB.x);
            out.y = Math.max(rectA.y, rectB.y);
            out.width = Math.min(rectA.right, rectB.right) - out.x;
            out.height = Math.min(rectA.bottom, rectB.bottom) - out.y;
          } else {
            out.setEmpty();
          }
          return out;
        };
        module2.exports = Intersection;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MergePoints = function(target, points) {
          var minX = target.x;
          var maxX = target.right;
          var minY = target.y;
          var maxY = target.bottom;
          for (var i2 = 0; i2 < points.length; i2++) {
            minX = Math.min(minX, points[i2].x);
            maxX = Math.max(maxX, points[i2].x);
            minY = Math.min(minY, points[i2].y);
            maxY = Math.max(maxY, points[i2].y);
          }
          target.x = minX;
          target.y = minY;
          target.width = maxX - minX;
          target.height = maxY - minY;
          return target;
        };
        module2.exports = MergePoints;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MergeRect = function(target, source) {
          var minX = Math.min(target.x, source.x);
          var maxX = Math.max(target.right, source.right);
          target.x = minX;
          target.width = maxX - minX;
          var minY = Math.min(target.y, source.y);
          var maxY = Math.max(target.bottom, source.bottom);
          target.y = minY;
          target.height = maxY - minY;
          return target;
        };
        module2.exports = MergeRect;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MergeXY = function(target, x2, y2) {
          var minX = Math.min(target.x, x2);
          var maxX = Math.max(target.right, x2);
          target.x = minX;
          target.width = maxX - minX;
          var minY = Math.min(target.y, y2);
          var maxY = Math.max(target.bottom, y2);
          target.y = minY;
          target.height = maxY - minY;
          return target;
        };
        module2.exports = MergeXY;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Offset = function(rect, x2, y2) {
          rect.x += x2;
          rect.y += y2;
          return rect;
        };
        module2.exports = Offset;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var OffsetPoint = function(rect, point) {
          rect.x += point.x;
          rect.y += point.y;
          return rect;
        };
        module2.exports = OffsetPoint;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Overlaps = function(rectA, rectB) {
          return rectA.x < rectB.right && rectA.right > rectB.x && rectA.y < rectB.bottom && rectA.bottom > rectB.y;
        };
        module2.exports = Overlaps;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Point = __webpack_require__(4);
        var DegToRad = __webpack_require__(36);
        var PerimeterPoint = function(rectangle, angle, out) {
          if (out === void 0) {
            out = new Point();
          }
          angle = DegToRad(angle);
          var s = Math.sin(angle);
          var c = Math.cos(angle);
          var dx = c > 0 ? rectangle.width / 2 : rectangle.width / -2;
          var dy = s > 0 ? rectangle.height / 2 : rectangle.height / -2;
          if (Math.abs(dx * s) < Math.abs(dy * c)) {
            dy = dx * s / c;
          } else {
            dx = dy * c / s;
          }
          out.x = dx + rectangle.centerX;
          out.y = dy + rectangle.centerY;
          return out;
        };
        module2.exports = PerimeterPoint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Between = __webpack_require__(195);
        var ContainsRect = __webpack_require__(503);
        var Point = __webpack_require__(4);
        var RandomOutside = function(outer, inner, out) {
          if (out === void 0) {
            out = new Point();
          }
          if (ContainsRect(outer, inner)) {
            switch (Between(0, 3)) {
              case 0:
                out.x = outer.x + Math.random() * (inner.right - outer.x);
                out.y = outer.y + Math.random() * (inner.top - outer.y);
                break;
              case 1:
                out.x = inner.x + Math.random() * (outer.right - inner.x);
                out.y = inner.bottom + Math.random() * (outer.bottom - inner.bottom);
                break;
              case 2:
                out.x = outer.x + Math.random() * (inner.x - outer.x);
                out.y = inner.y + Math.random() * (outer.bottom - inner.y);
                break;
              case 3:
                out.x = inner.right + Math.random() * (outer.right - inner.right);
                out.y = outer.y + Math.random() * (inner.bottom - outer.y);
                break;
            }
          }
          return out;
        };
        module2.exports = RandomOutside;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SameDimensions = function(rect, toCompare) {
          return rect.width === toCompare.width && rect.height === toCompare.height;
        };
        module2.exports = SameDimensions;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Scale = function(rect, x2, y2) {
          if (y2 === void 0) {
            y2 = x2;
          }
          rect.width *= x2;
          rect.height *= y2;
          return rect;
        };
        module2.exports = Scale;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Triangle = __webpack_require__(82);
        Triangle.Area = __webpack_require__(1294);
        Triangle.BuildEquilateral = __webpack_require__(1295);
        Triangle.BuildFromPolygon = __webpack_require__(1296);
        Triangle.BuildRight = __webpack_require__(1297);
        Triangle.CenterOn = __webpack_require__(1298);
        Triangle.Centroid = __webpack_require__(504);
        Triangle.CircumCenter = __webpack_require__(1299);
        Triangle.CircumCircle = __webpack_require__(1300);
        Triangle.Clone = __webpack_require__(1301);
        Triangle.Contains = __webpack_require__(115);
        Triangle.ContainsArray = __webpack_require__(235);
        Triangle.ContainsPoint = __webpack_require__(1302);
        Triangle.CopyFrom = __webpack_require__(1303);
        Triangle.Decompose = __webpack_require__(495);
        Triangle.Equals = __webpack_require__(1304);
        Triangle.GetPoint = __webpack_require__(476);
        Triangle.GetPoints = __webpack_require__(477);
        Triangle.InCenter = __webpack_require__(506);
        Triangle.Perimeter = __webpack_require__(1305);
        Triangle.Offset = __webpack_require__(505);
        Triangle.Random = __webpack_require__(181);
        Triangle.Rotate = __webpack_require__(1306);
        Triangle.RotateAroundPoint = __webpack_require__(1307);
        Triangle.RotateAroundXY = __webpack_require__(238);
        module2.exports = Triangle;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Area = function(triangle) {
          var x1 = triangle.x1;
          var y1 = triangle.y1;
          var x2 = triangle.x2;
          var y2 = triangle.y2;
          var x3 = triangle.x3;
          var y3 = triangle.y3;
          return Math.abs(((x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)) / 2);
        };
        module2.exports = Area;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Triangle = __webpack_require__(82);
        var BuildEquilateral = function(x2, y2, length) {
          var height = length * (Math.sqrt(3) / 2);
          var x1 = x2;
          var y1 = y2;
          var x22 = x2 + length / 2;
          var y22 = y2 + height;
          var x3 = x2 - length / 2;
          var y3 = y2 + height;
          return new Triangle(x1, y1, x22, y22, x3, y3);
        };
        module2.exports = BuildEquilateral;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var EarCut = __webpack_require__(59);
        var Triangle = __webpack_require__(82);
        var BuildFromPolygon = function(data, holes, scaleX, scaleY, out) {
          if (holes === void 0) {
            holes = null;
          }
          if (scaleX === void 0) {
            scaleX = 1;
          }
          if (scaleY === void 0) {
            scaleY = 1;
          }
          if (out === void 0) {
            out = [];
          }
          var tris = EarCut(data, holes);
          var a;
          var b2;
          var c;
          var x1;
          var y1;
          var x2;
          var y2;
          var x3;
          var y3;
          for (var i2 = 0; i2 < tris.length; i2 += 3) {
            a = tris[i2];
            b2 = tris[i2 + 1];
            c = tris[i2 + 2];
            x1 = data[a * 2] * scaleX;
            y1 = data[a * 2 + 1] * scaleY;
            x2 = data[b2 * 2] * scaleX;
            y2 = data[b2 * 2 + 1] * scaleY;
            x3 = data[c * 2] * scaleX;
            y3 = data[c * 2 + 1] * scaleY;
            out.push(new Triangle(x1, y1, x2, y2, x3, y3));
          }
          return out;
        };
        module2.exports = BuildFromPolygon;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Triangle = __webpack_require__(82);
        var BuildRight = function(x2, y2, width, height) {
          if (height === void 0) {
            height = width;
          }
          var x1 = x2;
          var y1 = y2;
          var x22 = x2;
          var y22 = y2 - height;
          var x3 = x2 + width;
          var y3 = y2;
          return new Triangle(x1, y1, x22, y22, x3, y3);
        };
        module2.exports = BuildRight;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Centroid = __webpack_require__(504);
        var Offset = __webpack_require__(505);
        var CenterOn = function(triangle, x2, y2, centerFunc) {
          if (centerFunc === void 0) {
            centerFunc = Centroid;
          }
          var center = centerFunc(triangle);
          var diffX = x2 - center.x;
          var diffY = y2 - center.y;
          return Offset(triangle, diffX, diffY);
        };
        module2.exports = CenterOn;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Vector2 = __webpack_require__(3);
        function det(m00, m01, m10, m11) {
          return m00 * m11 - m01 * m10;
        }
        var CircumCenter = function(triangle, out) {
          if (out === void 0) {
            out = new Vector2();
          }
          var cx = triangle.x3;
          var cy = triangle.y3;
          var ax = triangle.x1 - cx;
          var ay = triangle.y1 - cy;
          var bx = triangle.x2 - cx;
          var by = triangle.y2 - cy;
          var denom = 2 * det(ax, ay, bx, by);
          var numx = det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
          var numy = det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
          out.x = cx - numx / denom;
          out.y = cy + numy / denom;
          return out;
        };
        module2.exports = CircumCenter;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Circle = __webpack_require__(65);
        var CircumCircle = function(triangle, out) {
          if (out === void 0) {
            out = new Circle();
          }
          var x1 = triangle.x1;
          var y1 = triangle.y1;
          var x2 = triangle.x2;
          var y2 = triangle.y2;
          var x3 = triangle.x3;
          var y3 = triangle.y3;
          var A2 = x2 - x1;
          var B2 = y2 - y1;
          var C2 = x3 - x1;
          var D2 = y3 - y1;
          var E2 = A2 * (x1 + x2) + B2 * (y1 + y2);
          var F2 = C2 * (x1 + x3) + D2 * (y1 + y3);
          var G2 = 2 * (A2 * (y3 - y2) - B2 * (x3 - x2));
          var dx;
          var dy;
          if (Math.abs(G2) < 1e-6) {
            var minX = Math.min(x1, x2, x3);
            var minY = Math.min(y1, y2, y3);
            dx = (Math.max(x1, x2, x3) - minX) * 0.5;
            dy = (Math.max(y1, y2, y3) - minY) * 0.5;
            out.x = minX + dx;
            out.y = minY + dy;
            out.radius = Math.sqrt(dx * dx + dy * dy);
          } else {
            out.x = (D2 * E2 - B2 * F2) / G2;
            out.y = (A2 * F2 - C2 * E2) / G2;
            dx = out.x - x1;
            dy = out.y - y1;
            out.radius = Math.sqrt(dx * dx + dy * dy);
          }
          return out;
        };
        module2.exports = CircumCircle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Triangle = __webpack_require__(82);
        var Clone = function(source) {
          return new Triangle(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
        };
        module2.exports = Clone;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Contains = __webpack_require__(115);
        var ContainsPoint = function(triangle, point) {
          return Contains(triangle, point.x, point.y);
        };
        module2.exports = ContainsPoint;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CopyFrom = function(source, dest) {
          return dest.setTo(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
        };
        module2.exports = CopyFrom;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Equals = function(triangle, toCompare) {
          return triangle.x1 === toCompare.x1 && triangle.y1 === toCompare.y1 && triangle.x2 === toCompare.x2 && triangle.y2 === toCompare.y2 && triangle.x3 === toCompare.x3 && triangle.y3 === toCompare.y3;
        };
        module2.exports = Equals;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Length = __webpack_require__(67);
        var Perimeter = function(triangle) {
          var line1 = triangle.getLineA();
          var line2 = triangle.getLineB();
          var line3 = triangle.getLineC();
          return Length(line1) + Length(line2) + Length(line3);
        };
        module2.exports = Perimeter;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateAroundXY = __webpack_require__(238);
        var InCenter = __webpack_require__(506);
        var Rotate = function(triangle, angle) {
          var point = InCenter(triangle);
          return RotateAroundXY(triangle, point.x, point.y, angle);
        };
        module2.exports = Rotate;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RotateAroundXY = __webpack_require__(238);
        var RotateAroundPoint = function(triangle, point, angle) {
          return RotateAroundXY(triangle, point.x, point.y, angle);
        };
        module2.exports = RotateAroundPoint;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(203);
        var Extend = __webpack_require__(17);
        var Input = {
          CreatePixelPerfectHandler: __webpack_require__(507),
          CreateInteractiveObject: __webpack_require__(508),
          Events: __webpack_require__(51),
          Gamepad: __webpack_require__(1309),
          InputManager: __webpack_require__(409),
          InputPlugin: __webpack_require__(1321),
          InputPluginCache: __webpack_require__(153),
          Keyboard: __webpack_require__(1322),
          Mouse: __webpack_require__(1336),
          Pointer: __webpack_require__(412),
          Touch: __webpack_require__(1337)
        };
        Input = Extend(false, Input, CONST);
        module2.exports = Input;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Axis: __webpack_require__(509),
          Button: __webpack_require__(510),
          Events: __webpack_require__(239),
          Gamepad: __webpack_require__(511),
          GamepadPlugin: __webpack_require__(1316),
          Configs: __webpack_require__(1317)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "down";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "up";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "connected";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "disconnected";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "down";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "up";
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(239);
        var Gamepad = __webpack_require__(511);
        var GetValue = __webpack_require__(6);
        var InputPluginCache = __webpack_require__(153);
        var InputEvents = __webpack_require__(51);
        var GamepadPlugin = new Class({
          Extends: EventEmitter,
          initialize: function GamepadPlugin2(sceneInputPlugin) {
            EventEmitter.call(this);
            this.scene = sceneInputPlugin.scene;
            this.settings = this.scene.sys.settings;
            this.sceneInputPlugin = sceneInputPlugin;
            this.enabled = true;
            this.target;
            this.gamepads = [];
            this.queue = [];
            this.onGamepadHandler;
            this._pad1;
            this._pad2;
            this._pad3;
            this._pad4;
            sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);
            sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
          },
          boot: function() {
            var game = this.scene.sys.game;
            var settings = this.settings.input;
            var config = game.config;
            this.enabled = GetValue(settings, "gamepad", config.inputGamepad) && game.device.input.gamepads;
            this.target = GetValue(settings, "gamepad.target", config.inputGamepadEventTarget);
            this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
          },
          start: function() {
            if (this.enabled) {
              this.startListeners();
              this.refreshPads();
            }
            this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);
          },
          isActive: function() {
            return this.enabled && this.scene.sys.isActive();
          },
          startListeners: function() {
            var _this = this;
            var target = this.target;
            var handler = function(event) {
              if (event.defaultPrevented || !_this.isActive()) {
                return;
              }
              _this.refreshPads();
              _this.queue.push(event);
            };
            this.onGamepadHandler = handler;
            target.addEventListener("gamepadconnected", handler, false);
            target.addEventListener("gamepaddisconnected", handler, false);
            this.sceneInputPlugin.pluginEvents.on(InputEvents.UPDATE, this.update, this);
          },
          stopListeners: function() {
            this.target.removeEventListener("gamepadconnected", this.onGamepadHandler);
            this.target.removeEventListener("gamepaddisconnected", this.onGamepadHandler);
            this.sceneInputPlugin.pluginEvents.off(InputEvents.UPDATE, this.update);
            for (var i2 = 0; i2 < this.gamepads.length; i2++) {
              this.gamepads[i2].removeAllListeners();
            }
          },
          disconnectAll: function() {
            for (var i2 = 0; i2 < this.gamepads.length; i2++) {
              this.gamepads[i2].pad.connected = false;
            }
          },
          refreshPads: function() {
            var connectedPads = navigator.getGamepads();
            if (!connectedPads) {
              this.disconnectAll();
            } else {
              var currentPads = this.gamepads;
              for (var i2 = 0; i2 < connectedPads.length; i2++) {
                var livePad = connectedPads[i2];
                if (!livePad) {
                  continue;
                }
                var id2 = livePad.id;
                var index2 = livePad.index;
                var currentPad = currentPads[index2];
                if (!currentPad) {
                  var newPad = new Gamepad(this, livePad);
                  currentPads[index2] = newPad;
                  if (!this._pad1) {
                    this._pad1 = newPad;
                  } else if (!this._pad2) {
                    this._pad2 = newPad;
                  } else if (!this._pad3) {
                    this._pad3 = newPad;
                  } else if (!this._pad4) {
                    this._pad4 = newPad;
                  }
                } else if (currentPad.id !== id2) {
                  currentPad.destroy();
                  currentPads[index2] = new Gamepad(this, livePad);
                } else {
                  currentPad.update(livePad);
                }
              }
            }
          },
          getAll: function() {
            var out = [];
            var pads = this.gamepads;
            for (var i2 = 0; i2 < pads.length; i2++) {
              if (pads[i2]) {
                out.push(pads[i2]);
              }
            }
            return out;
          },
          getPad: function(index2) {
            var pads = this.gamepads;
            for (var i2 = 0; i2 < pads.length; i2++) {
              if (pads[i2] && pads[i2].index === index2) {
                return pads[i2];
              }
            }
          },
          update: function() {
            if (!this.enabled) {
              return;
            }
            this.refreshPads();
            var len = this.queue.length;
            if (len === 0) {
              return;
            }
            var queue = this.queue.splice(0, len);
            for (var i2 = 0; i2 < len; i2++) {
              var event = queue[i2];
              var pad = this.getPad(event.gamepad.index);
              if (event.type === "gamepadconnected") {
                this.emit(Events.CONNECTED, pad, event);
              } else if (event.type === "gamepaddisconnected") {
                this.emit(Events.DISCONNECTED, pad, event);
              }
            }
          },
          shutdown: function() {
            this.stopListeners();
            this.removeAllListeners();
          },
          destroy: function() {
            this.shutdown();
            for (var i2 = 0; i2 < this.gamepads.length; i2++) {
              if (this.gamepads[i2]) {
                this.gamepads[i2].destroy();
              }
            }
            this.gamepads = [];
            this.scene = null;
            this.settings = null;
            this.sceneInputPlugin = null;
            this.target = null;
          },
          total: {
            get: function() {
              return this.gamepads.length;
            }
          },
          pad1: {
            get: function() {
              return this._pad1;
            }
          },
          pad2: {
            get: function() {
              return this._pad2;
            }
          },
          pad3: {
            get: function() {
              return this._pad3;
            }
          },
          pad4: {
            get: function() {
              return this._pad4;
            }
          }
        });
        InputPluginCache.register("GamepadPlugin", GamepadPlugin, "gamepad", "gamepad", "inputGamepad");
        module2.exports = GamepadPlugin;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          DUALSHOCK_4: __webpack_require__(1318),
          SNES_USB: __webpack_require__(1319),
          XBOX_360: __webpack_require__(1320)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          UP: 12,
          DOWN: 13,
          LEFT: 14,
          RIGHT: 15,
          SHARE: 8,
          OPTIONS: 9,
          PS: 16,
          TOUCHBAR: 17,
          X: 0,
          CIRCLE: 1,
          SQUARE: 2,
          TRIANGLE: 3,
          L1: 4,
          R1: 5,
          L2: 6,
          R2: 7,
          L3: 10,
          R3: 11,
          LEFT_STICK_H: 0,
          LEFT_STICK_V: 1,
          RIGHT_STICK_H: 2,
          RIGHT_STICK_V: 3
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          UP: 12,
          DOWN: 13,
          LEFT: 14,
          RIGHT: 15,
          SELECT: 8,
          START: 9,
          B: 0,
          A: 1,
          Y: 2,
          X: 3,
          LEFT_SHOULDER: 4,
          RIGHT_SHOULDER: 5
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          UP: 12,
          DOWN: 13,
          LEFT: 14,
          RIGHT: 15,
          MENU: 16,
          A: 0,
          B: 1,
          X: 2,
          Y: 3,
          LB: 4,
          RB: 5,
          LT: 6,
          RT: 7,
          BACK: 8,
          START: 9,
          LS: 10,
          RS: 11,
          LEFT_STICK_H: 0,
          LEFT_STICK_V: 1,
          RIGHT_STICK_H: 2,
          RIGHT_STICK_V: 3
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Circle = __webpack_require__(65);
        var CircleContains = __webpack_require__(66);
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(203);
        var CreateInteractiveObject = __webpack_require__(508);
        var CreatePixelPerfectHandler = __webpack_require__(507);
        var DistanceBetween = __webpack_require__(50);
        var Ellipse = __webpack_require__(111);
        var EllipseContains = __webpack_require__(112);
        var Events = __webpack_require__(51);
        var EventEmitter = __webpack_require__(9);
        var GetFastValue = __webpack_require__(2);
        var GEOM_CONST = __webpack_require__(56);
        var InputPluginCache = __webpack_require__(153);
        var IsPlainObject2 = __webpack_require__(7);
        var PluginCache = __webpack_require__(24);
        var Rectangle = __webpack_require__(10);
        var RectangleContains = __webpack_require__(57);
        var SceneEvents = __webpack_require__(20);
        var Triangle = __webpack_require__(82);
        var TriangleContains = __webpack_require__(115);
        var InputPlugin = new Class({
          Extends: EventEmitter,
          initialize: function InputPlugin2(scene) {
            EventEmitter.call(this);
            this.scene = scene;
            this.systems = scene.sys;
            this.settings = scene.sys.settings;
            this.manager = scene.sys.game.input;
            this.pluginEvents = new EventEmitter();
            this.enabled = true;
            this.displayList;
            this.cameras;
            InputPluginCache.install(this);
            this.mouse = this.manager.mouse;
            this.topOnly = true;
            this.pollRate = -1;
            this._pollTimer = 0;
            var _eventData = { cancelled: false };
            this._eventContainer = {
              stopPropagation: function() {
                _eventData.cancelled = true;
              }
            };
            this._eventData = _eventData;
            this.dragDistanceThreshold = 0;
            this.dragTimeThreshold = 0;
            this._temp = [];
            this._tempZones = [];
            this._list = [];
            this._pendingInsertion = [];
            this._pendingRemoval = [];
            this._draggable = [];
            this._drag = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };
            this._dragState = [];
            this._over = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };
            this._validTypes = ["onDown", "onUp", "onOver", "onOut", "onMove", "onDragStart", "onDrag", "onDragEnd", "onDragEnter", "onDragLeave", "onDragOver", "onDrop"];
            this._updatedThisFrame = false;
            scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
            scene.sys.events.on(SceneEvents.START, this.start, this);
          },
          boot: function() {
            this.cameras = this.systems.cameras;
            this.displayList = this.systems.displayList;
            this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            this.pluginEvents.emit(Events.BOOT);
          },
          start: function() {
            var eventEmitter = this.systems.events;
            eventEmitter.on(SceneEvents.TRANSITION_START, this.transitionIn, this);
            eventEmitter.on(SceneEvents.TRANSITION_OUT, this.transitionOut, this);
            eventEmitter.on(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);
            eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
            eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            this.manager.events.on(Events.GAME_OUT, this.onGameOut, this);
            this.manager.events.on(Events.GAME_OVER, this.onGameOver, this);
            this.enabled = true;
            this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            this.pluginEvents.emit(Events.START);
          },
          onGameOver: function(event) {
            if (this.isActive()) {
              this.emit(Events.GAME_OVER, event.timeStamp, event);
            }
          },
          onGameOut: function(event) {
            if (this.isActive()) {
              this.emit(Events.GAME_OUT, event.timeStamp, event);
            }
          },
          preUpdate: function() {
            this.pluginEvents.emit(Events.PRE_UPDATE);
            var removeList = this._pendingRemoval;
            var insertList = this._pendingInsertion;
            var toRemove = removeList.length;
            var toInsert = insertList.length;
            if (toRemove === 0 && toInsert === 0) {
              return;
            }
            var current = this._list;
            for (var i2 = 0; i2 < toRemove; i2++) {
              var gameObject = removeList[i2];
              var index2 = current.indexOf(gameObject);
              if (index2 > -1) {
                current.splice(index2, 1);
                this.clear(gameObject, true);
              }
            }
            removeList.length = 0;
            this._pendingRemoval.length = 0;
            this._list = current.concat(insertList.splice(0));
          },
          isActive: function() {
            return this.enabled && this.scene.sys.isActive();
          },
          updatePoll: function(time, delta) {
            if (!this.isActive()) {
              return false;
            }
            this.pluginEvents.emit(Events.UPDATE, time, delta);
            if (this._updatedThisFrame) {
              this._updatedThisFrame = false;
              return false;
            }
            var i2;
            var manager = this.manager;
            var pointers = manager.pointers;
            var pointersTotal = manager.pointersTotal;
            for (i2 = 0; i2 < pointersTotal; i2++) {
              pointers[i2].updateMotion();
            }
            if (this._list.length === 0) {
              return false;
            }
            var rate = this.pollRate;
            if (rate === -1) {
              return false;
            } else if (rate > 0) {
              this._pollTimer -= delta;
              if (this._pollTimer < 0) {
                this._pollTimer = this.pollRate;
              } else {
                return false;
              }
            }
            var captured = false;
            for (i2 = 0; i2 < pointersTotal; i2++) {
              var total = 0;
              var pointer = pointers[i2];
              this._tempZones = [];
              this._temp = this.hitTestPointer(pointer);
              this.sortGameObjects(this._temp, pointer);
              this.sortDropZones(this._tempZones);
              if (this.topOnly) {
                if (this._temp.length) {
                  this._temp.splice(1);
                }
                if (this._tempZones.length) {
                  this._tempZones.splice(1);
                }
              }
              total += this.processOverOutEvents(pointer);
              if (this.getDragState(pointer) === 2) {
                this.processDragThresholdEvent(pointer, time);
              }
              if (total > 0) {
                captured = true;
              }
            }
            return captured;
          },
          update: function(type, pointers) {
            if (!this.isActive()) {
              return false;
            }
            var pointersTotal = pointers.length;
            var captured = false;
            for (var i2 = 0; i2 < pointersTotal; i2++) {
              var total = 0;
              var pointer = pointers[i2];
              this._tempZones = [];
              this._temp = this.hitTestPointer(pointer);
              this.sortGameObjects(this._temp, pointer);
              this.sortDropZones(this._tempZones);
              if (this.topOnly) {
                if (this._temp.length) {
                  this._temp.splice(1);
                }
                if (this._tempZones.length) {
                  this._tempZones.splice(1);
                }
              }
              switch (type) {
                case CONST.MOUSE_DOWN:
                  total += this.processDragDownEvent(pointer);
                  total += this.processDownEvents(pointer);
                  total += this.processOverOutEvents(pointer);
                  break;
                case CONST.MOUSE_UP:
                  total += this.processDragUpEvent(pointer);
                  total += this.processUpEvents(pointer);
                  total += this.processOverOutEvents(pointer);
                  break;
                case CONST.TOUCH_START:
                  total += this.processDragDownEvent(pointer);
                  total += this.processDownEvents(pointer);
                  total += this.processOverEvents(pointer);
                  break;
                case CONST.TOUCH_END:
                case CONST.TOUCH_CANCEL:
                  total += this.processDragUpEvent(pointer);
                  total += this.processUpEvents(pointer);
                  total += this.processOutEvents(pointer);
                  break;
                case CONST.MOUSE_MOVE:
                case CONST.TOUCH_MOVE:
                  total += this.processDragMoveEvent(pointer);
                  total += this.processMoveEvents(pointer);
                  total += this.processOverOutEvents(pointer);
                  break;
                case CONST.MOUSE_WHEEL:
                  total += this.processWheelEvent(pointer);
                  break;
              }
              if (total > 0) {
                captured = true;
              }
            }
            this._updatedThisFrame = true;
            return captured;
          },
          clear: function(gameObject, skipQueue) {
            if (skipQueue === void 0) {
              skipQueue = false;
            }
            var input = gameObject.input;
            if (!input) {
              return;
            }
            if (!skipQueue) {
              this.queueForRemoval(gameObject);
            }
            input.gameObject = void 0;
            input.target = void 0;
            input.hitArea = void 0;
            input.hitAreaCallback = void 0;
            input.callbackContext = void 0;
            gameObject.input = null;
            var index2 = this._draggable.indexOf(gameObject);
            if (index2 > -1) {
              this._draggable.splice(index2, 1);
            }
            index2 = this._drag[0].indexOf(gameObject);
            if (index2 > -1) {
              this._drag[0].splice(index2, 1);
            }
            index2 = this._over[0].indexOf(gameObject);
            if (index2 > -1) {
              this._over[0].splice(index2, 1);
              this.manager.resetCursor(input);
            }
            return gameObject;
          },
          disable: function(gameObject) {
            gameObject.input.enabled = false;
          },
          enable: function(gameObject, hitArea, hitAreaCallback, dropZone) {
            if (dropZone === void 0) {
              dropZone = false;
            }
            if (gameObject.input) {
              gameObject.input.enabled = true;
            } else {
              this.setHitArea(gameObject, hitArea, hitAreaCallback);
            }
            if (gameObject.input && dropZone && !gameObject.input.dropZone) {
              gameObject.input.dropZone = dropZone;
            }
            return this;
          },
          hitTestPointer: function(pointer) {
            var cameras = this.cameras.getCamerasBelowPointer(pointer);
            for (var c = 0; c < cameras.length; c++) {
              var camera = cameras[c];
              var over = this.manager.hitTest(pointer, this._list, camera);
              for (var i2 = 0; i2 < over.length; i2++) {
                var obj = over[i2];
                if (obj.input.dropZone) {
                  this._tempZones.push(obj);
                }
              }
              if (over.length > 0) {
                pointer.camera = camera;
                return over;
              }
            }
            pointer.camera = cameras[0];
            return [];
          },
          processDownEvents: function(pointer) {
            var total = 0;
            var currentlyOver = this._temp;
            var _eventData = this._eventData;
            var _eventContainer = this._eventContainer;
            _eventData.cancelled = false;
            var aborted = false;
            for (var i2 = 0; i2 < currentlyOver.length; i2++) {
              var gameObject = currentlyOver[i2];
              if (!gameObject.input) {
                continue;
              }
              total++;
              gameObject.emit(Events.GAMEOBJECT_POINTER_DOWN, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
              if (_eventData.cancelled || !gameObject.input) {
                aborted = true;
                break;
              }
              this.emit(Events.GAMEOBJECT_DOWN, pointer, gameObject, _eventContainer);
              if (_eventData.cancelled || !gameObject.input) {
                aborted = true;
                break;
              }
            }
            if (!aborted && this.manager) {
              if (pointer.downElement === this.manager.game.canvas) {
                this.emit(Events.POINTER_DOWN, pointer, currentlyOver);
              } else {
                this.emit(Events.POINTER_DOWN_OUTSIDE, pointer);
              }
            }
            return total;
          },
          getDragState: function(pointer) {
            return this._dragState[pointer.id];
          },
          setDragState: function(pointer, state) {
            this._dragState[pointer.id] = state;
          },
          processDragThresholdEvent: function(pointer, time) {
            var passed = false;
            var timeThreshold = this.dragTimeThreshold;
            var distanceThreshold = this.dragDistanceThreshold;
            if (distanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= distanceThreshold) {
              passed = true;
            } else if (timeThreshold > 0 && time >= pointer.downTime + timeThreshold) {
              passed = true;
            }
            if (passed) {
              this.setDragState(pointer, 3);
              return this.processDragStartList(pointer);
            }
          },
          processDragStartList: function(pointer) {
            if (this.getDragState(pointer) !== 3) {
              return 0;
            }
            var list = this._drag[pointer.id];
            for (var i2 = 0; i2 < list.length; i2++) {
              var gameObject = list[i2];
              var input = gameObject.input;
              input.dragState = 2;
              input.dragStartX = gameObject.x;
              input.dragStartY = gameObject.y;
              input.dragStartXGlobal = pointer.worldX;
              input.dragStartYGlobal = pointer.worldY;
              input.dragX = input.dragStartXGlobal - input.dragStartX;
              input.dragY = input.dragStartYGlobal - input.dragStartY;
              gameObject.emit(Events.GAMEOBJECT_DRAG_START, pointer, input.dragX, input.dragY);
              this.emit(Events.DRAG_START, pointer, gameObject);
            }
            this.setDragState(pointer, 4);
            return list.length;
          },
          processDragDownEvent: function(pointer) {
            var currentlyOver = this._temp;
            if (this._draggable.length === 0 || currentlyOver.length === 0 || !pointer.primaryDown || this.getDragState(pointer) !== 0) {
              return 0;
            }
            this.setDragState(pointer, 1);
            var draglist = [];
            for (var i2 = 0; i2 < currentlyOver.length; i2++) {
              var gameObject = currentlyOver[i2];
              if (gameObject.input.draggable && gameObject.input.dragState === 0) {
                draglist.push(gameObject);
              }
            }
            if (draglist.length === 0) {
              this.setDragState(pointer, 0);
              return 0;
            } else if (draglist.length > 1) {
              this.sortGameObjects(draglist, pointer);
              if (this.topOnly) {
                draglist.splice(1);
              }
            }
            this._drag[pointer.id] = draglist;
            if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0) {
              this.setDragState(pointer, 3);
              return this.processDragStartList(pointer);
            } else {
              this.setDragState(pointer, 2);
              return 0;
            }
          },
          processDragMoveEvent: function(pointer) {
            if (this.getDragState(pointer) === 2) {
              this.processDragThresholdEvent(pointer, this.manager.game.loop.now);
            }
            if (this.getDragState(pointer) !== 4) {
              return 0;
            }
            var dropZones = this._tempZones;
            var list = this._drag[pointer.id];
            for (var i2 = 0; i2 < list.length; i2++) {
              var gameObject = list[i2];
              var input = gameObject.input;
              var target = input.target;
              if (target) {
                var index2 = dropZones.indexOf(target);
                if (index2 === 0) {
                  gameObject.emit(Events.GAMEOBJECT_DRAG_OVER, pointer, target);
                  this.emit(Events.DRAG_OVER, pointer, gameObject, target);
                } else if (index2 > 0) {
                  gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);
                  this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);
                  input.target = dropZones[0];
                  target = input.target;
                  gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
                  this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
                } else {
                  gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);
                  this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);
                  if (dropZones[0]) {
                    input.target = dropZones[0];
                    target = input.target;
                    gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
                    this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
                  } else {
                    input.target = null;
                  }
                }
              } else if (!target && dropZones[0]) {
                input.target = dropZones[0];
                target = input.target;
                gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
                this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
              }
              var dragX;
              var dragY;
              if (!gameObject.parentContainer) {
                dragX = pointer.worldX - input.dragX;
                dragY = pointer.worldY - input.dragY;
              } else {
                var dx = pointer.worldX - input.dragStartXGlobal;
                var dy = pointer.worldY - input.dragStartYGlobal;
                var rotation = gameObject.getParentRotation();
                var dxRotated = dx * Math.cos(rotation) + dy * Math.sin(rotation);
                var dyRotated = dy * Math.cos(rotation) - dx * Math.sin(rotation);
                dxRotated *= 1 / gameObject.parentContainer.scaleX;
                dyRotated *= 1 / gameObject.parentContainer.scaleY;
                dragX = dxRotated + input.dragStartX;
                dragY = dyRotated + input.dragStartY;
              }
              gameObject.emit(Events.GAMEOBJECT_DRAG, pointer, dragX, dragY);
              this.emit(Events.DRAG, pointer, gameObject, dragX, dragY);
            }
            return list.length;
          },
          processDragUpEvent: function(pointer) {
            var list = this._drag[pointer.id];
            for (var i2 = 0; i2 < list.length; i2++) {
              var gameObject = list[i2];
              var input = gameObject.input;
              if (input && input.dragState === 2) {
                input.dragState = 0;
                input.dragX = input.localX - gameObject.displayOriginX;
                input.dragY = input.localY - gameObject.displayOriginY;
                var dropped = false;
                var target = input.target;
                if (target) {
                  gameObject.emit(Events.GAMEOBJECT_DROP, pointer, target);
                  this.emit(Events.DROP, pointer, gameObject, target);
                  input.target = null;
                  dropped = true;
                }
                if (gameObject.input) {
                  gameObject.emit(Events.GAMEOBJECT_DRAG_END, pointer, input.dragX, input.dragY, dropped);
                  this.emit(Events.DRAG_END, pointer, gameObject, dropped);
                }
              }
            }
            this.setDragState(pointer, 0);
            list.splice(0);
            return 0;
          },
          processMoveEvents: function(pointer) {
            var total = 0;
            var currentlyOver = this._temp;
            var _eventData = this._eventData;
            var _eventContainer = this._eventContainer;
            _eventData.cancelled = false;
            var aborted = false;
            for (var i2 = 0; i2 < currentlyOver.length; i2++) {
              var gameObject = currentlyOver[i2];
              if (!gameObject.input) {
                continue;
              }
              total++;
              gameObject.emit(Events.GAMEOBJECT_POINTER_MOVE, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
              if (_eventData.cancelled || !gameObject.input) {
                aborted = true;
                break;
              }
              this.emit(Events.GAMEOBJECT_MOVE, pointer, gameObject, _eventContainer);
              if (_eventData.cancelled || !gameObject.input) {
                aborted = true;
                break;
              }
              if (this.topOnly) {
                break;
              }
            }
            if (!aborted) {
              this.emit(Events.POINTER_MOVE, pointer, currentlyOver);
            }
            return total;
          },
          processWheelEvent: function(pointer) {
            var total = 0;
            var currentlyOver = this._temp;
            var _eventData = this._eventData;
            var _eventContainer = this._eventContainer;
            _eventData.cancelled = false;
            var aborted = false;
            var dx = pointer.deltaX;
            var dy = pointer.deltaY;
            var dz = pointer.deltaZ;
            for (var i2 = 0; i2 < currentlyOver.length; i2++) {
              var gameObject = currentlyOver[i2];
              if (!gameObject.input) {
                continue;
              }
              total++;
              gameObject.emit(Events.GAMEOBJECT_POINTER_WHEEL, pointer, dx, dy, dz, _eventContainer);
              if (_eventData.cancelled || !gameObject.input) {
                aborted = true;
                break;
              }
              this.emit(Events.GAMEOBJECT_WHEEL, pointer, gameObject, dx, dy, dz, _eventContainer);
              if (_eventData.cancelled || !gameObject.input) {
                aborted = true;
                break;
              }
            }
            if (!aborted) {
              this.emit(Events.POINTER_WHEEL, pointer, currentlyOver, dx, dy, dz);
            }
            return total;
          },
          processOverEvents: function(pointer) {
            var currentlyOver = this._temp;
            var totalInteracted = 0;
            var total = currentlyOver.length;
            var justOver = [];
            if (total > 0) {
              var manager = this.manager;
              var _eventData = this._eventData;
              var _eventContainer = this._eventContainer;
              _eventData.cancelled = false;
              var aborted = false;
              for (var i2 = 0; i2 < total; i2++) {
                var gameObject = currentlyOver[i2];
                if (!gameObject.input) {
                  continue;
                }
                justOver.push(gameObject);
                manager.setCursor(gameObject.input);
                gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                totalInteracted++;
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
              }
              if (!aborted) {
                this.emit(Events.POINTER_OVER, pointer, justOver);
              }
            }
            this._over[pointer.id] = justOver;
            return totalInteracted;
          },
          processOutEvents: function(pointer) {
            var previouslyOver = this._over[pointer.id];
            var totalInteracted = 0;
            var total = previouslyOver.length;
            if (total > 0) {
              var manager = this.manager;
              var _eventData = this._eventData;
              var _eventContainer = this._eventContainer;
              _eventData.cancelled = false;
              var aborted = false;
              this.sortGameObjects(previouslyOver, pointer);
              for (var i2 = 0; i2 < total; i2++) {
                var gameObject = previouslyOver[i2];
                gameObject = previouslyOver[i2];
                if (!gameObject.input) {
                  continue;
                }
                manager.resetCursor(gameObject.input);
                gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);
                totalInteracted++;
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                if (!aborted) {
                  this.emit(Events.POINTER_OUT, pointer, previouslyOver);
                }
              }
              this._over[pointer.id] = [];
            }
            return totalInteracted;
          },
          processOverOutEvents: function(pointer) {
            var currentlyOver = this._temp;
            var i2;
            var gameObject;
            var justOut = [];
            var justOver = [];
            var stillOver = [];
            var previouslyOver = this._over[pointer.id];
            var currentlyDragging = this._drag[pointer.id];
            var manager = this.manager;
            for (i2 = 0; i2 < previouslyOver.length; i2++) {
              gameObject = previouslyOver[i2];
              if (currentlyOver.indexOf(gameObject) === -1 && currentlyDragging.indexOf(gameObject) === -1) {
                justOut.push(gameObject);
              } else {
                stillOver.push(gameObject);
              }
            }
            for (i2 = 0; i2 < currentlyOver.length; i2++) {
              gameObject = currentlyOver[i2];
              if (previouslyOver.indexOf(gameObject) === -1) {
                justOver.push(gameObject);
              }
            }
            var total = justOut.length;
            var totalInteracted = 0;
            var _eventData = this._eventData;
            var _eventContainer = this._eventContainer;
            _eventData.cancelled = false;
            var aborted = false;
            if (total > 0) {
              this.sortGameObjects(justOut, pointer);
              for (i2 = 0; i2 < total; i2++) {
                gameObject = justOut[i2];
                if (!gameObject.input) {
                  continue;
                }
                manager.resetCursor(gameObject.input);
                gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);
                totalInteracted++;
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
              }
              if (!aborted) {
                this.emit(Events.POINTER_OUT, pointer, justOut);
              }
            }
            total = justOver.length;
            _eventData.cancelled = false;
            aborted = false;
            if (total > 0) {
              this.sortGameObjects(justOver, pointer);
              for (i2 = 0; i2 < total; i2++) {
                gameObject = justOver[i2];
                if (!gameObject.input) {
                  continue;
                }
                manager.setCursor(gameObject.input);
                gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                totalInteracted++;
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
              }
              if (!aborted) {
                this.emit(Events.POINTER_OVER, pointer, justOver);
              }
            }
            previouslyOver = stillOver.concat(justOver);
            this._over[pointer.id] = this.sortGameObjects(previouslyOver, pointer);
            return totalInteracted;
          },
          processUpEvents: function(pointer) {
            var currentlyOver = this._temp;
            var _eventData = this._eventData;
            var _eventContainer = this._eventContainer;
            _eventData.cancelled = false;
            var aborted = false;
            for (var i2 = 0; i2 < currentlyOver.length; i2++) {
              var gameObject = currentlyOver[i2];
              if (!gameObject.input) {
                continue;
              }
              gameObject.emit(Events.GAMEOBJECT_POINTER_UP, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
              if (_eventData.cancelled || !gameObject.input) {
                aborted = true;
                break;
              }
              this.emit(Events.GAMEOBJECT_UP, pointer, gameObject, _eventContainer);
              if (_eventData.cancelled || !gameObject.input) {
                aborted = true;
                break;
              }
            }
            if (!aborted && this.manager) {
              if (pointer.upElement === this.manager.game.canvas) {
                this.emit(Events.POINTER_UP, pointer, currentlyOver);
              } else {
                this.emit(Events.POINTER_UP_OUTSIDE, pointer);
              }
            }
            return currentlyOver.length;
          },
          queueForInsertion: function(child) {
            if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1) {
              this._pendingInsertion.push(child);
            }
            return this;
          },
          queueForRemoval: function(child) {
            this._pendingRemoval.push(child);
            return this;
          },
          setDraggable: function(gameObjects, value) {
            if (value === void 0) {
              value = true;
            }
            if (!Array.isArray(gameObjects)) {
              gameObjects = [gameObjects];
            }
            for (var i2 = 0; i2 < gameObjects.length; i2++) {
              var gameObject = gameObjects[i2];
              gameObject.input.draggable = value;
              var index2 = this._draggable.indexOf(gameObject);
              if (value && index2 === -1) {
                this._draggable.push(gameObject);
              } else if (!value && index2 > -1) {
                this._draggable.splice(index2, 1);
              }
            }
            return this;
          },
          makePixelPerfect: function(alphaTolerance) {
            if (alphaTolerance === void 0) {
              alphaTolerance = 1;
            }
            var textureManager = this.systems.textures;
            return CreatePixelPerfectHandler(textureManager, alphaTolerance);
          },
          setHitArea: function(gameObjects, hitArea, hitAreaCallback) {
            if (hitArea === void 0) {
              return this.setHitAreaFromTexture(gameObjects);
            }
            if (!Array.isArray(gameObjects)) {
              gameObjects = [gameObjects];
            }
            var draggable = false;
            var dropZone = false;
            var cursor = false;
            var useHandCursor = false;
            var pixelPerfect = false;
            var customHitArea = true;
            if (IsPlainObject2(hitArea)) {
              var config = hitArea;
              hitArea = GetFastValue(config, "hitArea", null);
              hitAreaCallback = GetFastValue(config, "hitAreaCallback", null);
              draggable = GetFastValue(config, "draggable", false);
              dropZone = GetFastValue(config, "dropZone", false);
              cursor = GetFastValue(config, "cursor", false);
              useHandCursor = GetFastValue(config, "useHandCursor", false);
              pixelPerfect = GetFastValue(config, "pixelPerfect", false);
              var alphaTolerance = GetFastValue(config, "alphaTolerance", 1);
              if (pixelPerfect) {
                hitArea = {};
                hitAreaCallback = this.makePixelPerfect(alphaTolerance);
              }
              if (!hitArea || !hitAreaCallback) {
                this.setHitAreaFromTexture(gameObjects);
                customHitArea = false;
              }
            } else if (typeof hitArea === "function" && !hitAreaCallback) {
              hitAreaCallback = hitArea;
              hitArea = {};
            }
            for (var i2 = 0; i2 < gameObjects.length; i2++) {
              var gameObject = gameObjects[i2];
              if (pixelPerfect && gameObject.type === "Container") {
                console.warn("Cannot pixelPerfect test a Container. Use a custom callback.");
                continue;
              }
              var io = !gameObject.input ? CreateInteractiveObject(gameObject, hitArea, hitAreaCallback) : gameObject.input;
              io.customHitArea = customHitArea;
              io.dropZone = dropZone;
              io.cursor = useHandCursor ? "pointer" : cursor;
              gameObject.input = io;
              if (draggable) {
                this.setDraggable(gameObject);
              }
              this.queueForInsertion(gameObject);
            }
            return this;
          },
          setHitAreaCircle: function(gameObjects, x2, y2, radius, callback) {
            if (callback === void 0) {
              callback = CircleContains;
            }
            var shape = new Circle(x2, y2, radius);
            return this.setHitArea(gameObjects, shape, callback);
          },
          setHitAreaEllipse: function(gameObjects, x2, y2, width, height, callback) {
            if (callback === void 0) {
              callback = EllipseContains;
            }
            var shape = new Ellipse(x2, y2, width, height);
            return this.setHitArea(gameObjects, shape, callback);
          },
          setHitAreaFromTexture: function(gameObjects, callback) {
            if (callback === void 0) {
              callback = RectangleContains;
            }
            if (!Array.isArray(gameObjects)) {
              gameObjects = [gameObjects];
            }
            for (var i2 = 0; i2 < gameObjects.length; i2++) {
              var gameObject = gameObjects[i2];
              var frame = gameObject.frame;
              var width = 0;
              var height = 0;
              if (gameObject.width) {
                width = gameObject.width;
                height = gameObject.height;
              } else if (frame) {
                width = frame.realWidth;
                height = frame.realHeight;
              }
              if (gameObject.type === "Container" && (width === 0 || height === 0)) {
                console.warn("Container.setInteractive must specify a Shape or call setSize() first");
                continue;
              }
              if (width !== 0 && height !== 0) {
                gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);
                this.queueForInsertion(gameObject);
              }
            }
            return this;
          },
          setHitAreaRectangle: function(gameObjects, x2, y2, width, height, callback) {
            if (callback === void 0) {
              callback = RectangleContains;
            }
            var shape = new Rectangle(x2, y2, width, height);
            return this.setHitArea(gameObjects, shape, callback);
          },
          setHitAreaTriangle: function(gameObjects, x1, y1, x2, y2, x3, y3, callback) {
            if (callback === void 0) {
              callback = TriangleContains;
            }
            var shape = new Triangle(x1, y1, x2, y2, x3, y3);
            return this.setHitArea(gameObjects, shape, callback);
          },
          enableDebug: function(gameObject, color) {
            if (color === void 0) {
              color = 65280;
            }
            var input = gameObject.input;
            if (!input || !input.hitArea) {
              return this;
            }
            var shape = input.hitArea;
            var shapeType = shape.type;
            var debug = input.hitAreaDebug;
            var factory = this.systems.add;
            var updateList = this.systems.updateList;
            if (debug) {
              updateList.remove(debug);
              debug.destroy();
              debug = null;
            }
            var offsetx = 0;
            var offsety = 0;
            switch (shapeType) {
              case GEOM_CONST.CIRCLE:
                debug = factory.arc(0, 0, shape.radius);
                offsetx = shape.x - shape.radius;
                offsety = shape.y - shape.radius;
                break;
              case GEOM_CONST.ELLIPSE:
                debug = factory.ellipse(0, 0, shape.width, shape.height);
                offsetx = shape.x - shape.width / 2;
                offsety = shape.y - shape.height / 2;
                break;
              case GEOM_CONST.LINE:
                debug = factory.line(0, 0, shape.x1, shape.y1, shape.x2, shape.y2);
                break;
              case GEOM_CONST.POLYGON:
                debug = factory.polygon(0, 0, shape.points);
                break;
              case GEOM_CONST.RECTANGLE:
                debug = factory.rectangle(0, 0, shape.width, shape.height);
                offsetx = shape.x;
                offsety = shape.y;
                break;
              case GEOM_CONST.TRIANGLE:
                debug = factory.triangle(0, 0, shape.x1, shape.y1, shape.x2, shape.y2, shape.x3, shape.y3);
                break;
            }
            if (debug) {
              debug.isFilled = false;
              debug.preUpdate = function() {
                debug.setStrokeStyle(1 / gameObject.scale, color);
                debug.setDisplayOrigin(gameObject.displayOriginX, gameObject.displayOriginY);
                var x2 = gameObject.x;
                var y2 = gameObject.y;
                var rotation = gameObject.rotation;
                var scaleX = gameObject.scaleX;
                var scaleY = gameObject.scaleY;
                if (gameObject.parentContainer) {
                  var matrix = gameObject.getWorldTransformMatrix();
                  x2 = matrix.tx;
                  y2 = matrix.ty;
                  rotation = matrix.rotation;
                  scaleX = matrix.scaleX;
                  scaleY = matrix.scaleY;
                }
                debug.setRotation(rotation);
                debug.setScale(scaleX, scaleY);
                debug.setPosition(x2 + offsetx, y2 + offsety);
                debug.setScrollFactor(gameObject.scrollFactorX, gameObject.scrollFactorY);
                debug.setDepth(gameObject.depth);
              };
              updateList.add(debug);
              input.hitAreaDebug = debug;
            }
            return this;
          },
          removeDebug: function(gameObject) {
            var input = gameObject.input;
            if (input && input.hitAreaDebug) {
              var debug = input.hitAreaDebug;
              this.systems.updateList.remove(debug);
              debug.destroy();
              input.hitAreaDebug = null;
            }
            return this;
          },
          setPollAlways: function() {
            return this.setPollRate(0);
          },
          setPollOnMove: function() {
            return this.setPollRate(-1);
          },
          setPollRate: function(value) {
            this.pollRate = value;
            this._pollTimer = 0;
            return this;
          },
          setGlobalTopOnly: function(value) {
            this.manager.globalTopOnly = value;
            return this;
          },
          setTopOnly: function(value) {
            this.topOnly = value;
            return this;
          },
          sortGameObjects: function(gameObjects, pointer) {
            if (gameObjects.length < 2) {
              return gameObjects;
            }
            var list = pointer.camera.renderList;
            return gameObjects.sort(function(childA, childB) {
              return list.indexOf(childB) - list.indexOf(childA);
            });
          },
          sortDropZones: function(gameObjects) {
            if (gameObjects.length < 2) {
              return gameObjects;
            }
            this.scene.sys.depthSort();
            return gameObjects.sort(this.sortDropZoneHandler.bind(this));
          },
          sortDropZoneHandler: function(childA, childB) {
            if (!childA.parentContainer && !childB.parentContainer) {
              return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);
            } else if (childA.parentContainer === childB.parentContainer) {
              return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);
            } else if (childA.parentContainer === childB) {
              return -1;
            } else if (childB.parentContainer === childA) {
              return 1;
            } else {
              var listA = childA.getIndexList();
              var listB = childB.getIndexList();
              var len = Math.min(listA.length, listB.length);
              for (var i2 = 0; i2 < len; i2++) {
                var indexA = listA[i2];
                var indexB = listB[i2];
                if (indexA === indexB) {
                  continue;
                } else {
                  return indexB - indexA;
                }
              }
              return listB.length - listA.length;
            }
          },
          stopPropagation: function() {
            this.manager._tempSkip = true;
            return this;
          },
          addPointer: function(quantity) {
            return this.manager.addPointer(quantity);
          },
          setDefaultCursor: function(cursor) {
            this.manager.setDefaultCursor(cursor);
            return this;
          },
          transitionIn: function() {
            this.enabled = this.settings.transitionAllowInput;
          },
          transitionComplete: function() {
            if (!this.settings.transitionAllowInput) {
              this.enabled = true;
            }
          },
          transitionOut: function() {
            this.enabled = this.settings.transitionAllowInput;
          },
          shutdown: function() {
            this.pluginEvents.emit(Events.SHUTDOWN);
            this._temp.length = 0;
            this._list.length = 0;
            this._draggable.length = 0;
            this._pendingRemoval.length = 0;
            this._pendingInsertion.length = 0;
            this._dragState.length = 0;
            for (var i2 = 0; i2 < 10; i2++) {
              this._drag[i2] = [];
              this._over[i2] = [];
            }
            this.removeAllListeners();
            var manager = this.manager;
            manager.canvas.style.cursor = manager.defaultCursor;
            var eventEmitter = this.systems.events;
            eventEmitter.off(SceneEvents.TRANSITION_START, this.transitionIn, this);
            eventEmitter.off(SceneEvents.TRANSITION_OUT, this.transitionOut, this);
            eventEmitter.off(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);
            eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
            manager.events.off(Events.GAME_OUT, this.onGameOut, this);
            manager.events.off(Events.GAME_OVER, this.onGameOver, this);
            eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          destroy: function() {
            this.shutdown();
            this.pluginEvents.emit(Events.DESTROY);
            this.pluginEvents.removeAllListeners();
            this.scene.sys.events.off(SceneEvents.START, this.start, this);
            this.scene = null;
            this.cameras = null;
            this.manager = null;
            this.events = null;
            this.mouse = null;
          },
          x: {
            get: function() {
              return this.manager.activePointer.x;
            }
          },
          y: {
            get: function() {
              return this.manager.activePointer.y;
            }
          },
          isOver: {
            get: function() {
              return this.manager.isOver;
            }
          },
          mousePointer: {
            get: function() {
              return this.manager.mousePointer;
            }
          },
          activePointer: {
            get: function() {
              return this.manager.activePointer;
            }
          },
          pointer1: {
            get: function() {
              return this.manager.pointers[1];
            }
          },
          pointer2: {
            get: function() {
              return this.manager.pointers[2];
            }
          },
          pointer3: {
            get: function() {
              return this.manager.pointers[3];
            }
          },
          pointer4: {
            get: function() {
              return this.manager.pointers[4];
            }
          },
          pointer5: {
            get: function() {
              return this.manager.pointers[5];
            }
          },
          pointer6: {
            get: function() {
              return this.manager.pointers[6];
            }
          },
          pointer7: {
            get: function() {
              return this.manager.pointers[7];
            }
          },
          pointer8: {
            get: function() {
              return this.manager.pointers[8];
            }
          },
          pointer9: {
            get: function() {
              return this.manager.pointers[9];
            }
          },
          pointer10: {
            get: function() {
              return this.manager.pointers[10];
            }
          }
        });
        PluginCache.register("InputPlugin", InputPlugin, "input");
        module2.exports = InputPlugin;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Events: __webpack_require__(154),
          KeyboardManager: __webpack_require__(410),
          KeyboardPlugin: __webpack_require__(1330),
          Key: __webpack_require__(512),
          KeyCodes: __webpack_require__(143),
          KeyCombo: __webpack_require__(513),
          AdvanceKeyCombo: __webpack_require__(515),
          ProcessKeyCombo: __webpack_require__(514),
          ResetKeyCombo: __webpack_require__(516),
          JustDown: __webpack_require__(1332),
          JustUp: __webpack_require__(1333),
          DownDuration: __webpack_require__(1334),
          UpDuration: __webpack_require__(1335)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "keydown";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "keyup";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "keycombomatch";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "down";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "keydown-";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "keyup-";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "up";
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(154);
        var GameEvents = __webpack_require__(22);
        var GetValue = __webpack_require__(6);
        var InputEvents = __webpack_require__(51);
        var InputPluginCache = __webpack_require__(153);
        var Key = __webpack_require__(512);
        var KeyCodes = __webpack_require__(143);
        var KeyCombo = __webpack_require__(513);
        var KeyMap = __webpack_require__(1331);
        var SceneEvents = __webpack_require__(20);
        var SnapFloor = __webpack_require__(76);
        var KeyboardPlugin = new Class({
          Extends: EventEmitter,
          initialize: function KeyboardPlugin2(sceneInputPlugin) {
            EventEmitter.call(this);
            this.game = sceneInputPlugin.systems.game;
            this.scene = sceneInputPlugin.scene;
            this.settings = this.scene.sys.settings;
            this.sceneInputPlugin = sceneInputPlugin;
            this.manager = sceneInputPlugin.manager.keyboard;
            this.enabled = true;
            this.keys = [];
            this.combos = [];
            this.prevCode = null;
            this.prevTime = 0;
            this.prevType = null;
            sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);
            sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
          },
          boot: function() {
            var settings = this.settings.input;
            this.enabled = GetValue(settings, "keyboard", true);
            var captures = GetValue(settings, "keyboard.capture", null);
            if (captures) {
              this.addCaptures(captures);
            }
            this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
          },
          start: function() {
            this.sceneInputPlugin.manager.events.on(InputEvents.MANAGER_PROCESS, this.update, this);
            this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);
            this.game.events.on(GameEvents.BLUR, this.resetKeys, this);
            this.scene.sys.events.on(SceneEvents.PAUSE, this.resetKeys, this);
            this.scene.sys.events.on(SceneEvents.SLEEP, this.resetKeys, this);
          },
          isActive: function() {
            return this.enabled && this.scene.sys.isActive();
          },
          addCapture: function(keycode) {
            this.manager.addCapture(keycode);
            return this;
          },
          removeCapture: function(keycode) {
            this.manager.removeCapture(keycode);
            return this;
          },
          getCaptures: function() {
            return this.manager.captures;
          },
          enableGlobalCapture: function() {
            this.manager.preventDefault = true;
            return this;
          },
          disableGlobalCapture: function() {
            this.manager.preventDefault = false;
            return this;
          },
          clearCaptures: function() {
            this.manager.clearCaptures();
            return this;
          },
          createCursorKeys: function() {
            return this.addKeys({
              up: KeyCodes.UP,
              down: KeyCodes.DOWN,
              left: KeyCodes.LEFT,
              right: KeyCodes.RIGHT,
              space: KeyCodes.SPACE,
              shift: KeyCodes.SHIFT
            });
          },
          addKeys: function(keys, enableCapture, emitOnRepeat) {
            if (enableCapture === void 0) {
              enableCapture = true;
            }
            if (emitOnRepeat === void 0) {
              emitOnRepeat = false;
            }
            var output = {};
            if (typeof keys === "string") {
              keys = keys.split(",");
              for (var i2 = 0; i2 < keys.length; i2++) {
                var currentKey = keys[i2].trim();
                if (currentKey) {
                  output[currentKey] = this.addKey(currentKey, enableCapture, emitOnRepeat);
                }
              }
            } else {
              for (var key in keys) {
                output[key] = this.addKey(keys[key], enableCapture, emitOnRepeat);
              }
            }
            return output;
          },
          addKey: function(key, enableCapture, emitOnRepeat) {
            if (enableCapture === void 0) {
              enableCapture = true;
            }
            if (emitOnRepeat === void 0) {
              emitOnRepeat = false;
            }
            var keys = this.keys;
            if (key instanceof Key) {
              var idx = keys.indexOf(key);
              if (idx > -1) {
                keys[idx] = key;
              } else {
                keys[key.keyCode] = key;
              }
              if (enableCapture) {
                this.addCapture(key.keyCode);
              }
              key.setEmitOnRepeat(emitOnRepeat);
              return key;
            }
            if (typeof key === "string") {
              key = KeyCodes[key.toUpperCase()];
            }
            if (!keys[key]) {
              keys[key] = new Key(this, key);
              if (enableCapture) {
                this.addCapture(key);
              }
              keys[key].setEmitOnRepeat(emitOnRepeat);
            }
            return keys[key];
          },
          removeKey: function(key, destroy) {
            if (destroy === void 0) {
              destroy = false;
            }
            var keys = this.keys;
            var ref;
            if (key instanceof Key) {
              var idx = keys.indexOf(key);
              if (idx > -1) {
                ref = this.keys[idx];
                this.keys[idx] = void 0;
              }
            } else if (typeof key === "string") {
              key = KeyCodes[key.toUpperCase()];
            }
            if (keys[key]) {
              ref = keys[key];
              keys[key] = void 0;
            }
            if (ref) {
              ref.plugin = null;
              if (destroy) {
                ref.destroy();
              }
            }
            return this;
          },
          removeAllKeys: function(destroy) {
            var keys = this.keys;
            for (var i2 = 0; i2 < keys.length; i2++) {
              var key = keys[i2];
              if (key) {
                keys[i2] = void 0;
                if (destroy) {
                  key.destroy();
                }
              }
            }
            return this;
          },
          createCombo: function(keys, config) {
            return new KeyCombo(this, keys, config);
          },
          checkDown: function(key, duration) {
            if (duration === void 0) {
              duration = 0;
            }
            if (this.enabled && key.isDown) {
              var t2 = SnapFloor(this.time - key.timeDown, duration);
              if (t2 > key._tick) {
                key._tick = t2;
                return true;
              }
            }
            return false;
          },
          update: function() {
            var queue = this.manager.queue;
            var len = queue.length;
            if (!this.isActive() || len === 0) {
              return;
            }
            var keys = this.keys;
            for (var i2 = 0; i2 < len; i2++) {
              var event = queue[i2];
              var code = event.keyCode;
              var key = keys[code];
              var repeat = false;
              if (event.cancelled === void 0) {
                event.cancelled = 0;
                event.stopImmediatePropagation = function() {
                  event.cancelled = 1;
                };
                event.stopPropagation = function() {
                  event.cancelled = -1;
                };
              }
              if (event.cancelled === -1) {
                continue;
              }
              if (code === this.prevCode && event.timeStamp === this.prevTime && event.type === this.prevType) {
                continue;
              }
              this.prevCode = code;
              this.prevTime = event.timeStamp;
              this.prevType = event.type;
              if (event.type === "keydown") {
                if (key) {
                  repeat = key.isDown;
                  key.onDown(event);
                }
                if (!event.cancelled && (!key || !repeat)) {
                  if (KeyMap[code]) {
                    this.emit(Events.KEY_DOWN + KeyMap[code], event);
                  }
                  if (!event.cancelled) {
                    this.emit(Events.ANY_KEY_DOWN, event);
                  }
                }
              } else {
                if (key) {
                  key.onUp(event);
                }
                if (!event.cancelled) {
                  if (KeyMap[code]) {
                    this.emit(Events.KEY_UP + KeyMap[code], event);
                  }
                  if (!event.cancelled) {
                    this.emit(Events.ANY_KEY_UP, event);
                  }
                }
              }
              if (event.cancelled === 1) {
                event.cancelled = 0;
              }
            }
          },
          resetKeys: function() {
            var keys = this.keys;
            for (var i2 = 0; i2 < keys.length; i2++) {
              if (keys[i2]) {
                keys[i2].reset();
              }
            }
            return this;
          },
          shutdown: function() {
            this.removeAllKeys(true);
            this.removeAllListeners();
            this.sceneInputPlugin.manager.events.off(InputEvents.MANAGER_PROCESS, this.update, this);
            this.game.events.off(GameEvents.BLUR, this.resetKeys);
            this.scene.sys.events.off(SceneEvents.PAUSE, this.resetKeys, this);
            this.scene.sys.events.off(SceneEvents.SLEEP, this.resetKeys, this);
            this.queue = [];
          },
          destroy: function() {
            this.shutdown();
            var keys = this.keys;
            for (var i2 = 0; i2 < keys.length; i2++) {
              if (keys[i2]) {
                keys[i2].destroy();
              }
            }
            this.keys = [];
            this.combos = [];
            this.queue = [];
            this.scene = null;
            this.settings = null;
            this.sceneInputPlugin = null;
            this.manager = null;
          },
          time: {
            get: function() {
              return this.sceneInputPlugin.manager.time;
            }
          }
        });
        InputPluginCache.register("KeyboardPlugin", KeyboardPlugin, "keyboard", "keyboard", "inputKeyboard");
        module2.exports = KeyboardPlugin;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var KeyCodes = __webpack_require__(143);
        var KeyMap = {};
        for (var key in KeyCodes) {
          KeyMap[KeyCodes[key]] = key;
        }
        module2.exports = KeyMap;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var JustDown = function(key) {
          if (key._justDown) {
            key._justDown = false;
            return true;
          } else {
            return false;
          }
        };
        module2.exports = JustDown;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var JustUp = function(key) {
          if (key._justUp) {
            key._justUp = false;
            return true;
          } else {
            return false;
          }
        };
        module2.exports = JustUp;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var DownDuration = function(key, duration) {
          if (duration === void 0) {
            duration = 50;
          }
          var current = key.plugin.game.loop.time - key.timeDown;
          return key.isDown && current < duration;
        };
        module2.exports = DownDuration;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var UpDuration = function(key, duration) {
          if (duration === void 0) {
            duration = 50;
          }
          var current = key.plugin.game.loop.time - key.timeUp;
          return key.isUp && current < duration;
        };
        module2.exports = UpDuration;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          MouseManager: __webpack_require__(411)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          TouchManager: __webpack_require__(413)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(21);
        var Extend = __webpack_require__(17);
        var Loader = {
          Events: __webpack_require__(95),
          FileTypes: __webpack_require__(1339),
          File: __webpack_require__(23),
          FileTypesManager: __webpack_require__(8),
          GetURL: __webpack_require__(155),
          LoaderPlugin: __webpack_require__(1365),
          MergeXHRSettings: __webpack_require__(240),
          MultiFile: __webpack_require__(49),
          XHRLoader: __webpack_require__(517),
          XHRSettings: __webpack_require__(156)
        };
        Loader = Extend(false, Loader, CONST);
        module2.exports = Loader;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          AnimationJSONFile: __webpack_require__(1340),
          AsepriteFile: __webpack_require__(1341),
          AtlasJSONFile: __webpack_require__(1342),
          AtlasXMLFile: __webpack_require__(1343),
          AudioFile: __webpack_require__(518),
          AudioSpriteFile: __webpack_require__(1344),
          BinaryFile: __webpack_require__(1345),
          BitmapFontFile: __webpack_require__(1346),
          CSSFile: __webpack_require__(1347),
          GLSLFile: __webpack_require__(1348),
          HTML5AudioFile: __webpack_require__(519),
          HTMLFile: __webpack_require__(1349),
          HTMLTextureFile: __webpack_require__(1350),
          ImageFile: __webpack_require__(71),
          JSONFile: __webpack_require__(61),
          MultiAtlasFile: __webpack_require__(1351),
          MultiScriptFile: __webpack_require__(1352),
          OBJFile: __webpack_require__(1353),
          PackFile: __webpack_require__(1354),
          PluginFile: __webpack_require__(1355),
          SceneFile: __webpack_require__(1356),
          ScenePluginFile: __webpack_require__(1357),
          ScriptFile: __webpack_require__(520),
          SpriteSheetFile: __webpack_require__(1358),
          SVGFile: __webpack_require__(1359),
          TextFile: __webpack_require__(242),
          TilemapCSVFile: __webpack_require__(1360),
          TilemapImpactFile: __webpack_require__(1361),
          TilemapJSONFile: __webpack_require__(1362),
          UnityAtlasFile: __webpack_require__(1363),
          VideoFile: __webpack_require__(1364),
          XMLFile: __webpack_require__(241)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FileTypesManager = __webpack_require__(8);
        var JSONFile = __webpack_require__(61);
        var LoaderEvents = __webpack_require__(95);
        var AnimationJSONFile = new Class({
          Extends: JSONFile,
          initialize: function AnimationJSONFile2(loader, key, url, xhrSettings, dataKey) {
            JSONFile.call(this, loader, key, url, xhrSettings, dataKey);
            this.type = "animationJSON";
          },
          onProcess: function() {
            this.loader.once(LoaderEvents.POST_PROCESS, this.onLoadComplete, this);
            JSONFile.prototype.onProcess.call(this);
          },
          onLoadComplete: function() {
            this.loader.systems.anims.fromJSON(this.data);
          }
        });
        FileTypesManager.register("animation", function(key, url, dataKey, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new AnimationJSONFile(this, key[i2]));
            }
          } else {
            this.addFile(new AnimationJSONFile(this, key, url, xhrSettings, dataKey));
          }
          return this;
        });
        module2.exports = AnimationJSONFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var ImageFile = __webpack_require__(71);
        var IsPlainObject2 = __webpack_require__(7);
        var JSONFile = __webpack_require__(61);
        var MultiFile = __webpack_require__(49);
        var AsepriteFile = new Class({
          Extends: MultiFile,
          initialize: function AsepriteFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
            var image;
            var data;
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              image = new ImageFile(loader, {
                key,
                url: GetFastValue(config, "textureURL"),
                extension: GetFastValue(config, "textureExtension", "png"),
                normalMap: GetFastValue(config, "normalMap"),
                xhrSettings: GetFastValue(config, "textureXhrSettings")
              });
              data = new JSONFile(loader, {
                key,
                url: GetFastValue(config, "atlasURL"),
                extension: GetFastValue(config, "atlasExtension", "json"),
                xhrSettings: GetFastValue(config, "atlasXhrSettings")
              });
            } else {
              image = new ImageFile(loader, key, textureURL, textureXhrSettings);
              data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
            }
            if (image.linkFile) {
              MultiFile.call(this, loader, "atlasjson", key, [image, data, image.linkFile]);
            } else {
              MultiFile.call(this, loader, "atlasjson", key, [image, data]);
            }
          },
          addToCache: function() {
            if (this.isReadyToProcess()) {
              var image = this.files[0];
              var json = this.files[1];
              var normalMap = this.files[2] ? this.files[2].data : null;
              this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);
              json.addToCache();
              this.complete = true;
            }
          }
        });
        FileTypesManager.register("aseprite", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
          var multifile;
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              multifile = new AsepriteFile(this, key[i2]);
              this.addFile(multifile.files);
            }
          } else {
            multifile = new AsepriteFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
            this.addFile(multifile.files);
          }
          return this;
        });
        module2.exports = AsepriteFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var ImageFile = __webpack_require__(71);
        var IsPlainObject2 = __webpack_require__(7);
        var JSONFile = __webpack_require__(61);
        var MultiFile = __webpack_require__(49);
        var AtlasJSONFile = new Class({
          Extends: MultiFile,
          initialize: function AtlasJSONFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
            var image;
            var data;
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              image = new ImageFile(loader, {
                key,
                url: GetFastValue(config, "textureURL"),
                extension: GetFastValue(config, "textureExtension", "png"),
                normalMap: GetFastValue(config, "normalMap"),
                xhrSettings: GetFastValue(config, "textureXhrSettings")
              });
              data = new JSONFile(loader, {
                key,
                url: GetFastValue(config, "atlasURL"),
                extension: GetFastValue(config, "atlasExtension", "json"),
                xhrSettings: GetFastValue(config, "atlasXhrSettings")
              });
            } else {
              image = new ImageFile(loader, key, textureURL, textureXhrSettings);
              data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
            }
            if (image.linkFile) {
              MultiFile.call(this, loader, "atlasjson", key, [image, data, image.linkFile]);
            } else {
              MultiFile.call(this, loader, "atlasjson", key, [image, data]);
            }
          },
          addToCache: function() {
            if (this.isReadyToProcess()) {
              var image = this.files[0];
              var json = this.files[1];
              var normalMap = this.files[2] ? this.files[2].data : null;
              this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);
              json.pendingDestroy();
              this.complete = true;
            }
          }
        });
        FileTypesManager.register("atlas", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
          var multifile;
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              multifile = new AtlasJSONFile(this, key[i2]);
              this.addFile(multifile.files);
            }
          } else {
            multifile = new AtlasJSONFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
            this.addFile(multifile.files);
          }
          return this;
        });
        module2.exports = AtlasJSONFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var ImageFile = __webpack_require__(71);
        var IsPlainObject2 = __webpack_require__(7);
        var MultiFile = __webpack_require__(49);
        var XMLFile = __webpack_require__(241);
        var AtlasXMLFile = new Class({
          Extends: MultiFile,
          initialize: function AtlasXMLFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
            var image;
            var data;
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              image = new ImageFile(loader, {
                key,
                url: GetFastValue(config, "textureURL"),
                extension: GetFastValue(config, "textureExtension", "png"),
                normalMap: GetFastValue(config, "normalMap"),
                xhrSettings: GetFastValue(config, "textureXhrSettings")
              });
              data = new XMLFile(loader, {
                key,
                url: GetFastValue(config, "atlasURL"),
                extension: GetFastValue(config, "atlasExtension", "xml"),
                xhrSettings: GetFastValue(config, "atlasXhrSettings")
              });
            } else {
              image = new ImageFile(loader, key, textureURL, textureXhrSettings);
              data = new XMLFile(loader, key, atlasURL, atlasXhrSettings);
            }
            if (image.linkFile) {
              MultiFile.call(this, loader, "atlasxml", key, [image, data, image.linkFile]);
            } else {
              MultiFile.call(this, loader, "atlasxml", key, [image, data]);
            }
          },
          addToCache: function() {
            if (this.isReadyToProcess()) {
              var image = this.files[0];
              var xml = this.files[1];
              var normalMap = this.files[2] ? this.files[2].data : null;
              this.loader.textureManager.addAtlasXML(image.key, image.data, xml.data, normalMap);
              xml.pendingDestroy();
              this.complete = true;
            }
          }
        });
        FileTypesManager.register("atlasXML", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
          var multifile;
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              multifile = new AtlasXMLFile(this, key[i2]);
              this.addFile(multifile.files);
            }
          } else {
            multifile = new AtlasXMLFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
            this.addFile(multifile.files);
          }
          return this;
        });
        module2.exports = AtlasXMLFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AudioFile = __webpack_require__(518);
        var Class = __webpack_require__(0);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var JSONFile = __webpack_require__(61);
        var MultiFile = __webpack_require__(49);
        var AudioSpriteFile = new Class({
          Extends: MultiFile,
          initialize: function AudioSpriteFile2(loader, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings) {
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              jsonURL = GetFastValue(config, "jsonURL");
              audioURL = GetFastValue(config, "audioURL");
              audioConfig = GetFastValue(config, "audioConfig");
              audioXhrSettings = GetFastValue(config, "audioXhrSettings");
              jsonXhrSettings = GetFastValue(config, "jsonXhrSettings");
            }
            var data;
            if (!audioURL) {
              data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);
              MultiFile.call(this, loader, "audiosprite", key, [data]);
              this.config.resourceLoad = true;
              this.config.audioConfig = audioConfig;
              this.config.audioXhrSettings = audioXhrSettings;
            } else {
              var audio = AudioFile.create(loader, key, audioURL, audioConfig, audioXhrSettings);
              if (audio) {
                data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);
                MultiFile.call(this, loader, "audiosprite", key, [audio, data]);
                this.config.resourceLoad = false;
              }
            }
          },
          onFileComplete: function(file) {
            var index2 = this.files.indexOf(file);
            if (index2 !== -1) {
              this.pending--;
              if (this.config.resourceLoad && file.type === "json" && file.data.hasOwnProperty("resources")) {
                var urls = file.data.resources;
                var audioConfig = GetFastValue(this.config, "audioConfig");
                var audioXhrSettings = GetFastValue(this.config, "audioXhrSettings");
                var audio = AudioFile.create(this.loader, file.key, urls, audioConfig, audioXhrSettings);
                if (audio) {
                  this.addToMultiFile(audio);
                  this.loader.addFile(audio);
                }
              }
            }
          },
          addToCache: function() {
            if (this.isReadyToProcess()) {
              var fileA = this.files[0];
              var fileB = this.files[1];
              fileA.addToCache();
              fileB.addToCache();
              this.complete = true;
            }
          }
        });
        FileTypesManager.register("audioSprite", function(key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings) {
          var game = this.systems.game;
          var gameAudioConfig = game.config.audio;
          var deviceAudio = game.device.audio;
          if (gameAudioConfig && gameAudioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
            return this;
          }
          var multifile;
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              multifile = new AudioSpriteFile(this, key[i2]);
              if (multifile.files) {
                this.addFile(multifile.files);
              }
            }
          } else {
            multifile = new AudioSpriteFile(this, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings);
            if (multifile.files) {
              this.addFile(multifile.files);
            }
          }
          return this;
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var BinaryFile = new Class({
          Extends: File,
          initialize: function BinaryFile2(loader, key, url, xhrSettings, dataType) {
            var extension = "bin";
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
              dataType = GetFastValue(config, "dataType", dataType);
            }
            var fileConfig = {
              type: "binary",
              cache: loader.cacheManager.binary,
              extension,
              responseType: "arraybuffer",
              key,
              url,
              xhrSettings,
              config: { dataType }
            };
            File.call(this, loader, fileConfig);
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            var ctor = this.config.dataType;
            this.data = ctor ? new ctor(this.xhrLoader.response) : this.xhrLoader.response;
            this.onProcessComplete();
          }
        });
        FileTypesManager.register("binary", function(key, url, dataType, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new BinaryFile(this, key[i2]));
            }
          } else {
            this.addFile(new BinaryFile(this, key, url, xhrSettings, dataType));
          }
          return this;
        });
        module2.exports = BinaryFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var ImageFile = __webpack_require__(71);
        var IsPlainObject2 = __webpack_require__(7);
        var MultiFile = __webpack_require__(49);
        var ParseXMLBitmapFont = __webpack_require__(212);
        var XMLFile = __webpack_require__(241);
        var BitmapFontFile = new Class({
          Extends: MultiFile,
          initialize: function BitmapFontFile2(loader, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) {
            var image;
            var data;
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              image = new ImageFile(loader, {
                key,
                url: GetFastValue(config, "textureURL"),
                extension: GetFastValue(config, "textureExtension", "png"),
                normalMap: GetFastValue(config, "normalMap"),
                xhrSettings: GetFastValue(config, "textureXhrSettings")
              });
              data = new XMLFile(loader, {
                key,
                url: GetFastValue(config, "fontDataURL"),
                extension: GetFastValue(config, "fontDataExtension", "xml"),
                xhrSettings: GetFastValue(config, "fontDataXhrSettings")
              });
            } else {
              image = new ImageFile(loader, key, textureURL, textureXhrSettings);
              data = new XMLFile(loader, key, fontDataURL, fontDataXhrSettings);
            }
            if (image.linkFile) {
              MultiFile.call(this, loader, "bitmapfont", key, [image, data, image.linkFile]);
            } else {
              MultiFile.call(this, loader, "bitmapfont", key, [image, data]);
            }
          },
          addToCache: function() {
            if (this.isReadyToProcess()) {
              var image = this.files[0];
              var xml = this.files[1];
              image.addToCache();
              xml.pendingDestroy();
              var texture = image.cache.get(image.key);
              var data = ParseXMLBitmapFont(xml.data, image.cache.getFrame(image.key), 0, 0, texture);
              this.loader.cacheManager.bitmapFont.add(image.key, { data, texture: image.key, frame: null });
              this.complete = true;
            }
          }
        });
        FileTypesManager.register("bitmapFont", function(key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) {
          var multifile;
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              multifile = new BitmapFontFile(this, key[i2]);
              this.addFile(multifile.files);
            }
          } else {
            multifile = new BitmapFontFile(this, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings);
            this.addFile(multifile.files);
          }
          return this;
        });
        module2.exports = BitmapFontFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var CSSFile = new Class({
          Extends: File,
          initialize: function CSSFile2(loader, key, url, xhrSettings) {
            var extension = "css";
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
            }
            var fileConfig = {
              type: "script",
              cache: false,
              extension,
              responseType: "text",
              key,
              url,
              xhrSettings
            };
            File.call(this, loader, fileConfig);
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            this.data = document.createElement("style");
            this.data.defer = false;
            this.data.innerHTML = this.xhrLoader.responseText;
            document.head.appendChild(this.data);
            this.onProcessComplete();
          }
        });
        FileTypesManager.register("css", function(key, url, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new CSSFile(this, key[i2]));
            }
          } else {
            this.addFile(new CSSFile(this, key, url, xhrSettings));
          }
          return this;
        });
        module2.exports = CSSFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var Shader = __webpack_require__(396);
        var GLSLFile = new Class({
          Extends: File,
          initialize: function GLSLFile2(loader, key, url, shaderType, xhrSettings) {
            var extension = "glsl";
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              shaderType = GetFastValue(config, "shaderType", "fragment");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
            } else if (shaderType === void 0) {
              shaderType = "fragment";
            }
            var fileConfig = {
              type: "glsl",
              cache: loader.cacheManager.shader,
              extension,
              responseType: "text",
              key,
              url,
              config: {
                shaderType
              },
              xhrSettings
            };
            File.call(this, loader, fileConfig);
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            this.data = this.xhrLoader.responseText;
            this.onProcessComplete();
          },
          addToCache: function() {
            var data = this.data.split("\n");
            var block = this.extractBlock(data, 0);
            if (block) {
              while (block) {
                var key = this.getShaderName(block.header);
                var shaderType = this.getShaderType(block.header);
                var uniforms = this.getShaderUniforms(block.header);
                var shaderSrc = block.shader;
                if (this.cache.has(key)) {
                  var shader = this.cache.get(key);
                  if (shaderType === "fragment") {
                    shader.fragmentSrc = shaderSrc;
                  } else {
                    shader.vertexSrc = shaderSrc;
                  }
                  if (!shader.uniforms) {
                    shader.uniforms = uniforms;
                  }
                } else if (shaderType === "fragment") {
                  this.cache.add(key, new Shader(key, shaderSrc, "", uniforms));
                } else {
                  this.cache.add(key, new Shader(key, "", shaderSrc, uniforms));
                }
                block = this.extractBlock(data, block.offset);
              }
            } else if (this.config.shaderType === "fragment") {
              this.cache.add(this.key, new Shader(this.key, this.data));
            } else {
              this.cache.add(this.key, new Shader(this.key, "", this.data));
            }
            this.pendingDestroy();
          },
          getShaderName: function(headerSource) {
            for (var i2 = 0; i2 < headerSource.length; i2++) {
              var line = headerSource[i2].trim();
              if (line.substring(0, 5) === "name:") {
                return line.substring(5).trim();
              }
            }
            return this.key;
          },
          getShaderType: function(headerSource) {
            for (var i2 = 0; i2 < headerSource.length; i2++) {
              var line = headerSource[i2].trim();
              if (line.substring(0, 5) === "type:") {
                return line.substring(5).trim();
              }
            }
            return this.config.shaderType;
          },
          getShaderUniforms: function(headerSource) {
            var uniforms = {};
            for (var i2 = 0; i2 < headerSource.length; i2++) {
              var line = headerSource[i2].trim();
              if (line.substring(0, 8) === "uniform.") {
                var pos = line.indexOf(":");
                if (pos) {
                  var key = line.substring(8, pos);
                  try {
                    uniforms[key] = JSON.parse(line.substring(pos + 1));
                  } catch (e) {
                    console.warn("Invalid uniform JSON: " + key);
                  }
                }
              }
            }
            return uniforms;
          },
          extractBlock: function(data, offset) {
            var headerStart = -1;
            var headerEnd = -1;
            var blockEnd = -1;
            var headerOpen = false;
            var captureSource = false;
            var headerSource = [];
            var shaderSource = [];
            for (var i2 = offset; i2 < data.length; i2++) {
              var line = data[i2].trim();
              if (line === "---") {
                if (headerStart === -1) {
                  headerStart = i2;
                  headerOpen = true;
                } else if (headerOpen) {
                  headerEnd = i2;
                  headerOpen = false;
                  captureSource = true;
                } else {
                  captureSource = false;
                  break;
                }
              } else if (headerOpen) {
                headerSource.push(line);
              } else if (captureSource) {
                shaderSource.push(line);
                blockEnd = i2;
              }
            }
            if (!headerOpen && headerEnd !== -1) {
              return { header: headerSource, shader: shaderSource.join("\n"), offset: blockEnd };
            } else {
              return null;
            }
          }
        });
        FileTypesManager.register("glsl", function(key, url, shaderType, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new GLSLFile(this, key[i2]));
            }
          } else {
            this.addFile(new GLSLFile(this, key, url, shaderType, xhrSettings));
          }
          return this;
        });
        module2.exports = GLSLFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var HTMLFile = new Class({
          Extends: File,
          initialize: function HTMLFile2(loader, key, url, xhrSettings) {
            var extension = "html";
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
            }
            var fileConfig = {
              type: "text",
              cache: loader.cacheManager.html,
              extension,
              responseType: "text",
              key,
              url,
              xhrSettings
            };
            File.call(this, loader, fileConfig);
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            this.data = this.xhrLoader.responseText;
            this.onProcessComplete();
          }
        });
        FileTypesManager.register("html", function(key, url, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new HTMLFile(this, key[i2]));
            }
          } else {
            this.addFile(new HTMLFile(this, key, url, xhrSettings));
          }
          return this;
        });
        module2.exports = HTMLFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var HTMLTextureFile = new Class({
          Extends: File,
          initialize: function HTMLTextureFile2(loader, key, url, width, height, xhrSettings) {
            if (width === void 0) {
              width = 512;
            }
            if (height === void 0) {
              height = 512;
            }
            var extension = "html";
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
              width = GetFastValue(config, "width", width);
              height = GetFastValue(config, "height", height);
            }
            var fileConfig = {
              type: "html",
              cache: loader.textureManager,
              extension,
              responseType: "text",
              key,
              url,
              xhrSettings,
              config: {
                width,
                height
              }
            };
            File.call(this, loader, fileConfig);
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            var w2 = this.config.width;
            var h2 = this.config.height;
            var data = [];
            data.push('<svg width="' + w2 + 'px" height="' + h2 + 'px" viewBox="0 0 ' + w2 + " " + h2 + '" xmlns="http://www.w3.org/2000/svg">');
            data.push('<foreignObject width="100%" height="100%">');
            data.push('<body xmlns="http://www.w3.org/1999/xhtml">');
            data.push(this.xhrLoader.responseText);
            data.push("</body>");
            data.push("</foreignObject>");
            data.push("</svg>");
            var svg = [data.join("\n")];
            var _this = this;
            try {
              var blob = new window.Blob(svg, { type: "image/svg+xml;charset=utf-8" });
            } catch (e) {
              _this.state = CONST.FILE_ERRORED;
              _this.onProcessComplete();
              return;
            }
            this.data = new Image();
            this.data.crossOrigin = this.crossOrigin;
            this.data.onload = function() {
              File.revokeObjectURL(_this.data);
              _this.onProcessComplete();
            };
            this.data.onerror = function() {
              File.revokeObjectURL(_this.data);
              _this.onProcessError();
            };
            File.createObjectURL(this.data, blob, "image/svg+xml");
          },
          addToCache: function() {
            var texture = this.cache.addImage(this.key, this.data);
            this.pendingDestroy(texture);
          }
        });
        FileTypesManager.register("htmlTexture", function(key, url, width, height, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new HTMLTextureFile(this, key[i2]));
            }
          } else {
            this.addFile(new HTMLTextureFile(this, key, url, width, height, xhrSettings));
          }
          return this;
        });
        module2.exports = HTMLTextureFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var ImageFile = __webpack_require__(71);
        var IsPlainObject2 = __webpack_require__(7);
        var JSONFile = __webpack_require__(61);
        var MultiFile = __webpack_require__(49);
        var MultiAtlasFile = new Class({
          Extends: MultiFile,
          initialize: function MultiAtlasFile2(loader, key, atlasURL, path, baseURL, atlasXhrSettings, textureXhrSettings) {
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              if (GetFastValue(config, "url", false)) {
                atlasURL = GetFastValue(config, "url");
              } else {
                atlasURL = GetFastValue(config, "atlasURL");
              }
              atlasXhrSettings = GetFastValue(config, "xhrSettings");
              path = GetFastValue(config, "path");
              baseURL = GetFastValue(config, "baseURL");
              textureXhrSettings = GetFastValue(config, "textureXhrSettings");
            }
            var data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
            MultiFile.call(this, loader, "multiatlas", key, [data]);
            this.config.path = path;
            this.config.baseURL = baseURL;
            this.config.textureXhrSettings = textureXhrSettings;
          },
          onFileComplete: function(file) {
            var index2 = this.files.indexOf(file);
            if (index2 !== -1) {
              this.pending--;
              if (file.type === "json" && file.data.hasOwnProperty("textures")) {
                var textures = file.data.textures;
                var config = this.config;
                var loader = this.loader;
                var currentBaseURL = loader.baseURL;
                var currentPath = loader.path;
                var currentPrefix = loader.prefix;
                var baseURL = GetFastValue(config, "baseURL", this.baseURL);
                var path = GetFastValue(config, "path", this.path);
                var prefix = GetFastValue(config, "prefix", this.prefix);
                var textureXhrSettings = GetFastValue(config, "textureXhrSettings");
                loader.setBaseURL(baseURL);
                loader.setPath(path);
                loader.setPrefix(prefix);
                for (var i2 = 0; i2 < textures.length; i2++) {
                  var textureURL = textures[i2].image;
                  var key = "MA" + this.multiKeyIndex + "_" + textureURL;
                  var image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                  this.addToMultiFile(image);
                  loader.addFile(image);
                  if (textures[i2].normalMap) {
                    var normalMap = new ImageFile(loader, key, textures[i2].normalMap, textureXhrSettings);
                    normalMap.type = "normalMap";
                    image.setLink(normalMap);
                    this.addToMultiFile(normalMap);
                    loader.addFile(normalMap);
                  }
                }
                loader.setBaseURL(currentBaseURL);
                loader.setPath(currentPath);
                loader.setPrefix(currentPrefix);
              }
            }
          },
          addToCache: function() {
            if (this.isReadyToProcess()) {
              var fileJSON = this.files[0];
              var data = [];
              var images = [];
              var normalMaps = [];
              for (var i2 = 1; i2 < this.files.length; i2++) {
                var file = this.files[i2];
                if (file.type === "normalMap") {
                  continue;
                }
                var pos = file.key.indexOf("_");
                var key = file.key.substr(pos + 1);
                var image = file.data;
                for (var t2 = 0; t2 < fileJSON.data.textures.length; t2++) {
                  var item = fileJSON.data.textures[t2];
                  if (item.image === key) {
                    images.push(image);
                    data.push(item);
                    if (file.linkFile) {
                      normalMaps.push(file.linkFile.data);
                    }
                    break;
                  }
                }
              }
              if (normalMaps.length === 0) {
                normalMaps = void 0;
              }
              this.loader.textureManager.addAtlasJSONArray(this.key, images, data, normalMaps);
              this.complete = true;
              for (i2 = 0; i2 < this.files.length; i2++) {
                this.files[i2].pendingDestroy();
              }
            }
          }
        });
        FileTypesManager.register("multiatlas", function(key, atlasURL, path, baseURL, atlasXhrSettings) {
          var multifile;
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              multifile = new MultiAtlasFile(this, key[i2]);
              this.addFile(multifile.files);
            }
          } else {
            multifile = new MultiAtlasFile(this, key, atlasURL, path, baseURL, atlasXhrSettings);
            this.addFile(multifile.files);
          }
          return this;
        });
        module2.exports = MultiAtlasFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var MultiFile = __webpack_require__(49);
        var ScriptFile = __webpack_require__(520);
        var MultiScriptFile = new Class({
          Extends: MultiFile,
          initialize: function MultiScriptFile2(loader, key, url, xhrSettings) {
            var extension = "js";
            var files = [];
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
            }
            if (!Array.isArray(url)) {
              url = [url];
            }
            for (var i2 = 0; i2 < url.length; i2++) {
              var scriptFile = new ScriptFile(loader, {
                key: key + "_" + i2.toString(),
                url: url[i2],
                extension,
                xhrSettings
              });
              scriptFile.onProcess = function() {
                this.onProcessComplete();
              };
              files.push(scriptFile);
            }
            MultiFile.call(this, loader, "scripts", key, files);
          },
          addToCache: function() {
            if (this.isReadyToProcess()) {
              for (var i2 = 0; i2 < this.files.length; i2++) {
                var file = this.files[i2];
                file.data = document.createElement("script");
                file.data.language = "javascript";
                file.data.type = "text/javascript";
                file.data.defer = false;
                file.data.text = file.xhrLoader.responseText;
                document.head.appendChild(file.data);
              }
              this.complete = true;
            }
          }
        });
        FileTypesManager.register("scripts", function(key, url, xhrSettings) {
          var multifile;
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              multifile = new MultiScriptFile(this, key[i2]);
              this.addFile(multifile.files);
            }
          } else {
            multifile = new MultiScriptFile(this, key, url, xhrSettings);
            this.addFile(multifile.files);
          }
          return this;
        });
        module2.exports = MultiScriptFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var MultiFile = __webpack_require__(49);
        var ParseObj = __webpack_require__(498);
        var ParseObjMaterial = __webpack_require__(499);
        var TextFile = __webpack_require__(242);
        var OBJFile = new Class({
          Extends: MultiFile,
          initialize: function OBJFile2(loader, key, objURL, matURL, flipUV, xhrSettings) {
            var obj;
            var mat;
            var cache = loader.cacheManager.obj;
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              obj = new TextFile(loader, {
                key,
                type: "obj",
                cache,
                url: GetFastValue(config, "url"),
                extension: GetFastValue(config, "extension", "obj"),
                xhrSettings: GetFastValue(config, "xhrSettings"),
                config: {
                  flipUV: GetFastValue(config, "flipUV", flipUV)
                }
              });
              matURL = GetFastValue(config, "matURL");
              if (matURL) {
                mat = new TextFile(loader, {
                  key,
                  type: "mat",
                  cache,
                  url: matURL,
                  extension: GetFastValue(config, "matExtension", "mat"),
                  xhrSettings: GetFastValue(config, "xhrSettings")
                });
              }
            } else {
              obj = new TextFile(loader, {
                key,
                url: objURL,
                type: "obj",
                cache,
                extension: "obj",
                xhrSettings,
                config: {
                  flipUV
                }
              });
              if (matURL) {
                mat = new TextFile(loader, {
                  key,
                  url: matURL,
                  type: "mat",
                  cache,
                  extension: "mat",
                  xhrSettings
                });
              }
            }
            MultiFile.call(this, loader, "obj", key, [obj, mat]);
          },
          addToCache: function() {
            if (this.isReadyToProcess()) {
              var obj = this.files[0];
              var mat = this.files[1];
              var objData = ParseObj(obj.data, obj.config.flipUV);
              if (mat) {
                objData.materials = ParseObjMaterial(mat.data);
              }
              obj.cache.add(obj.key, objData);
              this.complete = true;
            }
          }
        });
        FileTypesManager.register("obj", function(key, objURL, matURL, flipUVs, xhrSettings) {
          var multifile;
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              multifile = new OBJFile(this, key[i2]);
              this.addFile(multifile.files);
            }
          } else {
            multifile = new OBJFile(this, key, objURL, matURL, flipUVs, xhrSettings);
            this.addFile(multifile.files);
          }
          return this;
        });
        module2.exports = OBJFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var FileTypesManager = __webpack_require__(8);
        var JSONFile = __webpack_require__(61);
        var PackFile = new Class({
          Extends: JSONFile,
          initialize: function PackFile2(loader, key, url, xhrSettings, dataKey) {
            JSONFile.call(this, loader, key, url, xhrSettings, dataKey);
            this.type = "packfile";
          },
          onProcess: function() {
            if (this.state !== CONST.FILE_POPULATED) {
              this.state = CONST.FILE_PROCESSING;
              this.data = JSON.parse(this.xhrLoader.responseText);
            }
            this.loader.addPack(this.data, this.config);
            this.onProcessComplete();
          }
        });
        FileTypesManager.register("pack", function(key, url, packKey, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new PackFile(this, key[i2]));
            }
          } else {
            this.addFile(new PackFile(this, key, url, xhrSettings, packKey));
          }
          return this;
        });
        module2.exports = PackFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var PluginFile = new Class({
          Extends: File,
          initialize: function PluginFile2(loader, key, url, start, mapping, xhrSettings) {
            var extension = "js";
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
              start = GetFastValue(config, "start");
              mapping = GetFastValue(config, "mapping");
            }
            var fileConfig = {
              type: "plugin",
              cache: false,
              extension,
              responseType: "text",
              key,
              url,
              xhrSettings,
              config: {
                start,
                mapping
              }
            };
            File.call(this, loader, fileConfig);
            if (typeof url === "function") {
              this.data = url;
              this.state = CONST.FILE_POPULATED;
            }
          },
          onProcess: function() {
            var pluginManager = this.loader.systems.plugins;
            var config = this.config;
            var start = GetFastValue(config, "start", false);
            var mapping = GetFastValue(config, "mapping", null);
            if (this.state === CONST.FILE_POPULATED) {
              pluginManager.install(this.key, this.data, start, mapping);
            } else {
              this.state = CONST.FILE_PROCESSING;
              this.data = document.createElement("script");
              this.data.language = "javascript";
              this.data.type = "text/javascript";
              this.data.defer = false;
              this.data.text = this.xhrLoader.responseText;
              document.head.appendChild(this.data);
              var plugin = pluginManager.install(this.key, window[this.key], start, mapping);
              if (start || mapping) {
                this.loader.systems[mapping] = plugin;
                this.loader.scene[mapping] = plugin;
              }
            }
            this.onProcessComplete();
          }
        });
        FileTypesManager.register("plugin", function(key, url, start, mapping, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new PluginFile(this, key[i2]));
            }
          } else {
            this.addFile(new PluginFile(this, key, url, start, mapping, xhrSettings));
          }
          return this;
        });
        module2.exports = PluginFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var SceneFile = new Class({
          Extends: File,
          initialize: function SceneFile2(loader, key, url, xhrSettings) {
            var extension = "js";
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
            }
            var fileConfig = {
              type: "text",
              extension,
              responseType: "text",
              key,
              url,
              xhrSettings
            };
            File.call(this, loader, fileConfig);
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            this.data = this.xhrLoader.responseText;
            this.onProcessComplete();
          },
          addToCache: function() {
            var code = this.data.concat("(function(){\nreturn new " + this.key + "();\n}).call(this);");
            var eval2 = eval;
            this.loader.sceneManager.add(this.key, eval2(code));
            this.complete = true;
          }
        });
        FileTypesManager.register("sceneFile", function(key, url, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new SceneFile(this, key[i2]));
            }
          } else {
            this.addFile(new SceneFile(this, key, url, xhrSettings));
          }
          return this;
        });
        module2.exports = SceneFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var ScenePluginFile = new Class({
          Extends: File,
          initialize: function ScenePluginFile2(loader, key, url, systemKey, sceneKey, xhrSettings) {
            var extension = "js";
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
              systemKey = GetFastValue(config, "systemKey");
              sceneKey = GetFastValue(config, "sceneKey");
            }
            var fileConfig = {
              type: "scenePlugin",
              cache: false,
              extension,
              responseType: "text",
              key,
              url,
              xhrSettings,
              config: {
                systemKey,
                sceneKey
              }
            };
            File.call(this, loader, fileConfig);
            if (typeof url === "function") {
              this.data = url;
              this.state = CONST.FILE_POPULATED;
            }
          },
          onProcess: function() {
            var pluginManager = this.loader.systems.plugins;
            var config = this.config;
            var key = this.key;
            var systemKey = GetFastValue(config, "systemKey", key);
            var sceneKey = GetFastValue(config, "sceneKey", key);
            if (this.state === CONST.FILE_POPULATED) {
              pluginManager.installScenePlugin(systemKey, this.data, sceneKey, this.loader.scene, true);
            } else {
              this.state = CONST.FILE_PROCESSING;
              this.data = document.createElement("script");
              this.data.language = "javascript";
              this.data.type = "text/javascript";
              this.data.defer = false;
              this.data.text = this.xhrLoader.responseText;
              document.head.appendChild(this.data);
              pluginManager.installScenePlugin(systemKey, window[this.key], sceneKey, this.loader.scene, true);
            }
            this.onProcessComplete();
          }
        });
        FileTypesManager.register("scenePlugin", function(key, url, systemKey, sceneKey, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new ScenePluginFile(this, key[i2]));
            }
          } else {
            this.addFile(new ScenePluginFile(this, key, url, systemKey, sceneKey, xhrSettings));
          }
          return this;
        });
        module2.exports = ScenePluginFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FileTypesManager = __webpack_require__(8);
        var ImageFile = __webpack_require__(71);
        var SpriteSheetFile = new Class({
          Extends: ImageFile,
          initialize: function SpriteSheetFile2(loader, key, url, frameConfig, xhrSettings) {
            ImageFile.call(this, loader, key, url, xhrSettings, frameConfig);
            this.type = "spritesheet";
          },
          addToCache: function() {
            var texture = this.cache.addSpriteSheet(this.key, this.data, this.config);
            this.pendingDestroy(texture);
          }
        });
        FileTypesManager.register("spritesheet", function(key, url, frameConfig, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new SpriteSheetFile(this, key[i2]));
            }
          } else {
            this.addFile(new SpriteSheetFile(this, key, url, frameConfig, xhrSettings));
          }
          return this;
        });
        module2.exports = SpriteSheetFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var SVGFile = new Class({
          Extends: File,
          initialize: function SVGFile2(loader, key, url, svgConfig, xhrSettings) {
            var extension = "svg";
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              svgConfig = GetFastValue(config, "svgConfig", {});
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
            }
            var fileConfig = {
              type: "svg",
              cache: loader.textureManager,
              extension,
              responseType: "text",
              key,
              url,
              xhrSettings,
              config: {
                width: GetFastValue(svgConfig, "width"),
                height: GetFastValue(svgConfig, "height"),
                scale: GetFastValue(svgConfig, "scale")
              }
            };
            File.call(this, loader, fileConfig);
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            var text = this.xhrLoader.responseText;
            var svg = [text];
            var width = this.config.width;
            var height = this.config.height;
            var scale = this.config.scale;
            resize:
              if (width && height || scale) {
                var xml = null;
                var parser = new DOMParser();
                xml = parser.parseFromString(text, "text/xml");
                var svgXML = xml.getElementsByTagName("svg")[0];
                var hasViewBox = svgXML.hasAttribute("viewBox");
                var svgWidth = parseFloat(svgXML.getAttribute("width"));
                var svgHeight = parseFloat(svgXML.getAttribute("height"));
                if (!hasViewBox && svgWidth && svgHeight) {
                  svgXML.setAttribute("viewBox", "0  0 " + svgWidth + " " + svgHeight);
                } else if (hasViewBox && !svgWidth && !svgHeight) {
                  var viewBox = svgXML.getAttribute("viewBox").split(/\s+|,/);
                  svgWidth = viewBox[2];
                  svgHeight = viewBox[3];
                }
                if (scale) {
                  if (svgWidth && svgHeight) {
                    width = svgWidth * scale;
                    height = svgHeight * scale;
                  } else {
                    break resize;
                  }
                }
                svgXML.setAttribute("width", width.toString() + "px");
                svgXML.setAttribute("height", height.toString() + "px");
                svg = [new XMLSerializer().serializeToString(svgXML)];
              }
            try {
              var blob = new window.Blob(svg, { type: "image/svg+xml;charset=utf-8" });
            } catch (e) {
              this.onProcessError();
              return;
            }
            this.data = new Image();
            this.data.crossOrigin = this.crossOrigin;
            var _this = this;
            var retry = false;
            this.data.onload = function() {
              if (!retry) {
                File.revokeObjectURL(_this.data);
              }
              _this.onProcessComplete();
            };
            this.data.onerror = function() {
              if (!retry) {
                retry = true;
                File.revokeObjectURL(_this.data);
                _this.data.src = "data:image/svg+xml," + encodeURIComponent(svg.join(""));
              } else {
                _this.onProcessError();
              }
            };
            File.createObjectURL(this.data, blob, "image/svg+xml");
          },
          addToCache: function() {
            var texture = this.cache.addImage(this.key, this.data);
            this.pendingDestroy(texture);
          }
        });
        FileTypesManager.register("svg", function(key, url, svgConfig, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new SVGFile(this, key[i2]));
            }
          } else {
            this.addFile(new SVGFile(this, key, url, svgConfig, xhrSettings));
          }
          return this;
        });
        module2.exports = SVGFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var TILEMAP_FORMATS = __webpack_require__(40);
        var TilemapCSVFile = new Class({
          Extends: File,
          initialize: function TilemapCSVFile2(loader, key, url, xhrSettings) {
            var extension = "csv";
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              url = GetFastValue(config, "url");
              xhrSettings = GetFastValue(config, "xhrSettings");
              extension = GetFastValue(config, "extension", extension);
            }
            var fileConfig = {
              type: "tilemapCSV",
              cache: loader.cacheManager.tilemap,
              extension,
              responseType: "text",
              key,
              url,
              xhrSettings
            };
            File.call(this, loader, fileConfig);
            this.tilemapFormat = TILEMAP_FORMATS.CSV;
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            this.data = this.xhrLoader.responseText;
            this.onProcessComplete();
          },
          addToCache: function() {
            var tiledata = { format: this.tilemapFormat, data: this.data };
            this.cache.add(this.key, tiledata);
            this.pendingDestroy(tiledata);
          }
        });
        FileTypesManager.register("tilemapCSV", function(key, url, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new TilemapCSVFile(this, key[i2]));
            }
          } else {
            this.addFile(new TilemapCSVFile(this, key, url, xhrSettings));
          }
          return this;
        });
        module2.exports = TilemapCSVFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FileTypesManager = __webpack_require__(8);
        var JSONFile = __webpack_require__(61);
        var TILEMAP_FORMATS = __webpack_require__(40);
        var TilemapImpactFile = new Class({
          Extends: JSONFile,
          initialize: function TilemapImpactFile2(loader, key, url, xhrSettings) {
            JSONFile.call(this, loader, key, url, xhrSettings);
            this.type = "tilemapJSON";
            this.cache = loader.cacheManager.tilemap;
          },
          addToCache: function() {
            var tiledata = { format: TILEMAP_FORMATS.WELTMEISTER, data: this.data };
            this.cache.add(this.key, tiledata);
            this.pendingDestroy(tiledata);
          }
        });
        FileTypesManager.register("tilemapImpact", function(key, url, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new TilemapImpactFile(this, key[i2]));
            }
          } else {
            this.addFile(new TilemapImpactFile(this, key, url, xhrSettings));
          }
          return this;
        });
        module2.exports = TilemapImpactFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FileTypesManager = __webpack_require__(8);
        var JSONFile = __webpack_require__(61);
        var TILEMAP_FORMATS = __webpack_require__(40);
        var TilemapJSONFile = new Class({
          Extends: JSONFile,
          initialize: function TilemapJSONFile2(loader, key, url, xhrSettings) {
            JSONFile.call(this, loader, key, url, xhrSettings);
            this.type = "tilemapJSON";
            this.cache = loader.cacheManager.tilemap;
          },
          addToCache: function() {
            var tiledata = { format: TILEMAP_FORMATS.TILED_JSON, data: this.data };
            this.cache.add(this.key, tiledata);
            this.pendingDestroy(tiledata);
          }
        });
        FileTypesManager.register("tilemapTiledJSON", function(key, url, xhrSettings) {
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              this.addFile(new TilemapJSONFile(this, key[i2]));
            }
          } else {
            this.addFile(new TilemapJSONFile(this, key, url, xhrSettings));
          }
          return this;
        });
        module2.exports = TilemapJSONFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var ImageFile = __webpack_require__(71);
        var IsPlainObject2 = __webpack_require__(7);
        var MultiFile = __webpack_require__(49);
        var TextFile = __webpack_require__(242);
        var UnityAtlasFile = new Class({
          Extends: MultiFile,
          initialize: function UnityAtlasFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
            var image;
            var data;
            if (IsPlainObject2(key)) {
              var config = key;
              key = GetFastValue(config, "key");
              image = new ImageFile(loader, {
                key,
                url: GetFastValue(config, "textureURL"),
                extension: GetFastValue(config, "textureExtension", "png"),
                normalMap: GetFastValue(config, "normalMap"),
                xhrSettings: GetFastValue(config, "textureXhrSettings")
              });
              data = new TextFile(loader, {
                key,
                url: GetFastValue(config, "atlasURL"),
                extension: GetFastValue(config, "atlasExtension", "txt"),
                xhrSettings: GetFastValue(config, "atlasXhrSettings")
              });
            } else {
              image = new ImageFile(loader, key, textureURL, textureXhrSettings);
              data = new TextFile(loader, key, atlasURL, atlasXhrSettings);
            }
            if (image.linkFile) {
              MultiFile.call(this, loader, "unityatlas", key, [image, data, image.linkFile]);
            } else {
              MultiFile.call(this, loader, "unityatlas", key, [image, data]);
            }
          },
          addToCache: function() {
            if (this.isReadyToProcess()) {
              var image = this.files[0];
              var text = this.files[1];
              var normalMap = this.files[2] ? this.files[2].data : null;
              this.loader.textureManager.addUnityAtlas(image.key, image.data, text.data, normalMap);
              text.pendingDestroy();
              this.complete = true;
            }
          }
        });
        FileTypesManager.register("unityAtlas", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
          var multifile;
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              multifile = new UnityAtlasFile(this, key[i2]);
              this.addFile(multifile.files);
            }
          } else {
            multifile = new UnityAtlasFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
            this.addFile(multifile.files);
          }
          return this;
        });
        module2.exports = UnityAtlasFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var File = __webpack_require__(23);
        var FileTypesManager = __webpack_require__(8);
        var GetURL = __webpack_require__(155);
        var GetFastValue = __webpack_require__(2);
        var IsPlainObject2 = __webpack_require__(7);
        var VideoFile = new Class({
          Extends: File,
          initialize: function VideoFile2(loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings) {
            if (loadEvent === void 0) {
              loadEvent = "loadeddata";
            }
            if (asBlob === void 0) {
              asBlob = false;
            }
            if (noAudio === void 0) {
              noAudio = false;
            }
            if (loadEvent !== "loadeddata" && loadEvent !== "canplay" && loadEvent !== "canplaythrough") {
              loadEvent = "loadeddata";
            }
            var fileConfig = {
              type: "video",
              cache: loader.cacheManager.video,
              extension: urlConfig.type,
              responseType: "blob",
              key,
              url: urlConfig.url,
              xhrSettings,
              config: {
                loadEvent,
                asBlob,
                noAudio
              }
            };
            this.onLoadCallback = this.onVideoLoadHandler.bind(this);
            this.onErrorCallback = this.onVideoErrorHandler.bind(this);
            File.call(this, loader, fileConfig);
          },
          onProcess: function() {
            this.state = CONST.FILE_PROCESSING;
            if (!this.config.asBlob) {
              this.onProcessComplete();
              return;
            }
            var video = this.createVideoElement();
            this.data = video;
            var _this = this;
            this.data.onloadeddata = function() {
              _this.onProcessComplete();
            };
            this.data.onerror = function() {
              File.revokeObjectURL(_this.data);
              _this.onProcessError();
            };
            File.createObjectURL(video, this.xhrLoader.response, "");
            video.load();
          },
          createVideoElement: function() {
            var video = document.createElement("video");
            video.controls = false;
            video.crossOrigin = this.loader.crossOrigin;
            if (this.config.noAudio) {
              video.muted = true;
              video.defaultMuted = true;
              video.setAttribute("autoplay", "autoplay");
            }
            video.setAttribute("playsinline", "playsinline");
            video.setAttribute("preload", "auto");
            return video;
          },
          onVideoLoadHandler: function(event) {
            var video = event.target;
            video.removeEventListener(this.config.loadEvent, this.onLoadCallback, true);
            video.removeEventListener("error", this.onErrorCallback, true);
            this.data = video;
            this.resetXHR();
            this.loader.nextFile(this, true);
          },
          onVideoErrorHandler: function(event) {
            var video = event.target;
            if (video) {
              video.removeEventListener(this.config.loadEvent, this.onLoadCallback, true);
              video.removeEventListener("error", this.onErrorCallback, true);
            }
            this.resetXHR();
            this.loader.nextFile(this, false);
          },
          load: function() {
            var loadEvent = this.config.loadEvent;
            if (this.config.asBlob) {
              File.prototype.load.call(this);
            } else {
              this.percentComplete = 0;
              var video = this.createVideoElement();
              video.addEventListener(loadEvent, this.onLoadCallback, true);
              video.addEventListener("error", this.onErrorCallback, true);
              video.src = GetURL(this, this.loader.baseURL);
              video.load();
            }
          }
        });
        VideoFile.create = function(loader, key, urls, loadEvent, asBlob, noAudio, xhrSettings) {
          var game = loader.systems.game;
          if (IsPlainObject2(key)) {
            urls = GetFastValue(key, "url", []);
            loadEvent = GetFastValue(key, "loadEvent", "loadeddata");
            asBlob = GetFastValue(key, "asBlob", false);
            noAudio = GetFastValue(key, "noAudio", false);
            xhrSettings = GetFastValue(key, "xhrSettings");
            key = GetFastValue(key, "key");
          }
          var urlConfig = VideoFile.getVideoURL(game, urls);
          if (urlConfig) {
            return new VideoFile(loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings);
          }
        };
        VideoFile.getVideoURL = function(game, urls) {
          if (!Array.isArray(urls)) {
            urls = [urls];
          }
          for (var i2 = 0; i2 < urls.length; i2++) {
            var url = GetFastValue(urls[i2], "url", urls[i2]);
            if (url.indexOf("blob:") === 0) {
              return {
                url,
                type: ""
              };
            }
            var videoType;
            if (url.indexOf("data:") === 0) {
              videoType = url.split(",")[0].match(/\/(.*?);/);
            } else {
              videoType = url.match(/\.([a-zA-Z0-9]+)($|\?)/);
            }
            videoType = GetFastValue(urls[i2], "type", videoType ? videoType[1] : "").toLowerCase();
            if (game.device.video[videoType]) {
              return {
                url,
                type: videoType
              };
            }
          }
          return null;
        };
        FileTypesManager.register("video", function(key, urls, loadEvent, asBlob, noAudio, xhrSettings) {
          var videoFile;
          if (Array.isArray(key)) {
            for (var i2 = 0; i2 < key.length; i2++) {
              videoFile = VideoFile.create(this, key[i2]);
              if (videoFile) {
                this.addFile(videoFile);
              }
            }
          } else {
            videoFile = VideoFile.create(this, key, urls, loadEvent, asBlob, noAudio, xhrSettings);
            if (videoFile) {
              this.addFile(videoFile);
            }
          }
          return this;
        });
        module2.exports = VideoFile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var CONST = __webpack_require__(21);
        var CustomSet = __webpack_require__(149);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(95);
        var FileTypesManager = __webpack_require__(8);
        var GetFastValue = __webpack_require__(2);
        var PluginCache = __webpack_require__(24);
        var SceneEvents = __webpack_require__(20);
        var XHRSettings = __webpack_require__(156);
        var LoaderPlugin = new Class({
          Extends: EventEmitter,
          initialize: function LoaderPlugin2(scene) {
            EventEmitter.call(this);
            var gameConfig = scene.sys.game.config;
            var sceneConfig = scene.sys.settings.loader;
            this.scene = scene;
            this.systems = scene.sys;
            this.cacheManager = scene.sys.cache;
            this.textureManager = scene.sys.textures;
            this.sceneManager = scene.sys.game.scene;
            FileTypesManager.install(this);
            this.prefix = "";
            this.path = "";
            this.baseURL = "";
            this.setBaseURL(GetFastValue(sceneConfig, "baseURL", gameConfig.loaderBaseURL));
            this.setPath(GetFastValue(sceneConfig, "path", gameConfig.loaderPath));
            this.setPrefix(GetFastValue(sceneConfig, "prefix", gameConfig.loaderPrefix));
            this.maxParallelDownloads = GetFastValue(sceneConfig, "maxParallelDownloads", gameConfig.loaderMaxParallelDownloads);
            this.xhr = XHRSettings(GetFastValue(sceneConfig, "responseType", gameConfig.loaderResponseType), GetFastValue(sceneConfig, "async", gameConfig.loaderAsync), GetFastValue(sceneConfig, "user", gameConfig.loaderUser), GetFastValue(sceneConfig, "password", gameConfig.loaderPassword), GetFastValue(sceneConfig, "timeout", gameConfig.loaderTimeout), GetFastValue(sceneConfig, "withCredentials", gameConfig.loaderWithCredentials));
            this.crossOrigin = GetFastValue(sceneConfig, "crossOrigin", gameConfig.loaderCrossOrigin);
            this.totalToLoad = 0;
            this.progress = 0;
            this.list = new CustomSet();
            this.inflight = new CustomSet();
            this.queue = new CustomSet();
            this._deleteQueue = new CustomSet();
            this.totalFailed = 0;
            this.totalComplete = 0;
            this.state = CONST.LOADER_IDLE;
            this.multiKeyIndex = 0;
            scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
            scene.sys.events.on(SceneEvents.START, this.pluginStart, this);
          },
          boot: function() {
            this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
          },
          pluginStart: function() {
            this.systems.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          setBaseURL: function(url) {
            if (url === void 0) {
              url = "";
            }
            if (url !== "" && url.substr(-1) !== "/") {
              url = url.concat("/");
            }
            this.baseURL = url;
            return this;
          },
          setPath: function(path) {
            if (path === void 0) {
              path = "";
            }
            if (path !== "" && path.substr(-1) !== "/") {
              path = path.concat("/");
            }
            this.path = path;
            return this;
          },
          setPrefix: function(prefix) {
            if (prefix === void 0) {
              prefix = "";
            }
            this.prefix = prefix;
            return this;
          },
          setCORS: function(crossOrigin) {
            this.crossOrigin = crossOrigin;
            return this;
          },
          addFile: function(file) {
            if (!Array.isArray(file)) {
              file = [file];
            }
            for (var i2 = 0; i2 < file.length; i2++) {
              var item = file[i2];
              if (!this.keyExists(item)) {
                this.list.set(item);
                this.emit(Events.ADD, item.key, item.type, this, item);
                if (this.isLoading()) {
                  this.totalToLoad++;
                  this.updateProgress();
                }
              }
            }
          },
          keyExists: function(file) {
            var keyConflict = file.hasCacheConflict();
            if (!keyConflict) {
              this.list.iterate(function(item) {
                if (item.type === file.type && item.key === file.key) {
                  keyConflict = true;
                  return false;
                }
              });
            }
            if (!keyConflict && this.isLoading()) {
              this.inflight.iterate(function(item) {
                if (item.type === file.type && item.key === file.key) {
                  keyConflict = true;
                  return false;
                }
              });
              this.queue.iterate(function(item) {
                if (item.type === file.type && item.key === file.key) {
                  keyConflict = true;
                  return false;
                }
              });
            }
            return keyConflict;
          },
          addPack: function(pack, packKey) {
            if (packKey && pack.hasOwnProperty(packKey)) {
              pack = { packKey: pack[packKey] };
            }
            var total = 0;
            var currentBaseURL = this.baseURL;
            var currentPath = this.path;
            var currentPrefix = this.prefix;
            for (var key in pack) {
              if (!Object.prototype.hasOwnProperty.call(pack, key)) {
                continue;
              }
              var config = pack[key];
              var baseURL = GetFastValue(config, "baseURL", currentBaseURL);
              var path = GetFastValue(config, "path", currentPath);
              var prefix = GetFastValue(config, "prefix", currentPrefix);
              var files = GetFastValue(config, "files", null);
              var defaultType = GetFastValue(config, "defaultType", "void");
              if (Array.isArray(files)) {
                this.setBaseURL(baseURL);
                this.setPath(path);
                this.setPrefix(prefix);
                for (var i2 = 0; i2 < files.length; i2++) {
                  var file = files[i2];
                  var type = file.hasOwnProperty("type") ? file.type : defaultType;
                  if (this[type]) {
                    this[type](file);
                    total++;
                  }
                }
              }
            }
            this.setBaseURL(currentBaseURL);
            this.setPath(currentPath);
            this.setPrefix(currentPrefix);
            return total > 0;
          },
          isLoading: function() {
            return this.state === CONST.LOADER_LOADING || this.state === CONST.LOADER_PROCESSING;
          },
          isReady: function() {
            return this.state === CONST.LOADER_IDLE || this.state === CONST.LOADER_COMPLETE;
          },
          start: function() {
            if (!this.isReady()) {
              return;
            }
            this.progress = 0;
            this.totalFailed = 0;
            this.totalComplete = 0;
            this.totalToLoad = this.list.size;
            this.emit(Events.START, this);
            if (this.list.size === 0) {
              this.loadComplete();
            } else {
              this.state = CONST.LOADER_LOADING;
              this.inflight.clear();
              this.queue.clear();
              this.updateProgress();
              this.checkLoadQueue();
              this.systems.events.on(SceneEvents.UPDATE, this.update, this);
            }
          },
          updateProgress: function() {
            this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad;
            this.emit(Events.PROGRESS, this.progress);
          },
          update: function() {
            if (this.state === CONST.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads) {
              this.checkLoadQueue();
            }
          },
          checkLoadQueue: function() {
            this.list.each(function(file) {
              if (file.state === CONST.FILE_POPULATED || file.state === CONST.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) {
                this.inflight.set(file);
                this.list.delete(file);
                if (!file.crossOrigin) {
                  file.crossOrigin = this.crossOrigin;
                }
                file.load();
              }
              if (this.inflight.size === this.maxParallelDownloads) {
                return false;
              }
            }, this);
          },
          nextFile: function(file, success) {
            if (!this.inflight) {
              return;
            }
            this.inflight.delete(file);
            this.updateProgress();
            if (success) {
              this.totalComplete++;
              this.queue.set(file);
              this.emit(Events.FILE_LOAD, file);
              file.onProcess();
            } else {
              this.totalFailed++;
              this._deleteQueue.set(file);
              this.emit(Events.FILE_LOAD_ERROR, file);
              this.fileProcessComplete(file);
            }
          },
          fileProcessComplete: function(file) {
            if (!this.scene || !this.systems || !this.systems.game || this.systems.game.pendingDestroy) {
              return;
            }
            if (file.state === CONST.FILE_ERRORED) {
              if (file.multiFile) {
                file.multiFile.onFileFailed(file);
              }
            } else if (file.state === CONST.FILE_COMPLETE) {
              if (file.multiFile) {
                if (file.multiFile.isReadyToProcess()) {
                  file.multiFile.addToCache();
                }
              } else {
                file.addToCache();
              }
            }
            this.queue.delete(file);
            if (this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0) {
              this.loadComplete();
            }
          },
          loadComplete: function() {
            this.emit(Events.POST_PROCESS, this);
            this.list.clear();
            this.inflight.clear();
            this.queue.clear();
            this.progress = 1;
            this.state = CONST.LOADER_COMPLETE;
            this.systems.events.off(SceneEvents.UPDATE, this.update, this);
            this._deleteQueue.iterateLocal("destroy");
            this._deleteQueue.clear();
            this.emit(Events.COMPLETE, this, this.totalComplete, this.totalFailed);
          },
          flagForRemoval: function(file) {
            this._deleteQueue.set(file);
          },
          saveJSON: function(data, filename) {
            return this.save(JSON.stringify(data), filename);
          },
          save: function(data, filename, filetype) {
            if (filename === void 0) {
              filename = "file.json";
            }
            if (filetype === void 0) {
              filetype = "application/json";
            }
            var blob = new Blob([data], { type: filetype });
            var url = URL.createObjectURL(blob);
            var a = document.createElement("a");
            a.download = filename;
            a.textContent = "Download " + filename;
            a.href = url;
            a.click();
            return this;
          },
          reset: function() {
            this.list.clear();
            this.inflight.clear();
            this.queue.clear();
            var gameConfig = this.systems.game.config;
            var sceneConfig = this.systems.settings.loader;
            this.setBaseURL(GetFastValue(sceneConfig, "baseURL", gameConfig.loaderBaseURL));
            this.setPath(GetFastValue(sceneConfig, "path", gameConfig.loaderPath));
            this.setPrefix(GetFastValue(sceneConfig, "prefix", gameConfig.loaderPrefix));
            this.state = CONST.LOADER_IDLE;
          },
          shutdown: function() {
            this.reset();
            this.state = CONST.LOADER_SHUTDOWN;
            this.systems.events.off(SceneEvents.UPDATE, this.update, this);
            this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          destroy: function() {
            this.shutdown();
            this.state = CONST.LOADER_DESTROYED;
            this.systems.events.off(SceneEvents.UPDATE, this.update, this);
            this.systems.events.off(SceneEvents.START, this.pluginStart, this);
            this.list = null;
            this.inflight = null;
            this.queue = null;
            this.scene = null;
            this.systems = null;
            this.textureManager = null;
            this.cacheManager = null;
            this.sceneManager = null;
          }
        });
        PluginCache.register("Loader", LoaderPlugin, "load");
        module2.exports = LoaderPlugin;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(62);
        var Extend = __webpack_require__(17);
        var Arcade = {
          ArcadePhysics: __webpack_require__(1367),
          Body: __webpack_require__(527),
          Collider: __webpack_require__(528),
          Components: __webpack_require__(243),
          Events: __webpack_require__(245),
          Factory: __webpack_require__(521),
          GetOverlapX: __webpack_require__(246),
          GetOverlapY: __webpack_require__(247),
          SeparateX: __webpack_require__(537),
          SeparateY: __webpack_require__(538),
          Group: __webpack_require__(524),
          Image: __webpack_require__(522),
          Sprite: __webpack_require__(157),
          StaticBody: __webpack_require__(539),
          StaticGroup: __webpack_require__(525),
          Tilemap: __webpack_require__(1391),
          World: __webpack_require__(526)
        };
        Arcade = Extend(false, Arcade, CONST);
        module2.exports = Arcade;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var DegToRad = __webpack_require__(36);
        var DistanceBetween = __webpack_require__(50);
        var DistanceSquared = __webpack_require__(353);
        var Factory = __webpack_require__(521);
        var GetFastValue = __webpack_require__(2);
        var Merge = __webpack_require__(127);
        var OverlapCirc = __webpack_require__(523);
        var OverlapRect = __webpack_require__(244);
        var PluginCache = __webpack_require__(24);
        var SceneEvents = __webpack_require__(20);
        var Vector2 = __webpack_require__(3);
        var World = __webpack_require__(526);
        var ArcadePhysics = new Class({
          initialize: function ArcadePhysics2(scene) {
            this.scene = scene;
            this.systems = scene.sys;
            this.config = this.getConfig();
            this.world;
            this.add;
            scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
            scene.sys.events.on(SceneEvents.START, this.start, this);
          },
          boot: function() {
            this.world = new World(this.scene, this.config);
            this.add = new Factory(this.world);
            this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
          },
          start: function() {
            if (!this.world) {
              this.world = new World(this.scene, this.config);
              this.add = new Factory(this.world);
            }
            var eventEmitter = this.systems.events;
            if (!GetFastValue(this.config, "customUpdate", false)) {
              eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);
            }
            eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
            eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          enableUpdate: function() {
            this.systems.events.on(SceneEvents.UPDATE, this.world.update, this.world);
          },
          disableUpdate: function() {
            this.systems.events.off(SceneEvents.UPDATE, this.world.update, this.world);
          },
          getConfig: function() {
            var gameConfig = this.systems.game.config.physics;
            var sceneConfig = this.systems.settings.physics;
            var config = Merge(GetFastValue(sceneConfig, "arcade", {}), GetFastValue(gameConfig, "arcade", {}));
            return config;
          },
          overlap: function(object1, object2, overlapCallback, processCallback, callbackContext) {
            if (overlapCallback === void 0) {
              overlapCallback = null;
            }
            if (processCallback === void 0) {
              processCallback = null;
            }
            if (callbackContext === void 0) {
              callbackContext = overlapCallback;
            }
            return this.world.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);
          },
          collide: function(object1, object2, collideCallback, processCallback, callbackContext) {
            if (collideCallback === void 0) {
              collideCallback = null;
            }
            if (processCallback === void 0) {
              processCallback = null;
            }
            if (callbackContext === void 0) {
              callbackContext = collideCallback;
            }
            return this.world.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);
          },
          collideTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
            return this.world.collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext);
          },
          overlapTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
            return this.world.overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext);
          },
          pause: function() {
            return this.world.pause();
          },
          resume: function() {
            return this.world.resume();
          },
          accelerateTo: function(gameObject, x2, y2, speed, xSpeedMax, ySpeedMax) {
            if (speed === void 0) {
              speed = 60;
            }
            var angle = Math.atan2(y2 - gameObject.y, x2 - gameObject.x);
            gameObject.body.acceleration.setToPolar(angle, speed);
            if (xSpeedMax !== void 0 && ySpeedMax !== void 0) {
              gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax);
            }
            return angle;
          },
          accelerateToObject: function(gameObject, destination, speed, xSpeedMax, ySpeedMax) {
            return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);
          },
          closest: function(source, targets) {
            if (!targets) {
              targets = this.world.bodies.entries;
            }
            var min = Number.MAX_VALUE;
            var closest = null;
            var x2 = source.x;
            var y2 = source.y;
            var len = targets.length;
            for (var i2 = 0; i2 < len; i2++) {
              var target = targets[i2];
              var body = target.body || target;
              if (source === target || source === body || source === body.gameObject || source === body.center) {
                continue;
              }
              var distance = DistanceSquared(x2, y2, body.center.x, body.center.y);
              if (distance < min) {
                closest = target;
                min = distance;
              }
            }
            return closest;
          },
          furthest: function(source, targets) {
            if (!targets) {
              targets = this.world.bodies.entries;
            }
            var max = -1;
            var farthest = null;
            var x2 = source.x;
            var y2 = source.y;
            var len = targets.length;
            for (var i2 = 0; i2 < len; i2++) {
              var target = targets[i2];
              var body = target.body || target;
              if (source === target || source === body || source === body.gameObject || source === body.center) {
                continue;
              }
              var distance = DistanceSquared(x2, y2, body.center.x, body.center.y);
              if (distance > max) {
                farthest = target;
                max = distance;
              }
            }
            return farthest;
          },
          moveTo: function(gameObject, x2, y2, speed, maxTime) {
            if (speed === void 0) {
              speed = 60;
            }
            if (maxTime === void 0) {
              maxTime = 0;
            }
            var angle = Math.atan2(y2 - gameObject.y, x2 - gameObject.x);
            if (maxTime > 0) {
              speed = DistanceBetween(gameObject.x, gameObject.y, x2, y2) / (maxTime / 1e3);
            }
            gameObject.body.velocity.setToPolar(angle, speed);
            return angle;
          },
          moveToObject: function(gameObject, destination, speed, maxTime) {
            return this.moveTo(gameObject, destination.x, destination.y, speed, maxTime);
          },
          velocityFromAngle: function(angle, speed, vec2) {
            if (speed === void 0) {
              speed = 60;
            }
            if (vec2 === void 0) {
              vec2 = new Vector2();
            }
            return vec2.setToPolar(DegToRad(angle), speed);
          },
          velocityFromRotation: function(rotation, speed, vec2) {
            if (speed === void 0) {
              speed = 60;
            }
            if (vec2 === void 0) {
              vec2 = new Vector2();
            }
            return vec2.setToPolar(rotation, speed);
          },
          overlapRect: function(x2, y2, width, height, includeDynamic, includeStatic) {
            return OverlapRect(this.world, x2, y2, width, height, includeDynamic, includeStatic);
          },
          overlapCirc: function(x2, y2, radius, includeDynamic, includeStatic) {
            return OverlapCirc(this.world, x2, y2, radius, includeDynamic, includeStatic);
          },
          shutdown: function() {
            if (!this.world) {
              return;
            }
            var eventEmitter = this.systems.events;
            eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);
            eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
            eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            this.add.destroy();
            this.world.destroy();
            this.add = null;
            this.world = null;
          },
          destroy: function() {
            this.shutdown();
            this.scene.sys.events.off(SceneEvents.START, this.start, this);
            this.scene = null;
            this.systems = null;
          }
        });
        PluginCache.register("ArcadePhysics", ArcadePhysics, "arcadePhysics");
        module2.exports = ArcadePhysics;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Acceleration = {
          setAcceleration: function(x2, y2) {
            this.body.acceleration.set(x2, y2);
            return this;
          },
          setAccelerationX: function(value) {
            this.body.acceleration.x = value;
            return this;
          },
          setAccelerationY: function(value) {
            this.body.acceleration.y = value;
            return this;
          }
        };
        module2.exports = Acceleration;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Angular = {
          setAngularVelocity: function(value) {
            this.body.angularVelocity = value;
            return this;
          },
          setAngularAcceleration: function(value) {
            this.body.angularAcceleration = value;
            return this;
          },
          setAngularDrag: function(value) {
            this.body.angularDrag = value;
            return this;
          }
        };
        module2.exports = Angular;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Bounce = {
          setBounce: function(x2, y2) {
            this.body.bounce.set(x2, y2);
            return this;
          },
          setBounceX: function(value) {
            this.body.bounce.x = value;
            return this;
          },
          setBounceY: function(value) {
            this.body.bounce.y = value;
            return this;
          },
          setCollideWorldBounds: function(value, bounceX, bounceY) {
            this.body.setCollideWorldBounds(value, bounceX, bounceY);
            return this;
          }
        };
        module2.exports = Bounce;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Debug = {
          setDebug: function(showBody, showVelocity, bodyColor) {
            this.debugShowBody = showBody;
            this.debugShowVelocity = showVelocity;
            this.debugBodyColor = bodyColor;
            return this;
          },
          setDebugBodyColor: function(value) {
            this.body.debugBodyColor = value;
            return this;
          },
          debugShowBody: {
            get: function() {
              return this.body.debugShowBody;
            },
            set: function(value) {
              this.body.debugShowBody = value;
            }
          },
          debugShowVelocity: {
            get: function() {
              return this.body.debugShowVelocity;
            },
            set: function(value) {
              this.body.debugShowVelocity = value;
            }
          },
          debugBodyColor: {
            get: function() {
              return this.body.debugBodyColor;
            },
            set: function(value) {
              this.body.debugBodyColor = value;
            }
          }
        };
        module2.exports = Debug;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Drag = {
          setDrag: function(x2, y2) {
            this.body.drag.set(x2, y2);
            return this;
          },
          setDragX: function(value) {
            this.body.drag.x = value;
            return this;
          },
          setDragY: function(value) {
            this.body.drag.y = value;
            return this;
          },
          setDamping: function(value) {
            this.body.useDamping = value;
            return this;
          }
        };
        module2.exports = Drag;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Enable = {
          enableBody: function(reset, x2, y2, enableGameObject, showGameObject) {
            if (reset) {
              this.body.reset(x2, y2);
            }
            if (enableGameObject) {
              this.body.gameObject.active = true;
            }
            if (showGameObject) {
              this.body.gameObject.visible = true;
            }
            this.body.enable = true;
            return this;
          },
          disableBody: function(disableGameObject, hideGameObject) {
            if (disableGameObject === void 0) {
              disableGameObject = false;
            }
            if (hideGameObject === void 0) {
              hideGameObject = false;
            }
            this.body.stop();
            this.body.enable = false;
            if (disableGameObject) {
              this.body.gameObject.active = false;
            }
            if (hideGameObject) {
              this.body.gameObject.visible = false;
            }
            return this;
          },
          refreshBody: function() {
            this.body.updateFromGameObject();
            return this;
          }
        };
        module2.exports = Enable;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Friction = {
          setFriction: function(x2, y2) {
            this.body.friction.set(x2, y2);
            return this;
          },
          setFrictionX: function(x2) {
            this.body.friction.x = x2;
            return this;
          },
          setFrictionY: function(y2) {
            this.body.friction.y = y2;
            return this;
          }
        };
        module2.exports = Friction;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Gravity = {
          setGravity: function(x2, y2) {
            this.body.gravity.set(x2, y2);
            return this;
          },
          setGravityX: function(x2) {
            this.body.gravity.x = x2;
            return this;
          },
          setGravityY: function(y2) {
            this.body.gravity.y = y2;
            return this;
          }
        };
        module2.exports = Gravity;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Immovable = {
          setImmovable: function(value) {
            if (value === void 0) {
              value = true;
            }
            this.body.immovable = value;
            return this;
          }
        };
        module2.exports = Immovable;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Mass = {
          setMass: function(value) {
            this.body.mass = value;
            return this;
          }
        };
        module2.exports = Mass;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Pushable = {
          setPushable: function(value) {
            if (value === void 0) {
              value = true;
            }
            this.body.pushable = value;
            return this;
          }
        };
        module2.exports = Pushable;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Size = {
          setOffset: function(x2, y2) {
            this.body.setOffset(x2, y2);
            return this;
          },
          setSize: function(width, height, center) {
            this.body.setSize(width, height, center);
            return this;
          },
          setBodySize: function(width, height, center) {
            this.body.setSize(width, height, center);
            return this;
          },
          setCircle: function(radius, offsetX, offsetY) {
            this.body.setCircle(radius, offsetX, offsetY);
            return this;
          }
        };
        module2.exports = Size;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Velocity = {
          setVelocity: function(x2, y2) {
            this.body.setVelocity(x2, y2);
            return this;
          },
          setVelocityX: function(x2) {
            this.body.setVelocityX(x2);
            return this;
          },
          setVelocityY: function(y2) {
            this.body.setVelocityY(y2);
            return this;
          },
          setMaxVelocity: function(x2, y2) {
            this.body.maxVelocity.set(x2, y2);
            return this;
          }
        };
        module2.exports = Velocity;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "collide";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "overlap";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pause";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "resume";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "tilecollide";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "tileoverlap";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "worldbounds";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "worldstep";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var body1;
        var body2;
        var body1Pushable;
        var body2Pushable;
        var body1MassImpact;
        var body2MassImpact;
        var body1FullImpact;
        var body2FullImpact;
        var body1MovingLeft;
        var body1MovingRight;
        var body1Stationary;
        var body2MovingLeft;
        var body2MovingRight;
        var body2Stationary;
        var body1OnLeft;
        var body2OnLeft;
        var overlap;
        var Set2 = function(b1, b2, ov) {
          body1 = b1;
          body2 = b2;
          var v1 = body1.velocity.x;
          var v2 = body2.velocity.x;
          body1Pushable = body1.pushable;
          body1MovingLeft = body1._dx < 0;
          body1MovingRight = body1._dx > 0;
          body1Stationary = body1._dx === 0;
          body1OnLeft = Math.abs(body1.right - body2.x) <= Math.abs(body2.right - body1.x);
          body1FullImpact = v2 - v1 * body1.bounce.x;
          body2Pushable = body2.pushable;
          body2MovingLeft = body2._dx < 0;
          body2MovingRight = body2._dx > 0;
          body2Stationary = body2._dx === 0;
          body2OnLeft = !body1OnLeft;
          body2FullImpact = v1 - v2 * body2.bounce.x;
          overlap = Math.abs(ov);
          return BlockCheck();
        };
        var BlockCheck = function() {
          if (body1MovingRight && body1OnLeft && body2.blocked.right) {
            body1.processX(-overlap, body1FullImpact, false, true);
            return 1;
          }
          if (body1MovingLeft && body2OnLeft && body2.blocked.left) {
            body1.processX(overlap, body1FullImpact, true);
            return 1;
          }
          if (body2MovingRight && body2OnLeft && body1.blocked.right) {
            body2.processX(-overlap, body2FullImpact, false, true);
            return 2;
          }
          if (body2MovingLeft && body1OnLeft && body1.blocked.left) {
            body2.processX(overlap, body2FullImpact, true);
            return 2;
          }
          return 0;
        };
        var Check = function() {
          var v1 = body1.velocity.x;
          var v2 = body2.velocity.x;
          var nv1 = Math.sqrt(v2 * v2 * body2.mass / body1.mass) * (v2 > 0 ? 1 : -1);
          var nv2 = Math.sqrt(v1 * v1 * body1.mass / body2.mass) * (v1 > 0 ? 1 : -1);
          var avg = (nv1 + nv2) * 0.5;
          nv1 -= avg;
          nv2 -= avg;
          body1MassImpact = avg + nv1 * body1.bounce.x;
          body2MassImpact = avg + nv2 * body2.bounce.x;
          if (body1MovingLeft && body2OnLeft) {
            return Run(0);
          }
          if (body2MovingLeft && body1OnLeft) {
            return Run(1);
          }
          if (body1MovingRight && body1OnLeft) {
            return Run(2);
          }
          if (body2MovingRight && body2OnLeft) {
            return Run(3);
          }
          return false;
        };
        var Run = function(side) {
          if (body1Pushable && body2Pushable) {
            overlap *= 0.5;
            if (side === 0 || side === 3) {
              body1.processX(overlap, body1MassImpact);
              body2.processX(-overlap, body2MassImpact);
            } else {
              body1.processX(-overlap, body1MassImpact);
              body2.processX(overlap, body2MassImpact);
            }
          } else if (body1Pushable && !body2Pushable) {
            if (side === 0 || side === 3) {
              body1.processX(overlap, body1FullImpact, true);
            } else {
              body1.processX(-overlap, body1FullImpact, false, true);
            }
          } else if (!body1Pushable && body2Pushable) {
            if (side === 0 || side === 3) {
              body2.processX(-overlap, body2FullImpact, false, true);
            } else {
              body2.processX(overlap, body2FullImpact, true);
            }
          } else {
            var halfOverlap = overlap * 0.5;
            if (side === 0) {
              if (body2Stationary) {
                body1.processX(overlap, 0, true);
                body2.processX(0, null, false, true);
              } else if (body2MovingRight) {
                body1.processX(halfOverlap, 0, true);
                body2.processX(-halfOverlap, 0, false, true);
              } else {
                body1.processX(halfOverlap, body2.velocity.x, true);
                body2.processX(-halfOverlap, null, false, true);
              }
            } else if (side === 1) {
              if (body1Stationary) {
                body1.processX(0, null, false, true);
                body2.processX(overlap, 0, true);
              } else if (body1MovingRight) {
                body1.processX(-halfOverlap, 0, false, true);
                body2.processX(halfOverlap, 0, true);
              } else {
                body1.processX(-halfOverlap, null, false, true);
                body2.processX(halfOverlap, body1.velocity.x, true);
              }
            } else if (side === 2) {
              if (body2Stationary) {
                body1.processX(-overlap, 0, false, true);
                body2.processX(0, null, true);
              } else if (body2MovingLeft) {
                body1.processX(-halfOverlap, 0, false, true);
                body2.processX(halfOverlap, 0, true);
              } else {
                body1.processX(-halfOverlap, body2.velocity.x, false, true);
                body2.processX(halfOverlap, null, true);
              }
            } else if (side === 3) {
              if (body1Stationary) {
                body1.processX(0, null, true);
                body2.processX(-overlap, 0, false, true);
              } else if (body1MovingLeft) {
                body1.processX(halfOverlap, 0, true);
                body2.processX(-halfOverlap, 0, false, true);
              } else {
                body1.processX(halfOverlap, body2.velocity.y, true);
                body2.processX(-halfOverlap, null, false, true);
              }
            }
          }
          return true;
        };
        var RunImmovableBody1 = function(blockedState) {
          if (blockedState === 1) {
            body2.velocity.x = 0;
          } else if (body1OnLeft) {
            body2.processX(overlap, body2FullImpact, true);
          } else {
            body2.processX(-overlap, body2FullImpact, false, true);
          }
          if (body1.moves) {
            body2.y += (body1.y - body1.prev.y) * body1.friction.y;
            body2._dy = body2.y - body2.prev.y;
          }
        };
        var RunImmovableBody2 = function(blockedState) {
          if (blockedState === 2) {
            body1.velocity.x = 0;
          } else if (body2OnLeft) {
            body1.processX(overlap, body1FullImpact, true);
          } else {
            body1.processX(-overlap, body1FullImpact, false, true);
          }
          if (body2.moves) {
            body1.y += (body2.y - body2.prev.y) * body2.friction.y;
            body1._dy = body1.y - body1.prev.y;
          }
        };
        module2.exports = {
          BlockCheck,
          Check,
          Set: Set2,
          Run,
          RunImmovableBody1,
          RunImmovableBody2
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var body1;
        var body2;
        var body1Pushable;
        var body2Pushable;
        var body1MassImpact;
        var body2MassImpact;
        var body1FullImpact;
        var body2FullImpact;
        var body1MovingUp;
        var body1MovingDown;
        var body1Stationary;
        var body2MovingUp;
        var body2MovingDown;
        var body2Stationary;
        var body1OnTop;
        var body2OnTop;
        var overlap;
        var Set2 = function(b1, b2, ov) {
          body1 = b1;
          body2 = b2;
          var v1 = body1.velocity.y;
          var v2 = body2.velocity.y;
          body1Pushable = body1.pushable;
          body1MovingUp = body1._dy < 0;
          body1MovingDown = body1._dy > 0;
          body1Stationary = body1._dy === 0;
          body1OnTop = Math.abs(body1.bottom - body2.y) <= Math.abs(body2.bottom - body1.y);
          body1FullImpact = v2 - v1 * body1.bounce.y;
          body2Pushable = body2.pushable;
          body2MovingUp = body2._dy < 0;
          body2MovingDown = body2._dy > 0;
          body2Stationary = body2._dy === 0;
          body2OnTop = !body1OnTop;
          body2FullImpact = v1 - v2 * body2.bounce.y;
          overlap = Math.abs(ov);
          return BlockCheck();
        };
        var BlockCheck = function() {
          if (body1MovingDown && body1OnTop && body2.blocked.down) {
            body1.processY(-overlap, body1FullImpact, false, true);
            return 1;
          }
          if (body1MovingUp && body2OnTop && body2.blocked.up) {
            body1.processY(overlap, body1FullImpact, true);
            return 1;
          }
          if (body2MovingDown && body2OnTop && body1.blocked.down) {
            body2.processY(-overlap, body2FullImpact, false, true);
            return 2;
          }
          if (body2MovingUp && body1OnTop && body1.blocked.up) {
            body2.processY(overlap, body2FullImpact, true);
            return 2;
          }
          return 0;
        };
        var Check = function() {
          var v1 = body1.velocity.y;
          var v2 = body2.velocity.y;
          var nv1 = Math.sqrt(v2 * v2 * body2.mass / body1.mass) * (v2 > 0 ? 1 : -1);
          var nv2 = Math.sqrt(v1 * v1 * body1.mass / body2.mass) * (v1 > 0 ? 1 : -1);
          var avg = (nv1 + nv2) * 0.5;
          nv1 -= avg;
          nv2 -= avg;
          body1MassImpact = avg + nv1 * body1.bounce.y;
          body2MassImpact = avg + nv2 * body2.bounce.y;
          if (body1MovingUp && body2OnTop) {
            return Run(0);
          }
          if (body2MovingUp && body1OnTop) {
            return Run(1);
          }
          if (body1MovingDown && body1OnTop) {
            return Run(2);
          }
          if (body2MovingDown && body2OnTop) {
            return Run(3);
          }
          return false;
        };
        var Run = function(side) {
          if (body1Pushable && body2Pushable) {
            overlap *= 0.5;
            if (side === 0 || side === 3) {
              body1.processY(overlap, body1MassImpact);
              body2.processY(-overlap, body2MassImpact);
            } else {
              body1.processY(-overlap, body1MassImpact);
              body2.processY(overlap, body2MassImpact);
            }
          } else if (body1Pushable && !body2Pushable) {
            if (side === 0 || side === 3) {
              body1.processY(overlap, body1FullImpact, true);
            } else {
              body1.processY(-overlap, body1FullImpact, false, true);
            }
          } else if (!body1Pushable && body2Pushable) {
            if (side === 0 || side === 3) {
              body2.processY(-overlap, body2FullImpact, false, true);
            } else {
              body2.processY(overlap, body2FullImpact, true);
            }
          } else {
            var halfOverlap = overlap * 0.5;
            if (side === 0) {
              if (body2Stationary) {
                body1.processY(overlap, 0, true);
                body2.processY(0, null, false, true);
              } else if (body2MovingDown) {
                body1.processY(halfOverlap, 0, true);
                body2.processY(-halfOverlap, 0, false, true);
              } else {
                body1.processY(halfOverlap, body2.velocity.y, true);
                body2.processY(-halfOverlap, null, false, true);
              }
            } else if (side === 1) {
              if (body1Stationary) {
                body1.processY(0, null, false, true);
                body2.processY(overlap, 0, true);
              } else if (body1MovingDown) {
                body1.processY(-halfOverlap, 0, false, true);
                body2.processY(halfOverlap, 0, true);
              } else {
                body1.processY(-halfOverlap, null, false, true);
                body2.processY(halfOverlap, body1.velocity.y, true);
              }
            } else if (side === 2) {
              if (body2Stationary) {
                body1.processY(-overlap, 0, false, true);
                body2.processY(0, null, true);
              } else if (body2MovingUp) {
                body1.processY(-halfOverlap, 0, false, true);
                body2.processY(halfOverlap, 0, true);
              } else {
                body1.processY(-halfOverlap, body2.velocity.y, false, true);
                body2.processY(halfOverlap, null, true);
              }
            } else if (side === 3) {
              if (body1Stationary) {
                body1.processY(0, null, true);
                body2.processY(-overlap, 0, false, true);
              } else if (body1MovingUp) {
                body1.processY(halfOverlap, 0, true);
                body2.processY(-halfOverlap, 0, false, true);
              } else {
                body1.processY(halfOverlap, body2.velocity.y, true);
                body2.processY(-halfOverlap, null, false, true);
              }
            }
          }
          return true;
        };
        var RunImmovableBody1 = function(blockedState) {
          if (blockedState === 1) {
            body2.velocity.y = 0;
          } else if (body1OnTop) {
            body2.processY(overlap, body2FullImpact, true);
          } else {
            body2.processY(-overlap, body2FullImpact, false, true);
          }
          if (body1.moves) {
            body2.x += (body1.x - body1.prev.x) * body1.friction.x;
            body2._dx = body2.x - body2.prev.x;
          }
        };
        var RunImmovableBody2 = function(blockedState) {
          if (blockedState === 2) {
            body1.velocity.y = 0;
          } else if (body2OnTop) {
            body1.processY(overlap, body1FullImpact, true);
          } else {
            body1.processY(-overlap, body1FullImpact, false, true);
          }
          if (body2.moves) {
            body1.x += (body2.x - body2.prev.x) * body2.friction.x;
            body1._dx = body1.x - body1.prev.x;
          }
        };
        module2.exports = {
          BlockCheck,
          Check,
          Set: Set2,
          Run,
          RunImmovableBody1,
          RunImmovableBody2
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Tilemap = {
          ProcessTileCallbacks: __webpack_require__(530),
          ProcessTileSeparationX: __webpack_require__(534),
          ProcessTileSeparationY: __webpack_require__(536),
          SeparateTile: __webpack_require__(532),
          TileCheckX: __webpack_require__(533),
          TileCheckY: __webpack_require__(535),
          TileIntersectsBody: __webpack_require__(248)
        };
        module2.exports = Tilemap;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Vector2 = __webpack_require__(3);
        var BodyBounds = new Class({
          initialize: function BodyBounds2() {
            this.boundsCenter = new Vector2();
            this.centerDiff = new Vector2();
          },
          parseBody: function(body) {
            body = body.hasOwnProperty("body") ? body.body : body;
            if (!body.hasOwnProperty("bounds") || !body.hasOwnProperty("centerOfMass")) {
              return false;
            }
            var boundsCenter = this.boundsCenter;
            var centerDiff = this.centerDiff;
            var boundsWidth = body.bounds.max.x - body.bounds.min.x;
            var boundsHeight = body.bounds.max.y - body.bounds.min.y;
            var bodyCenterX = boundsWidth * body.centerOfMass.x;
            var bodyCenterY = boundsHeight * body.centerOfMass.y;
            boundsCenter.set(boundsWidth / 2, boundsHeight / 2);
            centerDiff.set(bodyCenterX - boundsCenter.x, bodyCenterY - boundsCenter.y);
            return true;
          },
          getTopLeft: function(body, x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (this.parseBody(body)) {
              var center = this.boundsCenter;
              var diff = this.centerDiff;
              return new Vector2(x2 + center.x + diff.x, y2 + center.y + diff.y);
            }
            return false;
          },
          getTopCenter: function(body, x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (this.parseBody(body)) {
              var center = this.boundsCenter;
              var diff = this.centerDiff;
              return new Vector2(x2 + diff.x, y2 + center.y + diff.y);
            }
            return false;
          },
          getTopRight: function(body, x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (this.parseBody(body)) {
              var center = this.boundsCenter;
              var diff = this.centerDiff;
              return new Vector2(x2 - (center.x - diff.x), y2 + center.y + diff.y);
            }
            return false;
          },
          getLeftCenter: function(body, x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (this.parseBody(body)) {
              var center = this.boundsCenter;
              var diff = this.centerDiff;
              return new Vector2(x2 + center.x + diff.x, y2 + diff.y);
            }
            return false;
          },
          getCenter: function(body, x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (this.parseBody(body)) {
              var diff = this.centerDiff;
              return new Vector2(x2 + diff.x, y2 + diff.y);
            }
            return false;
          },
          getRightCenter: function(body, x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (this.parseBody(body)) {
              var center = this.boundsCenter;
              var diff = this.centerDiff;
              return new Vector2(x2 - (center.x - diff.x), y2 + diff.y);
            }
            return false;
          },
          getBottomLeft: function(body, x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (this.parseBody(body)) {
              var center = this.boundsCenter;
              var diff = this.centerDiff;
              return new Vector2(x2 + center.x + diff.x, y2 - (center.y - diff.y));
            }
            return false;
          },
          getBottomCenter: function(body, x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (this.parseBody(body)) {
              var center = this.boundsCenter;
              var diff = this.centerDiff;
              return new Vector2(x2 + diff.x, y2 - (center.y - diff.y));
            }
            return false;
          },
          getBottomRight: function(body, x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (this.parseBody(body)) {
              var center = this.boundsCenter;
              var diff = this.centerDiff;
              return new Vector2(x2 - (center.x - diff.x), y2 - (center.y - diff.y));
            }
            return false;
          }
        });
        module2.exports = BodyBounds;
      },
      function(module2, exports2) {
        /**
         * @author       Stefan Hedman <schteppe@gmail.com> (http://steffe.se)
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          decomp: polygonDecomp,
          quickDecomp: polygonQuickDecomp,
          isSimple: polygonIsSimple,
          removeCollinearPoints: polygonRemoveCollinearPoints,
          removeDuplicatePoints: polygonRemoveDuplicatePoints,
          makeCCW: polygonMakeCCW
        };
        function lineInt(l1, l2, precision) {
          precision = precision || 0;
          var i2 = [0, 0];
          var a1, b1, c1, a2, b2, c2, det;
          a1 = l1[1][1] - l1[0][1];
          b1 = l1[0][0] - l1[1][0];
          c1 = a1 * l1[0][0] + b1 * l1[0][1];
          a2 = l2[1][1] - l2[0][1];
          b2 = l2[0][0] - l2[1][0];
          c2 = a2 * l2[0][0] + b2 * l2[0][1];
          det = a1 * b2 - a2 * b1;
          if (!scalar_eq(det, 0, precision)) {
            i2[0] = (b2 * c1 - b1 * c2) / det;
            i2[1] = (a1 * c2 - a2 * c1) / det;
          }
          return i2;
        }
        function lineSegmentsIntersect(p1, p2, q1, q2) {
          var dx = p2[0] - p1[0];
          var dy = p2[1] - p1[1];
          var da2 = q2[0] - q1[0];
          var db2 = q2[1] - q1[1];
          if (da2 * dy - db2 * dx === 0) {
            return false;
          }
          var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da2 * dy - db2 * dx);
          var t2 = (da2 * (p1[1] - q1[1]) + db2 * (q1[0] - p1[0])) / (db2 * dx - da2 * dy);
          return s >= 0 && s <= 1 && t2 >= 0 && t2 <= 1;
        }
        function triangleArea(a, b2, c) {
          return (b2[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b2[1] - a[1]);
        }
        function isLeft(a, b2, c) {
          return triangleArea(a, b2, c) > 0;
        }
        function isLeftOn(a, b2, c) {
          return triangleArea(a, b2, c) >= 0;
        }
        function isRight(a, b2, c) {
          return triangleArea(a, b2, c) < 0;
        }
        function isRightOn(a, b2, c) {
          return triangleArea(a, b2, c) <= 0;
        }
        var tmpPoint1 = [], tmpPoint2 = [];
        function collinear(a, b2, c, thresholdAngle) {
          if (!thresholdAngle) {
            return triangleArea(a, b2, c) === 0;
          } else {
            var ab = tmpPoint1, bc2 = tmpPoint2;
            ab[0] = b2[0] - a[0];
            ab[1] = b2[1] - a[1];
            bc2[0] = c[0] - b2[0];
            bc2[1] = c[1] - b2[1];
            var dot = ab[0] * bc2[0] + ab[1] * bc2[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc2[0] * bc2[0] + bc2[1] * bc2[1]), angle = Math.acos(dot / (magA * magB));
            return angle < thresholdAngle;
          }
        }
        function sqdist(a, b2) {
          var dx = b2[0] - a[0];
          var dy = b2[1] - a[1];
          return dx * dx + dy * dy;
        }
        function polygonAt(polygon, i2) {
          var s = polygon.length;
          return polygon[i2 < 0 ? i2 % s + s : i2 % s];
        }
        function polygonClear(polygon) {
          polygon.length = 0;
        }
        function polygonAppend(polygon, poly, from, to) {
          for (var i2 = from; i2 < to; i2++) {
            polygon.push(poly[i2]);
          }
        }
        function polygonMakeCCW(polygon) {
          var br = 0, v2 = polygon;
          for (var i2 = 1; i2 < polygon.length; ++i2) {
            if (v2[i2][1] < v2[br][1] || v2[i2][1] === v2[br][1] && v2[i2][0] > v2[br][0]) {
              br = i2;
            }
          }
          if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
            polygonReverse(polygon);
            return true;
          } else {
            return false;
          }
        }
        function polygonReverse(polygon) {
          var tmp = [];
          var N2 = polygon.length;
          for (var i2 = 0; i2 !== N2; i2++) {
            tmp.push(polygon.pop());
          }
          for (var i2 = 0; i2 !== N2; i2++) {
            polygon[i2] = tmp[i2];
          }
        }
        function polygonIsReflex(polygon, i2) {
          return isRight(polygonAt(polygon, i2 - 1), polygonAt(polygon, i2), polygonAt(polygon, i2 + 1));
        }
        var tmpLine1 = [], tmpLine2 = [];
        function polygonCanSee(polygon, a, b2) {
          var p2, dist, l1 = tmpLine1, l2 = tmpLine2;
          if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b2)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b2))) {
            return false;
          }
          dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b2));
          for (var i2 = 0; i2 !== polygon.length; ++i2) {
            if ((i2 + 1) % polygon.length === a || i2 === a) {
              continue;
            }
            if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b2), polygonAt(polygon, i2 + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b2), polygonAt(polygon, i2))) {
              l1[0] = polygonAt(polygon, a);
              l1[1] = polygonAt(polygon, b2);
              l2[0] = polygonAt(polygon, i2);
              l2[1] = polygonAt(polygon, i2 + 1);
              p2 = lineInt(l1, l2);
              if (sqdist(polygonAt(polygon, a), p2) < dist) {
                return false;
              }
            }
          }
          return true;
        }
        function polygonCanSee2(polygon, a, b2) {
          for (var i2 = 0; i2 !== polygon.length; ++i2) {
            if (i2 === a || i2 === b2 || (i2 + 1) % polygon.length === a || (i2 + 1) % polygon.length === b2) {
              continue;
            }
            if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b2), polygonAt(polygon, i2), polygonAt(polygon, i2 + 1))) {
              return false;
            }
          }
          return true;
        }
        function polygonCopy(polygon, i2, j, targetPoly) {
          var p2 = targetPoly || [];
          polygonClear(p2);
          if (i2 < j) {
            for (var k2 = i2; k2 <= j; k2++) {
              p2.push(polygon[k2]);
            }
          } else {
            for (var k2 = 0; k2 <= j; k2++) {
              p2.push(polygon[k2]);
            }
            for (var k2 = i2; k2 < polygon.length; k2++) {
              p2.push(polygon[k2]);
            }
          }
          return p2;
        }
        function polygonGetCutEdges(polygon) {
          var min = [], tmp1 = [], tmp2 = [], tmpPoly = [];
          var nDiags = Number.MAX_VALUE;
          for (var i2 = 0; i2 < polygon.length; ++i2) {
            if (polygonIsReflex(polygon, i2)) {
              for (var j = 0; j < polygon.length; ++j) {
                if (polygonCanSee(polygon, i2, j)) {
                  tmp1 = polygonGetCutEdges(polygonCopy(polygon, i2, j, tmpPoly));
                  tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i2, tmpPoly));
                  for (var k2 = 0; k2 < tmp2.length; k2++) {
                    tmp1.push(tmp2[k2]);
                  }
                  if (tmp1.length < nDiags) {
                    min = tmp1;
                    nDiags = tmp1.length;
                    min.push([polygonAt(polygon, i2), polygonAt(polygon, j)]);
                  }
                }
              }
            }
          }
          return min;
        }
        function polygonDecomp(polygon) {
          var edges = polygonGetCutEdges(polygon);
          if (edges.length > 0) {
            return polygonSlice(polygon, edges);
          } else {
            return [polygon];
          }
        }
        function polygonSlice(polygon, cutEdges) {
          if (cutEdges.length === 0) {
            return [polygon];
          }
          if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {
            var polys = [polygon];
            for (var i2 = 0; i2 < cutEdges.length; i2++) {
              var cutEdge = cutEdges[i2];
              for (var j = 0; j < polys.length; j++) {
                var poly = polys[j];
                var result = polygonSlice(poly, cutEdge);
                if (result) {
                  polys.splice(j, 1);
                  polys.push(result[0], result[1]);
                  break;
                }
              }
            }
            return polys;
          } else {
            var cutEdge = cutEdges;
            var i2 = polygon.indexOf(cutEdge[0]);
            var j = polygon.indexOf(cutEdge[1]);
            if (i2 !== -1 && j !== -1) {
              return [
                polygonCopy(polygon, i2, j),
                polygonCopy(polygon, j, i2)
              ];
            } else {
              return false;
            }
          }
        }
        function polygonIsSimple(polygon) {
          var path = polygon, i2;
          for (i2 = 0; i2 < path.length - 1; i2++) {
            for (var j = 0; j < i2 - 1; j++) {
              if (lineSegmentsIntersect(path[i2], path[i2 + 1], path[j], path[j + 1])) {
                return false;
              }
            }
          }
          for (i2 = 1; i2 < path.length - 2; i2++) {
            if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i2], path[i2 + 1])) {
              return false;
            }
          }
          return true;
        }
        function getIntersectionPoint(p1, p2, q1, q2, delta) {
          delta = delta || 0;
          var a1 = p2[1] - p1[1];
          var b1 = p1[0] - p2[0];
          var c1 = a1 * p1[0] + b1 * p1[1];
          var a2 = q2[1] - q1[1];
          var b2 = q1[0] - q2[0];
          var c2 = a2 * q1[0] + b2 * q1[1];
          var det = a1 * b2 - a2 * b1;
          if (!scalar_eq(det, 0, delta)) {
            return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];
          } else {
            return [0, 0];
          }
        }
        function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {
          maxlevel = maxlevel || 100;
          level = level || 0;
          delta = delta || 25;
          result = typeof result !== "undefined" ? result : [];
          reflexVertices = reflexVertices || [];
          steinerPoints = steinerPoints || [];
          var upperInt = [0, 0], lowerInt = [0, 0], p2 = [0, 0];
          var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0;
          var upperIndex = 0, lowerIndex = 0, closestIndex = 0;
          var lowerPoly = [], upperPoly = [];
          var poly = polygon, v2 = polygon;
          if (v2.length < 3) {
            return result;
          }
          level++;
          if (level > maxlevel) {
            console.warn("quickDecomp: max level (" + maxlevel + ") reached.");
            return result;
          }
          for (var i2 = 0; i2 < polygon.length; ++i2) {
            if (polygonIsReflex(poly, i2)) {
              reflexVertices.push(poly[i2]);
              upperDist = lowerDist = Number.MAX_VALUE;
              for (var j = 0; j < polygon.length; ++j) {
                if (isLeft(polygonAt(poly, i2 - 1), polygonAt(poly, i2), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i2 - 1), polygonAt(poly, i2), polygonAt(poly, j - 1))) {
                  p2 = getIntersectionPoint(polygonAt(poly, i2 - 1), polygonAt(poly, i2), polygonAt(poly, j), polygonAt(poly, j - 1));
                  if (isRight(polygonAt(poly, i2 + 1), polygonAt(poly, i2), p2)) {
                    d = sqdist(poly[i2], p2);
                    if (d < lowerDist) {
                      lowerDist = d;
                      lowerInt = p2;
                      lowerIndex = j;
                    }
                  }
                }
                if (isLeft(polygonAt(poly, i2 + 1), polygonAt(poly, i2), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i2 + 1), polygonAt(poly, i2), polygonAt(poly, j))) {
                  p2 = getIntersectionPoint(polygonAt(poly, i2 + 1), polygonAt(poly, i2), polygonAt(poly, j), polygonAt(poly, j + 1));
                  if (isLeft(polygonAt(poly, i2 - 1), polygonAt(poly, i2), p2)) {
                    d = sqdist(poly[i2], p2);
                    if (d < upperDist) {
                      upperDist = d;
                      upperInt = p2;
                      upperIndex = j;
                    }
                  }
                }
              }
              if (lowerIndex === (upperIndex + 1) % polygon.length) {
                p2[0] = (lowerInt[0] + upperInt[0]) / 2;
                p2[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p2);
                if (i2 < upperIndex) {
                  polygonAppend(lowerPoly, poly, i2, upperIndex + 1);
                  lowerPoly.push(p2);
                  upperPoly.push(p2);
                  if (lowerIndex !== 0) {
                    polygonAppend(upperPoly, poly, lowerIndex, poly.length);
                  }
                  polygonAppend(upperPoly, poly, 0, i2 + 1);
                } else {
                  if (i2 !== 0) {
                    polygonAppend(lowerPoly, poly, i2, poly.length);
                  }
                  polygonAppend(lowerPoly, poly, 0, upperIndex + 1);
                  lowerPoly.push(p2);
                  upperPoly.push(p2);
                  polygonAppend(upperPoly, poly, lowerIndex, i2 + 1);
                }
              } else {
                if (lowerIndex > upperIndex) {
                  upperIndex += polygon.length;
                }
                closestDist = Number.MAX_VALUE;
                if (upperIndex < lowerIndex) {
                  return result;
                }
                for (var j = lowerIndex; j <= upperIndex; ++j) {
                  if (isLeftOn(polygonAt(poly, i2 - 1), polygonAt(poly, i2), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i2 + 1), polygonAt(poly, i2), polygonAt(poly, j))) {
                    d = sqdist(polygonAt(poly, i2), polygonAt(poly, j));
                    if (d < closestDist && polygonCanSee2(poly, i2, j)) {
                      closestDist = d;
                      closestIndex = j % polygon.length;
                    }
                  }
                }
                if (i2 < closestIndex) {
                  polygonAppend(lowerPoly, poly, i2, closestIndex + 1);
                  if (closestIndex !== 0) {
                    polygonAppend(upperPoly, poly, closestIndex, v2.length);
                  }
                  polygonAppend(upperPoly, poly, 0, i2 + 1);
                } else {
                  if (i2 !== 0) {
                    polygonAppend(lowerPoly, poly, i2, v2.length);
                  }
                  polygonAppend(lowerPoly, poly, 0, closestIndex + 1);
                  polygonAppend(upperPoly, poly, closestIndex, i2 + 1);
                }
              }
              if (lowerPoly.length < upperPoly.length) {
                polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
              } else {
                polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
              }
              return result;
            }
          }
          result.push(polygon);
          return result;
        }
        function polygonRemoveCollinearPoints(polygon, precision) {
          var num = 0;
          for (var i2 = polygon.length - 1; polygon.length > 3 && i2 >= 0; --i2) {
            if (collinear(polygonAt(polygon, i2 - 1), polygonAt(polygon, i2), polygonAt(polygon, i2 + 1), precision)) {
              polygon.splice(i2 % polygon.length, 1);
              num++;
            }
          }
          return num;
        }
        function polygonRemoveDuplicatePoints(polygon, precision) {
          for (var i2 = polygon.length - 1; i2 >= 1; --i2) {
            var pi2 = polygon[i2];
            for (var j = i2 - 1; j >= 0; --j) {
              if (points_eq(pi2, polygon[j], precision)) {
                polygon.splice(i2, 1);
                continue;
              }
            }
          }
        }
        function scalar_eq(a, b2, precision) {
          precision = precision || 0;
          return Math.abs(a - b2) <= precision;
        }
        function points_eq(a, b2, precision) {
          return scalar_eq(a[0], b2[0], precision) && scalar_eq(a[1], b2[1], precision);
        }
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Bodies = __webpack_require__(86);
        var Class = __webpack_require__(0);
        var Composites = __webpack_require__(591);
        var Constraint = __webpack_require__(128);
        var Svg = __webpack_require__(592);
        var MatterGameObject = __webpack_require__(1395);
        var MatterImage = __webpack_require__(1396);
        var MatterSprite = __webpack_require__(1397);
        var MatterTileBody = __webpack_require__(593);
        var PhysicsEditorParser = __webpack_require__(589);
        var PhysicsJSONParser = __webpack_require__(590);
        var PointerConstraint = __webpack_require__(1398);
        var Vertices = __webpack_require__(64);
        var Factory = new Class({
          initialize: function Factory2(world) {
            this.world = world;
            this.scene = world.scene;
            this.sys = world.scene.sys;
          },
          rectangle: function(x2, y2, width, height, options) {
            var body = Bodies.rectangle(x2, y2, width, height, options);
            this.world.add(body);
            return body;
          },
          trapezoid: function(x2, y2, width, height, slope, options) {
            var body = Bodies.trapezoid(x2, y2, width, height, slope, options);
            this.world.add(body);
            return body;
          },
          circle: function(x2, y2, radius, options, maxSides) {
            var body = Bodies.circle(x2, y2, radius, options, maxSides);
            this.world.add(body);
            return body;
          },
          polygon: function(x2, y2, sides, radius, options) {
            var body = Bodies.polygon(x2, y2, sides, radius, options);
            this.world.add(body);
            return body;
          },
          fromVertices: function(x2, y2, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
            if (typeof vertexSets === "string") {
              vertexSets = Vertices.fromPath(vertexSets);
            }
            var body = Bodies.fromVertices(x2, y2, vertexSets, options, flagInternal, removeCollinear, minimumArea);
            this.world.add(body);
            return body;
          },
          fromPhysicsEditor: function(x2, y2, config, options, addToWorld) {
            if (addToWorld === void 0) {
              addToWorld = true;
            }
            var body = PhysicsEditorParser.parseBody(x2, y2, config, options);
            if (addToWorld && !this.world.has(body)) {
              this.world.add(body);
            }
            return body;
          },
          fromSVG: function(x2, y2, xml, scale, options, addToWorld) {
            if (scale === void 0) {
              scale = 1;
            }
            if (options === void 0) {
              options = {};
            }
            if (addToWorld === void 0) {
              addToWorld = true;
            }
            var path = xml.getElementsByTagName("path");
            var vertexSets = [];
            for (var i2 = 0; i2 < path.length; i2++) {
              var points = Svg.pathToVertices(path[i2], 30);
              if (scale !== 1) {
                Vertices.scale(points, scale, scale);
              }
              vertexSets.push(points);
            }
            var body = Bodies.fromVertices(x2, y2, vertexSets, options);
            if (addToWorld) {
              this.world.add(body);
            }
            return body;
          },
          fromJSON: function(x2, y2, config, options, addToWorld) {
            if (options === void 0) {
              options = {};
            }
            if (addToWorld === void 0) {
              addToWorld = true;
            }
            var body = PhysicsJSONParser.parseBody(x2, y2, config, options);
            if (body && addToWorld) {
              this.world.add(body);
            }
            return body;
          },
          imageStack: function(key, frame, x2, y2, columns, rows, columnGap, rowGap, options) {
            if (columnGap === void 0) {
              columnGap = 0;
            }
            if (rowGap === void 0) {
              rowGap = 0;
            }
            if (options === void 0) {
              options = {};
            }
            var world = this.world;
            var displayList = this.sys.displayList;
            options.addToWorld = false;
            var stack = Composites.stack(x2, y2, columns, rows, columnGap, rowGap, function(x3, y3) {
              var image = new MatterImage(world, x3, y3, key, frame, options);
              displayList.add(image);
              return image.body;
            });
            world.add(stack);
            return stack;
          },
          stack: function(x2, y2, columns, rows, columnGap, rowGap, callback) {
            var stack = Composites.stack(x2, y2, columns, rows, columnGap, rowGap, callback);
            this.world.add(stack);
            return stack;
          },
          pyramid: function(x2, y2, columns, rows, columnGap, rowGap, callback) {
            var stack = Composites.pyramid(x2, y2, columns, rows, columnGap, rowGap, callback);
            this.world.add(stack);
            return stack;
          },
          chain: function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
            return Composites.chain(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options);
          },
          mesh: function(composite, columns, rows, crossBrace, options) {
            return Composites.mesh(composite, columns, rows, crossBrace, options);
          },
          newtonsCradle: function(x2, y2, number, size, length) {
            var composite = Composites.newtonsCradle(x2, y2, number, size, length);
            this.world.add(composite);
            return composite;
          },
          car: function(x2, y2, width, height, wheelSize) {
            var composite = Composites.car(x2, y2, width, height, wheelSize);
            this.world.add(composite);
            return composite;
          },
          softBody: function(x2, y2, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
            var composite = Composites.softBody(x2, y2, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions);
            this.world.add(composite);
            return composite;
          },
          joint: function(bodyA, bodyB, length, stiffness, options) {
            return this.constraint(bodyA, bodyB, length, stiffness, options);
          },
          spring: function(bodyA, bodyB, length, stiffness, options) {
            return this.constraint(bodyA, bodyB, length, stiffness, options);
          },
          constraint: function(bodyA, bodyB, length, stiffness, options) {
            if (stiffness === void 0) {
              stiffness = 1;
            }
            if (options === void 0) {
              options = {};
            }
            options.bodyA = bodyA.type === "body" ? bodyA : bodyA.body;
            options.bodyB = bodyB.type === "body" ? bodyB : bodyB.body;
            if (!isNaN(length)) {
              options.length = length;
            }
            options.stiffness = stiffness;
            var constraint = Constraint.create(options);
            this.world.add(constraint);
            return constraint;
          },
          worldConstraint: function(body, length, stiffness, options) {
            if (stiffness === void 0) {
              stiffness = 1;
            }
            if (options === void 0) {
              options = {};
            }
            options.bodyB = body.type === "body" ? body : body.body;
            if (!isNaN(length)) {
              options.length = length;
            }
            options.stiffness = stiffness;
            var constraint = Constraint.create(options);
            this.world.add(constraint);
            return constraint;
          },
          mouseSpring: function(options) {
            return this.pointerConstraint(options);
          },
          pointerConstraint: function(options) {
            if (options === void 0) {
              options = {};
            }
            if (!options.hasOwnProperty("render")) {
              options.render = { visible: false };
            }
            var pointerConstraint = new PointerConstraint(this.scene, this.world, options);
            this.world.add(pointerConstraint.constraint);
            return pointerConstraint;
          },
          image: function(x2, y2, key, frame, options) {
            var image = new MatterImage(this.world, x2, y2, key, frame, options);
            this.sys.displayList.add(image);
            return image;
          },
          tileBody: function(tile, options) {
            return new MatterTileBody(this.world, tile, options);
          },
          sprite: function(x2, y2, key, frame, options) {
            var sprite = new MatterSprite(this.world, x2, y2, key, frame, options);
            this.sys.displayList.add(sprite);
            this.sys.updateList.add(sprite);
            return sprite;
          },
          gameObject: function(gameObject, options, addToWorld) {
            return MatterGameObject(this.world, gameObject, options, addToWorld);
          },
          destroy: function() {
            this.world = null;
            this.scene = null;
            this.sys = null;
          }
        });
        module2.exports = Factory;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Components = __webpack_require__(249);
        var GetFastValue = __webpack_require__(2);
        var Vector2 = __webpack_require__(3);
        function hasGetterOrSetter(def) {
          return !!def.get && typeof def.get === "function" || !!def.set && typeof def.set === "function";
        }
        var MatterGameObject = function(world, gameObject, options, addToWorld) {
          if (options === void 0) {
            options = {};
          }
          if (addToWorld === void 0) {
            addToWorld = true;
          }
          var x2 = gameObject.x;
          var y2 = gameObject.y;
          gameObject.body = {
            temp: true,
            position: {
              x: x2,
              y: y2
            }
          };
          var mixins = [
            Components.Bounce,
            Components.Collision,
            Components.Force,
            Components.Friction,
            Components.Gravity,
            Components.Mass,
            Components.Sensor,
            Components.SetBody,
            Components.Sleep,
            Components.Static,
            Components.Transform,
            Components.Velocity
          ];
          mixins.forEach(function(mixin) {
            for (var key in mixin) {
              if (hasGetterOrSetter(mixin[key])) {
                Object.defineProperty(gameObject, key, {
                  get: mixin[key].get,
                  set: mixin[key].set
                });
              } else {
                Object.defineProperty(gameObject, key, { value: mixin[key] });
              }
            }
          });
          gameObject.world = world;
          gameObject._tempVec2 = new Vector2(x2, y2);
          if (options.hasOwnProperty("type") && options.type === "body") {
            gameObject.setExistingBody(options, addToWorld);
          } else {
            var shape = GetFastValue(options, "shape", null);
            if (!shape) {
              shape = "rectangle";
            }
            options.addToWorld = addToWorld;
            gameObject.setBody(shape, options);
          }
          return gameObject;
        };
        module2.exports = MatterGameObject;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(249);
        var GameObject = __webpack_require__(15);
        var GetFastValue = __webpack_require__(2);
        var Image2 = __webpack_require__(125);
        var Pipeline = __webpack_require__(167);
        var Vector2 = __webpack_require__(3);
        var MatterImage = new Class({
          Extends: Image2,
          Mixins: [
            Components.Bounce,
            Components.Collision,
            Components.Force,
            Components.Friction,
            Components.Gravity,
            Components.Mass,
            Components.Sensor,
            Components.SetBody,
            Components.Sleep,
            Components.Static,
            Components.Transform,
            Components.Velocity,
            Pipeline
          ],
          initialize: function MatterImage2(world, x2, y2, texture, frame, options) {
            GameObject.call(this, world.scene, "Image");
            this._crop = this.resetCropObject();
            this.setTexture(texture, frame);
            this.setSizeToFrame();
            this.setOrigin();
            this.world = world;
            this._tempVec2 = new Vector2(x2, y2);
            var shape = GetFastValue(options, "shape", null);
            if (shape) {
              this.setBody(shape, options);
            } else {
              this.setRectangle(this.width, this.height, options);
            }
            this.setPosition(x2, y2);
            this.initPipeline();
          }
        });
        module2.exports = MatterImage;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var AnimationState = __webpack_require__(164);
        var Class = __webpack_require__(0);
        var Components = __webpack_require__(249);
        var GameObject = __webpack_require__(15);
        var GetFastValue = __webpack_require__(2);
        var Pipeline = __webpack_require__(167);
        var Sprite = __webpack_require__(73);
        var Vector2 = __webpack_require__(3);
        var MatterSprite = new Class({
          Extends: Sprite,
          Mixins: [
            Components.Bounce,
            Components.Collision,
            Components.Force,
            Components.Friction,
            Components.Gravity,
            Components.Mass,
            Components.Sensor,
            Components.SetBody,
            Components.Sleep,
            Components.Static,
            Components.Transform,
            Components.Velocity,
            Pipeline
          ],
          initialize: function MatterSprite2(world, x2, y2, texture, frame, options) {
            GameObject.call(this, world.scene, "Sprite");
            this._crop = this.resetCropObject();
            this.anims = new AnimationState(this);
            this.setTexture(texture, frame);
            this.setSizeToFrame();
            this.setOrigin();
            this.world = world;
            this._tempVec2 = new Vector2(x2, y2);
            var shape = GetFastValue(options, "shape", null);
            if (shape) {
              this.setBody(shape, options);
            } else {
              this.setRectangle(this.width, this.height, options);
            }
            this.setPosition(x2, y2);
            this.initPipeline();
          }
        });
        module2.exports = MatterSprite;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Bounds = __webpack_require__(84);
        var Class = __webpack_require__(0);
        var Composite = __webpack_require__(118);
        var Constraint = __webpack_require__(128);
        var Detector = __webpack_require__(273);
        var Events = __webpack_require__(272);
        var InputEvents = __webpack_require__(51);
        var Merge = __webpack_require__(127);
        var Sleeping = __webpack_require__(165);
        var Vector2 = __webpack_require__(3);
        var Vertices = __webpack_require__(64);
        var PointerConstraint = new Class({
          initialize: function PointerConstraint2(scene, world, options) {
            if (options === void 0) {
              options = {};
            }
            var defaults = {
              label: "Pointer Constraint",
              pointA: { x: 0, y: 0 },
              pointB: { x: 0, y: 0 },
              length: 0.01,
              stiffness: 0.1,
              angularStiffness: 1,
              collisionFilter: {
                category: 1,
                mask: 4294967295,
                group: 0
              }
            };
            this.scene = scene;
            this.world = world;
            this.camera = null;
            this.pointer = null;
            this.active = true;
            this.position = new Vector2();
            this.body = null;
            this.part = null;
            this.constraint = Constraint.create(Merge(options, defaults));
            this.world.on(Events.BEFORE_UPDATE, this.update, this);
            scene.sys.input.on(InputEvents.POINTER_DOWN, this.onDown, this);
            scene.sys.input.on(InputEvents.POINTER_UP, this.onUp, this);
          },
          onDown: function(pointer) {
            if (!this.pointer) {
              this.pointer = pointer;
              this.camera = pointer.camera;
            }
          },
          onUp: function(pointer) {
            if (pointer === this.pointer) {
              this.pointer = null;
            }
          },
          getBody: function(pointer) {
            var pos = this.position;
            var constraint = this.constraint;
            this.camera.getWorldPoint(pointer.x, pointer.y, pos);
            var bodies = Composite.allBodies(this.world.localWorld);
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2];
              if (!body.ignorePointer && Bounds.contains(body.bounds, pos) && Detector.canCollide(body.collisionFilter, constraint.collisionFilter)) {
                if (this.hitTestBody(body, pos)) {
                  this.world.emit(Events.DRAG_START, body, this.part, this);
                  return true;
                }
              }
            }
            return false;
          },
          hitTestBody: function(body, position) {
            var constraint = this.constraint;
            var partsLength = body.parts.length;
            var start = partsLength > 1 ? 1 : 0;
            for (var i2 = start; i2 < partsLength; i2++) {
              var part = body.parts[i2];
              if (Vertices.contains(part.vertices, position)) {
                constraint.pointA = position;
                constraint.pointB = { x: position.x - body.position.x, y: position.y - body.position.y };
                constraint.bodyB = body;
                constraint.angleB = body.angle;
                Sleeping.set(body, false);
                this.part = part;
                this.body = body;
                return true;
              }
            }
            return false;
          },
          update: function() {
            var pointer = this.pointer;
            var body = this.body;
            if (!this.active || !pointer) {
              if (body) {
                this.stopDrag();
              }
              return;
            }
            if (!pointer.isDown && body) {
              this.stopDrag();
              return;
            } else if (pointer.isDown) {
              if (!body && !this.getBody(pointer)) {
                return;
              }
              body = this.body;
              var pos = this.position;
              var constraint = this.constraint;
              this.camera.getWorldPoint(pointer.x, pointer.y, pos);
              constraint.pointA.x = pos.x;
              constraint.pointA.y = pos.y;
              Sleeping.set(body, false);
              this.world.emit(Events.DRAG, body, this);
            }
          },
          stopDrag: function() {
            var body = this.body;
            var constraint = this.constraint;
            constraint.bodyB = null;
            constraint.pointB = null;
            this.pointer = null;
            this.body = null;
            this.part = null;
            if (body) {
              this.world.emit(Events.DRAG_END, body, this);
            }
          },
          destroy: function() {
            this.world.removeConstraint(this.constraint);
            this.pointer = null;
            this.constraint = null;
            this.body = null;
            this.part = null;
            this.world.off(Events.BEFORE_UPDATE, this.update);
            this.scene.sys.input.off(InputEvents.POINTER_DOWN, this.onDown, this);
            this.scene.sys.input.off(InputEvents.POINTER_UP, this.onUp, this);
          }
        });
        module2.exports = PointerConstraint;
      },
      function(module2, exports2, __webpack_require__) {
        var Matter = {};
        module2.exports = Matter;
        var Plugin = __webpack_require__(595);
        var Common = __webpack_require__(32);
        (function() {
          Matter.name = "matter-js";
          Matter.version = "0.14.2";
          Matter.uses = [];
          Matter.used = [];
          Matter.use = function() {
            Plugin.use(Matter, Array.prototype.slice.call(arguments));
          };
          Matter.before = function(path, func) {
            path = path.replace(/^Matter./, "");
            return Common.chainPathBefore(Matter, path, func);
          };
          Matter.after = function(path, func) {
            path = path.replace(/^Matter./, "");
            return Common.chainPathAfter(Matter, path, func);
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        var Query = {};
        module2.exports = Query;
        var Vector = __webpack_require__(83);
        var SAT = __webpack_require__(274);
        var Bounds = __webpack_require__(84);
        var Bodies = __webpack_require__(86);
        var Vertices = __webpack_require__(64);
        (function() {
          Query.collides = function(body, bodies) {
            var collisions = [];
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var bodyA = bodies[i2];
              if (body === bodyA) {
                continue;
              }
              if (Bounds.overlaps(bodyA.bounds, body.bounds)) {
                for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {
                  var part = bodyA.parts[j];
                  if (Bounds.overlaps(part.bounds, body.bounds)) {
                    var collision = SAT.collides(part, body);
                    if (collision.collided) {
                      collisions.push(collision);
                      break;
                    }
                  }
                }
              }
            }
            return collisions;
          };
          Query.ray = function(bodies, startPoint, endPoint, rayWidth) {
            rayWidth = rayWidth || 1e-100;
            var rayAngle = Vector.angle(startPoint, endPoint), rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)), rayX = (endPoint.x + startPoint.x) * 0.5, rayY = (endPoint.y + startPoint.y) * 0.5, ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, { angle: rayAngle }), collisions = Query.collides(ray, bodies);
            for (var i2 = 0; i2 < collisions.length; i2 += 1) {
              var collision = collisions[i2];
              collision.body = collision.bodyB = collision.bodyA;
            }
            return collisions;
          };
          Query.region = function(bodies, bounds, outside) {
            var result = [];
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2], overlaps = Bounds.overlaps(body.bounds, bounds);
              if (overlaps && !outside || !overlaps && outside)
                result.push(body);
            }
            return result;
          };
          Query.point = function(bodies, point) {
            var result = [];
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2];
              if (Bounds.contains(body.bounds, point)) {
                for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {
                  var part = body.parts[j];
                  if (Bounds.contains(part.bounds, point) && Vertices.contains(part.vertices, point)) {
                    result.push(body);
                    break;
                  }
                }
              }
            }
            return result;
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        var Engine = {};
        module2.exports = Engine;
        var World = __webpack_require__(596);
        var Sleeping = __webpack_require__(165);
        var Resolver = __webpack_require__(599);
        var Pairs = __webpack_require__(598);
        var Metrics = __webpack_require__(1523);
        var Grid = __webpack_require__(597);
        var Events = __webpack_require__(166);
        var Composite = __webpack_require__(118);
        var Constraint = __webpack_require__(128);
        var Common = __webpack_require__(32);
        var Body = __webpack_require__(41);
        (function() {
          Engine.create = function(element, options) {
            options = Common.isElement(element) ? options : element;
            element = Common.isElement(element) ? element : null;
            options = options || {};
            if (element || options.render) {
              Common.warn("Engine.create: engine.render is deprecated (see docs)");
            }
            var defaults = {
              positionIterations: 6,
              velocityIterations: 4,
              constraintIterations: 2,
              enableSleeping: false,
              events: [],
              plugin: {},
              timing: {
                timestamp: 0,
                timeScale: 1
              },
              broadphase: {
                controller: Grid
              }
            };
            var engine = Common.extend(defaults, options);
            engine.world = options.world || World.create(engine.world);
            engine.pairs = Pairs.create();
            engine.broadphase = engine.broadphase.controller.create(engine.broadphase);
            engine.metrics = engine.metrics || { extended: false };
            engine.metrics = Metrics.create(engine.metrics);
            return engine;
          };
          Engine.update = function(engine, delta, correction) {
            delta = delta || 1e3 / 60;
            correction = correction || 1;
            var world = engine.world, timing = engine.timing, broadphase = engine.broadphase, broadphasePairs = [], i2;
            timing.timestamp += delta * timing.timeScale;
            var event = {
              timestamp: timing.timestamp
            };
            Events.trigger(engine, "beforeUpdate", event);
            var allBodies = Composite.allBodies(world), allConstraints = Composite.allConstraints(world);
            Metrics.reset(engine.metrics);
            if (engine.enableSleeping)
              Sleeping.update(allBodies, timing.timeScale);
            Engine._bodiesApplyGravity(allBodies, world.gravity);
            Engine._bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);
            Constraint.preSolveAll(allBodies);
            for (i2 = 0; i2 < engine.constraintIterations; i2++) {
              Constraint.solveAll(allConstraints, timing.timeScale);
            }
            Constraint.postSolveAll(allBodies);
            if (broadphase.controller) {
              if (world.isModified)
                broadphase.controller.clear(broadphase);
              broadphase.controller.update(broadphase, allBodies, engine, world.isModified);
              broadphasePairs = broadphase.pairsList;
            } else {
              broadphasePairs = allBodies;
            }
            if (world.isModified) {
              Composite.setModified(world, false, false, true);
            }
            var collisions = broadphase.detector(broadphasePairs, engine);
            var pairs = engine.pairs, timestamp = timing.timestamp;
            Pairs.update(pairs, collisions, timestamp);
            Pairs.removeOld(pairs, timestamp);
            if (engine.enableSleeping)
              Sleeping.afterCollisions(pairs.list, timing.timeScale);
            if (pairs.collisionStart.length > 0)
              Events.trigger(engine, "collisionStart", { pairs: pairs.collisionStart });
            Resolver.preSolvePosition(pairs.list);
            for (i2 = 0; i2 < engine.positionIterations; i2++) {
              Resolver.solvePosition(pairs.list, allBodies, timing.timeScale);
            }
            Resolver.postSolvePosition(allBodies);
            Constraint.preSolveAll(allBodies);
            for (i2 = 0; i2 < engine.constraintIterations; i2++) {
              Constraint.solveAll(allConstraints, timing.timeScale);
            }
            Constraint.postSolveAll(allBodies);
            Resolver.preSolveVelocity(pairs.list);
            for (i2 = 0; i2 < engine.velocityIterations; i2++) {
              Resolver.solveVelocity(pairs.list, timing.timeScale);
            }
            if (pairs.collisionActive.length > 0)
              Events.trigger(engine, "collisionActive", { pairs: pairs.collisionActive });
            if (pairs.collisionEnd.length > 0)
              Events.trigger(engine, "collisionEnd", { pairs: pairs.collisionEnd });
            Metrics.update(engine.metrics, engine);
            Engine._bodiesClearForces(allBodies);
            Events.trigger(engine, "afterUpdate", event);
            return engine;
          };
          Engine.merge = function(engineA, engineB) {
            Common.extend(engineA, engineB);
            if (engineB.world) {
              engineA.world = engineB.world;
              Engine.clear(engineA);
              var bodies = Composite.allBodies(engineA.world);
              for (var i2 = 0; i2 < bodies.length; i2++) {
                var body = bodies[i2];
                Sleeping.set(body, false);
                body.id = Common.nextId();
              }
            }
          };
          Engine.clear = function(engine) {
            var world = engine.world;
            Pairs.clear(engine.pairs);
            var broadphase = engine.broadphase;
            if (broadphase.controller) {
              var bodies = Composite.allBodies(world);
              broadphase.controller.clear(broadphase);
              broadphase.controller.update(broadphase, bodies, engine, true);
            }
          };
          Engine._bodiesClearForces = function(bodies) {
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2];
              body.force.x = 0;
              body.force.y = 0;
              body.torque = 0;
            }
          };
          Engine._bodiesApplyGravity = function(bodies, gravity) {
            var gravityScale = typeof gravity.scale !== "undefined" ? gravity.scale : 1e-3;
            if (gravity.x === 0 && gravity.y === 0 || gravityScale === 0) {
              return;
            }
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2];
              if (body.ignoreGravity || body.isStatic || body.isSleeping)
                continue;
              body.force.x += body.mass * gravity.x * gravityScale * body.gravityScale.x;
              body.force.y += body.mass * gravity.y * gravityScale * body.gravityScale.y;
            }
          };
          Engine._bodiesUpdate = function(bodies, deltaTime, timeScale, correction, worldBounds) {
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2];
              if (body.isStatic || body.isSleeping)
                continue;
              Body.update(body, deltaTime, timeScale, correction);
            }
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Bodies = __webpack_require__(86);
        var Body = __webpack_require__(41);
        var Class = __webpack_require__(0);
        var Common = __webpack_require__(32);
        var Composite = __webpack_require__(118);
        var Engine = __webpack_require__(1401);
        var EventEmitter = __webpack_require__(9);
        var Events = __webpack_require__(272);
        var GetFastValue = __webpack_require__(2);
        var GetValue = __webpack_require__(6);
        var MatterBody = __webpack_require__(41);
        var MatterEvents = __webpack_require__(166);
        var MatterTileBody = __webpack_require__(593);
        var MatterWorld = __webpack_require__(596);
        var Vector = __webpack_require__(83);
        var World = new Class({
          Extends: EventEmitter,
          initialize: function World2(scene, config) {
            EventEmitter.call(this);
            this.scene = scene;
            this.engine = Engine.create(config);
            this.localWorld = this.engine.world;
            var gravity = GetValue(config, "gravity", null);
            if (gravity) {
              this.setGravity(gravity.x, gravity.y, gravity.scale);
            } else if (gravity === false) {
              this.setGravity(0, 0, 0);
            }
            this.walls = { left: null, right: null, top: null, bottom: null };
            this.enabled = GetValue(config, "enabled", true);
            this.correction = GetValue(config, "correction", 1);
            this.getDelta = GetValue(config, "getDelta", this.update60Hz);
            var runnerConfig = GetFastValue(config, "runner", {});
            var hasFPS = GetFastValue(runnerConfig, "fps", false);
            var fps = GetFastValue(runnerConfig, "fps", 60);
            var delta = GetFastValue(runnerConfig, "delta", 1e3 / fps);
            var deltaMin = GetFastValue(runnerConfig, "deltaMin", 1e3 / fps);
            var deltaMax = GetFastValue(runnerConfig, "deltaMax", 1e3 / (fps * 0.5));
            if (!hasFPS) {
              fps = 1e3 / delta;
            }
            this.runner = {
              fps,
              correction: GetFastValue(runnerConfig, "correction", 1),
              deltaSampleSize: GetFastValue(runnerConfig, "deltaSampleSize", 60),
              counterTimestamp: 0,
              frameCounter: 0,
              deltaHistory: [],
              timePrev: null,
              timeScalePrev: 1,
              frameRequestId: null,
              isFixed: GetFastValue(runnerConfig, "isFixed", false),
              delta,
              deltaMin,
              deltaMax
            };
            this.autoUpdate = GetValue(config, "autoUpdate", true);
            var debugConfig = GetValue(config, "debug", false);
            this.drawDebug = typeof debugConfig === "object" ? true : debugConfig;
            this.debugGraphic;
            this.debugConfig = {
              showAxes: GetFastValue(debugConfig, "showAxes", false),
              showAngleIndicator: GetFastValue(debugConfig, "showAngleIndicator", false),
              angleColor: GetFastValue(debugConfig, "angleColor", 15208787),
              showBroadphase: GetFastValue(debugConfig, "showBroadphase", false),
              broadphaseColor: GetFastValue(debugConfig, "broadphaseColor", 16757760),
              showBounds: GetFastValue(debugConfig, "showBounds", false),
              boundsColor: GetFastValue(debugConfig, "boundsColor", 16777215),
              showVelocity: GetFastValue(debugConfig, "showVelocity", false),
              velocityColor: GetFastValue(debugConfig, "velocityColor", 44783),
              showCollisions: GetFastValue(debugConfig, "showCollisions", false),
              collisionColor: GetFastValue(debugConfig, "collisionColor", 16094476),
              showSeparations: GetFastValue(debugConfig, "showSeparations", false),
              separationColor: GetFastValue(debugConfig, "separationColor", 16753920),
              showBody: GetFastValue(debugConfig, "showBody", true),
              showStaticBody: GetFastValue(debugConfig, "showStaticBody", true),
              showInternalEdges: GetFastValue(debugConfig, "showInternalEdges", false),
              renderFill: GetFastValue(debugConfig, "renderFill", false),
              renderLine: GetFastValue(debugConfig, "renderLine", true),
              fillColor: GetFastValue(debugConfig, "fillColor", 1075465),
              fillOpacity: GetFastValue(debugConfig, "fillOpacity", 1),
              lineColor: GetFastValue(debugConfig, "lineColor", 2678297),
              lineOpacity: GetFastValue(debugConfig, "lineOpacity", 1),
              lineThickness: GetFastValue(debugConfig, "lineThickness", 1),
              staticFillColor: GetFastValue(debugConfig, "staticFillColor", 857979),
              staticLineColor: GetFastValue(debugConfig, "staticLineColor", 1255396),
              showSleeping: GetFastValue(debugConfig, "showSleeping", false),
              staticBodySleepOpacity: GetFastValue(debugConfig, "staticBodySleepOpacity", 0.7),
              sleepFillColor: GetFastValue(debugConfig, "sleepFillColor", 4605510),
              sleepLineColor: GetFastValue(debugConfig, "sleepLineColor", 10066585),
              showSensors: GetFastValue(debugConfig, "showSensors", true),
              sensorFillColor: GetFastValue(debugConfig, "sensorFillColor", 857979),
              sensorLineColor: GetFastValue(debugConfig, "sensorLineColor", 1255396),
              showPositions: GetFastValue(debugConfig, "showPositions", true),
              positionSize: GetFastValue(debugConfig, "positionSize", 4),
              positionColor: GetFastValue(debugConfig, "positionColor", 14697178),
              showJoint: GetFastValue(debugConfig, "showJoint", true),
              jointColor: GetFastValue(debugConfig, "jointColor", 14737474),
              jointLineOpacity: GetFastValue(debugConfig, "jointLineOpacity", 1),
              jointLineThickness: GetFastValue(debugConfig, "jointLineThickness", 2),
              pinSize: GetFastValue(debugConfig, "pinSize", 4),
              pinColor: GetFastValue(debugConfig, "pinColor", 4382944),
              springColor: GetFastValue(debugConfig, "springColor", 14697184),
              anchorColor: GetFastValue(debugConfig, "anchorColor", 15724527),
              anchorSize: GetFastValue(debugConfig, "anchorSize", 4),
              showConvexHulls: GetFastValue(debugConfig, "showConvexHulls", false),
              hullColor: GetFastValue(debugConfig, "hullColor", 14091216)
            };
            if (this.drawDebug) {
              this.createDebugGraphic();
            }
            this.setEventsProxy();
            if (GetFastValue(config, "setBounds", false)) {
              var boundsConfig = config["setBounds"];
              if (typeof boundsConfig === "boolean") {
                this.setBounds();
              } else {
                var x2 = GetFastValue(boundsConfig, "x", 0);
                var y2 = GetFastValue(boundsConfig, "y", 0);
                var width = GetFastValue(boundsConfig, "width", scene.sys.scale.width);
                var height = GetFastValue(boundsConfig, "height", scene.sys.scale.height);
                var thickness = GetFastValue(boundsConfig, "thickness", 64);
                var left = GetFastValue(boundsConfig, "left", true);
                var right = GetFastValue(boundsConfig, "right", true);
                var top = GetFastValue(boundsConfig, "top", true);
                var bottom = GetFastValue(boundsConfig, "bottom", true);
                this.setBounds(x2, y2, width, height, thickness, left, right, top, bottom);
              }
            }
          },
          setCompositeRenderStyle: function(composite) {
            var bodies = composite.bodies;
            var constraints = composite.constraints;
            var composites = composite.composites;
            var i2;
            var obj;
            var render;
            for (i2 = 0; i2 < bodies.length; i2++) {
              obj = bodies[i2];
              render = obj.render;
              this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);
            }
            for (i2 = 0; i2 < constraints.length; i2++) {
              obj = constraints[i2];
              render = obj.render;
              this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);
            }
            for (i2 = 0; i2 < composites.length; i2++) {
              obj = composites[i2];
              this.setCompositeRenderStyle(obj);
            }
            return this;
          },
          setBodyRenderStyle: function(body, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity) {
            var render = body.render;
            var config = this.debugConfig;
            if (!render) {
              return this;
            }
            if (lineColor === void 0 || lineColor === null) {
              lineColor = body.isStatic ? config.staticLineColor : config.lineColor;
            }
            if (lineOpacity === void 0 || lineOpacity === null) {
              lineOpacity = config.lineOpacity;
            }
            if (lineThickness === void 0 || lineThickness === null) {
              lineThickness = config.lineThickness;
            }
            if (fillColor === void 0 || fillColor === null) {
              fillColor = body.isStatic ? config.staticFillColor : config.fillColor;
            }
            if (fillOpacity === void 0 || fillOpacity === null) {
              fillOpacity = config.fillOpacity;
            }
            if (lineColor !== false) {
              render.lineColor = lineColor;
            }
            if (lineOpacity !== false) {
              render.lineOpacity = lineOpacity;
            }
            if (lineThickness !== false) {
              render.lineThickness = lineThickness;
            }
            if (fillColor !== false) {
              render.fillColor = fillColor;
            }
            if (fillOpacity !== false) {
              render.fillOpacity = fillOpacity;
            }
            return this;
          },
          setConstraintRenderStyle: function(constraint, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize) {
            var render = constraint.render;
            var config = this.debugConfig;
            if (!render) {
              return this;
            }
            if (lineColor === void 0 || lineColor === null) {
              var type = render.type;
              if (type === "line") {
                lineColor = config.jointColor;
              } else if (type === "pin") {
                lineColor = config.pinColor;
              } else if (type === "spring") {
                lineColor = config.springColor;
              }
            }
            if (lineOpacity === void 0 || lineOpacity === null) {
              lineOpacity = config.jointLineOpacity;
            }
            if (lineThickness === void 0 || lineThickness === null) {
              lineThickness = config.jointLineThickness;
            }
            if (pinSize === void 0 || pinSize === null) {
              pinSize = config.pinSize;
            }
            if (anchorColor === void 0 || anchorColor === null) {
              anchorColor = config.anchorColor;
            }
            if (anchorSize === void 0 || anchorSize === null) {
              anchorSize = config.anchorSize;
            }
            if (lineColor !== false) {
              render.lineColor = lineColor;
            }
            if (lineOpacity !== false) {
              render.lineOpacity = lineOpacity;
            }
            if (lineThickness !== false) {
              render.lineThickness = lineThickness;
            }
            if (pinSize !== false) {
              render.pinSize = pinSize;
            }
            if (anchorColor !== false) {
              render.anchorColor = anchorColor;
            }
            if (anchorSize !== false) {
              render.anchorSize = anchorSize;
            }
            return this;
          },
          setEventsProxy: function() {
            var _this = this;
            var engine = this.engine;
            var world = this.localWorld;
            if (this.drawDebug) {
              MatterEvents.on(world, "compositeModified", function(composite) {
                _this.setCompositeRenderStyle(composite);
              });
              MatterEvents.on(world, "beforeAdd", function(event) {
                var objects = [].concat(event.object);
                for (var i2 = 0; i2 < objects.length; i2++) {
                  var obj = objects[i2];
                  var render = obj.render;
                  if (obj.type === "body") {
                    _this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);
                  } else if (obj.type === "composite") {
                    _this.setCompositeRenderStyle(obj);
                  } else if (obj.type === "constraint") {
                    _this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);
                  }
                }
              });
            }
            MatterEvents.on(world, "beforeAdd", function(event) {
              _this.emit(Events.BEFORE_ADD, event);
            });
            MatterEvents.on(world, "afterAdd", function(event) {
              _this.emit(Events.AFTER_ADD, event);
            });
            MatterEvents.on(world, "beforeRemove", function(event) {
              _this.emit(Events.BEFORE_REMOVE, event);
            });
            MatterEvents.on(world, "afterRemove", function(event) {
              _this.emit(Events.AFTER_REMOVE, event);
            });
            MatterEvents.on(engine, "beforeUpdate", function(event) {
              _this.emit(Events.BEFORE_UPDATE, event);
            });
            MatterEvents.on(engine, "afterUpdate", function(event) {
              _this.emit(Events.AFTER_UPDATE, event);
            });
            MatterEvents.on(engine, "collisionStart", function(event) {
              var pairs = event.pairs;
              var bodyA;
              var bodyB;
              if (pairs.length > 0) {
                bodyA = pairs[0].bodyA;
                bodyB = pairs[0].bodyB;
              }
              _this.emit(Events.COLLISION_START, event, bodyA, bodyB);
            });
            MatterEvents.on(engine, "collisionActive", function(event) {
              var pairs = event.pairs;
              var bodyA;
              var bodyB;
              if (pairs.length > 0) {
                bodyA = pairs[0].bodyA;
                bodyB = pairs[0].bodyB;
              }
              _this.emit(Events.COLLISION_ACTIVE, event, bodyA, bodyB);
            });
            MatterEvents.on(engine, "collisionEnd", function(event) {
              var pairs = event.pairs;
              var bodyA;
              var bodyB;
              if (pairs.length > 0) {
                bodyA = pairs[0].bodyA;
                bodyB = pairs[0].bodyB;
              }
              _this.emit(Events.COLLISION_END, event, bodyA, bodyB);
            });
          },
          setBounds: function(x2, y2, width, height, thickness, left, right, top, bottom) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 0;
            }
            if (width === void 0) {
              width = this.scene.sys.scale.width;
            }
            if (height === void 0) {
              height = this.scene.sys.scale.height;
            }
            if (thickness === void 0) {
              thickness = 64;
            }
            if (left === void 0) {
              left = true;
            }
            if (right === void 0) {
              right = true;
            }
            if (top === void 0) {
              top = true;
            }
            if (bottom === void 0) {
              bottom = true;
            }
            this.updateWall(left, "left", x2 - thickness, y2 - thickness, thickness, height + thickness * 2);
            this.updateWall(right, "right", x2 + width, y2 - thickness, thickness, height + thickness * 2);
            this.updateWall(top, "top", x2, y2 - thickness, width, thickness);
            this.updateWall(bottom, "bottom", x2, y2 + height, width, thickness);
            return this;
          },
          updateWall: function(add, position, x2, y2, width, height) {
            var wall = this.walls[position];
            if (add) {
              if (wall) {
                MatterWorld.remove(this.localWorld, wall);
              }
              x2 += width / 2;
              y2 += height / 2;
              this.walls[position] = this.create(x2, y2, width, height, { isStatic: true, friction: 0, frictionStatic: 0 });
            } else {
              if (wall) {
                MatterWorld.remove(this.localWorld, wall);
              }
              this.walls[position] = null;
            }
          },
          createDebugGraphic: function() {
            var graphic = this.scene.sys.add.graphics({ x: 0, y: 0 });
            graphic.setDepth(Number.MAX_VALUE);
            this.debugGraphic = graphic;
            this.drawDebug = true;
            return graphic;
          },
          disableGravity: function() {
            this.localWorld.gravity.x = 0;
            this.localWorld.gravity.y = 0;
            this.localWorld.gravity.scale = 0;
            return this;
          },
          setGravity: function(x2, y2, scale) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = 1;
            }
            this.localWorld.gravity.x = x2;
            this.localWorld.gravity.y = y2;
            if (scale !== void 0) {
              this.localWorld.gravity.scale = scale;
            }
            return this;
          },
          create: function(x2, y2, width, height, options) {
            var body = Bodies.rectangle(x2, y2, width, height, options);
            MatterWorld.add(this.localWorld, body);
            return body;
          },
          add: function(object) {
            MatterWorld.add(this.localWorld, object);
            return this;
          },
          remove: function(object, deep) {
            if (!Array.isArray(object)) {
              object = [object];
            }
            for (var i2 = 0; i2 < object.length; i2++) {
              var entity = object[i2];
              var body = entity.body ? entity.body : entity;
              Composite.remove(this.localWorld, body, deep);
            }
            return this;
          },
          removeConstraint: function(constraint, deep) {
            Composite.remove(this.localWorld, constraint, deep);
            return this;
          },
          convertTilemapLayer: function(tilemapLayer, options) {
            var layerData = tilemapLayer.layer;
            var tiles = tilemapLayer.getTilesWithin(0, 0, layerData.width, layerData.height, { isColliding: true });
            this.convertTiles(tiles, options);
            return this;
          },
          convertTiles: function(tiles, options) {
            if (tiles.length === 0) {
              return this;
            }
            for (var i2 = 0; i2 < tiles.length; i2++) {
              new MatterTileBody(this, tiles[i2], options);
            }
            return this;
          },
          nextGroup: function(isNonColliding) {
            return MatterBody.nextGroup(isNonColliding);
          },
          nextCategory: function() {
            return MatterBody.nextCategory();
          },
          pause: function() {
            this.enabled = false;
            this.emit(Events.PAUSE);
            return this;
          },
          resume: function() {
            this.enabled = true;
            this.emit(Events.RESUME);
            return this;
          },
          update: function(time, delta) {
            if (!this.enabled || !this.autoUpdate) {
              return;
            }
            var engine = this.engine;
            var runner = this.runner;
            var timing = engine.timing;
            var correction = this.correction;
            if (runner.isFixed) {
              delta = this.getDelta(time, delta);
            } else {
              delta = time - runner.timePrev || runner.delta;
              runner.timePrev = time;
              runner.deltaHistory.push(delta);
              runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);
              delta = Math.min.apply(null, runner.deltaHistory);
              delta = delta < runner.deltaMin ? runner.deltaMin : delta;
              delta = delta > runner.deltaMax ? runner.deltaMax : delta;
              correction = delta / runner.delta;
              runner.delta = delta;
            }
            if (runner.timeScalePrev !== 0) {
              correction *= timing.timeScale / runner.timeScalePrev;
            }
            if (timing.timeScale === 0) {
              correction = 0;
            }
            runner.timeScalePrev = timing.timeScale;
            runner.correction = correction;
            runner.frameCounter += 1;
            if (time - runner.counterTimestamp >= 1e3) {
              runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1e3);
              runner.counterTimestamp = time;
              runner.frameCounter = 0;
            }
            Engine.update(engine, delta, correction);
          },
          step: function(delta, correction) {
            Engine.update(this.engine, delta, correction);
          },
          update60Hz: function() {
            return 1e3 / 60;
          },
          update30Hz: function() {
            return 1e3 / 30;
          },
          has: function(body) {
            var src = body.hasOwnProperty("body") ? body.body : body;
            return Composite.get(this.localWorld, src.id, src.type) !== null;
          },
          getAllBodies: function() {
            return Composite.allBodies(this.localWorld);
          },
          getAllConstraints: function() {
            return Composite.allConstraints(this.localWorld);
          },
          getAllComposites: function() {
            return Composite.allComposites(this.localWorld);
          },
          postUpdate: function() {
            if (!this.drawDebug) {
              return;
            }
            var config = this.debugConfig;
            var engine = this.engine;
            var graphics = this.debugGraphic;
            var bodies = Composite.allBodies(this.localWorld);
            this.debugGraphic.clear();
            if (config.showBroadphase && engine.broadphase.controller) {
              this.renderGrid(engine.broadphase, graphics, config.broadphaseColor, 0.5);
            }
            if (config.showBounds) {
              this.renderBodyBounds(bodies, graphics, config.boundsColor, 0.5);
            }
            if (config.showBody || config.showStaticBody) {
              this.renderBodies(bodies);
            }
            if (config.showJoint) {
              this.renderJoints();
            }
            if (config.showAxes || config.showAngleIndicator) {
              this.renderBodyAxes(bodies, graphics, config.showAxes, config.angleColor, 0.5);
            }
            if (config.showVelocity) {
              this.renderBodyVelocity(bodies, graphics, config.velocityColor, 1, 2);
            }
            if (config.showSeparations) {
              this.renderSeparations(engine.pairs.list, graphics, config.separationColor);
            }
            if (config.showCollisions) {
              this.renderCollisions(engine.pairs.list, graphics, config.collisionColor);
            }
          },
          renderGrid: function(grid, graphics, lineColor, lineOpacity) {
            graphics.lineStyle(1, lineColor, lineOpacity);
            var bucketKeys = Common.keys(grid.buckets);
            for (var i2 = 0; i2 < bucketKeys.length; i2++) {
              var bucketId = bucketKeys[i2];
              if (grid.buckets[bucketId].length < 2) {
                continue;
              }
              var region = bucketId.split(/C|R/);
              graphics.strokeRect(parseInt(region[1], 10) * grid.bucketWidth, parseInt(region[2], 10) * grid.bucketHeight, grid.bucketWidth, grid.bucketHeight);
            }
            return this;
          },
          renderSeparations: function(pairs, graphics, lineColor) {
            graphics.lineStyle(1, lineColor, 1);
            for (var i2 = 0; i2 < pairs.length; i2++) {
              var pair = pairs[i2];
              if (!pair.isActive) {
                continue;
              }
              var collision = pair.collision;
              var bodyA = collision.bodyA;
              var bodyB = collision.bodyB;
              var posA = bodyA.position;
              var posB = bodyB.position;
              var penetration = collision.penetration;
              var k2 = !bodyA.isStatic && !bodyB.isStatic ? 4 : 1;
              if (bodyB.isStatic) {
                k2 = 0;
              }
              graphics.lineBetween(posB.x, posB.y, posB.x - penetration.x * k2, posB.y - penetration.y * k2);
              k2 = !bodyA.isStatic && !bodyB.isStatic ? 4 : 1;
              if (bodyA.isStatic) {
                k2 = 0;
              }
              graphics.lineBetween(posA.x, posA.y, posA.x - penetration.x * k2, posA.y - penetration.y * k2);
            }
            return this;
          },
          renderCollisions: function(pairs, graphics, lineColor) {
            graphics.lineStyle(1, lineColor, 0.5);
            graphics.fillStyle(lineColor, 1);
            var i2;
            var pair;
            for (i2 = 0; i2 < pairs.length; i2++) {
              pair = pairs[i2];
              if (!pair.isActive) {
                continue;
              }
              for (var j = 0; j < pair.activeContacts.length; j++) {
                var contact = pair.activeContacts[j];
                var vertex = contact.vertex;
                graphics.fillRect(vertex.x - 2, vertex.y - 2, 5, 5);
              }
            }
            for (i2 = 0; i2 < pairs.length; i2++) {
              pair = pairs[i2];
              if (!pair.isActive) {
                continue;
              }
              var collision = pair.collision;
              var contacts = pair.activeContacts;
              if (contacts.length > 0) {
                var normalPosX = contacts[0].vertex.x;
                var normalPosY = contacts[0].vertex.y;
                if (contacts.length === 2) {
                  normalPosX = (contacts[0].vertex.x + contacts[1].vertex.x) / 2;
                  normalPosY = (contacts[0].vertex.y + contacts[1].vertex.y) / 2;
                }
                if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic) {
                  graphics.lineBetween(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8, normalPosX, normalPosY);
                } else {
                  graphics.lineBetween(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8, normalPosX, normalPosY);
                }
              }
            }
            return this;
          },
          renderBodyBounds: function(bodies, graphics, lineColor, lineOpacity) {
            graphics.lineStyle(1, lineColor, lineOpacity);
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2];
              if (!body.render.visible) {
                continue;
              }
              var bounds = body.bounds;
              if (bounds) {
                graphics.strokeRect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);
              } else {
                var parts = body.parts;
                for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                  var part = parts[j];
                  graphics.strokeRect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);
                }
              }
            }
            return this;
          },
          renderBodyAxes: function(bodies, graphics, showAxes, lineColor, lineOpacity) {
            graphics.lineStyle(1, lineColor, lineOpacity);
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2];
              var parts = body.parts;
              if (!body.render.visible) {
                continue;
              }
              var part;
              var j;
              var k2;
              if (showAxes) {
                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                  part = parts[j];
                  for (k2 = 0; k2 < part.axes.length; k2++) {
                    var axis = part.axes[k2];
                    graphics.lineBetween(part.position.x, part.position.y, part.position.x + axis.x * 20, part.position.y + axis.y * 20);
                  }
                }
              } else {
                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                  part = parts[j];
                  for (k2 = 0; k2 < part.axes.length; k2++) {
                    graphics.lineBetween(part.position.x, part.position.y, (part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2);
                  }
                }
              }
            }
            return this;
          },
          renderBodyVelocity: function(bodies, graphics, lineColor, lineOpacity, lineThickness) {
            graphics.lineStyle(lineThickness, lineColor, lineOpacity);
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2];
              if (!body.render.visible) {
                continue;
              }
              graphics.lineBetween(body.position.x, body.position.y, body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);
            }
            return this;
          },
          renderBodies: function(bodies) {
            var graphics = this.debugGraphic;
            var config = this.debugConfig;
            var showBody = config.showBody;
            var showStaticBody = config.showStaticBody;
            var showSleeping = config.showSleeping;
            var showInternalEdges = config.showInternalEdges;
            var showConvexHulls = config.showConvexHulls;
            var renderFill = config.renderFill;
            var renderLine = config.renderLine;
            var staticBodySleepOpacity = config.staticBodySleepOpacity;
            var sleepFillColor = config.sleepFillColor;
            var sleepLineColor = config.sleepLineColor;
            var hullColor = config.hullColor;
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2];
              if (!body.render.visible) {
                continue;
              }
              if (!showStaticBody && body.isStatic || !showBody && !body.isStatic) {
                continue;
              }
              var lineColor = body.render.lineColor;
              var lineOpacity = body.render.lineOpacity;
              var lineThickness = body.render.lineThickness;
              var fillColor = body.render.fillColor;
              var fillOpacity = body.render.fillOpacity;
              if (showSleeping && body.isSleeping) {
                if (body.isStatic) {
                  lineOpacity *= staticBodySleepOpacity;
                  fillOpacity *= staticBodySleepOpacity;
                } else {
                  lineColor = sleepLineColor;
                  fillColor = sleepFillColor;
                }
              }
              if (!renderFill) {
                fillColor = null;
              }
              if (!renderLine) {
                lineColor = null;
              }
              this.renderBody(body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity);
              var partsLength = body.parts.length;
              if (showConvexHulls && partsLength > 1) {
                this.renderConvexHull(body, graphics, hullColor, lineThickness);
              }
            }
          },
          renderBody: function(body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity) {
            if (lineColor === void 0) {
              lineColor = null;
            }
            if (lineOpacity === void 0) {
              lineOpacity = null;
            }
            if (lineThickness === void 0) {
              lineThickness = 1;
            }
            if (fillColor === void 0) {
              fillColor = null;
            }
            if (fillOpacity === void 0) {
              fillOpacity = null;
            }
            var config = this.debugConfig;
            var sensorFillColor = config.sensorFillColor;
            var sensorLineColor = config.sensorLineColor;
            var parts = body.parts;
            var partsLength = parts.length;
            for (var k2 = partsLength > 1 ? 1 : 0; k2 < partsLength; k2++) {
              var part = parts[k2];
              var render = part.render;
              var opacity = render.opacity;
              if (!render.visible || opacity === 0 || part.isSensor && !config.showSensors) {
                continue;
              }
              var circleRadius = part.circleRadius;
              graphics.beginPath();
              if (part.isSensor) {
                if (fillColor !== null) {
                  graphics.fillStyle(sensorFillColor, fillOpacity * opacity);
                }
                if (lineColor !== null) {
                  graphics.lineStyle(lineThickness, sensorLineColor, lineOpacity * opacity);
                }
              } else {
                if (fillColor !== null) {
                  graphics.fillStyle(fillColor, fillOpacity * opacity);
                }
                if (lineColor !== null) {
                  graphics.lineStyle(lineThickness, lineColor, lineOpacity * opacity);
                }
              }
              if (circleRadius) {
                graphics.arc(part.position.x, part.position.y, circleRadius, 0, 2 * Math.PI);
              } else {
                var vertices = part.vertices;
                var vertLength = vertices.length;
                graphics.moveTo(vertices[0].x, vertices[0].y);
                for (var j = 1; j < vertLength; j++) {
                  var vert = vertices[j];
                  if (!vertices[j - 1].isInternal || showInternalEdges) {
                    graphics.lineTo(vert.x, vert.y);
                  } else {
                    graphics.moveTo(vert.x, vert.y);
                  }
                  if (j < vertLength && vert.isInternal && !showInternalEdges) {
                    var nextIndex = (j + 1) % vertLength;
                    graphics.moveTo(vertices[nextIndex].x, vertices[nextIndex].y);
                  }
                }
                graphics.closePath();
              }
              if (fillColor !== null) {
                graphics.fillPath();
              }
              if (lineColor !== null) {
                graphics.strokePath();
              }
            }
            if (config.showPositions && !body.isStatic) {
              var px = body.position.x;
              var py = body.position.y;
              var hs = Math.ceil(config.positionSize / 2);
              graphics.fillStyle(config.positionColor, 1);
              graphics.fillRect(px - hs, py - hs, config.positionSize, config.positionSize);
            }
            return this;
          },
          renderConvexHull: function(body, graphics, hullColor, lineThickness) {
            if (lineThickness === void 0) {
              lineThickness = 1;
            }
            var parts = body.parts;
            var partsLength = parts.length;
            if (partsLength > 1) {
              var verts = body.vertices;
              graphics.lineStyle(lineThickness, hullColor);
              graphics.beginPath();
              graphics.moveTo(verts[0].x, verts[0].y);
              for (var v2 = 1; v2 < verts.length; v2++) {
                graphics.lineTo(verts[v2].x, verts[v2].y);
              }
              graphics.lineTo(verts[0].x, verts[0].y);
              graphics.strokePath();
            }
            return this;
          },
          renderJoints: function() {
            var graphics = this.debugGraphic;
            var constraints = Composite.allConstraints(this.localWorld);
            for (var i2 = 0; i2 < constraints.length; i2++) {
              var config = constraints[i2].render;
              var lineColor = config.lineColor;
              var lineOpacity = config.lineOpacity;
              var lineThickness = config.lineThickness;
              var pinSize = config.pinSize;
              var anchorColor = config.anchorColor;
              var anchorSize = config.anchorSize;
              this.renderConstraint(constraints[i2], graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize);
            }
          },
          renderConstraint: function(constraint, graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize) {
            var render = constraint.render;
            if (!render.visible || !constraint.pointA || !constraint.pointB) {
              return this;
            }
            graphics.lineStyle(lineThickness, lineColor, lineOpacity);
            var bodyA = constraint.bodyA;
            var bodyB = constraint.bodyB;
            var start;
            var end;
            if (bodyA) {
              start = Vector.add(bodyA.position, constraint.pointA);
            } else {
              start = constraint.pointA;
            }
            if (render.type === "pin") {
              graphics.strokeCircle(start.x, start.y, pinSize);
            } else {
              if (bodyB) {
                end = Vector.add(bodyB.position, constraint.pointB);
              } else {
                end = constraint.pointB;
              }
              graphics.beginPath();
              graphics.moveTo(start.x, start.y);
              if (render.type === "spring") {
                var delta = Vector.sub(end, start);
                var normal = Vector.perp(Vector.normalise(delta));
                var coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20));
                var offset;
                for (var j = 1; j < coils; j += 1) {
                  offset = j % 2 === 0 ? 1 : -1;
                  graphics.lineTo(start.x + delta.x * (j / coils) + normal.x * offset * 4, start.y + delta.y * (j / coils) + normal.y * offset * 4);
                }
              }
              graphics.lineTo(end.x, end.y);
            }
            graphics.strokePath();
            if (render.anchors && anchorSize > 0) {
              graphics.fillStyle(anchorColor);
              graphics.fillCircle(start.x, start.y, anchorSize);
              graphics.fillCircle(end.x, end.y, anchorSize);
            }
            return this;
          },
          resetCollisionIDs: function() {
            Body._nextCollidingGroupId = 1;
            Body._nextNonCollidingGroupId = -1;
            Body._nextCategory = 1;
            return this;
          },
          shutdown: function() {
            MatterEvents.off(this.engine);
            this.removeAllListeners();
            MatterWorld.clear(this.localWorld, false);
            Engine.clear(this.engine);
            if (this.drawDebug) {
              this.debugGraphic.destroy();
            }
          },
          destroy: function() {
            this.shutdown();
          }
        });
        module2.exports = World;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          BasePlugin: __webpack_require__(540),
          DefaultPlugins: __webpack_require__(197),
          PluginCache: __webpack_require__(24),
          PluginManager: __webpack_require__(414),
          ScenePlugin: __webpack_require__(1404)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
        * @author       Richard Davey <rich@photonstorm.com>
        * @copyright    2020 Photon Storm Ltd.
        * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}
        */
        var BasePlugin = __webpack_require__(540);
        var Class = __webpack_require__(0);
        var SceneEvents = __webpack_require__(20);
        var ScenePlugin = new Class({
          Extends: BasePlugin,
          initialize: function ScenePlugin2(scene, pluginManager, pluginKey) {
            BasePlugin.call(this, pluginManager);
            this.scene = scene;
            this.systems = scene.sys;
            this.pluginKey = pluginKey;
            scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
          },
          boot: function() {
          },
          destroy: function() {
            this.pluginManager = null;
            this.game = null;
            this.scene = null;
            this.systems = null;
          }
        });
        module2.exports = ScenePlugin;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Canvas: __webpack_require__(1406),
          Events: __webpack_require__(91),
          Snapshot: __webpack_require__(1407),
          WebGL: __webpack_require__(1408)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          CanvasRenderer: __webpack_require__(368),
          GetBlendModes: __webpack_require__(370),
          SetTransform: __webpack_require__(30)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Canvas: __webpack_require__(369),
          WebGL: __webpack_require__(383)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var WEBGL_CONST = __webpack_require__(107);
        var Extend = __webpack_require__(17);
        var WebGL = {
          PipelineManager: __webpack_require__(372),
          Pipelines: __webpack_require__(1409),
          RenderTarget: __webpack_require__(141),
          Utils: __webpack_require__(12),
          WebGLPipeline: __webpack_require__(58),
          WebGLRenderer: __webpack_require__(371),
          WebGLShader: __webpack_require__(375)
        };
        WebGL = Extend(false, WebGL, WEBGL_CONST);
        module2.exports = WebGL;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(92);
        var Extend = __webpack_require__(17);
        var Pipelines = {
          BitmapMaskPipeline: __webpack_require__(373),
          Events: __webpack_require__(374),
          GraphicsPipeline: __webpack_require__(376),
          LightPipeline: __webpack_require__(377),
          MultiPipeline: __webpack_require__(108),
          PointLightPipeline: __webpack_require__(378),
          PostFXPipeline: __webpack_require__(1410),
          RopePipeline: __webpack_require__(379),
          SinglePipeline: __webpack_require__(380),
          UtilityPipeline: __webpack_require__(381)
        };
        Pipelines = Extend(false, Pipelines, CONST);
        module2.exports = Pipelines;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var ColorMatrix = __webpack_require__(198);
        var GetFastValue = __webpack_require__(2);
        var ShaderSourceFS = __webpack_require__(1411);
        var ShaderSourceVS = __webpack_require__(382);
        var WebGLPipeline = __webpack_require__(58);
        var PostFXPipeline = new Class({
          Extends: WebGLPipeline,
          initialize: function PostFXPipeline2(config) {
            config.renderTarget = GetFastValue(config, "renderTarget", 1);
            config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS);
            config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS);
            config.attributes = GetFastValue(config, "attributes", [
              {
                name: "inPosition",
                size: 2
              },
              {
                name: "inTexCoord",
                size: 2
              }
            ]);
            config.batchSize = 1;
            config.vertices = [
              -1,
              -1,
              0,
              0,
              -1,
              1,
              0,
              1,
              1,
              1,
              1,
              1,
              -1,
              -1,
              0,
              0,
              1,
              1,
              1,
              1,
              1,
              -1,
              1,
              0
            ];
            WebGLPipeline.call(this, config);
            this.isPostFX = true;
            this.gameObject;
            this.colorMatrix = new ColorMatrix();
            this.fullFrame1;
            this.fullFrame2;
            this.halfFrame1;
            this.halfFrame2;
            if (this.renderer.isBooted) {
              this.manager = this.renderer.pipelines;
              this.boot();
            }
          },
          boot: function() {
            WebGLPipeline.prototype.boot.call(this);
            var utility = this.manager.UTILITY_PIPELINE;
            this.fullFrame1 = utility.fullFrame1;
            this.fullFrame2 = utility.fullFrame2;
            this.halfFrame1 = utility.halfFrame1;
            this.halfFrame2 = utility.halfFrame2;
            this.set1i("uMainSampler", 0);
          },
          onDraw: function(renderTarget) {
            this.bindAndDraw(renderTarget);
          },
          copyFrame: function(source, target, brightness, clear, clearAlpha) {
            this.manager.copyFrame(source, target, brightness, clear, clearAlpha);
          },
          copyToGame: function(source) {
            this.manager.copyToGame(source);
          },
          drawFrame: function(source, target, clearAlpha) {
            this.manager.drawFrame(source, target, clearAlpha, this.colorMatrix);
          },
          blendFrames: function(source1, source2, target, strength, clearAlpha) {
            this.manager.blendFrames(source1, source2, target, strength, clearAlpha);
          },
          blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
            this.manager.blendFramesAdditive(source1, source2, target, strength, clearAlpha);
          },
          clearFrame: function(target, clearAlpha) {
            this.manager.clearFrame(target, clearAlpha);
          },
          blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode) {
            this.manager.blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);
          },
          copyFrameRect: function(source, target, x2, y2, width, height, clear, clearAlpha) {
            this.manager.copyFrameRect(source, target, x2, y2, width, height, clear, clearAlpha);
          },
          bindAndDraw: function(source, target, clear, clearAlpha, currentShader) {
            if (clear === void 0) {
              clear = true;
            }
            if (clearAlpha === void 0) {
              clearAlpha = true;
            }
            var gl2 = this.gl;
            var renderer = this.renderer;
            this.bind(currentShader);
            this.set1i("uMainSampler", 0);
            if (target) {
              gl2.viewport(0, 0, target.width, target.height);
              gl2.bindFramebuffer(gl2.FRAMEBUFFER, target.framebuffer);
              gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, target.texture, 0);
              if (clear) {
                if (clearAlpha) {
                  gl2.clearColor(0, 0, 0, 0);
                } else {
                  gl2.clearColor(0, 0, 0, 1);
                }
                gl2.clear(gl2.COLOR_BUFFER_BIT);
              }
            } else {
              renderer.popFramebuffer(false, false, false);
              if (!renderer.currentFramebuffer) {
                gl2.viewport(0, 0, renderer.width, renderer.height);
              }
            }
            gl2.activeTexture(gl2.TEXTURE0);
            gl2.bindTexture(gl2.TEXTURE_2D, source.texture);
            gl2.bufferData(gl2.ARRAY_BUFFER, this.vertexData, gl2.STATIC_DRAW);
            gl2.drawArrays(gl2.TRIANGLES, 0, 6);
            if (!target) {
              renderer.resetTextures();
            } else {
              gl2.bindTexture(gl2.TEXTURE_2D, null);
              gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
            }
          }
        });
        module2.exports = PostFXPipeline;
      },
      function(module2, exports2) {
        module2.exports = [
          "#define SHADER_NAME PHASER_POSTFX_FS",
          "",
          "precision mediump float;",
          "",
          "uniform sampler2D uMainSampler;",
          "",
          "varying vec2 outTexCoord;",
          "",
          "void main ()",
          "{",
          "    gl_FragColor = texture2D(uMainSampler, outTexCoord);",
          "}",
          ""
        ].join("\n");
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Extend = __webpack_require__(17);
        var CONST = __webpack_require__(201);
        var Scale = {
          Center: __webpack_require__(403),
          Events: __webpack_require__(104),
          Orientation: __webpack_require__(404),
          ScaleManager: __webpack_require__(415),
          ScaleModes: __webpack_require__(405),
          Zoom: __webpack_require__(406)
        };
        Scale = Extend(false, Scale, CONST.CENTER);
        Scale = Extend(false, Scale, CONST.ORIENTATION);
        Scale = Extend(false, Scale, CONST.SCALE_MODE);
        Scale = Extend(false, Scale, CONST.ZOOM);
        module2.exports = Scale;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(144);
        var Extend = __webpack_require__(17);
        var Scene = {
          Events: __webpack_require__(20),
          GetPhysicsPlugins: __webpack_require__(419),
          GetScenePlugins: __webpack_require__(420),
          SceneManager: __webpack_require__(417),
          ScenePlugin: __webpack_require__(1414),
          Settings: __webpack_require__(421),
          Systems: __webpack_require__(204)
        };
        Scene = Extend(false, Scene, CONST);
        module2.exports = Scene;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clamp = __webpack_require__(18);
        var Class = __webpack_require__(0);
        var Events = __webpack_require__(20);
        var GetFastValue = __webpack_require__(2);
        var PluginCache = __webpack_require__(24);
        var ScenePlugin = new Class({
          initialize: function ScenePlugin2(scene) {
            this.scene = scene;
            this.systems = scene.sys;
            this.settings = scene.sys.settings;
            this.key = scene.sys.settings.key;
            this.manager = scene.sys.game.scene;
            this.transitionProgress = 0;
            this._elapsed = 0;
            this._target = null;
            this._duration = 0;
            this._onUpdate;
            this._onUpdateScope;
            this._willSleep = false;
            this._willRemove = false;
            scene.sys.events.once(Events.BOOT, this.boot, this);
            scene.sys.events.on(Events.START, this.pluginStart, this);
          },
          boot: function() {
            this.systems.events.once(Events.DESTROY, this.destroy, this);
          },
          pluginStart: function() {
            this._target = null;
            this.systems.events.once(Events.SHUTDOWN, this.shutdown, this);
          },
          start: function(key, data) {
            if (key === void 0) {
              key = this.key;
            }
            this.manager.queueOp("stop", this.key);
            this.manager.queueOp("start", key, data);
            return this;
          },
          restart: function(data) {
            var key = this.key;
            this.manager.queueOp("stop", key);
            this.manager.queueOp("start", key, data);
            return this;
          },
          transition: function(config) {
            if (config === void 0) {
              config = {};
            }
            var key = GetFastValue(config, "target", false);
            var target = this.manager.getScene(key);
            if (!key || !this.checkValidTransition(target)) {
              return false;
            }
            var duration = GetFastValue(config, "duration", 1e3);
            this._elapsed = 0;
            this._target = target;
            this._duration = duration;
            this._willSleep = GetFastValue(config, "sleep", false);
            this._willRemove = GetFastValue(config, "remove", false);
            var callback = GetFastValue(config, "onUpdate", null);
            if (callback) {
              this._onUpdate = callback;
              this._onUpdateScope = GetFastValue(config, "onUpdateScope", this.scene);
            }
            var allowInput = GetFastValue(config, "allowInput", false);
            this.settings.transitionAllowInput = allowInput;
            var targetSettings = target.sys.settings;
            targetSettings.isTransition = true;
            targetSettings.transitionFrom = this.scene;
            targetSettings.transitionDuration = duration;
            targetSettings.transitionAllowInput = allowInput;
            if (GetFastValue(config, "moveAbove", false)) {
              this.manager.moveAbove(this.key, key);
            } else if (GetFastValue(config, "moveBelow", false)) {
              this.manager.moveBelow(this.key, key);
            }
            if (target.sys.isSleeping()) {
              target.sys.wake(GetFastValue(config, "data"));
            } else {
              this.manager.start(key, GetFastValue(config, "data"));
            }
            this.systems.events.emit(Events.TRANSITION_OUT, target, duration);
            this.systems.events.on(Events.UPDATE, this.step, this);
            return true;
          },
          checkValidTransition: function(target) {
            if (!target || target.sys.isActive() || target.sys.isTransitioning() || target === this.scene || this.systems.isTransitioning()) {
              return false;
            }
            return true;
          },
          step: function(time, delta) {
            this._elapsed += delta;
            this.transitionProgress = Clamp(this._elapsed / this._duration, 0, 1);
            if (this._onUpdate) {
              this._onUpdate.call(this._onUpdateScope, this.transitionProgress);
            }
            if (this._elapsed >= this._duration) {
              this.transitionComplete();
            }
          },
          transitionComplete: function() {
            var targetSys = this._target.sys;
            var targetSettings = this._target.sys.settings;
            this.systems.events.off(Events.UPDATE, this.step, this);
            targetSys.events.emit(Events.TRANSITION_COMPLETE, this.scene);
            targetSettings.isTransition = false;
            targetSettings.transitionFrom = null;
            this._duration = 0;
            this._target = null;
            this._onUpdate = null;
            this._onUpdateScope = null;
            if (this._willRemove) {
              this.manager.remove(this.key);
            } else if (this._willSleep) {
              this.systems.sleep();
            } else {
              this.manager.stop(this.key);
            }
          },
          add: function(key, sceneConfig, autoStart, data) {
            return this.manager.add(key, sceneConfig, autoStart, data);
          },
          launch: function(key, data) {
            if (key && key !== this.key) {
              this.manager.queueOp("start", key, data);
            }
            return this;
          },
          run: function(key, data) {
            if (key && key !== this.key) {
              this.manager.queueOp("run", key, data);
            }
            return this;
          },
          pause: function(key, data) {
            if (key === void 0) {
              key = this.key;
            }
            this.manager.queueOp("pause", key, data);
            return this;
          },
          resume: function(key, data) {
            if (key === void 0) {
              key = this.key;
            }
            this.manager.queueOp("resume", key, data);
            return this;
          },
          sleep: function(key, data) {
            if (key === void 0) {
              key = this.key;
            }
            this.manager.queueOp("sleep", key, data);
            return this;
          },
          wake: function(key, data) {
            if (key === void 0) {
              key = this.key;
            }
            this.manager.queueOp("wake", key, data);
            return this;
          },
          switch: function(key) {
            if (key !== this.key) {
              this.manager.queueOp("switch", this.key, key);
            }
            return this;
          },
          stop: function(key, data) {
            if (key === void 0) {
              key = this.key;
            }
            this.manager.queueOp("stop", key, data);
            return this;
          },
          setActive: function(value, key, data) {
            if (key === void 0) {
              key = this.key;
            }
            var scene = this.manager.getScene(key);
            if (scene) {
              scene.sys.setActive(value, data);
            }
            return this;
          },
          setVisible: function(value, key) {
            if (key === void 0) {
              key = this.key;
            }
            var scene = this.manager.getScene(key);
            if (scene) {
              scene.sys.setVisible(value);
            }
            return this;
          },
          isSleeping: function(key) {
            if (key === void 0) {
              key = this.key;
            }
            return this.manager.isSleeping(key);
          },
          isActive: function(key) {
            if (key === void 0) {
              key = this.key;
            }
            return this.manager.isActive(key);
          },
          isPaused: function(key) {
            if (key === void 0) {
              key = this.key;
            }
            return this.manager.isPaused(key);
          },
          isVisible: function(key) {
            if (key === void 0) {
              key = this.key;
            }
            return this.manager.isVisible(key);
          },
          swapPosition: function(keyA, keyB) {
            if (keyB === void 0) {
              keyB = this.key;
            }
            if (keyA !== keyB) {
              this.manager.swapPosition(keyA, keyB);
            }
            return this;
          },
          moveAbove: function(keyA, keyB) {
            if (keyB === void 0) {
              keyB = this.key;
            }
            if (keyA !== keyB) {
              this.manager.moveAbove(keyA, keyB);
            }
            return this;
          },
          moveBelow: function(keyA, keyB) {
            if (keyB === void 0) {
              keyB = this.key;
            }
            if (keyA !== keyB) {
              this.manager.moveBelow(keyA, keyB);
            }
            return this;
          },
          remove: function(key) {
            if (key === void 0) {
              key = this.key;
            }
            this.manager.remove(key);
            return this;
          },
          moveUp: function(key) {
            if (key === void 0) {
              key = this.key;
            }
            this.manager.moveUp(key);
            return this;
          },
          moveDown: function(key) {
            if (key === void 0) {
              key = this.key;
            }
            this.manager.moveDown(key);
            return this;
          },
          bringToTop: function(key) {
            if (key === void 0) {
              key = this.key;
            }
            this.manager.bringToTop(key);
            return this;
          },
          sendToBack: function(key) {
            if (key === void 0) {
              key = this.key;
            }
            this.manager.sendToBack(key);
            return this;
          },
          get: function(key) {
            return this.manager.getScene(key);
          },
          getIndex: function(key) {
            if (key === void 0) {
              key = this.key;
            }
            return this.manager.getIndex(key);
          },
          shutdown: function() {
            var eventEmitter = this.systems.events;
            eventEmitter.off(Events.SHUTDOWN, this.shutdown, this);
            eventEmitter.off(Events.POST_UPDATE, this.step, this);
            eventEmitter.off(Events.TRANSITION_OUT);
          },
          destroy: function() {
            this.shutdown();
            this.scene.sys.events.off(Events.START, this.start, this);
            this.scene = null;
            this.systems = null;
            this.settings = null;
            this.manager = null;
          }
        });
        PluginCache.register("ScenePlugin", ScenePlugin, "scenePlugin");
        module2.exports = ScenePlugin;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Events: __webpack_require__(438),
          List: __webpack_require__(110),
          Map: __webpack_require__(102),
          ProcessQueue: __webpack_require__(211),
          RTree: __webpack_require__(531),
          Set: __webpack_require__(149),
          Size: __webpack_require__(416)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Extend = __webpack_require__(17);
        var FilterMode = __webpack_require__(1417);
        var Textures = {
          CanvasTexture: __webpack_require__(423),
          Events: __webpack_require__(106),
          FilterMode,
          Frame: __webpack_require__(109),
          Parsers: __webpack_require__(425),
          Texture: __webpack_require__(206),
          TextureManager: __webpack_require__(422),
          TextureSource: __webpack_require__(424)
        };
        Textures = Extend(false, Textures, FilterMode);
        module2.exports = Textures;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = {
          LINEAR: 0,
          NEAREST: 1
        };
        module2.exports = CONST;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Extend = __webpack_require__(17);
        var CONST = __webpack_require__(1419);
        var Tilemaps = {
          Components: __webpack_require__(251),
          Parsers: __webpack_require__(1452),
          Formats: __webpack_require__(40),
          ImageCollection: __webpack_require__(576),
          ParseToTilemap: __webpack_require__(262),
          Tile: __webpack_require__(85),
          Tilemap: __webpack_require__(580),
          TilemapCreator: __webpack_require__(1459),
          TilemapFactory: __webpack_require__(1460),
          Tileset: __webpack_require__(122),
          TilemapLayer: __webpack_require__(581),
          Orientation: __webpack_require__(29),
          LayerData: __webpack_require__(120),
          MapData: __webpack_require__(121),
          ObjectLayer: __webpack_require__(572)
        };
        Tilemaps = Extend(false, Tilemaps, CONST.ORIENTATION);
        module2.exports = Tilemaps;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = {
          ORIENTATION: __webpack_require__(29)
        };
        module2.exports = CONST;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTilesWithin = __webpack_require__(26);
        var CalculateFacesWithin = __webpack_require__(63);
        var Copy = function(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer) {
          if (recalculateFaces === void 0) {
            recalculateFaces = true;
          }
          if (srcTileX < 0) {
            srcTileX = 0;
          }
          if (srcTileY < 0) {
            srcTileY = 0;
          }
          var srcTiles = GetTilesWithin(srcTileX, srcTileY, width, height, null, layer);
          var offsetX = destTileX - srcTileX;
          var offsetY = destTileY - srcTileY;
          for (var i2 = 0; i2 < srcTiles.length; i2++) {
            var tileX = srcTiles[i2].x + offsetX;
            var tileY = srcTiles[i2].y + offsetY;
            if (tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height) {
              if (layer.data[tileY][tileX]) {
                layer.data[tileY][tileX].copy(srcTiles[i2]);
              }
            }
          }
          if (recalculateFaces) {
            CalculateFacesWithin(destTileX - 1, destTileY - 1, width + 2, height + 2, layer);
          }
        };
        module2.exports = Copy;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTilesWithin = __webpack_require__(26);
        var ReplaceByIndex = __webpack_require__(542);
        var CreateFromTiles = function(indexes, replacements, spriteConfig, scene, camera, layer) {
          if (!spriteConfig) {
            spriteConfig = {};
          }
          if (!Array.isArray(indexes)) {
            indexes = [indexes];
          }
          var tilemapLayer = layer.tilemapLayer;
          if (!scene) {
            scene = tilemapLayer.scene;
          }
          if (!camera) {
            camera = scene.cameras.main;
          }
          var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);
          var sprites = [];
          var i2;
          for (i2 = 0; i2 < tiles.length; i2++) {
            var tile = tiles[i2];
            if (indexes.indexOf(tile.index) !== -1) {
              var point = tilemapLayer.tileToWorldXY(tile.x, tile.y, void 0, camera, layer);
              spriteConfig.x = point.x;
              spriteConfig.y = point.y;
              sprites.push(scene.make.sprite(spriteConfig));
            }
          }
          if (typeof replacements === "number") {
            for (i2 = 0; i2 < indexes.length; i2++) {
              ReplaceByIndex(indexes[i2], replacements, 0, 0, layer.width, layer.height, layer);
            }
          } else if (Array.isArray(replacements)) {
            for (i2 = 0; i2 < indexes.length; i2++) {
              ReplaceByIndex(indexes[i2], replacements[i2], 0, 0, layer.width, layer.height, layer);
            }
          }
          return sprites;
        };
        module2.exports = CreateFromTiles;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTilesWithin = __webpack_require__(26);
        var CalculateFacesWithin = __webpack_require__(63);
        var SetTileCollision = __webpack_require__(72);
        var Fill = function(index2, tileX, tileY, width, height, recalculateFaces, layer) {
          var doesIndexCollide = layer.collideIndexes.indexOf(index2) !== -1;
          var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
          for (var i2 = 0; i2 < tiles.length; i2++) {
            tiles[i2].index = index2;
            SetTileCollision(tiles[i2], doesIndexCollide);
          }
          if (recalculateFaces) {
            CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);
          }
        };
        module2.exports = Fill;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTilesWithin = __webpack_require__(26);
        var FilterTiles = function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
          var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
          return tiles.filter(callback, context);
        };
        module2.exports = FilterTiles;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var FindByIndex = function(findIndex, skip, reverse, layer) {
          if (skip === void 0) {
            skip = 0;
          }
          if (reverse === void 0) {
            reverse = false;
          }
          var count = 0;
          var tx;
          var ty;
          var tile;
          if (reverse) {
            for (ty = layer.height - 1; ty >= 0; ty--) {
              for (tx = layer.width - 1; tx >= 0; tx--) {
                tile = layer.data[ty][tx];
                if (tile && tile.index === findIndex) {
                  if (count === skip) {
                    return tile;
                  } else {
                    count += 1;
                  }
                }
              }
            }
          } else {
            for (ty = 0; ty < layer.height; ty++) {
              for (tx = 0; tx < layer.width; tx++) {
                tile = layer.data[ty][tx];
                if (tile && tile.index === findIndex) {
                  if (count === skip) {
                    return tile;
                  } else {
                    count += 1;
                  }
                }
              }
            }
          }
          return null;
        };
        module2.exports = FindByIndex;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTilesWithin = __webpack_require__(26);
        var FindTile = function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
          var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
          return tiles.find(callback, context) || null;
        };
        module2.exports = FindTile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTilesWithin = __webpack_require__(26);
        var ForEachTile = function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
          var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
          tiles.forEach(callback, context);
        };
        module2.exports = ForEachTile;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(29);
        var CullTiles = __webpack_require__(544);
        var HexagonalCullTiles = __webpack_require__(545);
        var IsometricCullTiles = __webpack_require__(547);
        var NOOP = __webpack_require__(1);
        var StaggeredCullTiles = __webpack_require__(548);
        var GetCullTilesFunction = function(orientation) {
          if (orientation === CONST.ORTHOGONAL) {
            return CullTiles;
          } else if (orientation === CONST.HEXAGONAL) {
            return HexagonalCullTiles;
          } else if (orientation === CONST.STAGGERED) {
            return StaggeredCullTiles;
          } else if (orientation === CONST.ISOMETRIC) {
            return IsometricCullTiles;
          } else {
            return NOOP;
          }
        };
        module2.exports = GetCullTilesFunction;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTileAt = __webpack_require__(158);
        var Vector2 = __webpack_require__(3);
        var point = new Vector2();
        var GetTileAtWorldXY = function(worldX, worldY, nonNull, camera, layer) {
          layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);
          return GetTileAt(point.x, point.y, nonNull, layer);
        };
        module2.exports = GetTileAtWorldXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Geom = __webpack_require__(483);
        var GetTilesWithin = __webpack_require__(26);
        var Intersects = __webpack_require__(484);
        var NOOP = __webpack_require__(1);
        var Vector2 = __webpack_require__(3);
        var TriangleToRectangle = function(triangle, rect) {
          return Intersects.RectangleToTriangle(rect, triangle);
        };
        var point = new Vector2();
        var pointStart = new Vector2();
        var pointEnd = new Vector2();
        var GetTilesWithinShape = function(shape, filteringOptions, camera, layer) {
          if (shape === void 0) {
            return [];
          }
          var intersectTest = NOOP;
          if (shape instanceof Geom.Circle) {
            intersectTest = Intersects.CircleToRectangle;
          } else if (shape instanceof Geom.Rectangle) {
            intersectTest = Intersects.RectangleToRectangle;
          } else if (shape instanceof Geom.Triangle) {
            intersectTest = TriangleToRectangle;
          } else if (shape instanceof Geom.Line) {
            intersectTest = Intersects.LineToRectangle;
          }
          layer.tilemapLayer.worldToTileXY(shape.left, shape.top, true, pointStart, camera);
          var xStart = pointStart.x;
          var yStart = pointStart.y;
          layer.tilemapLayer.worldToTileXY(shape.right, shape.bottom, true, pointEnd, camera);
          var xEnd = Math.ceil(pointEnd.x);
          var yEnd = Math.ceil(pointEnd.y);
          var width = Math.max(xEnd - xStart, 1);
          var height = Math.max(yEnd - yStart, 1);
          var tiles = GetTilesWithin(xStart, yStart, width, height, filteringOptions, layer);
          var tileWidth = layer.tileWidth;
          var tileHeight = layer.tileHeight;
          if (layer.tilemapLayer) {
            tileWidth *= layer.tilemapLayer.scaleX;
            tileHeight *= layer.tilemapLayer.scaleY;
          }
          var results = [];
          var tileRect = new Geom.Rectangle(0, 0, tileWidth, tileHeight);
          for (var i2 = 0; i2 < tiles.length; i2++) {
            var tile = tiles[i2];
            layer.tilemapLayer.tileToWorldXY(tile.x, tile.y, point, camera);
            tileRect.x = point.x;
            tileRect.y = point.y;
            if (intersectTest(shape, tileRect)) {
              results.push(tile);
            }
          }
          return results;
        };
        module2.exports = GetTilesWithinShape;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(29);
        var NOOP = __webpack_require__(1);
        var TileToWorldX = __webpack_require__(253);
        var GetTileToWorldXFunction = function(orientation) {
          if (orientation === CONST.ORTHOGONAL) {
            return TileToWorldX;
          } else {
            return NOOP;
          }
        };
        module2.exports = GetTileToWorldXFunction;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(29);
        var HexagonalTileToWorldXY = __webpack_require__(550);
        var IsometricTileToWorldXY = __webpack_require__(551);
        var NOOP = __webpack_require__(1);
        var StaggeredTileToWorldXY = __webpack_require__(552);
        var TileToWorldXY = __webpack_require__(553);
        var GetTileToWorldXYFunction = function(orientation) {
          if (orientation === CONST.ORTHOGONAL) {
            return TileToWorldXY;
          } else if (orientation === CONST.ISOMETRIC) {
            return IsometricTileToWorldXY;
          } else if (orientation === CONST.HEXAGONAL) {
            return HexagonalTileToWorldXY;
          } else if (orientation === CONST.STAGGERED) {
            return StaggeredTileToWorldXY;
          } else {
            return NOOP;
          }
        };
        module2.exports = GetTileToWorldXYFunction;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(29);
        var HexagonalTileToWorldY = __webpack_require__(554);
        var NOOP = __webpack_require__(1);
        var StaggeredTileToWorldY = __webpack_require__(555);
        var TileToWorldY = __webpack_require__(254);
        var GetTileToWorldYFunction = function(orientation) {
          if (orientation === CONST.ORTHOGONAL) {
            return TileToWorldY;
          } else if (orientation === CONST.HEXAGONAL) {
            return HexagonalTileToWorldY;
          } else if (orientation === CONST.STAGGERED) {
            return StaggeredTileToWorldY;
          } else {
            return NOOP;
          }
        };
        module2.exports = GetTileToWorldYFunction;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(29);
        var NOOP = __webpack_require__(1);
        var WorldToTileX = __webpack_require__(255);
        var GetWorldToTileXFunction = function(orientation) {
          if (orientation === CONST.ORTHOGONAL) {
            return WorldToTileX;
          } else {
            return NOOP;
          }
        };
        module2.exports = GetWorldToTileXFunction;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(29);
        var HexagonalWorldToTileXY = __webpack_require__(556);
        var IsometricWorldToTileXY = __webpack_require__(557);
        var NOOP = __webpack_require__(1);
        var StaggeredWorldToTileXY = __webpack_require__(558);
        var WorldToTileXY = __webpack_require__(559);
        var GetWorldToTileXYFunction = function(orientation) {
          if (orientation === CONST.ORTHOGONAL) {
            return WorldToTileXY;
          } else if (orientation === CONST.ISOMETRIC) {
            return IsometricWorldToTileXY;
          } else if (orientation === CONST.HEXAGONAL) {
            return HexagonalWorldToTileXY;
          } else if (orientation === CONST.STAGGERED) {
            return StaggeredWorldToTileXY;
          } else {
            return NOOP;
          }
        };
        module2.exports = GetWorldToTileXYFunction;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(29);
        var HexagonalWorldToTileY = __webpack_require__(560);
        var NOOP = __webpack_require__(1);
        var StaggeredWorldToTileY = __webpack_require__(561);
        var WorldToTileY = __webpack_require__(256);
        var GetWorldToTileYFunction = function(orientation) {
          if (orientation === CONST.ORTHOGONAL) {
            return WorldToTileY;
          } else if (orientation === CONST.HEXAGONAL) {
            return HexagonalWorldToTileY;
          } else if (orientation === CONST.STAGGERED) {
            return StaggeredWorldToTileY;
          } else {
            return NOOP;
          }
        };
        module2.exports = GetWorldToTileYFunction;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var HasTileAt = __webpack_require__(562);
        var Vector2 = __webpack_require__(3);
        var point = new Vector2();
        var HasTileAtWorldXY = function(worldX, worldY, camera, layer) {
          layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);
          var tileX = point.x;
          var tileY = point.y;
          return HasTileAt(tileX, tileY, layer);
        };
        module2.exports = HasTileAtWorldXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var PutTileAt = __webpack_require__(257);
        var Vector2 = __webpack_require__(3);
        var point = new Vector2();
        var PutTileAtWorldXY = function(tile, worldX, worldY, recalculateFaces, camera, layer) {
          layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);
          return PutTileAt(tile, point.x, point.y, recalculateFaces, layer);
        };
        module2.exports = PutTileAtWorldXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CalculateFacesWithin = __webpack_require__(63);
        var PutTileAt = __webpack_require__(257);
        var PutTilesAt = function(tilesArray, tileX, tileY, recalculateFaces, layer) {
          if (recalculateFaces === void 0) {
            recalculateFaces = true;
          }
          if (!Array.isArray(tilesArray)) {
            return null;
          }
          if (!Array.isArray(tilesArray[0])) {
            tilesArray = [tilesArray];
          }
          var height = tilesArray.length;
          var width = tilesArray[0].length;
          for (var ty = 0; ty < height; ty++) {
            for (var tx = 0; tx < width; tx++) {
              var tile = tilesArray[ty][tx];
              PutTileAt(tile, tileX + tx, tileY + ty, false, layer);
            }
          }
          if (recalculateFaces) {
            CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);
          }
        };
        module2.exports = PutTilesAt;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTilesWithin = __webpack_require__(26);
        var GetRandom = __webpack_require__(210);
        var Randomize = function(tileX, tileY, width, height, indexes, layer) {
          var i2;
          var tiles = GetTilesWithin(tileX, tileY, width, height, {}, layer);
          if (!indexes) {
            indexes = [];
            for (i2 = 0; i2 < tiles.length; i2++) {
              if (indexes.indexOf(tiles[i2].index) === -1) {
                indexes.push(tiles[i2].index);
              }
            }
          }
          for (i2 = 0; i2 < tiles.length; i2++) {
            tiles[i2].index = GetRandom(indexes);
          }
        };
        module2.exports = Randomize;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RemoveTileAt = __webpack_require__(563);
        var Vector2 = __webpack_require__(3);
        var point = new Vector2();
        var RemoveTileAtWorldXY = function(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer) {
          layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);
          return RemoveTileAt(point.x, point.y, replaceWithNull, recalculateFaces, layer);
        };
        module2.exports = RemoveTileAtWorldXY;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTilesWithin = __webpack_require__(26);
        var Color = __webpack_require__(397);
        var defaultTileColor = new Color(105, 210, 231, 150);
        var defaultCollidingTileColor = new Color(243, 134, 48, 200);
        var defaultFaceColor = new Color(40, 39, 37, 150);
        var RenderDebug = function(graphics, styleConfig, layer) {
          if (styleConfig === void 0) {
            styleConfig = {};
          }
          var tileColor = styleConfig.tileColor !== void 0 ? styleConfig.tileColor : defaultTileColor;
          var collidingTileColor = styleConfig.collidingTileColor !== void 0 ? styleConfig.collidingTileColor : defaultCollidingTileColor;
          var faceColor = styleConfig.faceColor !== void 0 ? styleConfig.faceColor : defaultFaceColor;
          var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);
          graphics.translateCanvas(layer.tilemapLayer.x, layer.tilemapLayer.y);
          graphics.scaleCanvas(layer.tilemapLayer.scaleX, layer.tilemapLayer.scaleY);
          for (var i2 = 0; i2 < tiles.length; i2++) {
            var tile = tiles[i2];
            var tw = tile.width;
            var th2 = tile.height;
            var x2 = tile.pixelX;
            var y2 = tile.pixelY;
            var color = tile.collides ? collidingTileColor : tileColor;
            if (color !== null) {
              graphics.fillStyle(color.color, color.alpha / 255);
              graphics.fillRect(x2, y2, tw, th2);
            }
            x2 += 1;
            y2 += 1;
            tw -= 2;
            th2 -= 2;
            if (faceColor !== null) {
              graphics.lineStyle(1, faceColor.color, faceColor.alpha / 255);
              if (tile.faceTop) {
                graphics.lineBetween(x2, y2, x2 + tw, y2);
              }
              if (tile.faceRight) {
                graphics.lineBetween(x2 + tw, y2, x2 + tw, y2 + th2);
              }
              if (tile.faceBottom) {
                graphics.lineBetween(x2, y2 + th2, x2 + tw, y2 + th2);
              }
              if (tile.faceLeft) {
                graphics.lineBetween(x2, y2, x2, y2 + th2);
              }
            }
          }
        };
        module2.exports = RenderDebug;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetTileCollision = __webpack_require__(72);
        var CalculateFacesWithin = __webpack_require__(63);
        var SetLayerCollisionIndex = __webpack_require__(160);
        var SetCollision = function(indexes, collides, recalculateFaces, layer, updateLayer) {
          if (collides === void 0) {
            collides = true;
          }
          if (recalculateFaces === void 0) {
            recalculateFaces = true;
          }
          if (updateLayer === void 0) {
            updateLayer = true;
          }
          if (!Array.isArray(indexes)) {
            indexes = [indexes];
          }
          for (var i2 = 0; i2 < indexes.length; i2++) {
            SetLayerCollisionIndex(indexes[i2], collides, layer);
          }
          if (updateLayer) {
            for (var ty = 0; ty < layer.height; ty++) {
              for (var tx = 0; tx < layer.width; tx++) {
                var tile = layer.data[ty][tx];
                if (tile && indexes.indexOf(tile.index) !== -1) {
                  SetTileCollision(tile, collides);
                }
              }
            }
          }
          if (recalculateFaces) {
            CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
          }
        };
        module2.exports = SetCollision;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetTileCollision = __webpack_require__(72);
        var CalculateFacesWithin = __webpack_require__(63);
        var SetLayerCollisionIndex = __webpack_require__(160);
        var SetCollisionBetween = function(start, stop, collides, recalculateFaces, layer, updateLayer) {
          if (collides === void 0) {
            collides = true;
          }
          if (recalculateFaces === void 0) {
            recalculateFaces = true;
          }
          if (updateLayer === void 0) {
            updateLayer = true;
          }
          if (start > stop) {
            return;
          }
          for (var index2 = start; index2 <= stop; index2++) {
            SetLayerCollisionIndex(index2, collides, layer);
          }
          if (updateLayer) {
            for (var ty = 0; ty < layer.height; ty++) {
              for (var tx = 0; tx < layer.width; tx++) {
                var tile = layer.data[ty][tx];
                if (tile) {
                  if (tile.index >= start && tile.index <= stop) {
                    SetTileCollision(tile, collides);
                  }
                }
              }
            }
          }
          if (recalculateFaces) {
            CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
          }
        };
        module2.exports = SetCollisionBetween;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetTileCollision = __webpack_require__(72);
        var CalculateFacesWithin = __webpack_require__(63);
        var SetLayerCollisionIndex = __webpack_require__(160);
        var SetCollisionByExclusion = function(indexes, collides, recalculateFaces, layer) {
          if (collides === void 0) {
            collides = true;
          }
          if (recalculateFaces === void 0) {
            recalculateFaces = true;
          }
          if (!Array.isArray(indexes)) {
            indexes = [indexes];
          }
          for (var ty = 0; ty < layer.height; ty++) {
            for (var tx = 0; tx < layer.width; tx++) {
              var tile = layer.data[ty][tx];
              if (tile && indexes.indexOf(tile.index) === -1) {
                SetTileCollision(tile, collides);
                SetLayerCollisionIndex(tile.index, collides, layer);
              }
            }
          }
          if (recalculateFaces) {
            CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
          }
        };
        module2.exports = SetCollisionByExclusion;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetTileCollision = __webpack_require__(72);
        var CalculateFacesWithin = __webpack_require__(63);
        var HasValue = __webpack_require__(126);
        var SetCollisionByProperty = function(properties, collides, recalculateFaces, layer) {
          if (collides === void 0) {
            collides = true;
          }
          if (recalculateFaces === void 0) {
            recalculateFaces = true;
          }
          for (var ty = 0; ty < layer.height; ty++) {
            for (var tx = 0; tx < layer.width; tx++) {
              var tile = layer.data[ty][tx];
              if (!tile) {
                continue;
              }
              for (var property in properties) {
                if (!HasValue(tile.properties, property)) {
                  continue;
                }
                var values = properties[property];
                if (!Array.isArray(values)) {
                  values = [values];
                }
                for (var i2 = 0; i2 < values.length; i2++) {
                  if (tile.properties[property] === values[i2]) {
                    SetTileCollision(tile, collides);
                  }
                }
              }
            }
          }
          if (recalculateFaces) {
            CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
          }
        };
        module2.exports = SetCollisionByProperty;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetTileCollision = __webpack_require__(72);
        var CalculateFacesWithin = __webpack_require__(63);
        var SetCollisionFromCollisionGroup = function(collides, recalculateFaces, layer) {
          if (collides === void 0) {
            collides = true;
          }
          if (recalculateFaces === void 0) {
            recalculateFaces = true;
          }
          for (var ty = 0; ty < layer.height; ty++) {
            for (var tx = 0; tx < layer.width; tx++) {
              var tile = layer.data[ty][tx];
              if (!tile) {
                continue;
              }
              var collisionGroup = tile.getCollisionGroup();
              if (collisionGroup && collisionGroup.objects && collisionGroup.objects.length > 0) {
                SetTileCollision(tile, collides);
              }
            }
          }
          if (recalculateFaces) {
            CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
          }
        };
        module2.exports = SetCollisionFromCollisionGroup;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var SetTileIndexCallback = function(indexes, callback, callbackContext, layer) {
          if (typeof indexes === "number") {
            layer.callbacks[indexes] = callback !== null ? { callback, callbackContext } : void 0;
          } else {
            for (var i2 = 0, len = indexes.length; i2 < len; i2++) {
              layer.callbacks[indexes[i2]] = callback !== null ? { callback, callbackContext } : void 0;
            }
          }
        };
        module2.exports = SetTileIndexCallback;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTilesWithin = __webpack_require__(26);
        var SetTileLocationCallback = function(tileX, tileY, width, height, callback, callbackContext, layer) {
          var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
          for (var i2 = 0; i2 < tiles.length; i2++) {
            tiles[i2].setCollisionCallback(callback, callbackContext);
          }
        };
        module2.exports = SetTileLocationCallback;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTilesWithin = __webpack_require__(26);
        var ShuffleArray = __webpack_require__(131);
        var Shuffle = function(tileX, tileY, width, height, layer) {
          var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
          var indexes = tiles.map(function(tile) {
            return tile.index;
          });
          ShuffleArray(indexes);
          for (var i2 = 0; i2 < tiles.length; i2++) {
            tiles[i2].index = indexes[i2];
          }
        };
        module2.exports = Shuffle;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTilesWithin = __webpack_require__(26);
        var SwapByIndex = function(indexA, indexB, tileX, tileY, width, height, layer) {
          var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
          for (var i2 = 0; i2 < tiles.length; i2++) {
            if (tiles[i2]) {
              if (tiles[i2].index === indexA) {
                tiles[i2].index = indexB;
              } else if (tiles[i2].index === indexB) {
                tiles[i2].index = indexA;
              }
            }
          }
        };
        module2.exports = SwapByIndex;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetTilesWithin = __webpack_require__(26);
        var WeightedRandomize = function(tileX, tileY, width, height, weightedIndexes, layer) {
          if (!weightedIndexes) {
            return;
          }
          var i2;
          var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
          var weightTotal = 0;
          for (i2 = 0; i2 < weightedIndexes.length; i2++) {
            weightTotal += weightedIndexes[i2].weight;
          }
          if (weightTotal <= 0) {
            return;
          }
          for (i2 = 0; i2 < tiles.length; i2++) {
            var rand = Math.random() * weightTotal;
            var sum = 0;
            var randomIndex = -1;
            for (var j = 0; j < weightedIndexes.length; j++) {
              sum += weightedIndexes[j].weight;
              if (rand <= sum) {
                var chosen = weightedIndexes[j].index;
                randomIndex = Array.isArray(chosen) ? chosen[Math.floor(Math.random() * chosen.length)] : chosen;
                break;
              }
            }
            tiles[i2].index = randomIndex;
          }
        };
        module2.exports = WeightedRandomize;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          FromOrientationString: __webpack_require__(258),
          Parse: __webpack_require__(564),
          Parse2DArray: __webpack_require__(259),
          ParseCSV: __webpack_require__(565),
          Impact: __webpack_require__(1454),
          Tiled: __webpack_require__(1455)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ParseWangsets = function(wangsets, datas) {
          for (var w2 = 0; w2 < wangsets.length; w2++) {
            var wangset = wangsets[w2];
            var identifier = w2;
            if (wangset.name && wangset.name !== "") {
              identifier = wangset.name;
            }
            if (Array.isArray(wangset.wangtiles) && wangset.wangtiles.length > 0) {
              var edgeColors = {};
              var cornerColors = {};
              var c;
              var color;
              var colorIndex;
              if (Array.isArray(wangset.edgecolors)) {
                for (c = 0; c < wangset.edgecolors.length; c++) {
                  colorIndex = 1 + c;
                  color = wangset.edgecolors[c];
                  if (color.name !== "") {
                    edgeColors[colorIndex] = color.name;
                  }
                }
              }
              if (Array.isArray(wangset.cornercolors)) {
                for (c = 0; c < wangset.cornercolors.length; c++) {
                  colorIndex = 1 + c;
                  color = wangset.cornercolors[c];
                  if (color.name !== "") {
                    cornerColors[colorIndex] = color.name;
                  }
                }
              }
              if (Array.isArray(wangset.colors)) {
                for (c = 0; c < wangset.colors.length; c++) {
                  color = wangset.colors[c];
                  colorIndex = 1 + c;
                  if (color.name !== "") {
                    edgeColors[colorIndex] = cornerColors[colorIndex] = color.name;
                  }
                }
              }
              var idLayout = [
                edgeColors,
                cornerColors,
                edgeColors,
                cornerColors,
                edgeColors,
                cornerColors,
                edgeColors,
                cornerColors
              ];
              for (var t2 = 0; t2 < wangset.wangtiles.length; t2++) {
                var wangtile = wangset.wangtiles[t2];
                var obj = datas[wangtile.tileid] || (datas[wangtile.tileid] = {});
                obj = obj.wangid || (obj.wangid = {});
                var wangid = [];
                for (var i2 = 0; i2 < Math.min(idLayout.length, wangtile.wangid.length); i2++) {
                  color = wangtile.wangid[i2];
                  if (color === 0) {
                    wangid.push(void 0);
                    continue;
                  }
                  var renamed = idLayout[i2][color];
                  if (renamed !== void 0) {
                    wangid.push(renamed);
                    continue;
                  }
                  wangid.push(color);
                }
                obj[identifier] = wangid;
              }
            }
          }
        };
        module2.exports = ParseWangsets;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          ParseTileLayers: __webpack_require__(578),
          ParseTilesets: __webpack_require__(579),
          ParseWeltmeister: __webpack_require__(577)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          AssignTileProperties: __webpack_require__(567),
          Base64Decode: __webpack_require__(574),
          BuildTilesetIndex: __webpack_require__(568),
          CreateGroupLayer: __webpack_require__(161),
          ParseGID: __webpack_require__(261),
          ParseImageLayers: __webpack_require__(569),
          ParseJSONTiled: __webpack_require__(566),
          ParseObject: __webpack_require__(260),
          ParseObjectLayers: __webpack_require__(570),
          ParseTileLayers: __webpack_require__(573),
          ParseTilesets: __webpack_require__(575)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var renderWebGL = __webpack_require__(1);
        var renderCanvas = __webpack_require__(1);
        {
          renderWebGL = __webpack_require__(1457);
        }
        {
          renderCanvas = __webpack_require__(1458);
        }
        module2.exports = {
          renderWebGL,
          renderCanvas
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Utils = __webpack_require__(12);
        var TilemapLayerWebGLRenderer = function(renderer, src, camera) {
          var renderTiles = src.cull(camera);
          var tileCount = renderTiles.length;
          var alpha = camera.alpha * src.alpha;
          if (tileCount === 0 || alpha <= 0) {
            return;
          }
          var gidMap = src.gidMap;
          var pipeline = renderer.pipelines.set(src.pipeline, src);
          var getTint = Utils.getTintAppendFloatAlpha;
          var scrollFactorX = src.scrollFactorX;
          var scrollFactorY = src.scrollFactorY;
          var x2 = src.x;
          var y2 = src.y;
          var sx = src.scaleX;
          var sy = src.scaleY;
          renderer.pipelines.preBatch(src);
          for (var i2 = 0; i2 < tileCount; i2++) {
            var tile = renderTiles[i2];
            var tileset = gidMap[tile.index];
            if (!tileset) {
              continue;
            }
            var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);
            if (tileTexCoords === null) {
              continue;
            }
            var texture = tileset.glTexture;
            var textureUnit = pipeline.setTexture2D(texture, src);
            var frameWidth = tileset.tileWidth;
            var frameHeight = tileset.tileHeight;
            var frameX = tileTexCoords.x;
            var frameY = tileTexCoords.y;
            var tw = tileset.tileWidth * 0.5;
            var th2 = tileset.tileHeight * 0.5;
            var tint = getTint(tile.tint, alpha * tile.alpha);
            pipeline.batchTexture(src, texture, texture.width, texture.height, x2 + (tw + tile.pixelX) * sx, y2 + (th2 + tile.pixelY) * sy, tile.width, tile.height, sx, sy, tile.rotation, tile.flipX, tile.flipY, scrollFactorX, scrollFactorY, tw, th2, frameX, frameY, frameWidth, frameHeight, tint, tint, tint, tint, false, 0, 0, camera, null, true, textureUnit);
          }
          renderer.pipelines.postBatch(src);
        };
        module2.exports = TilemapLayerWebGLRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var TransformMatrix = __webpack_require__(25);
        var tempMatrix1 = new TransformMatrix();
        var tempMatrix2 = new TransformMatrix();
        var tempMatrix3 = new TransformMatrix();
        var TilemapLayerCanvasRenderer = function(renderer, src, camera, parentMatrix) {
          var renderTiles = src.cull(camera);
          var tileCount = renderTiles.length;
          var alpha = camera.alpha * src.alpha;
          if (tileCount === 0 || alpha <= 0) {
            return;
          }
          var camMatrix = tempMatrix1;
          var layerMatrix = tempMatrix2;
          var calcMatrix = tempMatrix3;
          layerMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);
          camMatrix.copyFrom(camera.matrix);
          var ctx = renderer.currentContext;
          var gidMap = src.gidMap;
          ctx.save();
          if (parentMatrix) {
            camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
            layerMatrix.e = src.x;
            layerMatrix.f = src.y;
            camMatrix.multiply(layerMatrix, calcMatrix);
            calcMatrix.copyToContext(ctx);
          } else {
            layerMatrix.e -= camera.scrollX * src.scrollFactorX;
            layerMatrix.f -= camera.scrollY * src.scrollFactorY;
            layerMatrix.copyToContext(ctx);
          }
          if (!renderer.antialias || src.scaleX > 1 || src.scaleY > 1) {
            ctx.imageSmoothingEnabled = false;
          }
          for (var i2 = 0; i2 < tileCount; i2++) {
            var tile = renderTiles[i2];
            var tileset = gidMap[tile.index];
            if (!tileset) {
              continue;
            }
            var image = tileset.image.getSourceImage();
            var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);
            if (tileTexCoords === null) {
              continue;
            }
            var tileWidth = tileset.tileWidth;
            var tileHeight = tileset.tileHeight;
            var halfWidth = tileWidth * 0.5;
            var halfHeight = tileHeight * 0.5;
            ctx.save();
            ctx.translate(tile.pixelX + halfWidth, tile.pixelY + halfHeight);
            if (tile.rotation !== 0) {
              ctx.rotate(tile.rotation);
            }
            if (tile.flipX || tile.flipY) {
              ctx.scale(tile.flipX ? -1 : 1, tile.flipY ? -1 : 1);
            }
            ctx.globalAlpha = alpha * tile.alpha;
            ctx.drawImage(image, tileTexCoords.x, tileTexCoords.y, tileWidth, tileHeight, -halfWidth, -halfHeight, tileWidth, tileHeight);
            ctx.restore();
          }
          ctx.restore();
        };
        module2.exports = TilemapLayerCanvasRenderer;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectCreator = __webpack_require__(16);
        var ParseToTilemap = __webpack_require__(262);
        GameObjectCreator.register("tilemap", function(config) {
          var c = config !== void 0 ? config : {};
          return ParseToTilemap(this.scene, c.key, c.tileWidth, c.tileHeight, c.width, c.height, c.data, c.insertNull);
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GameObjectFactory = __webpack_require__(5);
        var ParseToTilemap = __webpack_require__(262);
        GameObjectFactory.register("tilemap", function(key, tileWidth, tileHeight, width, height, data, insertNull) {
          if (key === null) {
            key = void 0;
          }
          if (tileWidth === null) {
            tileWidth = void 0;
          }
          if (tileHeight === null) {
            tileHeight = void 0;
          }
          if (width === null) {
            width = void 0;
          }
          if (height === null) {
            height = void 0;
          }
          return ParseToTilemap(this.scene, key, tileWidth, tileHeight, width, height, data, insertNull);
        });
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Clock: __webpack_require__(1462),
          TimerEvent: __webpack_require__(582)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Class = __webpack_require__(0);
        var PluginCache = __webpack_require__(24);
        var SceneEvents = __webpack_require__(20);
        var TimerEvent = __webpack_require__(582);
        var Remove = __webpack_require__(93);
        var Clock = new Class({
          initialize: function Clock2(scene) {
            this.scene = scene;
            this.systems = scene.sys;
            this.now = 0;
            this.timeScale = 1;
            this.paused = false;
            this._active = [];
            this._pendingInsertion = [];
            this._pendingRemoval = [];
            scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
            scene.sys.events.on(SceneEvents.START, this.start, this);
          },
          boot: function() {
            this.now = this.systems.game.loop.time;
            this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
          },
          start: function() {
            var eventEmitter = this.systems.events;
            eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
            eventEmitter.on(SceneEvents.UPDATE, this.update, this);
            eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          addEvent: function(config) {
            var event;
            if (config instanceof TimerEvent) {
              event = config;
              this.removeEvent(event);
              event.elapsed = event.startAt;
              event.hasDispatched = false;
              event.repeatCount = event.repeat === -1 || event.loop ? 999999999999 : event.repeat;
            } else {
              event = new TimerEvent(config);
            }
            this._pendingInsertion.push(event);
            return event;
          },
          delayedCall: function(delay, callback, args, callbackScope) {
            return this.addEvent({ delay, callback, args, callbackScope });
          },
          clearPendingEvents: function() {
            this._pendingInsertion = [];
            return this;
          },
          removeEvent: function(events) {
            if (!Array.isArray(events)) {
              events = [events];
            }
            for (var i2 = 0; i2 < events.length; i2++) {
              var event = events[i2];
              Remove(this._pendingRemoval, event);
              Remove(this._pendingInsertion, event);
              Remove(this._active, event);
            }
            return this;
          },
          removeAllEvents: function() {
            this._pendingRemoval = this._pendingRemoval.concat(this._active);
            return this;
          },
          preUpdate: function() {
            var toRemove = this._pendingRemoval.length;
            var toInsert = this._pendingInsertion.length;
            if (toRemove === 0 && toInsert === 0) {
              return;
            }
            var i2;
            var event;
            for (i2 = 0; i2 < toRemove; i2++) {
              event = this._pendingRemoval[i2];
              var index2 = this._active.indexOf(event);
              if (index2 > -1) {
                this._active.splice(index2, 1);
              }
              event.destroy();
            }
            for (i2 = 0; i2 < toInsert; i2++) {
              event = this._pendingInsertion[i2];
              this._active.push(event);
            }
            this._pendingRemoval.length = 0;
            this._pendingInsertion.length = 0;
          },
          update: function(time, delta) {
            this.now = time;
            if (this.paused) {
              return;
            }
            delta *= this.timeScale;
            for (var i2 = 0; i2 < this._active.length; i2++) {
              var event = this._active[i2];
              if (event.paused) {
                continue;
              }
              event.elapsed += delta * event.timeScale;
              if (event.elapsed >= event.delay) {
                var remainder = event.elapsed - event.delay;
                event.elapsed = event.delay;
                if (!event.hasDispatched && event.callback) {
                  event.hasDispatched = true;
                  event.callback.apply(event.callbackScope, event.args);
                }
                if (event.repeatCount > 0) {
                  event.repeatCount--;
                  event.elapsed = remainder;
                  event.hasDispatched = false;
                } else {
                  this._pendingRemoval.push(event);
                }
              }
            }
          },
          shutdown: function() {
            var i2;
            for (i2 = 0; i2 < this._pendingInsertion.length; i2++) {
              this._pendingInsertion[i2].destroy();
            }
            for (i2 = 0; i2 < this._active.length; i2++) {
              this._active[i2].destroy();
            }
            for (i2 = 0; i2 < this._pendingRemoval.length; i2++) {
              this._pendingRemoval[i2].destroy();
            }
            this._active.length = 0;
            this._pendingRemoval.length = 0;
            this._pendingInsertion.length = 0;
            var eventEmitter = this.systems.events;
            eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
            eventEmitter.off(SceneEvents.UPDATE, this.update, this);
            eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          destroy: function() {
            this.shutdown();
            this.scene.sys.events.off(SceneEvents.START, this.start, this);
            this.scene = null;
            this.systems = null;
          }
        });
        PluginCache.register("Clock", Clock, "time");
        module2.exports = Clock;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var CONST = __webpack_require__(100);
        var Extend = __webpack_require__(17);
        var Tweens = {
          Builders: __webpack_require__(1464),
          Events: __webpack_require__(267),
          TweenManager: __webpack_require__(1480),
          Tween: __webpack_require__(266),
          TweenData: __webpack_require__(268),
          Timeline: __webpack_require__(588)
        };
        Tweens = Extend(false, Tweens, CONST);
        module2.exports = Tweens;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          GetBoolean: __webpack_require__(99),
          GetEaseFunction: __webpack_require__(80),
          GetNewValue: __webpack_require__(162),
          GetProps: __webpack_require__(583),
          GetTargets: __webpack_require__(263),
          GetTweens: __webpack_require__(584),
          GetValueOp: __webpack_require__(264),
          NumberTweenBuilder: __webpack_require__(585),
          StaggerBuilder: __webpack_require__(586),
          TimelineBuilder: __webpack_require__(587),
          TweenBuilder: __webpack_require__(163)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = [
          "callbackScope",
          "completeDelay",
          "delay",
          "duration",
          "ease",
          "easeParams",
          "flipX",
          "flipY",
          "hold",
          "loop",
          "loopDelay",
          "offset",
          "onActive",
          "onActiveParams",
          "onActiveScope",
          "onComplete",
          "onCompleteParams",
          "onCompleteScope",
          "onLoop",
          "onLoopParams",
          "onLoopScope",
          "onRepeat",
          "onRepeatParams",
          "onRepeatScope",
          "onStart",
          "onStartParams",
          "onStartScope",
          "onStop",
          "onStopParams",
          "onStopScope",
          "onUpdate",
          "onUpdateParams",
          "onUpdateScope",
          "onYoyo",
          "onYoyoParams",
          "onYoyoScope",
          "paused",
          "props",
          "repeat",
          "repeatDelay",
          "targets",
          "useFrames",
          "yoyo"
        ];
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "complete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "loop";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pause";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "resume";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "start";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "update";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "active";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "complete";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "loop";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "repeat";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "start";
      },
      function(module2, exports2) {
        /**
         * @author       samme
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "stop";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "update";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "yoyo";
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ArrayRemove = __webpack_require__(93);
        var Class = __webpack_require__(0);
        var NumberTweenBuilder = __webpack_require__(585);
        var PluginCache = __webpack_require__(24);
        var SceneEvents = __webpack_require__(20);
        var StaggerBuilder = __webpack_require__(586);
        var TimelineBuilder = __webpack_require__(587);
        var TWEEN_CONST = __webpack_require__(100);
        var TweenBuilder = __webpack_require__(163);
        var TweenManager = new Class({
          initialize: function TweenManager2(scene) {
            this.scene = scene;
            this.systems = scene.sys;
            this.timeScale = 1;
            this._add = [];
            this._pending = [];
            this._active = [];
            this._destroy = [];
            this._toProcess = 0;
            scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
            scene.sys.events.on(SceneEvents.START, this.start, this);
          },
          boot: function() {
            this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
          },
          start: function() {
            var eventEmitter = this.systems.events;
            eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
            eventEmitter.on(SceneEvents.UPDATE, this.update, this);
            eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            this.timeScale = 1;
          },
          createTimeline: function(config) {
            return TimelineBuilder(this, config);
          },
          timeline: function(config) {
            var timeline = TimelineBuilder(this, config);
            if (!timeline.paused) {
              this._add.push(timeline);
              this._toProcess++;
            }
            return timeline;
          },
          create: function(config) {
            return TweenBuilder(this, config);
          },
          add: function(config) {
            var tween = TweenBuilder(this, config);
            this._add.push(tween);
            this._toProcess++;
            return tween;
          },
          existing: function(tween) {
            this._add.push(tween);
            this._toProcess++;
            return this;
          },
          addCounter: function(config) {
            var tween = NumberTweenBuilder(this, config);
            this._add.push(tween);
            this._toProcess++;
            return tween;
          },
          stagger: function(value, options) {
            return StaggerBuilder(value, options);
          },
          preUpdate: function() {
            if (this._toProcess === 0) {
              return;
            }
            var list = this._destroy;
            var active = this._active;
            var pending = this._pending;
            var i2;
            var tween;
            for (i2 = 0; i2 < list.length; i2++) {
              tween = list[i2];
              var idx = active.indexOf(tween);
              if (idx === -1) {
                idx = pending.indexOf(tween);
                if (idx > -1) {
                  tween.state = TWEEN_CONST.REMOVED;
                  pending.splice(idx, 1);
                }
              } else {
                tween.state = TWEEN_CONST.REMOVED;
                active.splice(idx, 1);
              }
            }
            list.length = 0;
            list = this._add;
            for (i2 = 0; i2 < list.length; i2++) {
              tween = list[i2];
              if (tween.state === TWEEN_CONST.PENDING_ADD) {
                if (tween.init()) {
                  tween.play();
                  this._active.push(tween);
                } else {
                  this._pending.push(tween);
                }
              }
            }
            list.length = 0;
            this._toProcess = 0;
          },
          update: function(timestamp, delta) {
            var list = this._active;
            var tween;
            delta *= this.timeScale;
            for (var i2 = 0; i2 < list.length; i2++) {
              tween = list[i2];
              if (tween.update(timestamp, delta)) {
                this._destroy.push(tween);
                this._toProcess++;
              }
            }
          },
          remove: function(tween) {
            ArrayRemove(this._add, tween);
            ArrayRemove(this._pending, tween);
            ArrayRemove(this._active, tween);
            ArrayRemove(this._destroy, tween);
            tween.state = TWEEN_CONST.REMOVED;
            return this;
          },
          makeActive: function(tween) {
            if (this._add.indexOf(tween) !== -1 || this._active.indexOf(tween) !== -1) {
              return this;
            }
            var idx = this._pending.indexOf(tween);
            if (idx !== -1) {
              this._pending.splice(idx, 1);
            }
            this._add.push(tween);
            tween.state = TWEEN_CONST.PENDING_ADD;
            this._toProcess++;
            return this;
          },
          each: function(callback, scope) {
            var args = [null];
            for (var i2 = 1; i2 < arguments.length; i2++) {
              args.push(arguments[i2]);
            }
            for (var texture in this.list) {
              args[0] = this.list[texture];
              callback.apply(scope, args);
            }
          },
          getAllTweens: function() {
            var list = this._active;
            var output = [];
            for (var i2 = 0; i2 < list.length; i2++) {
              output.push(list[i2]);
            }
            return output;
          },
          getGlobalTimeScale: function() {
            return this.timeScale;
          },
          getTweensOf: function(target, includePending) {
            if (includePending === void 0) {
              includePending = false;
            }
            var list = this._active;
            var tween;
            var output = [];
            var i2;
            var t2;
            if (!Array.isArray(target)) {
              target = [target];
            }
            for (i2 = 0; i2 < list.length; i2++) {
              tween = list[i2];
              for (t2 = 0; t2 < target.length; t2++) {
                if (tween.hasTarget(target[t2])) {
                  output.push(tween);
                }
              }
            }
            if (includePending) {
              list = this._pending;
              for (i2 = 0; i2 < list.length; i2++) {
                tween = list[i2];
                for (t2 = 0; t2 < target.length; t2++) {
                  if (tween.hasTarget(target[t2])) {
                    output.push(tween);
                  }
                }
              }
            }
            return output;
          },
          isTweening: function(target) {
            var list = this._active;
            var tween;
            for (var i2 = 0; i2 < list.length; i2++) {
              tween = list[i2];
              if (tween.hasTarget(target) && tween.isPlaying()) {
                return true;
              }
            }
            return false;
          },
          killAll: function() {
            var tweens = this.getAllTweens();
            for (var i2 = 0; i2 < tweens.length; i2++) {
              tweens[i2].stop();
            }
            return this;
          },
          killTweensOf: function(target) {
            var tweens = this.getTweensOf(target);
            for (var i2 = 0; i2 < tweens.length; i2++) {
              tweens[i2].stop();
            }
            return this;
          },
          pauseAll: function() {
            var list = this._active;
            for (var i2 = 0; i2 < list.length; i2++) {
              list[i2].pause();
            }
            return this;
          },
          resumeAll: function() {
            var list = this._active;
            for (var i2 = 0; i2 < list.length; i2++) {
              list[i2].resume();
            }
            return this;
          },
          setGlobalTimeScale: function(value) {
            this.timeScale = value;
            return this;
          },
          shutdown: function() {
            this.killAll();
            this._add = [];
            this._pending = [];
            this._active = [];
            this._destroy = [];
            this._toProcess = 0;
            var eventEmitter = this.systems.events;
            eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
            eventEmitter.off(SceneEvents.UPDATE, this.update, this);
            eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          destroy: function() {
            this.shutdown();
            this.scene.sys.events.off(SceneEvents.START, this.start, this);
            this.scene = null;
            this.systems = null;
          }
        });
        PluginCache.register("TweenManager", TweenManager, "tweens");
        module2.exports = TweenManager;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Array: __webpack_require__(208),
          Base64: __webpack_require__(1482),
          Objects: __webpack_require__(1484),
          String: __webpack_require__(1488),
          NOOP: __webpack_require__(1)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          ArrayBufferToBase64: __webpack_require__(1483),
          Base64ToArrayBuffer: __webpack_require__(433)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var ArrayBufferToBase64 = function(arrayBuffer, mediaType) {
          var bytes = new Uint8Array(arrayBuffer);
          var len = bytes.length;
          var base64 = mediaType ? "data:" + mediaType + ";base64," : "";
          for (var i2 = 0; i2 < len; i2 += 3) {
            base64 += chars[bytes[i2] >> 2];
            base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
            base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
            base64 += chars[bytes[i2 + 2] & 63];
          }
          if (len % 3 === 2) {
            base64 = base64.substring(0, base64.length - 1) + "=";
          } else if (len % 3 === 1) {
            base64 = base64.substring(0, base64.length - 2) + "==";
          }
          return base64;
        };
        module2.exports = ArrayBufferToBase64;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Clone: __webpack_require__(77),
          DeepCopy: __webpack_require__(175),
          Extend: __webpack_require__(17),
          GetAdvancedValue: __webpack_require__(13),
          GetFastValue: __webpack_require__(2),
          GetMinMaxValue: __webpack_require__(1485),
          GetValue: __webpack_require__(6),
          HasAll: __webpack_require__(1486),
          HasAny: __webpack_require__(455),
          HasValue: __webpack_require__(126),
          IsPlainObject: __webpack_require__(7),
          Merge: __webpack_require__(127),
          MergeRight: __webpack_require__(1487),
          Pick: __webpack_require__(571),
          SetValue: __webpack_require__(478)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var GetValue = __webpack_require__(6);
        var Clamp = __webpack_require__(18);
        var GetMinMaxValue = function(source, key, min, max, defaultValue) {
          if (defaultValue === void 0) {
            defaultValue = min;
          }
          var value = GetValue(source, key, defaultValue);
          return Clamp(value, min, max);
        };
        module2.exports = GetMinMaxValue;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var HasAll = function(source, keys) {
          for (var i2 = 0; i2 < keys.length; i2++) {
            if (!source.hasOwnProperty(keys[i2])) {
              return false;
            }
          }
          return true;
        };
        module2.exports = HasAll;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Clone = __webpack_require__(77);
        var MergeRight = function(obj1, obj2) {
          var clone = Clone(obj1);
          for (var key in obj2) {
            if (clone.hasOwnProperty(key)) {
              clone[key] = obj2[key];
            }
          }
          return clone;
        };
        module2.exports = MergeRight;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Format: __webpack_require__(1489),
          Pad: __webpack_require__(186),
          RemoveAt: __webpack_require__(1490),
          Reverse: __webpack_require__(1491),
          UppercaseFirst: __webpack_require__(205),
          UUID: __webpack_require__(222)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Format = function(string, values) {
          return string.replace(/%([0-9]+)/g, function(s, n2) {
            return values[Number(n2) - 1];
          });
        };
        module2.exports = Format;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var RemoveAt = function(string, index2) {
          if (index2 === 0) {
            return string.slice(1);
          } else {
            return string.slice(0, index2 - 1) + string.slice(index2);
          }
        };
        module2.exports = RemoveAt;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Reverse = function(string) {
          return string.split("").reverse().join("");
        };
        module2.exports = Reverse;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          SoundManagerCreator: __webpack_require__(426),
          Events: __webpack_require__(70),
          BaseSound: __webpack_require__(146),
          BaseSoundManager: __webpack_require__(145),
          WebAudioSound: __webpack_require__(434),
          WebAudioSoundManager: __webpack_require__(432),
          HTML5AudioSound: __webpack_require__(429),
          HTML5AudioSoundManager: __webpack_require__(427),
          NoAudioSound: __webpack_require__(431),
          NoAudioSoundManager: __webpack_require__(430)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          Arcade: __webpack_require__(1366),
          Matter: __webpack_require__(1494)
        };
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = {
          BodyBounds: __webpack_require__(1392),
          Components: __webpack_require__(249),
          Events: __webpack_require__(272),
          Factory: __webpack_require__(1394),
          MatterGameObject: __webpack_require__(1395),
          Image: __webpack_require__(1396),
          Matter: __webpack_require__(594),
          MatterPhysics: __webpack_require__(1524),
          PolyDecomp: __webpack_require__(1393),
          Sprite: __webpack_require__(1397),
          TileBody: __webpack_require__(593),
          PhysicsEditorParser: __webpack_require__(589),
          PhysicsJSONParser: __webpack_require__(590),
          PointerConstraint: __webpack_require__(1398),
          World: __webpack_require__(1402)
        };
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Bounce = {
          setBounce: function(value) {
            this.body.restitution = value;
            return this;
          }
        };
        module2.exports = Bounce;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Collision = {
          setCollisionCategory: function(value) {
            this.body.collisionFilter.category = value;
            return this;
          },
          setCollisionGroup: function(value) {
            this.body.collisionFilter.group = value;
            return this;
          },
          setCollidesWith: function(categories) {
            var flags = 0;
            if (!Array.isArray(categories)) {
              flags = categories;
            } else {
              for (var i2 = 0; i2 < categories.length; i2++) {
                flags |= categories[i2];
              }
            }
            this.body.collisionFilter.mask = flags;
            return this;
          },
          setOnCollide: function(callback) {
            this.body.onCollideCallback = callback;
            return this;
          },
          setOnCollideEnd: function(callback) {
            this.body.onCollideEndCallback = callback;
            return this;
          },
          setOnCollideActive: function(callback) {
            this.body.onCollideActiveCallback = callback;
            return this;
          },
          setOnCollideWith: function(body, callback) {
            if (!Array.isArray(body)) {
              body = [body];
            }
            for (var i2 = 0; i2 < body.length; i2++) {
              var src = body[i2].hasOwnProperty("body") ? body[i2].body : body[i2];
              this.body.setOnCollideWith(src, callback);
            }
            return this;
          }
        };
        module2.exports = Collision;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Body = __webpack_require__(41);
        var Force = {
          applyForce: function(force) {
            this._tempVec2.set(this.body.position.x, this.body.position.y);
            Body.applyForce(this.body, this._tempVec2, force);
            return this;
          },
          applyForceFrom: function(position, force) {
            Body.applyForce(this.body, position, force);
            return this;
          },
          thrust: function(speed) {
            var angle = this.body.angle;
            this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
            Body.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2);
            return this;
          },
          thrustLeft: function(speed) {
            var angle = this.body.angle - Math.PI / 2;
            this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
            Body.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2);
            return this;
          },
          thrustRight: function(speed) {
            var angle = this.body.angle + Math.PI / 2;
            this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
            Body.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2);
            return this;
          },
          thrustBack: function(speed) {
            var angle = this.body.angle - Math.PI;
            this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
            Body.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2);
            return this;
          }
        };
        module2.exports = Force;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Friction = {
          setFriction: function(value, air, fstatic) {
            this.body.friction = value;
            if (air !== void 0) {
              this.body.frictionAir = air;
            }
            if (fstatic !== void 0) {
              this.body.frictionStatic = fstatic;
            }
            return this;
          },
          setFrictionAir: function(value) {
            this.body.frictionAir = value;
            return this;
          },
          setFrictionStatic: function(value) {
            this.body.frictionStatic = value;
            return this;
          }
        };
        module2.exports = Friction;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Gravity = {
          setIgnoreGravity: function(value) {
            this.body.ignoreGravity = value;
            return this;
          }
        };
        module2.exports = Gravity;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Body = __webpack_require__(41);
        var Vector2 = __webpack_require__(3);
        var Mass = {
          setMass: function(value) {
            Body.setMass(this.body, value);
            return this;
          },
          setDensity: function(value) {
            Body.setDensity(this.body, value);
            return this;
          },
          centerOfMass: {
            get: function() {
              return new Vector2(this.body.centerOfMass.x, this.body.centerOfMass.y);
            }
          }
        };
        module2.exports = Mass;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Sensor = {
          setSensor: function(value) {
            this.body.isSensor = value;
            return this;
          },
          isSensor: function() {
            return this.body.isSensor;
          }
        };
        module2.exports = Sensor;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Bodies = __webpack_require__(86);
        var Body = __webpack_require__(41);
        var FuzzyEquals = __webpack_require__(124);
        var GetFastValue = __webpack_require__(2);
        var PhysicsEditorParser = __webpack_require__(589);
        var PhysicsJSONParser = __webpack_require__(590);
        var Vertices = __webpack_require__(64);
        var SetBody = {
          setRectangle: function(width, height, options) {
            return this.setBody({ type: "rectangle", width, height }, options);
          },
          setCircle: function(radius, options) {
            return this.setBody({ type: "circle", radius }, options);
          },
          setPolygon: function(radius, sides, options) {
            return this.setBody({ type: "polygon", sides, radius }, options);
          },
          setTrapezoid: function(width, height, slope, options) {
            return this.setBody({ type: "trapezoid", width, height, slope }, options);
          },
          setExistingBody: function(body, addToWorld) {
            if (addToWorld === void 0) {
              addToWorld = true;
            }
            if (this.body) {
              this.world.remove(this.body, true);
            }
            this.body = body;
            for (var i2 = 0; i2 < body.parts.length; i2++) {
              body.parts[i2].gameObject = this;
            }
            var _this = this;
            body.destroy = function destroy() {
              _this.world.remove(_this.body, true);
              _this.body.gameObject = null;
            };
            if (addToWorld) {
              if (this.world.has(body)) {
                this.world.remove(body, true);
              }
              this.world.add(body);
            }
            if (this._originComponent) {
              var rx = body.render.sprite.xOffset;
              var ry = body.render.sprite.yOffset;
              var comx = body.centerOfMass.x;
              var comy = body.centerOfMass.y;
              if (FuzzyEquals(comx, 0.5) && FuzzyEquals(comy, 0.5)) {
                this.setOrigin(rx + 0.5, ry + 0.5);
              } else {
                var cx = body.centerOffset.x;
                var cy = body.centerOffset.y;
                this.setOrigin(rx + cx / this.displayWidth, ry + cy / this.displayHeight);
              }
            }
            return this;
          },
          setBody: function(config, options) {
            if (!config) {
              return this;
            }
            var body;
            if (typeof config === "string") {
              config = { type: config };
            }
            var shapeType = GetFastValue(config, "type", "rectangle");
            var bodyX = GetFastValue(config, "x", this._tempVec2.x);
            var bodyY = GetFastValue(config, "y", this._tempVec2.y);
            var bodyWidth = GetFastValue(config, "width", this.width);
            var bodyHeight = GetFastValue(config, "height", this.height);
            switch (shapeType) {
              case "rectangle":
                body = Bodies.rectangle(bodyX, bodyY, bodyWidth, bodyHeight, options);
                break;
              case "circle":
                var radius = GetFastValue(config, "radius", Math.max(bodyWidth, bodyHeight) / 2);
                var maxSides = GetFastValue(config, "maxSides", 25);
                body = Bodies.circle(bodyX, bodyY, radius, options, maxSides);
                break;
              case "trapezoid":
                var slope = GetFastValue(config, "slope", 0.5);
                body = Bodies.trapezoid(bodyX, bodyY, bodyWidth, bodyHeight, slope, options);
                break;
              case "polygon":
                var sides = GetFastValue(config, "sides", 5);
                var pRadius = GetFastValue(config, "radius", Math.max(bodyWidth, bodyHeight) / 2);
                body = Bodies.polygon(bodyX, bodyY, sides, pRadius, options);
                break;
              case "fromVertices":
              case "fromVerts":
                var verts = GetFastValue(config, "verts", null);
                if (verts) {
                  if (typeof verts === "string") {
                    verts = Vertices.fromPath(verts);
                  }
                  if (this.body && !this.body.hasOwnProperty("temp")) {
                    Body.setVertices(this.body, verts);
                    body = this.body;
                  } else {
                    var flagInternal = GetFastValue(config, "flagInternal", false);
                    var removeCollinear = GetFastValue(config, "removeCollinear", 0.01);
                    var minimumArea = GetFastValue(config, "minimumArea", 10);
                    body = Bodies.fromVertices(bodyX, bodyY, verts, options, flagInternal, removeCollinear, minimumArea);
                  }
                }
                break;
              case "fromPhysicsEditor":
                body = PhysicsEditorParser.parseBody(bodyX, bodyY, config, options);
                break;
              case "fromPhysicsTracer":
                body = PhysicsJSONParser.parseBody(bodyX, bodyY, config, options);
                break;
            }
            if (body) {
              this.setExistingBody(body, config.addToWorld);
            }
            return this;
          }
        };
        module2.exports = SetBody;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Events = __webpack_require__(272);
        var Sleeping = __webpack_require__(165);
        var MatterEvents = __webpack_require__(166);
        var Sleep = {
          setToSleep: function() {
            Sleeping.set(this.body, true);
            return this;
          },
          setAwake: function() {
            Sleeping.set(this.body, false);
            return this;
          },
          setSleepThreshold: function(value) {
            if (value === void 0) {
              value = 60;
            }
            this.body.sleepThreshold = value;
            return this;
          },
          setSleepEvents: function(start, end) {
            this.setSleepStartEvent(start);
            this.setSleepEndEvent(end);
            return this;
          },
          setSleepStartEvent: function(value) {
            if (value) {
              var world = this.world;
              MatterEvents.on(this.body, "sleepStart", function(event) {
                world.emit(Events.SLEEP_START, event, this);
              });
            } else {
              MatterEvents.off(this.body, "sleepStart");
            }
            return this;
          },
          setSleepEndEvent: function(value) {
            if (value) {
              var world = this.world;
              MatterEvents.on(this.body, "sleepEnd", function(event) {
                world.emit(Events.SLEEP_END, event, this);
              });
            } else {
              MatterEvents.off(this.body, "sleepEnd");
            }
            return this;
          }
        };
        module2.exports = Sleep;
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "afteradd";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "afterremove";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "afterupdate";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "beforeadd";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "beforeremove";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "beforeupdate";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "collisionactive";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "collisionend";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "collisionstart";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "dragend";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "drag";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "dragstart";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "pause";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "resume";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "sleepend";
      },
      function(module2, exports2) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        module2.exports = "sleepstart";
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Body = __webpack_require__(41);
        var Static = {
          setStatic: function(value) {
            Body.setStatic(this.body, value);
            return this;
          },
          isStatic: function() {
            return this.body.isStatic;
          }
        };
        module2.exports = Static;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Body = __webpack_require__(41);
        var MATH_CONST = __webpack_require__(14);
        var WrapAngle = __webpack_require__(269);
        var WrapAngleDegrees = __webpack_require__(270);
        var _FLAG = 4;
        var Transform = {
          x: {
            get: function() {
              return this.body.position.x;
            },
            set: function(value) {
              this._tempVec2.set(value, this.y);
              Body.setPosition(this.body, this._tempVec2);
            }
          },
          y: {
            get: function() {
              return this.body.position.y;
            },
            set: function(value) {
              this._tempVec2.set(this.x, value);
              Body.setPosition(this.body, this._tempVec2);
            }
          },
          scaleX: {
            get: function() {
              return this._scaleX;
            },
            set: function(value) {
              var factorX = 1 / this._scaleX;
              var factorY = 1 / this._scaleY;
              this._scaleX = value;
              if (this._scaleX === 0) {
                this.renderFlags &= ~_FLAG;
              } else {
                this.renderFlags |= _FLAG;
              }
              Body.scale(this.body, factorX, factorY);
              Body.scale(this.body, value, this._scaleY);
            }
          },
          scaleY: {
            get: function() {
              return this._scaleY;
            },
            set: function(value) {
              var factorX = 1 / this._scaleX;
              var factorY = 1 / this._scaleY;
              this._scaleY = value;
              if (this._scaleY === 0) {
                this.renderFlags &= ~_FLAG;
              } else {
                this.renderFlags |= _FLAG;
              }
              Body.scale(this.body, factorX, factorY);
              Body.scale(this.body, this._scaleX, value);
            }
          },
          angle: {
            get: function() {
              return WrapAngleDegrees(this.body.angle * MATH_CONST.RAD_TO_DEG);
            },
            set: function(value) {
              this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
            }
          },
          rotation: {
            get: function() {
              return this.body.angle;
            },
            set: function(value) {
              this._rotation = WrapAngle(value);
              Body.setAngle(this.body, this._rotation);
            }
          },
          setPosition: function(x2, y2) {
            if (x2 === void 0) {
              x2 = 0;
            }
            if (y2 === void 0) {
              y2 = x2;
            }
            this._tempVec2.set(x2, y2);
            Body.setPosition(this.body, this._tempVec2);
            return this;
          },
          setRotation: function(radians) {
            if (radians === void 0) {
              radians = 0;
            }
            this._rotation = WrapAngle(radians);
            Body.setAngle(this.body, radians);
            return this;
          },
          setFixedRotation: function() {
            Body.setInertia(this.body, Infinity);
            return this;
          },
          setAngle: function(degrees) {
            if (degrees === void 0) {
              degrees = 0;
            }
            this.angle = degrees;
            Body.setAngle(this.body, this.rotation);
            return this;
          },
          setScale: function(x2, y2, point) {
            if (x2 === void 0) {
              x2 = 1;
            }
            if (y2 === void 0) {
              y2 = x2;
            }
            var factorX = 1 / this._scaleX;
            var factorY = 1 / this._scaleY;
            this._scaleX = x2;
            this._scaleY = y2;
            Body.scale(this.body, factorX, factorY, point);
            Body.scale(this.body, x2, y2, point);
            return this;
          }
        };
        module2.exports = Transform;
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var Body = __webpack_require__(41);
        var Velocity = {
          setAngularVelocity: function(value) {
            Body.setAngularVelocity(this.body, value);
            return this;
          },
          setVelocityX: function(x2) {
            this._tempVec2.set(x2, this.body.velocity.y);
            Body.setVelocity(this.body, this._tempVec2);
            return this;
          },
          setVelocityY: function(y2) {
            this._tempVec2.set(this.body.velocity.x, y2);
            Body.setVelocity(this.body, this._tempVec2);
            return this;
          },
          setVelocity: function(x2, y2) {
            this._tempVec2.set(x2, y2);
            Body.setVelocity(this.body, this._tempVec2);
            return this;
          }
        };
        module2.exports = Velocity;
      },
      function(module2, exports2, __webpack_require__) {
        var Metrics = {};
        module2.exports = Metrics;
        var Composite = __webpack_require__(118);
        var Common = __webpack_require__(32);
        (function() {
          Metrics.create = function(options) {
            var defaults = {
              extended: false,
              narrowDetections: 0,
              narrowphaseTests: 0,
              narrowReuse: 0,
              narrowReuseCount: 0,
              midphaseTests: 0,
              broadphaseTests: 0,
              narrowEff: 1e-4,
              midEff: 1e-4,
              broadEff: 1e-4,
              collisions: 0,
              buckets: 0,
              bodies: 0,
              pairs: 0
            };
            return Common.extend(defaults, false, options);
          };
          Metrics.reset = function(metrics) {
            if (metrics.extended) {
              metrics.narrowDetections = 0;
              metrics.narrowphaseTests = 0;
              metrics.narrowReuse = 0;
              metrics.narrowReuseCount = 0;
              metrics.midphaseTests = 0;
              metrics.broadphaseTests = 0;
              metrics.narrowEff = 0;
              metrics.midEff = 0;
              metrics.broadEff = 0;
              metrics.collisions = 0;
              metrics.buckets = 0;
              metrics.pairs = 0;
              metrics.bodies = 0;
            }
          };
          Metrics.update = function(metrics, engine) {
            if (metrics.extended) {
              var world = engine.world, bodies = Composite.allBodies(world);
              metrics.collisions = metrics.narrowDetections;
              metrics.pairs = engine.pairs.list.length;
              metrics.bodies = bodies.length;
              metrics.midEff = (metrics.narrowDetections / (metrics.midphaseTests || 1)).toFixed(2);
              metrics.narrowEff = (metrics.narrowDetections / (metrics.narrowphaseTests || 1)).toFixed(2);
              metrics.broadEff = (1 - metrics.broadphaseTests / (bodies.length || 1)).toFixed(2);
              metrics.narrowReuse = (metrics.narrowReuseCount / (metrics.narrowphaseTests || 1)).toFixed(2);
            }
          };
        })();
      },
      function(module2, exports2, __webpack_require__) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2020 Photon Storm Ltd.
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var ALIGN_CONST = __webpack_require__(123);
        var Axes = __webpack_require__(271);
        var Bodies = __webpack_require__(86);
        var Body = __webpack_require__(41);
        var BodyBounds = __webpack_require__(1392);
        var Bounds = __webpack_require__(84);
        var Class = __webpack_require__(0);
        var Composite = __webpack_require__(118);
        var Composites = __webpack_require__(591);
        var Constraint = __webpack_require__(128);
        var Detector = __webpack_require__(273);
        var DistanceBetween = __webpack_require__(50);
        var Factory = __webpack_require__(1394);
        var GetFastValue = __webpack_require__(2);
        var GetValue = __webpack_require__(6);
        var Grid = __webpack_require__(597);
        var MatterAttractors = __webpack_require__(1525);
        var MatterCollisionEvents = __webpack_require__(1526);
        var MatterLib = __webpack_require__(1399);
        var MatterWrap = __webpack_require__(1527);
        var Merge = __webpack_require__(127);
        var Pair = __webpack_require__(250);
        var Pairs = __webpack_require__(598);
        var Plugin = __webpack_require__(595);
        var PluginCache = __webpack_require__(24);
        var Query = __webpack_require__(1400);
        var Resolver = __webpack_require__(599);
        var SAT = __webpack_require__(274);
        var SceneEvents = __webpack_require__(20);
        var Svg = __webpack_require__(592);
        var Vector = __webpack_require__(83);
        var Vertices = __webpack_require__(64);
        var World = __webpack_require__(1402);
        var MatterPhysics = new Class({
          initialize: function MatterPhysics2(scene) {
            this.scene = scene;
            this.systems = scene.sys;
            this.config = this.getConfig();
            this.world;
            this.add;
            this.bodyBounds;
            this.body = Body;
            this.composite = Composite;
            this.detector = Detector;
            this.grid = Grid;
            this.pair = Pair;
            this.pairs = Pairs;
            this.query = Query;
            this.resolver = Resolver;
            this.sat = SAT;
            this.constraint = Constraint;
            this.bodies = Bodies;
            this.composites = Composites;
            this.axes = Axes;
            this.bounds = Bounds;
            this.svg = Svg;
            this.vector = Vector;
            this.vertices = Vertices;
            this.verts = Vertices;
            this._tempVec2 = Vector.create();
            if (GetValue(this.config, "plugins.collisionevents", true)) {
              this.enableCollisionEventsPlugin();
            }
            if (GetValue(this.config, "plugins.attractors", false)) {
              this.enableAttractorPlugin();
            }
            if (GetValue(this.config, "plugins.wrap", false)) {
              this.enableWrapPlugin();
            }
            Resolver._restingThresh = GetValue(this.config, "restingThresh", 4);
            Resolver._restingThreshTangent = GetValue(this.config, "restingThreshTangent", 6);
            Resolver._positionDampen = GetValue(this.config, "positionDampen", 0.9);
            Resolver._positionWarming = GetValue(this.config, "positionWarming", 0.8);
            Resolver._frictionNormalMultiplier = GetValue(this.config, "frictionNormalMultiplier", 5);
            scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
            scene.sys.events.on(SceneEvents.START, this.start, this);
          },
          boot: function() {
            this.world = new World(this.scene, this.config);
            this.add = new Factory(this.world);
            this.bodyBounds = new BodyBounds();
            this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
          },
          start: function() {
            if (!this.world) {
              this.world = new World(this.scene, this.config);
              this.add = new Factory(this.world);
            }
            var eventEmitter = this.systems.events;
            eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);
            eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
            eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
          },
          getConfig: function() {
            var gameConfig = this.systems.game.config.physics;
            var sceneConfig = this.systems.settings.physics;
            var config = Merge(GetFastValue(sceneConfig, "matter", {}), GetFastValue(gameConfig, "matter", {}));
            return config;
          },
          enableAttractorPlugin: function() {
            Plugin.register(MatterAttractors);
            Plugin.use(MatterLib, MatterAttractors);
            return this;
          },
          enableWrapPlugin: function() {
            Plugin.register(MatterWrap);
            Plugin.use(MatterLib, MatterWrap);
            return this;
          },
          enableCollisionEventsPlugin: function() {
            Plugin.register(MatterCollisionEvents);
            Plugin.use(MatterLib, MatterCollisionEvents);
            return this;
          },
          pause: function() {
            return this.world.pause();
          },
          resume: function() {
            return this.world.resume();
          },
          set60Hz: function() {
            this.world.getDelta = this.world.update60Hz;
            this.world.autoUpdate = true;
            return this;
          },
          set30Hz: function() {
            this.world.getDelta = this.world.update30Hz;
            this.world.autoUpdate = true;
            return this;
          },
          step: function(delta, correction) {
            this.world.step(delta, correction);
          },
          containsPoint: function(body, x2, y2) {
            body = this.getMatterBodies(body);
            var position = Vector.create(x2, y2);
            var result = Query.point(body, position);
            return result.length > 0 ? true : false;
          },
          intersectPoint: function(x2, y2, bodies) {
            bodies = this.getMatterBodies(bodies);
            var position = Vector.create(x2, y2);
            var output = [];
            var result = Query.point(bodies, position);
            result.forEach(function(body) {
              if (output.indexOf(body) === -1) {
                output.push(body);
              }
            });
            return output;
          },
          intersectRect: function(x2, y2, width, height, outside, bodies) {
            if (outside === void 0) {
              outside = false;
            }
            bodies = this.getMatterBodies(bodies);
            var bounds = {
              min: { x: x2, y: y2 },
              max: { x: x2 + width, y: y2 + height }
            };
            var output = [];
            var result = Query.region(bodies, bounds, outside);
            result.forEach(function(body) {
              if (output.indexOf(body) === -1) {
                output.push(body);
              }
            });
            return output;
          },
          intersectRay: function(x1, y1, x2, y2, rayWidth, bodies) {
            if (rayWidth === void 0) {
              rayWidth = 1;
            }
            bodies = this.getMatterBodies(bodies);
            var result = [];
            var collisions = Query.ray(bodies, Vector.create(x1, y1), Vector.create(x2, y2), rayWidth);
            for (var i2 = 0; i2 < collisions.length; i2++) {
              result.push(collisions[i2].body);
            }
            return result;
          },
          intersectBody: function(body, bodies) {
            bodies = this.getMatterBodies(bodies);
            var result = [];
            var collisions = Query.collides(body, bodies);
            for (var i2 = 0; i2 < collisions.length; i2++) {
              var pair = collisions[i2];
              if (pair.bodyA === body) {
                result.push(pair.bodyB);
              } else {
                result.push(pair.bodyA);
              }
            }
            return result;
          },
          overlap: function(target, bodies, overlapCallback, processCallback, callbackContext) {
            if (overlapCallback === void 0) {
              overlapCallback = null;
            }
            if (processCallback === void 0) {
              processCallback = null;
            }
            if (callbackContext === void 0) {
              callbackContext = overlapCallback;
            }
            if (!Array.isArray(target)) {
              target = [target];
            }
            target = this.getMatterBodies(target);
            bodies = this.getMatterBodies(bodies);
            var match = false;
            for (var i2 = 0; i2 < target.length; i2++) {
              var entry = target[i2];
              var collisions = Query.collides(entry, bodies);
              for (var c = 0; c < collisions.length; c++) {
                var info = collisions[c];
                var bodyB = info.bodyA.id === entry.id ? info.bodyB : info.bodyA;
                if (!processCallback || processCallback.call(callbackContext, entry, bodyB, info)) {
                  match = true;
                  if (overlapCallback) {
                    overlapCallback.call(callbackContext, entry, bodyB, info);
                  } else if (!processCallback) {
                    return true;
                  }
                }
              }
            }
            return match;
          },
          setCollisionCategory: function(bodies, value) {
            bodies = this.getMatterBodies(bodies);
            bodies.forEach(function(body) {
              body.collisionFilter.category = value;
            });
            return this;
          },
          setCollisionGroup: function(bodies, value) {
            bodies = this.getMatterBodies(bodies);
            bodies.forEach(function(body) {
              body.collisionFilter.group = value;
            });
            return this;
          },
          setCollidesWith: function(bodies, categories) {
            bodies = this.getMatterBodies(bodies);
            var flags = 0;
            if (!Array.isArray(categories)) {
              flags = categories;
            } else {
              for (var i2 = 0; i2 < categories.length; i2++) {
                flags |= categories[i2];
              }
            }
            bodies.forEach(function(body) {
              body.collisionFilter.mask = flags;
            });
            return this;
          },
          getMatterBodies: function(bodies) {
            if (!bodies) {
              return this.world.getAllBodies();
            }
            if (!Array.isArray(bodies)) {
              bodies = [bodies];
            }
            var output = [];
            for (var i2 = 0; i2 < bodies.length; i2++) {
              var body = bodies[i2].hasOwnProperty("body") ? bodies[i2].body : bodies[i2];
              output.push(body);
            }
            return output;
          },
          setVelocity: function(bodies, x2, y2) {
            bodies = this.getMatterBodies(bodies);
            var vec2 = this._tempVec2;
            vec2.x = x2;
            vec2.y = y2;
            bodies.forEach(function(body) {
              Body.setVelocity(body, vec2);
            });
            return this;
          },
          setVelocityX: function(bodies, x2) {
            bodies = this.getMatterBodies(bodies);
            var vec2 = this._tempVec2;
            vec2.x = x2;
            bodies.forEach(function(body) {
              vec2.y = body.velocity.y;
              Body.setVelocity(body, vec2);
            });
            return this;
          },
          setVelocityY: function(bodies, y2) {
            bodies = this.getMatterBodies(bodies);
            var vec2 = this._tempVec2;
            vec2.y = y2;
            bodies.forEach(function(body) {
              vec2.x = body.velocity.x;
              Body.setVelocity(body, vec2);
            });
            return this;
          },
          setAngularVelocity: function(bodies, value) {
            bodies = this.getMatterBodies(bodies);
            bodies.forEach(function(body) {
              Body.setAngularVelocity(body, value);
            });
            return this;
          },
          applyForce: function(bodies, force) {
            bodies = this.getMatterBodies(bodies);
            var vec2 = this._tempVec2;
            bodies.forEach(function(body) {
              vec2.x = body.position.x;
              vec2.y = body.position.y;
              Body.applyForce(body, vec2, force);
            });
            return this;
          },
          applyForceFromPosition: function(bodies, position, speed, angle) {
            bodies = this.getMatterBodies(bodies);
            var vec2 = this._tempVec2;
            bodies.forEach(function(body) {
              if (angle === void 0) {
                angle = body.angle;
              }
              vec2.x = speed * Math.cos(angle);
              vec2.y = speed * Math.sin(angle);
              Body.applyForce(body, position, vec2);
            });
            return this;
          },
          applyForceFromAngle: function(bodies, speed, angle) {
            bodies = this.getMatterBodies(bodies);
            var vec2 = this._tempVec2;
            bodies.forEach(function(body) {
              if (angle === void 0) {
                angle = body.angle;
              }
              vec2.x = speed * Math.cos(angle);
              vec2.y = speed * Math.sin(angle);
              Body.applyForce(body, { x: body.position.x, y: body.position.y }, vec2);
            });
            return this;
          },
          getConstraintLength: function(constraint) {
            var aX = constraint.pointA.x;
            var aY = constraint.pointA.y;
            var bX = constraint.pointB.x;
            var bY = constraint.pointB.y;
            if (constraint.bodyA) {
              aX += constraint.bodyA.position.x;
              aY += constraint.bodyA.position.y;
            }
            if (constraint.bodyB) {
              bX += constraint.bodyB.position.x;
              bY += constraint.bodyB.position.y;
            }
            return DistanceBetween(aX, aY, bX, bY);
          },
          alignBody: function(body, x2, y2, align) {
            body = body.hasOwnProperty("body") ? body.body : body;
            var pos;
            switch (align) {
              case ALIGN_CONST.TOP_LEFT:
              case ALIGN_CONST.LEFT_TOP:
                pos = this.bodyBounds.getTopLeft(body, x2, y2);
                break;
              case ALIGN_CONST.TOP_CENTER:
                pos = this.bodyBounds.getTopCenter(body, x2, y2);
                break;
              case ALIGN_CONST.TOP_RIGHT:
              case ALIGN_CONST.RIGHT_TOP:
                pos = this.bodyBounds.getTopRight(body, x2, y2);
                break;
              case ALIGN_CONST.LEFT_CENTER:
                pos = this.bodyBounds.getLeftCenter(body, x2, y2);
                break;
              case ALIGN_CONST.CENTER:
                pos = this.bodyBounds.getCenter(body, x2, y2);
                break;
              case ALIGN_CONST.RIGHT_CENTER:
                pos = this.bodyBounds.getRightCenter(body, x2, y2);
                break;
              case ALIGN_CONST.LEFT_BOTTOM:
              case ALIGN_CONST.BOTTOM_LEFT:
                pos = this.bodyBounds.getBottomLeft(body, x2, y2);
                break;
              case ALIGN_CONST.BOTTOM_CENTER:
                pos = this.bodyBounds.getBottomCenter(body, x2, y2);
                break;
              case ALIGN_CONST.BOTTOM_RIGHT:
              case ALIGN_CONST.RIGHT_BOTTOM:
                pos = this.bodyBounds.getBottomRight(body, x2, y2);
                break;
            }
            if (pos) {
              Body.setPosition(body, pos);
            }
            return this;
          },
          shutdown: function() {
            var eventEmitter = this.systems.events;
            if (this.world) {
              eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);
              eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
            }
            eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            if (this.add) {
              this.add.destroy();
            }
            if (this.world) {
              this.world.destroy();
            }
            this.add = null;
            this.world = null;
          },
          destroy: function() {
            this.shutdown();
            this.scene.sys.events.off(SceneEvents.START, this.start, this);
            this.scene = null;
            this.systems = null;
          }
        });
        PluginCache.register("MatterPhysics", MatterPhysics, "matterPhysics");
        module2.exports = MatterPhysics;
      },
      function(module2, exports2, __webpack_require__) {
        var Matter = __webpack_require__(594);
        var MatterAttractors = {
          name: "matter-attractors",
          version: "0.1.7",
          for: "matter-js@^0.14.2",
          silent: true,
          install: function(base) {
            base.after("Body.create", function() {
              MatterAttractors.Body.init(this);
            });
            base.before("Engine.update", function(engine) {
              MatterAttractors.Engine.update(engine);
            });
          },
          Body: {
            init: function(body) {
              body.plugin.attractors = body.plugin.attractors || [];
            }
          },
          Engine: {
            update: function(engine) {
              var bodies = Matter.Composite.allBodies(engine.world);
              for (var i2 = 0; i2 < bodies.length; i2++) {
                var bodyA = bodies[i2];
                var attractors = bodyA.plugin.attractors;
                if (attractors && attractors.length > 0) {
                  for (var j = 0; j < bodies.length; j++) {
                    var bodyB = bodies[j];
                    if (i2 !== j) {
                      for (var k2 = 0; k2 < attractors.length; k2++) {
                        var attractor = attractors[k2];
                        var forceVector = attractor;
                        if (Matter.Common.isFunction(attractor)) {
                          forceVector = attractor(bodyA, bodyB);
                        }
                        if (forceVector) {
                          Matter.Body.applyForce(bodyB, bodyB.position, forceVector);
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          Attractors: {
            gravityConstant: 1e-3,
            gravity: function(bodyA, bodyB) {
              var bToA = Matter.Vector.sub(bodyB.position, bodyA.position);
              var distanceSq = Matter.Vector.magnitudeSquared(bToA) || 1e-4;
              var normal = Matter.Vector.normalise(bToA);
              var magnitude = -MatterAttractors.Attractors.gravityConstant * (bodyA.mass * bodyB.mass / distanceSq);
              var force = Matter.Vector.mult(normal, magnitude);
              Matter.Body.applyForce(bodyA, bodyA.position, Matter.Vector.neg(force));
              Matter.Body.applyForce(bodyB, bodyB.position, force);
            }
          }
        };
        module2.exports = MatterAttractors;
      },
      function(module2, exports2) {
        /**
         * @author       @dxu https://github.com/dxu/matter-collision-events
         * @author       Richard Davey <rich@photonstorm.com>
         * @license      {@link https://opensource.org/licenses/MIT|MIT License}
         */
        var MatterCollisionEvents = {
          name: "matter-collision-events",
          version: "0.1.6",
          for: "matter-js@^0.14.2",
          silent: true,
          install: function(matter) {
            matter.after("Engine.create", function() {
              matter.Events.on(this, "collisionStart", function(event) {
                event.pairs.map(function(pair) {
                  var bodyA = pair.bodyA;
                  var bodyB = pair.bodyB;
                  if (bodyA.gameObject) {
                    bodyA.gameObject.emit("collide", bodyA, bodyB, pair);
                  }
                  if (bodyB.gameObject) {
                    bodyB.gameObject.emit("collide", bodyB, bodyA, pair);
                  }
                  matter.Events.trigger(bodyA, "onCollide", { pair });
                  matter.Events.trigger(bodyB, "onCollide", { pair });
                  if (bodyA.onCollideCallback) {
                    bodyA.onCollideCallback(pair);
                  }
                  if (bodyB.onCollideCallback) {
                    bodyB.onCollideCallback(pair);
                  }
                  if (bodyA.onCollideWith[bodyB.id]) {
                    bodyA.onCollideWith[bodyB.id](bodyB, pair);
                  }
                  if (bodyB.onCollideWith[bodyA.id]) {
                    bodyB.onCollideWith[bodyA.id](bodyA, pair);
                  }
                });
              });
              matter.Events.on(this, "collisionActive", function(event) {
                event.pairs.map(function(pair) {
                  var bodyA = pair.bodyA;
                  var bodyB = pair.bodyB;
                  if (bodyA.gameObject) {
                    bodyA.gameObject.emit("collideActive", bodyA, bodyB, pair);
                  }
                  if (bodyB.gameObject) {
                    bodyB.gameObject.emit("collideActive", bodyB, bodyA, pair);
                  }
                  matter.Events.trigger(bodyA, "onCollideActive", { pair });
                  matter.Events.trigger(bodyB, "onCollideActive", { pair });
                  if (bodyA.onCollideActiveCallback) {
                    bodyA.onCollideActiveCallback(pair);
                  }
                  if (bodyB.onCollideActiveCallback) {
                    bodyB.onCollideActiveCallback(pair);
                  }
                });
              });
              matter.Events.on(this, "collisionEnd", function(event) {
                event.pairs.map(function(pair) {
                  var bodyA = pair.bodyA;
                  var bodyB = pair.bodyB;
                  if (bodyA.gameObject) {
                    bodyA.gameObject.emit("collideEnd", bodyA, bodyB, pair);
                  }
                  if (bodyB.gameObject) {
                    bodyB.gameObject.emit("collideEnd", bodyB, bodyA, pair);
                  }
                  matter.Events.trigger(bodyA, "onCollideEnd", { pair });
                  matter.Events.trigger(bodyB, "onCollideEnd", { pair });
                  if (bodyA.onCollideEndCallback) {
                    bodyA.onCollideEndCallback(pair);
                  }
                  if (bodyB.onCollideEndCallback) {
                    bodyB.onCollideEndCallback(pair);
                  }
                });
              });
            });
          }
        };
        module2.exports = MatterCollisionEvents;
      },
      function(module2, exports2, __webpack_require__) {
        var Matter = __webpack_require__(594);
        var MatterWrap = {
          name: "matter-wrap",
          version: "0.1.4",
          for: "matter-js@^0.14.2",
          silent: true,
          install: function(base) {
            base.after("Engine.update", function() {
              MatterWrap.Engine.update(this);
            });
          },
          Engine: {
            update: function(engine) {
              var world = engine.world, bodies = Matter.Composite.allBodies(world), composites = Matter.Composite.allComposites(world);
              for (var i2 = 0; i2 < bodies.length; i2 += 1) {
                var body = bodies[i2];
                if (body.plugin.wrap) {
                  MatterWrap.Body.wrap(body, body.plugin.wrap);
                }
              }
              for (i2 = 0; i2 < composites.length; i2 += 1) {
                var composite = composites[i2];
                if (composite.plugin.wrap) {
                  MatterWrap.Composite.wrap(composite, composite.plugin.wrap);
                }
              }
            }
          },
          Bounds: {
            wrap: function(objectBounds, bounds) {
              var x2 = null, y2 = null;
              if (typeof bounds.min.x !== "undefined" && typeof bounds.max.x !== "undefined") {
                if (objectBounds.min.x > bounds.max.x) {
                  x2 = bounds.min.x - objectBounds.max.x;
                } else if (objectBounds.max.x < bounds.min.x) {
                  x2 = bounds.max.x - objectBounds.min.x;
                }
              }
              if (typeof bounds.min.y !== "undefined" && typeof bounds.max.y !== "undefined") {
                if (objectBounds.min.y > bounds.max.y) {
                  y2 = bounds.min.y - objectBounds.max.y;
                } else if (objectBounds.max.y < bounds.min.y) {
                  y2 = bounds.max.y - objectBounds.min.y;
                }
              }
              if (x2 !== null || y2 !== null) {
                return {
                  x: x2 || 0,
                  y: y2 || 0
                };
              }
            }
          },
          Body: {
            wrap: function(body, bounds) {
              var translation = MatterWrap.Bounds.wrap(body.bounds, bounds);
              if (translation) {
                Matter.Body.translate(body, translation);
              }
              return translation;
            }
          },
          Composite: {
            bounds: function(composite) {
              var bodies = Matter.Composite.allBodies(composite), vertices = [];
              for (var i2 = 0; i2 < bodies.length; i2 += 1) {
                var body = bodies[i2];
                vertices.push(body.bounds.min, body.bounds.max);
              }
              return Matter.Bounds.create(vertices);
            },
            wrap: function(composite, bounds) {
              var translation = MatterWrap.Bounds.wrap(MatterWrap.Composite.bounds(composite), bounds);
              if (translation) {
                Matter.Composite.translate(composite, translation);
              }
              return translation;
            }
          }
        };
        module2.exports = MatterWrap;
      },
      function(module2, exports2, __webpack_require__) {
        (function(global2) {
          /**
          * @author       Richard Davey <rich@photonstorm.com>
          * @copyright    2020 Photon Storm Ltd.
          * @license      {@link https://opensource.org/licenses/MIT|MIT License}
          */
          var CONST = __webpack_require__(33);
          var Extend = __webpack_require__(17);
          var Phaser2 = {
            Actions: __webpack_require__(275),
            Animations: __webpack_require__(723),
            BlendModes: __webpack_require__(35),
            Cache: __webpack_require__(735),
            Cameras: __webpack_require__(738),
            Core: __webpack_require__(806),
            Class: __webpack_require__(0),
            Create: __webpack_require__(888),
            Curves: __webpack_require__(894),
            Data: __webpack_require__(896),
            Display: __webpack_require__(898),
            DOM: __webpack_require__(917),
            Events: __webpack_require__(918),
            Game: __webpack_require__(920),
            GameObjects: __webpack_require__(1011),
            Geom: __webpack_require__(483),
            Input: __webpack_require__(1308),
            Loader: __webpack_require__(1338),
            Math: __webpack_require__(193),
            Physics: __webpack_require__(1493),
            Plugins: __webpack_require__(1403),
            Renderer: __webpack_require__(1405),
            Scale: __webpack_require__(1412),
            ScaleModes: __webpack_require__(168),
            Scene: __webpack_require__(418),
            Scenes: __webpack_require__(1413),
            Structs: __webpack_require__(1415),
            Textures: __webpack_require__(1416),
            Tilemaps: __webpack_require__(1418),
            Time: __webpack_require__(1461),
            Tweens: __webpack_require__(1463),
            Utils: __webpack_require__(1481)
          };
          {
            Phaser2.Sound = __webpack_require__(1492);
          }
          Phaser2 = Extend(false, Phaser2, CONST);
          module2.exports = Phaser2;
          global2.Phaser = Phaser2;
        }).call(this, __webpack_require__(600));
      }
    ]);
  });
})(phaser);
const FILE_POPULATED = Phaser.Loader.FILE_POPULATED;
const UUID = Phaser.Utils.String.UUID;
class AwaitFile extends Phaser.Loader.File {
  constructor(loader, fileConfig) {
    if (!fileConfig.hasOwnProperty("type")) {
      fileConfig.type = "await";
    }
    if (!fileConfig.hasOwnProperty("url")) {
      fileConfig.url = "";
    }
    if (!fileConfig.hasOwnProperty("key")) {
      fileConfig.key = UUID();
    }
    super(loader, fileConfig);
  }
  load() {
    if (this.state === FILE_POPULATED) {
      this.loader.nextFile(this, true);
    } else {
      var config = this.config;
      var callback = config.callback;
      var scope = config.scope;
      var successCallback = this.onLoad.bind(this);
      var failureCallback = this.onError.bind(this);
      if (callback) {
        if (scope) {
          callback.call(scope, successCallback, failureCallback);
        } else {
          callback(successCallback, failureCallback);
        }
      } else {
        this.onLoad();
      }
    }
  }
  onLoad() {
    this.loader.nextFile(this, true);
  }
  onError() {
    this.loader.nextFile(this, false);
  }
}
var IsFunction = function(obj) {
  return obj && typeof obj === "function";
};
const IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
const loaderCallback = function(key, config) {
  if (IsFunction(key)) {
    var callback = key;
    var scope = config;
    config = {
      config: {
        callback,
        scope
      }
    };
  } else if (IsPlainObject(key)) {
    config = key;
    if (!config.hasOwnProperty("config")) {
      config = {
        config
      };
    }
  } else {
    config = {
      key,
      config
    };
  }
  this.addFile(new AwaitFile(this, config));
  return this;
};
class AwaitLoaderPlugin extends Phaser.Plugins.BasePlugin {
  constructor(pluginManager) {
    super(pluginManager);
    pluginManager.registerFileType("rexAwait", loaderCallback);
  }
  addToScene(scene) {
    scene.sys.load.rexAwait = loaderCallback;
  }
}
class Game extends Phaser.Game {
  constructor(config) {
    super(__spreadValues({
      plugins: {
        global: [
          {
            key: "rexAwaitLoader",
            plugin: AwaitLoaderPlugin,
            start: true
          }
        ]
      }
    }, config));
  }
}
const loadFont = async (name, url) => {
  const newFont = new FontFace(name, `url(${url})`);
  try {
    const loadedFont = await newFont.load();
    document.fonts.add(loadedFont);
  } catch (e) {
    console.error(e);
  }
};
class BootScene extends Phaser.Scene {
  constructor() {
    super({
      key: "BootScene"
    });
    __publicField(this, "loadingBar");
    __publicField(this, "progressBar");
  }
  preload() {
    this.cameras.main.setBackgroundColor(0);
    this.createLoadingbar();
    this.load.on("progress", (value) => {
      console.log("progress this", this);
      this.progressBar.clear();
      this.progressBar.fillStyle(16774867, 1);
      this.progressBar.fillRect(this.cameras.main.width / 4, this.cameras.main.height / 2 - 16, this.cameras.main.width / 2 * value, 16);
    }, this);
    this.load.on("complete", () => {
      this.progressBar.destroy();
      this.loadingBar.destroy();
    }, this);
    this.load.rexAwait(async (successCallback, failureCallback) => {
      try {
        await loadFont("PressStart2P", "https://fonts.gstatic.com/s/pressstart2p/v14/e3t4euO8T-267oIAQAu6jDQyK3nVivNm4I81.woff2");
        successCallback();
      } catch (e) {
        failureCallback(e);
      }
    });
    this.load.spritesheet("player", "./assets/images/fighter.png", { frameWidth: 27, frameHeight: 32 });
    this.load.spritesheet("enemy-mine", "./assets/images/mine.png", { frameWidth: 32, frameHeight: 32 });
    this.load.image("background-level1", "./assets/images/level1.png");
  }
  update() {
    this.scene.start("GameScene");
  }
  createLoadingbar() {
    this.loadingBar = this.add.graphics();
    this.loadingBar.fillStyle(6139463, 1);
    this.loadingBar.fillRect(this.cameras.main.width / 4 - 2, this.cameras.main.height / 2 - 18, this.cameras.main.width / 2 + 4, 20);
    this.progressBar = this.add.graphics();
  }
}
class Bullet extends Phaser.GameObjects.Graphics {
  constructor(aParams) {
    super(aParams.scene, aParams.options);
    __publicField(this, "color");
    __publicField(this, "velocity");
    __publicField(this, "lifeSpan");
    __publicField(this, "isOffScreen");
    this.initVariables();
    this.initGraphics();
    this.initPhysics();
    this.initBullet(aParams.options.x, aParams.options.y, aParams.rotation);
    this.scene.add.existing(this);
  }
  getBody() {
    return this.body;
  }
  initVariables() {
    this.color = 16777215;
    this.lifeSpan = 100;
    this.isOffScreen = false;
  }
  initGraphics() {
    this.fillStyle(this.color, 1);
    this.fillCircle(0, 0, 3);
  }
  initPhysics() {
    this.scene.physics.world.enable(this);
    this.getBody().allowGravity = false;
    this.getBody().setCircle(3);
    this.getBody().setOffset(-3, -3);
    this.getBody().setMaxVelocity(20, 20);
  }
  initBullet(x2, y2, rotation) {
    this.x = x2;
    this.y = y2;
    this.velocity = new Phaser.Math.Vector2(this.getBody().maxVelocity.x * Math.cos(rotation - Math.PI / 2), this.getBody().maxVelocity.y * Math.sin(rotation - Math.PI / 2));
  }
  update() {
    this.x += this.velocity.x;
    this.y += this.velocity.y;
    if (this.lifeSpan < 0 || this.isOffScreen) {
      this.setActive(false);
    } else {
      this.lifeSpan--;
    }
    this.checkIfOffScreen();
  }
  checkIfOffScreen() {
    if (this.x > this.scene.sys.canvas.width + 1 || this.y > this.scene.sys.canvas.height + 1) {
      this.isOffScreen = true;
    }
  }
}
class Player extends Phaser.GameObjects.Sprite {
  constructor(aParams) {
    super(aParams.scene, aParams.x, aParams.y, aParams.texture, aParams.frame);
    __publicField(this, "bullets");
    __publicField(this, "cursors");
    __publicField(this, "isShooting");
    __publicField(this, "shootKey");
    __publicField(this, "leftFlag", false);
    __publicField(this, "rightFlag", false);
    this.initImage();
    this.initVariables();
    this.initInput();
    this.initPhysics();
    this.scene.add.existing(this);
    this.initAnims();
  }
  getBody() {
    return this.body;
  }
  initAnims() {
    this.anims.create({
      key: "move-right",
      duration: 50,
      frames: this.anims.generateFrameNumbers("player", { start: 2, end: 4 }),
      frameRate: 20,
      repeat: 0
    });
    this.anims.create({
      key: "move-left",
      duration: 50,
      frames: this.anims.generateFrameNumbers("player", { start: 2, end: 0 }),
      frameRate: 20,
      repeat: 0
    });
  }
  initImage() {
    this.setScale(2);
  }
  initVariables() {
    this.bullets = [];
    this.isShooting = false;
  }
  initInput() {
    this.cursors = this.scene.input.keyboard.createCursorKeys();
    this.shootKey = this.scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
  }
  initPhysics() {
    this.scene.physics.world.enable(this);
    this.getBody().setDamping(true);
    this.getBody().setDrag(0.99, 0.99);
    this.getBody().setMaxVelocity(300);
  }
  update() {
    if (this.active) {
      this.handleInput();
    }
    this.updateBullets();
    this.scene.physics.world.wrap(this.getBody(), 16);
  }
  getDefaultYPosition() {
    return this.scene.game.canvas.height - 48;
  }
  handleInput() {
    if (this.shootKey.isDown && !this.isShooting) {
      this.doubleShoot();
      this.isShooting = true;
    }
    if (this.shootKey.isUp) {
      this.isShooting = false;
    }
    if (this.cursors.up.isDown) {
      this.setY(this.y - 4);
      if (this.y <= 30) {
        this.setY(30);
      }
    } else if (this.cursors.down.isDown) {
      this.setY(this.y + 4);
      if (this.y >= this.getDefaultYPosition()) {
        this.setY(this.getDefaultYPosition());
      }
    }
    if (this.cursors.left.isDown) {
      this.rightFlag = false;
      this.setX(this.x - 4);
      if (!this.leftFlag) {
        this.anims.play("move-left");
      }
      this.leftFlag = true;
    } else if (this.cursors.right.isDown) {
      this.leftFlag = false;
      this.setX(this.x + 4);
      if (!this.rightFlag) {
        this.anims.play("move-right");
      }
      this.rightFlag = true;
    } else {
      this.leftFlag = false;
      this.rightFlag = false;
      this.setFrame(2);
    }
  }
  doubleShoot() {
    this.bullets.push(new Bullet({
      scene: this.scene,
      rotation: this.rotation,
      options: {
        x: this.x + Math.cos(this.rotation) * 20,
        y: this.y + Math.sin(this.rotation) * 20
      }
    }), new Bullet({
      scene: this.scene,
      rotation: this.rotation,
      options: {
        x: this.x - Math.cos(this.rotation) * 20,
        y: this.y - Math.sin(this.rotation) * 20
      }
    }));
  }
  updateBullets() {
    for (let i2 = 0; i2 < this.bullets.length; i2++) {
      if (this.bullets[i2].active) {
        this.bullets[i2].update();
      } else {
        this.bullets[i2].destroy();
        this.bullets.splice(i2, 1);
      }
    }
  }
}
class GameScene extends Phaser.Scene {
  constructor() {
    super({ key: "GameScene" });
    __publicField(this, "player");
    __publicField(this, "bg");
    __publicField(this, "enemyGroup");
    __publicField(this, "mine");
  }
  create() {
    this.bg = this.add.tileSprite(0, 0, 288, 4928, "background-level1", "level1");
    this.bg.setScale(4.5);
    this.data.set("respawns", 3);
    this.data.set("level", 1);
    this.data.set("score", 0);
    const text = this.add.text(8, 8, "", { font: "16px PressStart2P", color: "#cc0000" });
    text.setText([
      "Level: " + this.data.get("level"),
      "Respawns: " + this.data.get("respawns"),
      "Score: " + this.data.get("score")
    ]);
    this.player = new Player({
      scene: this,
      x: 320,
      y: this.game.canvas.height - 48,
      texture: "player",
      frame: 2
    });
    this.anims.create({
      key: "mine-blink",
      duration: 2e3,
      frames: this.anims.generateFrameNumbers("enemy-mine", { start: 0, end: 1 }),
      frameRate: 2,
      repeat: -1
    });
    this.enemyGroup = this.add.group();
    this.mine = this.enemyGroup.create(200, 0, "enemy-mine");
    this.mine.setScale(2);
    this.physics.world.enableBody(this.mine);
    console.log("this.mine", this.mine);
    this.enemyGroup.scene.anims.play("mine-blink", this.mine);
  }
  update() {
    this.player.update();
    this.physics.collide(this.player, this.mine, () => {
      console.log("collided");
      this.mine.destroy();
    });
    if (this.mine && this.mine.active) {
      this.mine.body.velocity.y = 0.5 * 100;
    }
    this.bg.setTilePosition(0, this.bg.tilePositionY - 0.25);
  }
}
const GameConfig = {
  title: "Space Shooter",
  url: "https://github.com/digitsensitive/phaser3-typescript",
  version: "1.0.0",
  width: 640,
  height: 480,
  backgroundColor: 0,
  type: Phaser.CANVAS,
  pixelArt: true,
  antialias: false,
  parent: "game",
  physics: {
    default: "arcade",
    arcade: {
      fps: 60,
      gravity: { y: 0 }
    }
  },
  scene: [BootScene, GameScene]
};
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = react.exports, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
function q(c, a, g2) {
  var b2, d = {}, e = null, h2 = null;
  g2 !== void 0 && (e = "" + g2);
  a.key !== void 0 && (e = "" + a.key);
  a.ref !== void 0 && (h2 = a.ref);
  for (b2 in a)
    m.call(a, b2) && !p.hasOwnProperty(b2) && (d[b2] = a[b2]);
  if (c && c.defaultProps)
    for (b2 in a = c.defaultProps, a)
      d[b2] === void 0 && (d[b2] = a[b2]);
  return { $$typeof: k, type: c, key: e, ref: h2, props: d, _owner: n.current };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
const jsx = jsxRuntime.exports.jsx;
const Fragment = jsxRuntime.exports.Fragment;
function App() {
  react.exports.useEffect(() => {
    new Game(GameConfig);
  }, []);
  return /* @__PURE__ */ jsx(Fragment, {
    children: /* @__PURE__ */ jsx(bo, {
      style: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      },
      children: /* @__PURE__ */ jsx(ke, {
        roundedCorners: true,
        title: "RapRap @ 640x480",
        alignTitle: "center",
        style: {
          backgroundColor: "#000",
          maxWidth: 700
        },
        children: /* @__PURE__ */ jsx("div", {
          id: "game"
        })
      })
    })
  });
}
var index = "";
client.createRoot(document.getElementById("root")).render(/* @__PURE__ */ jsx(App, {}));
